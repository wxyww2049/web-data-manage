[
    {
        "url": "https://www.nowcoder.com/discuss/594573550074212352?sourceSSR=users",
        "title": "b站测开一面（1h）",
        "content": "1.自我介绍\n\n2.拷打项目（介绍一下项目架构和技术栈、为什么写这个项目、项目中遇到过什么问题、怎么解决的、测试用例发现了哪些bug）\n\n3.Java的语言特性（这里答了跨平台和面向对象）\n\n4.面向对象的特点是什么\n\n5.Java多态是怎么实现的（这里不是问原理，指代码实现）\n\n6.重写和重载的区别，分别讲讲他们使用场景\n\n7.讲讲抽象类和普通类的区别\n\n8.项目中用到了接口吗，他和抽象类有什么区别，为什么要使用接口\n\n9.讲讲Java中的数据类型\n\n10.int和Integer的区别\n\n11.==和equals()的区别\n\n12.集合和数组的区别\n\n13.static关键字的作用及使用场景\n\n14.Java中控制语句有哪写（指for if else等）\n\n15.Java如何去跳出一个多层for循环\n\n16.break、continue、return有什么区别\n\n17.Java中exception和error有什么区别，你遇到过什么异常（这里提到了空指针）\n\n18.什么情况下会遇到空指针异常\n\n19.jre、jvm、jdk的区别\n\n20.讲讲Java的内存区域有哪些\n\n21.Java的类加载过程\n\n22.JVM垃圾回收机制\n\n23.关系型数据库和非关系型数据库区别\n\n24.讲讲MySQL和Redis的使用场景和对比\n\n25.MySQL使用索引的优缺点，什么时候使用索引\n\n26.MyISAM和InnoDB的区别\n\n27.讲讲你对Spring的理解\n\n28.给你一张学生表，查询姓张且成绩大于90的所有学生\n\n29.力扣215，要求使用快排（寄）\n\n面试官是个小姐姐，遇到一些问题会引导，面试体验不错，奈何实力不够[牛泪]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594571077011910656?sourceSSR=users",
        "title": "阿里云 暑期实习面经 三面｜讲解｜0305",
        "content": "前面讲解过该同学阿里云的[一面讲解](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F590576768491216896)和[二面讲解](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F592128174994075648)，这是**第三面**\n的，继续给大家做**讲解分析，参考回答和学习资料指引** ，联合起来，参考意义很大，期望大家有所收获～\n\n这篇文章主要考察点：**海量数据场景题+操作系统+计算机网络+数据库**\n\n>\n> [原贴链接](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F593036111606198272%3FsourceSSR%3Dusers)\n>\n>\n> ![alt](https://uploadfiles.nowcoder.com/images/20240305/7538287_1709628370924/D2B5CA33BD970F64A6301FA75AE2EB22)\n> **感谢这位同学分享！！！**\n\n开始吧～～\n\n## 1.场景题：不考虑系统限制，如何快速在大量字符串中统计出现次数前10的字符串？如果考虑内存限制，应该采取什么措施在海量数据中进行统计？\n\n**解析：** ：\n\n属于**海量数据面试** 题之一，系统学习推荐资料，掌握常用的分析处理方法，例如分治，外排序等方法，这些问题基本问不住你～～\n\n**参考回答：**\n\n> **无限内存**\n>\n>   1. hash_map统计\n> 先对这批海量数据预处理。具体方法是：维护一个Key为字符串，Value为该Query出现次数的hash_map，即hash_map(KeyStr,\n> Value)，每次读取一个KeyStr，如果该字串不在Table中，那么加入该字串，并将Value值设为1；如果该字串在Table中，那么将该字串的计数加1\n> 即可。最终我们在O(N)的时间复杂度内用hash_map完成了统计；\n>   2. 堆排序 借助堆这个数据结构，找出Top\n> K，时间复杂度为N‘logK。即借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历hash_map，分别和根元素进行对比。所以，我们最终的时间复杂度是：O(n)\n> + N' * O(logk），其中，N’为300万中不同的String个数，即hash_map中Key的个数。\n>\n\n> **有限内存**\n>\n> 这一类问题中，限制内存的面试题才是更常见的，解法也是。\n>\n> **1.分而治之/hash映射：**\n> 首先把所有字符串，采用Hash映射的方法，比如%1000，把整个大文件映射为1000个小文件（目标是拆分到每个小文件大小可以装入内存）。\n>\n> 2.**hash_map统计 + 堆排序** 针对每个小文件，采用上面不限内存的方式，统计出每个小文件的Top10\n>\n> 3.**合并小文件结果** 讲1000个文件的Top10取出，一共1万个元素，再用一次堆排序，取出这1万个中的Top10, 即最终结果。\n\n**学习指引：**\n\n系统学习这篇文章，类似海量数据面试题问不住你～～\n\n系统学习：[《后端海量数据面试题讲解-01分治》｜第1题｜第2题](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FdflEmPoVEtkFLs2RAZXz_g)\n\n## 2.场景题：设计实现一个高可用、高并发的系统，讲讲有哪些需要注意的地方？对于突发的大流量有哪些处理方法？热点数据有哪些处理方法？\n\n**解析：** ：\n\n笼统的答一下就行，面试官会细问你，再详细回答。\n\n**参考回答：**\n\n> **注意的地方：**\n> 设计实现一个高可用、高并发的系统时，需要注意的关键点包括：采用微服务架构和负载均衡确保系统的可扩展性和故障隔离；实现数据库读写分离、分库分表以及合理使用缓存来优化数据存储和访问性能；利用异步处理和消息队列提高系统吞吐量；强化安全性设计，包括身份验证、授权和数据加密；建立完善的监控和告警机制，以及时发现和解决性能瓶颈；通过容器化部署和自动扩缩容实现弹性伸缩；同时，容错和恢复策略的制定，以及充分的功能、压力和安全测试都是确保系统高可用和高并发的重要环节。\n\n> **突发大流量：** 应首先确保系统架构具备**水平扩展** 能力，利用**负载均衡** 技术分散请求压力；同时，结合缓存策略，将热点数据**缓存**\n> 至高性能存储中，减少对后端服务的冲击；若流量仍超出处理能力，可启用**限流机制** 保护核心资源，并通过**降级**\n> 非关键服务维持整体稳定；此外，**监控** 系统需实时检测流量变化，自动触发扩展资源以应对峰值。\n\n> **热点数据处理：**\n>\n> **缓存优化**\n> ：为了缓解数据库的压力，我们应该将热点数据缓存起来。使用高性能的缓存系统，如Redis或Memcached，可以将这些数据存储在内存中，从而大幅度减少对数据库的访问。通过合理的缓存策略，如基于访问频率的动态缓存、缓存预热等，可以进一步提高缓存的命中率和效果。\n>\n> **数据库优化**\n> ：数据库的优化也是处理热点数据的关键环节。对于读多写少的热点数据，可以考虑使用读写分离的策略，将读操作和写操作分散到不同的数据库服务器上，以提高并发处理能力。同时，通过数据库分片技术，可以将数据水平分割到多个数据库服务器上，每个服务器只处理一部分数据，进一步分散存储和访问压力。\n\n**学习指引：**\n\n系统学习：[《网课：高并发系统设计40问》](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Flearn.lianglianglee.com%2F%25E4%25B8%2593%25E6%25A0%258F%2F%25E9%25AB%2598%25E5%25B9%25B6%25E5%258F%2591%25E7%25B3%25BB%25E7%25BB%259F%25E8%25AE%25BE%25E8%25AE%25A140%25E9%2597%25AE)\n\n## 3.Redis：为什么redis是单线程但速度依旧很快？\n\n**解析：** ：\n\nredis高频面试题之一\n\n**参考回答：**\n\n>\n> Redis速度快的原因主要有以下几点：首先，Redis是一个内存数据库，所有的数据都存储在内存中，这大大减少了磁盘I/O的延迟，使得数据读写速度非常快；其次，Redis使用单线程模型，避免了线程切换和锁竞争等开销，能够更高效地利用CPU资源；此外，Redis提供了多种高效的数据结构，如字符串、哈希表、列表、集合等，这些数据结构都经过了高度优化，能够实现快速的读写操作；最后，Redis还使用了异步I/O模型，能够同时处理多个并发请求，提高了系统的吞吐量。这些因素共同作用，使得Redis在处理大量读写请求时表现出色，成为了一个高性能的键值数据库。\n\n**学习指引**\n\n面试学习：[《小林 Coding》｜图解Redis|Redis\n采用单线程为什么还这么快？](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxiaolincoding.com%2Fredis%2Fbase%2Fredis_interview.html%23redis-%25E9%2587%2587%25E7%2594%25A8%25E5%258D%2595%25E7%25BA%25BF%25E7%25A8%258B%25E4%25B8%25BA%25E4%25BB%2580%25E4%25B9%2588%25E8%25BF%2598%25E8%25BF%2599%25E4%25B9%2588%25E5%25BF%25AB)\n\n## 4.操作系统：介绍下IO多路复用？select、poll和epoll各自的区别？\n\n**解析：** ：\n\n操作系统高频考题，重点掌握\n\n**参考回答：**\n\n> **是什么？**\n>\n>\n> IO多路复用是一种在操作系统中用于处理多个输入/输出流的技术，它允许单个进程或线程同时监控多个文件描述符，以确定它们中的哪些可以进行非阻塞的读/写操作，从而提高系统对并发IO请求的处理效率。这项技术广泛应用于构建高性能、高并发的网络服务器。\n>\n> **select、poll和epoll各自的区别？**\n>\n>   * **select** ：\n> select是早期Unix系统上的IO多路复用技术，它使用一个位图来表示文件描述符集合，并允许程序同时监控这些描述符的读/写状态。然而，select存在两个主要问题：一是它所能监控的文件描述符数量受限于FD_SETSIZE（通常为1024）；二是每次调用select时，都需要传递并处理整个文件描述符集合，这在描述符数量较多时效率较低。\n>\n>   * **poll** ：\n> poll解决了select中文件描述符数量限制的问题，它使用一个数组来存储文件描述符及其对应的事件，因此可以支持更多的描述符。与select类似，poll也采用轮询的方式检查描述符的状态，但它在处理大量描述符时比select更高效，因为poll不需要像select那样在调用前后重新设置文件描述符集合。\n>\n>   * **epoll** ：\n> epoll是Linux特有的IO多路复用技术，与select和poll不同，它使用基于事件驱动的方式来工作。epoll通过注册感兴趣的事件到文件描述符上，并在这些事件发生时接收通知，从而避免了轮询的开销。此外，epoll还支持水平触发和边缘触发两种模式，提供了更大的灵活性。在高并发场景下，epoll通常比select和poll具有更好的性能表现。\n>\n>\n\n**学习指引：**\n\n面试学习：[《小林coding》｜图解系统｜I/O\n多路复用](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxiaolincoding.com%2Fos%2F8_network_system%2Fselete_poll_epoll.html%23i-o-%25E5%25A4%259A%25E8%25B7%25AF%25E5%25A4%258D%25E7%2594%25A8)\n\n## 5.操作系统：磁盘快照有了解吗？介绍下COW和ROW？\n\n**解析：** ：\n\n了解。虽然是个操作系统问题，但是Redis的RDB持久化其实就有用到COW（写时复制）技术。\n\n**参考回答：**\n\n> **磁盘快照** ：\n> 磁盘快照是一种创建文件系统或卷在某个特定时间点的只读副本的技术。它允许用户在不影响原始数据的情况下访问、备份或恢复数据。快照通常用于数据保护、恢复和备份场景，可以迅速创建并占用较少的存储空间。\n>\n> **COW（写时复制）** ：\n> COW是“写时复制”的缩写，是一种实现磁盘快照的技术。在使用COW时，原始数据块在修改之前不会被覆盖，而是将修改的数据块复制到新的位置，并更新文件系统的元数据以指向新的数据块。这样，快照可以继续访问原始数据块，而修改则反映在新的数据块上。COW技术提高了快照创建和管理的效率，因为快照和原始数据可以共享相同的数据块，直到发生修改为止。\n>\n> **ROW（写时重定向）** ：\n> ROW是“写时重定向”的缩写，是另一种实现磁盘快照的技术。与COW不同，在使用ROW时，当原始数据块需要修改时，修改会被重定向到新的位置，并且文件系统的元数据会更新以反映这种重定向。然而，与COW不同的是，ROW通常保留原始数据块的副本以供快照使用，而不是共享数据块。这意味着每个修改都会导致新的数据块被分配和写入，这可能会增加存储空间的消耗。\n\n**学习指引：**\n\n[存储快照-\nCOW和ROW](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F617400029)\n\n## 6.操作系统：进程、线程和协程各自的作用和区别？进程和线程的组成？\n\n**解析：** ：\n\n操作系统，简单且“最”常考面试题。必须掌握\n\n**参考回答：**\n\n> **进程、线程和协程区别？**\n>\n>   * **进程**\n> 是操作系统资源分配的基本单位，它包含了正在运行的程序的所有状态信息，如代码、数据、系统资源和线程等。每个进程都有独立的内存空间和系统资源，相互之间互不干扰，保证了系统的稳定性和安全性。但是，进程间的切换和通信需要较大的开销。\n>   * **线程**\n> 是进程内的执行单元，共享同一个进程的内存空间和资源，如文件句柄、信号量等。线程间的切换和通信比进程更快，因为它们共享同一地址空间。但是，线程没有独立的地址空间，一个线程的崩溃可能会影响整个进程。\n>   * **协程**\n> 是一种更轻量级的线程，也被称为微线程。它们完全在用户态下执行，不需要内核的参与，因此切换开销更小。协程可以由程序自身控制调度，实现非抢占式的多任务处理。\n>\n\n> **进程和线程的组成？**\n>\n>   * 进程的组成：\n> 进程主要由三部分组成：程序代码（即指令序列）、相关数据（包括变量、缓冲区、文件等）以及进程控制块（PCB）。其中，进程控制块是用于描述系统进程状态的关键数据结构，它包含了进程ID、进程状态、内存指针、文件描述符表、信号处理函数等重要信息。\n>   * 线程的组成：\n> 线程是进程内的一个执行单元，其组成通常包括线程ID、当前指令指针（PC）、寄存器集合（用于保存线程上下文）、堆栈（用于函数调用和局部变量存储）以及线程控制块（TCB，类似于进程中的PCB，但更轻量级）。线程共享其所属进程的内存空间和部分资源，如文件句柄和信号量等，这使得线程间的数据交互变得容易，但同时也增加了同步和互斥的复杂性。\n>\n\n**学习指引：**\n[《小林coding》｜图解系统｜进成线程基础知识](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxiaolincoding.com%2Fos%2F4_process%2Fprocess_base.html%23%25E8%25BF%259B%25E7%25A8%258B)\n\n## 7.操作系统：CPU数量为1的进程执行死循环会发生什么？如何解决？\n\n**参考回答：**\n\n>\n> 在Linux系统中，如果某个进程出现死循环，其本身的运行会受到影响，但不会直接导致其他进程的运行受阻。这是因为Linux系统采用了多任务调度的机制，每个进程都有自己的时间片，通过轮转的方式依次分配给各个进程。当某个进程出现死循环时，它会占用自己分配到的时间片，导致其他进程在该时间片内无法执行。但是，当时间片轮转到其他进程时，它们仍然可以正常运行。\n>\n>\n> 然而，死循环可能会导致系统的整体性能下降。因为死循环会消耗CPU的资源，导致其他进程无法充分利用CPU进行运算。如果死循环的进程是一个重要的系统进程，其消耗过多的CPU资源可能会导致系统响应变慢，甚至出现卡顿的情况。此外，如果死循环的进程还涉及到资源的竞争，如文件、网络连接等，可能会对其他进程的正常运行产生影响。\n\n> **如何解决？**\n>\n>   1. 杀死进程：通过操作系统的任务管理器或命令行工具，可以强制终止执行死循环的进程。这通常是最直接和有效的方法。\n>   2. 调试和修复：如果可能的话，应该对导致死循环的代码进行调试和修复。通过检查循环条件和逻辑，找出问题所在，并进行相应的修改。\n>   3.\n> 资源限制：操作系统可以提供一些机制来限制进程对CPU的占用，如设置进程优先级、使用CPU配额或限制进程的CPU使用时间。这些措施可以在一定程度上减轻死循环对系统的影响。\n>   4. 系统监控：实施系统监控和日志记录，以便及时发现并处理死循环等异常情况。这有助于提高系统的可维护性和可靠性。\n>   5.\n> 多核或多CPU环境：虽然问题是关于单CPU系统的，但将系统升级到具有多个核心或CPU的环境可以提供更高的并发处理能力。这样，即使一个进程陷入死循环，其他进程仍然可以在其他核心或CPU上正常运行。\n>\n\n**学习指引：**\n了解学习：[如何快速定位死循环](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%2Fnews%2F208611)\n\n## 8.计算机网络：有哪些网络攻击方式？在项目中针对可能的网络攻击采取了哪些相应的防范措施？\n\n**解析：** ：\n\n需要掌握一些常见的网络攻击方式，然后按照自己的理解，简单描述就行。\n\n**参考回答：**\n\n网络攻击方式多种多样，常见的包括拒绝服务攻击（DoS/DDoS），通过大量请求耗尽目标系统资源；SQL注入攻击，利用恶意SQL代码绕过身份验证；跨站脚本攻击（XSS），注入恶意脚本窃取用户信息。在项目中，我们采取了多种防范措施来应对这些攻击，例如实施防火墙和入侵检测系统来抵御DoS/DDoS攻击，使用参数化查询和预编译语句防止SQL注入，以及对用户输入进行严格的验证和过滤来防范XSS攻击。\n\n**学习指引：**\n\n面试学习：[《JavaGuide》|\n网络攻击常见手段总结](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjavaguide.cn%2Fcs-\nbasics%2Fnetwork%2Fnetwork-attack-means.html)\n\n## 9.计算机网络：cookie、session和token的区别？各自的使用场景？\n\n**解析：** ：\n\n计算机网络重点考题之一，后端真实项目中也会频繁涉及相关知识，所以不管从面试还是工作来说，都需要掌握\n\n**参考回答：**\n\n>   *\n> Cookie是由服务器发送到用户浏览器并存储在客户端的小段数据。它通常用于识别用户并保持会话状态。然而，由于Cookie存储在客户端，存在安全风险，如跨站请求伪造（CSRF）和跨站脚本攻击（XSS）。因此，它们适用于非敏感信息的短期存储，如用户偏好或购物车内容。\n>   *\n> Session是在服务器端创建并维护的用户会话信息。与Cookie不同，Session数据存储在服务器端，并通过唯一的会话标识符（通常存储在Cookie中）与用户关联。这提供了更高的安全性，因为敏感数据不会传输到客户端。Session适用于需要维护用户状态和进行身份验证的Web应用程序，如登录状态和用户个人资料。\n>   *\n> Token是一种身份验证和授权机制，通常用于API和微服务之间的通信。与Cookie和Session不同，Token是无状态的，意味着服务器不需要维护用户会话信息。相反，客户端在每次请求时附带Token，服务器验证其有效性并授权访问资源。Token的主要优势在于其可扩展性和跨域能力，适用于分布式系统和跨多个应用程序的身份验证。常见的Token类型包括JWT（JSON\n> Web Token），它们包含用户的身份信息和授权声明，并可以用于单点登录（SSO）和微服务之间的安全通信。\n>\n\n**学习指引：**\n\n一文搞懂：[《掘金博客》｜傻傻分不清之\nCookie、Session、Token、JWT](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjuejin.cn%2Fpost%2F6844904034181070861)\n\n## 10.数据库：项目中使用了NoSQL和MySQL，说说NoSQL和关系数据库的区别？\n\n**解析：** ： 可以从存储方式，扩展性，一致性，应用场景等几个方面来回答\n\n**参考回答：**\n\n>   * **存储方式**\n> :NoSQL数据库通常采用键值对、文档、宽列存储或图结构等非关系型数据模型，而关系数据库则使用表格形式来存储数据，具有严格的模式和结构。这种差异使得NoSQL数据库在处理非结构化或半结构化数据时更加灵活。\n>   * **扩展性方面:**\n> NoSQL数据库通常设计为易于水平扩展的，即通过增加更多的服务器来增加数据库的容量和性能。而关系数据库虽然也可以进行扩展，但通常更倾向于垂直扩展，即通过提升单个服务器的性能来增强数据库的处理能力。这使得NoSQL数据库在处理大量数据时更具优势。\n>   * **一致性**\n> :另外，NoSQL数据库通常不遵循ACID（原子性、一致性、隔离性、持久性）原则，而是在可用性和一致性之间做出了权衡。这意味着在某些情况下，NoSQL数据库可能会牺牲数据的一致性来保证系统的可用性和响应速度。而关系数据库则严格遵守ACID原则，确保数据的完整性和一致性。\n>   * **应用场景上:** :\n> NoSQL数据库更适合处理海量数据、高并发读写、对数据一致性要求不那么严格的场景，如社交网络、实时分析等。而关系数据库则更适合处理结构化数据、需要复杂查询和事务处理的场景，如银行、企业资源规划等。\n>\n\n**学习指引：** [《知乎》｜关系型数据库 VS\n非关系型数据库](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F78619241)\n\n本文也是**热门面经讲解》专栏** 系列文章之一，**文末尾有专栏链接** ，大家可以**点个关注** ，我会持续更新～～\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594570357311356928?sourceSSR=users",
        "title": "孩子王测试实习生面经",
        "content": "没有HR面，直接就是技术面\n\n1、自我介绍\n\n2、简历项目深挖\n\n3、职业规划\n\n4、测试案例（登录界面测试）\n\n5、sql考察\n\n6、linux命令考察\n\n7、编程语言考察\n\n8、职业规划\n\n9、抗压能力\n\n10、反问（我只问了一些日常工作内容的问题）\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594563356359479296?sourceSSR=users",
        "title": "华诺康 测试",
        "content": "一面\n\n三道笔试题\n\n根据直播需求写测试用例\n\n奇怪语言的编程题\n\n最长不重复字符串\n\n工作经历\n\n发展规划\n\nHr面\n\n自我介绍\n\n薪资期望\n\n离职原因\n\n空窗期原因\n\n对公司期望\n\n反问\n\n总监面\n\n离职原因\n\n求职考虑的因素\n\n测试流程\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594560422536101888?sourceSSR=users",
        "title": "美团笔试✍你准备好了吗，往年真题已上线，速刷！🏃‍♀️",
        "content": "[**春季刷题节活动正在进行中，限量周边/****100元****京东卡等你哦，和牛牛一起刷真题进大厂！**](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Flink%2Fchunjishauti2)\n\n[![](https://uploadfiles.nowcoder.com/images/20240228/999991353_1709091127200/45F820A377D8F6816998CB7A61BDB83B)](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Flink%2Fchunjishauti2)\n\n#### ** _不得不说，美团的笔试安排是周周见过的最清晰明确的👍_**\n\n![](https://uploadfiles.nowcoder.com/images/20240305/999991353_1709625515223/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n💡💡还有不到一周第一场笔试就要开始啦，还不知道笔试考什么的友友看过来！\n\n🔔🔔美团官方授权牛客一批笔试原题已上线！🎺是24届秋招考过的原题噢！！！\n\n**软开：**\n\n[https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=100&selectStatus=0&tagIds=179](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FcurrentTab%3Drecommand%26jobId%3D100%26selectStatus%3D0%26tagIds%3D179)\n\n**非技术：**\n\n[https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=104&selectStatus=0&tagIds=179](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FcurrentTab%3Drecommand%26jobId%3D104%26selectStatus%3D0%26tagIds%3D179)\n\n> 小贴士：电脑端使用Ctrl+F快捷键更方便查找\n\n![](https://uploadfiles.nowcoder.com/images/20240305/999991353_1709625714847/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n#### **校招详情**\n\n> 1、招聘岗位：技术/产品/商业分析 /零售/运营/设计市场营销/职能/金融/销售、客服和支持等10大类\n>\n> 2、2025届**转正实习招3000人** (其中技术约2000人)\n>\n> 3、2024届招**1000人**(其中技术/产品/运营合计约400人，需尽早投递)\n>\n> 4、北斗计划：美团面向全球精尖校园科技人才的招聘项目\n\n![](https://uploadfiles.nowcoder.com/images/20240305/999991353_1709626220836/38F0E83DE85FDFFC5A7D85D543C0CC78)\n\n> ###\n> **✨✨****更新更多更全校招信息请关注**[**牛客校招日程**](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgw-c.nowcoder.com%2Fapi%2Fsparta%2Fjump%2Flink%3Flink%3Dhttps%253A%252F%252Fgw-c.nowcoder.com%252Fapi%252Fsparta%252Fjump%252Flink%253Flink%253Dhttps%25253A%25252F%25252Fgw-c.nowcoder.com%25252Fapi%25252Fsparta%25252Fjump%25252Flink%25253Flink%25253Dhttps%2525253A%2525252F%2525252Fgw-c.nowcoder.com%2525252Fapi%2525252Fsparta%2525252Fjump%2525252Flink%2525253Flink%2525253Dhttps%252525253A%252525252F%252525252Fgw-c.nowcoder.com%252525252Fapi%252525252Fsparta%252525252Fjump%252525252Flink%252525253Flink%252525253Dhttps%25252525253A%25252525252F%25252525252Fwww.nowcoder.com%25252525252Flink%25252525252Fstxzrc)\n>\n> ###\n> [**https://www.nowcoder.com/link/stxzrc**](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgw-c.nowcoder.com%2Fapi%2Fsparta%2Fjump%2Flink%3Flink%3Dhttps%253A%252F%252Fgw-c.nowcoder.com%252Fapi%252Fsparta%252Fjump%252Flink%253Flink%253Dhttps%25253A%25252F%25252Fgw-c.nowcoder.com%25252Fapi%25252Fsparta%25252Fjump%25252Flink%25253Flink%25253Dhttps%2525253A%2525252F%2525252Fgw-c.nowcoder.com%2525252Fapi%2525252Fsparta%2525252Fjump%2525252Flink%2525253Flink%2525253Dhttps%252525253A%252525252F%252525252Fgw-c.nowcoder.com%252525252Fapi%252525252Fsparta%252525252Fjump%252525252Flink%252525253Flink%252525253Dhttps%25252525253A%25252525252F%25252525252Fwww.nowcoder.com%25252525252Flink%25252525252Fstxzrc)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594555579029340160?sourceSSR=users",
        "title": "雪浪云实习一面面经",
        "content": "问的比较基础\n\n#### 1.抽象类和接口的区别？\n\n1.定义与实现：抽象是一个类，可以有普通方法和抽象方法，抽象方法必须被子类实现。而接口是一组抽象方法的集合，所有方法都是抽象方法，没有具体实现。子类只能集成一个抽象类，但可以实现多个接口。\n\n2.构造函数和变量：抽象类可以有构造函数和变量，而接口没有构造函数，只能定义常量\n\n3.访问控制：抽象类方法可以是public、protected和default控制，而接口中方法默认是public\n\n4.默认实现：抽象类可以有普通方法的默认实现，而接口中所有方法都没有默认实现\n\n5.继承与实现：子类继承抽象类时必须实现其中的抽象方法，否则该子类也必须是抽象类；子类实现接口时必须实现其中所有方法(这个可以不答)\n\n#### 2.final关键字的作用？\n\n1.修饰类：该类不能被继承，保护类的完整性\n\n2.修饰方法：方法不能被重写，维护核心逻辑代码\n\n3.修饰变量：一个变量被声明final时，该变量表示一个常量，必须在构造函数中进行初始化。\n\n#### 3.Java集合是数据结构的实现\n\nCollection包含很多接口和类 如List、Set、Queue、Map等\n\n1.添加元素\n\n.add (Object o)：插入元素\n\n.addAll(~): 插入该集合里的所有元素\n\n2.删除\n\n.remove(Object o)：删除\n\n3.检查元素是否存在\n\n.contains(Object o)\n\nisEmpty()\n\n4.获取元素数量\n\n.size()\n\n5.遍历元素：\n\n使用迭代器\n\n使用增强for循环(for-each loop)\n\n6.获取元素：\n\nget(int Index) 返回列表中指定位置上的元素，如List ArrayList\n\ntoArray(): 返回包含此集合中所有元素的数组\n\n7.集合比较\n\n.equals(Object o)比较集合和指定对象是否相等\n\n.hashCode() 返回集合的哈希码值\n\n8.排序\n\n.Collections.sort() 对列表按照其自然顺序排列\n\n9.查找\n\nindexOf(Object o)：查找首次出现该元素的位置\n\n#### 4.redis有哪几种数据类型\n\n1.String、Hash、List、Set、Sorted Set\n\n#### 5.redis中如何添加元素\n\n1.字符串使用 set 命令，如 SET mykey\"myvalue\"将键mykey的值设置为myvalue\n\n2.哈希表 使用HSET命令来设置哈希表的字段和值。例如，HSET myhash field1\n\"value1\"将哈希表myhash的field1字段的值设置为value1\n\n3.列表 使用LPUSH或RPUSH，来在左侧或者右侧插入元素\n\n4.集合使用SADD来向集合添加元素\n\n(补充 List和set的区别) List是有序数据结构，可以重复存储元素。Set是无序数据结构，不允许存储重复元素\n\n#### 6.介绍下springboot启动注解\n\n在Spring\nBoot中，@SpringBootApplication注解是一个复合注解，它包括了其他三个重要的注解：@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan。当你创建一个Spring\nBoot项目时，通常会有一个带有@SpringBootApplication注解的类，这个类通常被称为主类（Start类）或启动类。\n\n除了@SpringBootApplication注解外，还有一些其他的注解和配置类在Spring\nBoot应用中可能会用到，但与“Start类”这一概念直接相关的主要是@SpringBootApplication。\n\n下面简单介绍一下这些注解和配置类：\n\n  1. ：这是一个复合注解，它包括了、和。它通常被放在主类上，用于启动Spring Boot应用。\n  2. ：这个注解表明该类是一个Spring Boot的配置类，通常与一起使用，用于定义bean。\n  3. ：这个注解告诉Spring Boot根据你的类路径、属性设置、各种条件等来自动配置项目。\n  4. ：这个注解用于让Spring扫描当前包及其子包下的组件、配置和服务等，并将其加入到应用上下文中。\n  5. ：这是一个泛化的概念，用于表示一个组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\n  6. ：用于标注数据访问组件，即DAO组件。\n  7. ：用于标注业务层组件。\n  8. 或 ：用于标注控制层组件（如struts中的action）。是和的合体，表示该类中的所有方法都返回JSON数据。\n\n7.SpringBoot的自动配置原理？\n\n8.springcloud不同模块怎么保证事务的一致？ 不会\n\n9.有哪些索引？答的是聚集索引和非聚集索引，还有复合索引\n\n10.怎么判断索引是否失效\n\n还有好几个问题不记得了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594554101548007424?sourceSSR=users",
        "title": "携程测试实习一面",
        "content": "1.自我介绍\n\n2.介绍一下项目的技术栈和使用的测试方法\n\n3.测试流程\n\n4.给你一个搜索框你会怎么去测试他\n\n5.如何对一个接口去进行测试\n\n6.给你一张酒店的订单表，查询某个日期某一酒店的订单数（口述）\n\n7.MySQL索引的优缺点，讲讲什么是聚簇索引和非聚簇索引\n\n8.如何尽快融入工作环境\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594550901583466496?sourceSSR=users",
        "title": "好难啊",
        "content": "今天二面了一家公司，深有感触，前面的时候面试官就项目扣的很细。\n\n到项目最后一个点支付功能，他问我第三方如果回调很慢怎么办，这个咱比较菜只关注于自己业务逻辑了，这个属实没想到。最后也是说了不会，他给我说的思路是前端同学可以拿到第三方的相关信息手动去调用，如果按照面试官的说法，那就等于否定了我实现这个支付低代码的初衷，我问了面试官，他说这就是他的一个想法，就是问问我有什么思路之类的，唉，还是自己太菜了，没有什么架构之类的思想，这一弄最后算法也写的不尽人意，虽然自己思路面试官是认可的，但是毕竟自己没写出来，唉。。。。。。。。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594498957061951488?sourceSSR=users",
        "title": "执行任务赚积分 - 华为OD统一考试（C卷）",
        "content": "> OD统一考试（C卷）\n>\n> 分值： 100分\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n现有 N 个任务需要处理，同一时间只能处理一个任务，处理每个任务所需要的时间固定为 1。\n\n每个任务都有**最晚处理时间限制** 和**积分值** ，在最晚处理时间点之前处理完成任务才可获得对应的积分奖励。\n\n可用于处理任务的时间有限，请问在有限的时间内，可获得的最多积分。\n\n## 输入描述\n\n第一行为一个数 N ，表示有 N 个任务（1 ≤ N ≤ 100 ）\n\n第二行为一个数 T ，表示可用于处理任务的时间。（1 ≤ T ≤ 100）\n\n接下来 N 行，每行两个空格分隔的整数（SLA 和 和 V ），SLA 表示任务的最晚处理时间，V 表示任务对应的积分。\n\n1≤SLA≤100 , 0 ≤ V ≤ 100000\n\n## 输出描述\n\n可获得的最多积分\n\n## 示例1\n\n    \n    \n    输入：\n    4\n    3\n    1 2\n    1 3\n    1 4\n    1 5\n    \n    输出：\n    5\n    \n    说明：\n    虽然有 3 个单位的时间用于处理任务，可是所有任务在时刻1之后都无效。 所以在第 1 个时间单位内，选择处理有 5 个积分的任务。1−3 时无任务处理。\n    \n\n## 示例2\n\n    \n    \n    输入：\n    4\n    3\n    1 2\n    1 3\n    1 4\n    3 5\n    \n    输出：\n    9\n    \n    说明：\n    第 1 个时间单位内，处理任务3，获得 4 个积分\n    第 2 个时间单位内，处理任务 4，获得 5 个积分\n    第 3 个时间单位内，无任务可处理。\n    共获得 9 个积分\n    \n\n## 题解\n\n> 这道题是一个**贪心算法** 的问题。以下是解题思路：\n>\n>   1. 将任务按照最晚处理时间（SLA）升序排序。\n>   2. 使用一个最小堆（优先队列）来维护当前可选任务的积分值。\n>   3. 遍历排序后的任务列表，将任务的积分值放入最小堆中，并累加总积分。\n>   4. 在每一步中，判断优先队里中所有任务能否在（优先队列里中）任务最晚完成时间之内完成，完成不了则将积分值最小的任务删除掉同时维护总积分。\n>   5. 最终的总积分即为答案\n>\n\n### Java\n\n    \n    \n    import java.util.Arrays;\n    import java.util.Comparator;\n    import java.util.PriorityQueue;\n    import java.util.Scanner;\n    \n    /**\n     * @author code5bug\n     */\n    public class Main {\n    \n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            int n = scanner.nextInt(), t = scanner.nextInt();\n    \n            int[][] tasks = new int[n][2];\n            for (int i = 0; i < n; i++) {\n                tasks[i][0] = scanner.nextInt();\n                tasks[i][1] = scanner.nextInt();\n            }\n    \n            // 对任务进行排序（时间升序）\n            Arrays.sort(tasks, Comparator.c\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594497401184927744?sourceSSR=users",
        "title": "面经 飞鱼",
        "content": "感觉面试主打一个真诚的菜，预计凉了，主要针对实习经历展开，其他倒是没多少询问的\n\n  1. 自我介绍\n  2. 询问实习经历中参与的分房系统和游戏项目经历\n  3. 实习期间时间主要用于做什么\n  4. 关卡设计的经验和感悟\n  5. 抽卡系统的经验和感悟 \n  6. 为什么gap半年\n  7. 对之前做的游戏有什么觉得不满意的点\n  8. 有没有觉得你们关卡设计是一厢情愿（问到了游戏真正的痛点）\n  9. 关卡之间的区别\n  10. 和同事领导有什么分歧（很奇怪为什么问这个）\n  11. 设计一个保卫萝卜的塔\n  12. 实习期间犯过的最严重的错误是？\n  13. 还有其他问题吗？\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594457518957408256?sourceSSR=users",
        "title": "2024.3.4鹅厂后台开发一面凉经",
        "content": "发出来攒攒人品\n\n面试官人很和蔼，态度也很好。\n\n1.讲一下TCP三次握手 为什么要3次，两次或者四次不行吗\n\n2.讲一下常见的针对TCP的网络攻击\n\n3.如何应对SYN flood攻击？\n\n4.讲一下TCP的TIme_WAIT状态，如果服务器中存在大量的这个状态应该怎么排查？\n\n5.如果项目中出现CPU占用过高的情况，该怎么排查和处理？\n\n6.介绍一下Linux常见命令？top命令具体是做什么的？\n\n7.讲一下HashMap，为什么HashMap要引入红黑树？为什么树化的默认节点是8？如果不用红黑树如何处理过长的链表？\n\n8.HashMap是线程安全的吗？如果不是那什么是？\n\n9.为什么ConcurrentHashMap是线程安全的？是如何实现线程安全的呢？\n\n10.介绍一下Base64编码的原理，为什么Base64编码会使数据体积变大33%？\n\n11.介绍一下Flink CEP是如何匹配事件的？\n\n12.讲一下用Flink处理流数据的时候如何分割两个不同的帖子或者推文？\n\n13.为什么Redis Pub/Sub比Kafka更快一些？二者之间如何选取？\n\n14.Kafka是如何做到数据持久化的？\n\n还有一些琐碎的问题，不太记得了。\n\n然后就是算法题，有思路但是太久没敲代码了结果没写出来，太烂了！\n\n反问：接下来该朝哪个方向努力？面试官答编码能力（我想也是，确实太烂了）\n\n**想问问在鹅厂的朋友，这种情况挂了还能继续投其他岗位的吗？**\n\n**或者有没有招后端实习生的公司，孩子真的很想实习！**\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594467008666746880?sourceSSR=users",
        "title": "剩余银饰的重量 - 华为OD统一考试（C卷）",
        "content": "> OD统一考试（C卷）\n>\n> 分值： 100分\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n有N块二手市场收集的银饰，每块银饰的重量都是正整数，收集到的银饰会被熔化用于打造新的饰品。\n\n每一回合，从中选出三块 最重的 银饰，然后一起熔掉。\n\n假设银饰的重量分别为 x 、y和z，且 x <= y <= z。那么熔掉的可能结果如下：\n\n  * 如果 x == y == z，那么三块银饰都会被完全熔掉；\n  * 如果 x == y 且 y != z，会剩余重量为 z - y 的银块无法被熔掉；\n  * 如果 x != y 且 y == z，会剩余重量为 y - x 的银块无法被熔掉；\n  * 如果 x != y 且 y != z，会剩余重量为 z - y 与 y - x 差值 的银块无法被熔掉。\n  * 最后，如果剩余两块，返回较大的重量（若两块重量相同，返回任意一块皆可）；\n  * 如果只剩下一块，返回该块的重量；如果没有剩下，就返回 0。\n\n## 输入描述\n\n输入数据为两行\n\n第一行为银饰数组长度 n，1 ≤ n ≤ 40，\n\n第二行为n块银饰的重量，重量的取值范围为[1，2000]，重量之间使用空格隔开\n\n## 输出描述\n\n如果剩余两块，返回较大的重量（若两块重量相同，返回任意一块皆可）；\n\n如果只剩下一块，返回该块的重量；如果没有剩下，就返回 0。\n\n## 示例1\n\n    \n    \n    输入：\n    3\n    1 1 1\n    \n    输出：\n    0\n    \n    说明：\n    选出1 1 1，得到 0，最终数组转换为 []，最后没有剩下银块，返回0\n    \n\n## 示例2\n\n    \n    \n    输入：\n    3\n    3 7 10\n    \n    输出：\n    1\n    \n    说明：\n    选出 3 7 10，需要计算 (7-3) 和 (10-7) 的差值，即(7-3)-(10-7)=1，所以数组转换为 [1]，剩余一块，返回该块重量，返回1\n    \n\n## 题解\n\n> 这道题目属于**贪心算法**\n> 的范畴，通过每一轮选择最重的三块银饰进行熔化，根据题目规则计算剩余银块的重量，并不断重复这个过程，直到没有银块为止。在这个过程中，需要注意每一轮熔化的计算方式，以及处理剩余银块的规则。\n>\n> ### 解题思路\n>\n>   1. 使用一个最大堆（或最小堆，但在 Python 中需要对元素取反以实现最大堆的效果）来存储银饰的重量，保证每次选择的都是最重的三块银饰。\n>   2. 每次从堆中取出三块银饰，根据题目规则计算剩余银块的重量，并将结果重新放入堆中。\n>   3. 不断重复上述步骤，直到堆中银饰数量小于3个。\n>   4. 根据题目要求，返回最后剩余的银块重量。\n>\n\n### Java\n\n    \n    \n    import java.util.Collections;\n    import java.util.PriorityQueue;\n    import java.util.Scanner;\n    /**\n     * @author code5bug\n     */\n    public class Main {\n        public static void main(String[] args) {\n            Scanner in = new Scanner(System.in);\n            int n = in.nextInt();\n            PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\n            for (int i = 0; i < n; i++) {\n                pq.offer(in.nextInt());\n            }\n    \n            Solution solution = new Solution();\n            System.out.println(solution.solve(pq));\n        }\n    }\n    \n    \n    class Solution {\n        public int solve(PriorityQueue<Integer> pq) {\n            if (pq.isEmpty()) {\n                return 0;\n            } else if (pq.size() == 1) {\n                return pq.peek();\n            } else \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594457201540894720?sourceSSR=users",
        "title": "苏州奇梦者科技 软件测试",
        "content": "Boss电话面 下面开始面试问答\n\n**为什么开发转测试** 测试转跳\n\n**c语言三种基本数据模型（模型？**[拜拜]**）** 基本数据类型 数组类型 结构体类型\n\n**结构与联合的区别** 结构体适合用于存储和处理多种类型的数据，每个成员有自己的内存空间，各个成员之间相互独立。\n\n联合适合用于节省内存空间，只需一次性存储其中一个成员的数据，不同成员之间共享同一块内存空间，适合用于某种时刻只会使用其中一个成员的情况。\n\n**怎样引用一个已经定义的全局变量** extern关键字来声明该全局变量\n\n**变量声明和定义与什么区别** 声明只是告诉编译器变量的类型和名称，不会分配内存空间，而定义则会为变量分配内存空间。\n\n在大多数情况下，变量的声明会放在头文件中，而变量的定义会放在源文件中。\n\n**python内存管理** 自动内存分配： 引用计数：垃圾回收： 内存池：\n\n**python 命名空间** 命名空间（Namespace）是指变量名到对象的映射关系 局部命名空间 全局命名空间 内置命名空间 模块命名空间\n\n**python切片** 切片（Slice）是一种用于从序列（如列表、元组、字符串等）中获取子序列的机制\n\n**postman测一万个并发** [喝可乐]好像是个坑 Python的requests Apache JMeter、LoadRunner 要使用\nrequests 库来模拟一万个并发请求，您可以编写一个简单的Python脚本，利用多线程或者异步请求来实现并发。以下是一个使用多线程的示例：\n\n`python`\n\n`Copy code`\n\n`import requests`\n\n`import threading`\n\n``\n\n`# 要发送的请求的URL`\n\n`url = 'http://example.com/api'`\n\n``\n\n`# 要发送的请求数据（如果需要的话）`\n\n`data = {'key': 'value'}`\n\n``\n\n`# 发送请求的函数`\n\n`def send_request():`\n\n` response = requests.post(url, json=data)`\n\n` print(response.text)`\n\n``\n\n`# 启动一万个线程发送请求`\n\n`for _ in range(10000):`\n\n` threading.Thread(target=send_request).start()`\n\n**JMter创建基本测试计划**\n\n要使用 JMeter 进行一万个并发请求测试，您可以按照以下步骤操作：\n\n`安装 JMeter：`\n\n``\n\n`首先，您需要从 JMeter 官方网站（https://jmeter.apache.org/）下载并安装 JMeter。JMeter\n是一个纯Java应用程序，因此可以在多个操作系统上运行。`\n\n`创建测试计划：`\n\n``\n\n`启动 JMeter 后，您需要创建一个新的测试计划。在 JMeter 主界面中，右键单击“Test Plan”，然后选择“Add -> Threads\n(Users) -> Thread Group”来添加一个线程组。`\n\n`配置线程组：`\n\n``\n\n`在 Thread Group 下，您可以配置线程数（即并发用户数）、Ramp-Up\nPeriod（线程启动间隔）、循环次数等参数。设置线程数为一万，表示要模拟一万个并发用户。`\n\n`添加 HTTP 请求：`\n\n``\n\n`在 Thread Group 下，右键单击选择“Add -> Sampler -> HTTP Request”，然后配置请求的\nURL、请求方法、请求参数等信息。`\n\n`运行测试：`\n\n``\n\n`配置好测试计划后，您可以点击工具栏中的“Start”按钮来运行测试。JMeter 将会模拟一万个并发用户发送请求，并且收集性能数据。`\n\n`分析测试结果：`\n\n`测试运行完成后，您可以查看 JMeter 的测试结果。您可以通过图形报告、性能分析报告等方式来查看请求响应时间、吞吐量、错误率等性能指标。`\n\n（开始正式）\n\n测试流程 测试用例要素 黑盒用例方法 测试v字图[羞涩]（只知道测试流程） 加班怎么看 996怎么看\n\n反问\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594446533064404992?sourceSSR=users",
        "title": "京东 | 测开 | 一面 | 0301",
        "content": "> ## 发面经 攒好运\n\n## 一面 技术面 0301\n\n40min\n\n  1. 自我介绍\n  2. 聊项目、美赛\n  3. 写Linux命令：有一个纯文本文件log.txt，搜索出来所有带 error 关键字的\n  4. 列出当前文件夹所有的文件和文件夹，按照修改时间升序排列\n  5. 644对应的权限 & 755对应的权限 \n  6. C++中的指针和引用的区别？\n  7. 使用的Python是什么版本的？python中哪些类型是可变的？哪些不可变？ \n  8. 迭代器和生成器的区别\n  9. MySQL内联、左联、右联的区别 \n  10. Git的rebase和merge的区别\n  11. 为什么选择flask框架？\n  12. HTTP的状态码\n  13. 对测试有什么了解？学习了什么？\n  14. 黑盒和白盒测试的区别\n  15. 兼容性测试通常测什么？\n  16. 手撕：找平衡点\n  17. 对上面那题该如何测试？\n  18. 代码为什么用C++写 没有用Python？。。。好久没用python\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594304527226933248?sourceSSR=users",
        "title": "腾讯暑期实习-微信支付",
        "content": "上来三道算法题\n\n1，LRU。\n\n2, 接雨水。\n\n3，删除链表中倒数第n个节点。\n\n大概30分钟全写完了。\n\n能不能转C++ 能\n\n八股：\n\nJVM垃圾删除\n\nhttps的加密技术\n\n说一说常用的并发容器\n\n项目：说一说项目的亮点。\n\n（面完一个小时后流程结束[牛泪]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594294704125071360?sourceSSR=users",
        "title": "腾讯前端实习一面",
        "content": "![](https://uploadfiles.nowcoder.com/message_images/20240304/550678068_1709562853049/discuss_1709562852484.jpeg)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594278801438232576?sourceSSR=users",
        "title": "百度Java实习面试都这么难了吗？|0304",
        "content": ">\n> ![alt](https://uploadfiles.nowcoder.com/images/20240304/630265916_1709559567924/89466982D4547CCCEF0DD78D2CA0B3BE)\n\n>\n> ![](https://git.acwing.com/Hasity/interview_hunter/-/raw/master/2024/image/%E9%9D%A2%E7%BB%8F_9%E7%99%BE%E5%BA%A6%E5%AE%9E%E4%B9%A0.png)\n\n## 1、联合索引底层存储结构(和其他种类的索引的存储结构有什么区别?)\n\n联合索引是数据库中一种常见的索引类型，它允许在多个列上创建索引，以提高查询性能。与单列索引相比，联合索引的底层存储结构有一些区别，主要体现在如何组织和存储索引数据的方式上。\n\n  1. **存储数据的组织方式** ：\n\n     * 单列索引：单列索引只包含一个列的值和指向相应数据行的指针。通常，单列索引按照列值的大小顺序来组织存储数据。\n     * 联合索引：联合索引则包含多个列的值，以及指向相应数据行的指针。联合索引可以按照多个列值的组合来组织存储数据，这意味着可以根据多个列的值来定位数据行。\n  2. **查询时的性能影响** ：\n\n     * 单列索引：单列索引适合用于只涉及单个列的查询。当查询条件涉及到索引列时，数据库可以更快地定位到匹配的数据行。\n     * 联合索引：联合索引适合用于涉及多个列的查询。当查询涉及到联合索引中的多个列时，数据库可以利用索引中列值的组合来快速定位匹配的数据行。\n  3. **索引维护的复杂性** ：\n\n     * 单列索引：单列索引的维护相对简单，因为它只需要维护单个列的值和指针。\n     * 联合索引：联合索引的维护相对复杂一些，因为它需要考虑多个列值的组合。当表中的数据发生变化时，数据库需要确保联合索引中的多个列值的组合保持有序，这可能需要更多的资源和时间。\n\n联合索引在适当的情况下可以提供更好的查询性能，特别是对于涉及到联合索引中列值的组合的查询。然而，需要注意的是，联合索引的创建和维护可能会带来一些额外的开销，并且需要根据具体的查询需求和数据模式来合理选择索引策略。\n\n>\n> **[面经专栏直通车](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fcreation%2Fmanager%2FcolumnDetail%2F0xKkDM)**\n\n>\n> **[面经专栏下载](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgit.acwing.com%2Flicw%2F24_job_hunter)**\n\n## 2、联合索引的叶子节点存的什么内容?\n\n联合索引的叶子节点存储的是索引列的值以及指向对应数据行的指针（聚集索引键值）。在联合索引中，叶子节点包含了多个列的值，以及指向对应数据行的指针（者聚集索引键值）的组合。\n\n具体来说，叶子节点中存储了索引列的实际值，以及一个指向相应数据行的指针（者聚集索引键值）。这样，当数据库引擎根据联合索引执行查询时，它可以通过索引中的列值找到对应的叶子节点，然后使用叶子节点中的指针（键值）来定位到相应的数据行。\n\n联合索引的叶子节点存储了索引列的值和指向数据行的指针（键值）的组合，这样可以在查询时快速定位到匹配的数据行。\n\n## 3、事务会不会自动提交?\n\nMySQL 默认开启事务自动提交模式，即除非显式的开启事务（BEGIN 或 START TRANSACTION），否则每条 SOL\n语句都会被当做一个单独的事务自动执行。\n\n要启用自动提交，在执行任何DML（Data Manipulation\nLanguage）语句（例如INSERT、UPDATE、DELETE）之前，可以使用以下语句开启自动提交：\n\n    \n    \n    SET autocommit = 1;\n    \n\n或者可以在连接到数据库时在连接字符串中指定`autocommit`参数为1。\n\n    \n    \n    mysql -u username -p -h hostname dbname --autocommit=1\n    \n\n这将使得MySQL会话处于自动提交模式，这意味着每个单独的DML语句都将自动成为一个事务，并在执行完成后立即提交。\n\n如果想要禁用自动提交，可以使用以下语句：\n\n    \n    \n    SET autocommit = 0;\n    \n\n或者在连接字符串中指定`autocommit`参数为0。\n\n## 4、MySQL默认的隔离级别是什么?\n\nMySQL的默认隔离级别是可重复读（Repeatable\nRead）。在可重复读隔离级别下，事务可以读取其他事务已经提交的数据，但是不会看到其他事务未提交的数据。这意味着在同一个事务中多次读取相同的数据，将会得到相同的结果，即使其他事务对该数据进行了修改也是如此。\n\n可重复读隔离级别保证了在同一个事务中多次读取数据时的一致性，但也可能导致一些并发问题，如幻读（Phantom\nRead）。MySQL提供了其他隔离级别来解决不同的并发问题，包括读未提交（Read Uncommitted）、读已提交（Read\nCommitted）和串行化（Serializable）等。\n\n需要注意的是，虽然MySQL的默认隔离级别是可重复读，但实际上可以在会话级别或全局级别进行更改，以满足特定的应用需求。\n\nInnoDB\n当前读下的幻读是通过间隙锁（gap_lock)来实现的。在事务A查询的时候，会锁住一个间隙，其它事务往这个间隙插入、删除等操作都是会被锁阻塞的。间隙锁和插入意向锁互斥，彻底解决了当前读下的幻读问题。\n\n但是InnoDB 没有完全解决快照读下的幻读问题。\n\n## 5、Gc算法有哪些?\n\nJava的垃圾收集（Garbage Collection，GC）算法有多种，每种算法都有其独特的特点和适用场景。以下是几种常见的Java GC算法：\n\n  1. **标记-清除算法（Mark and Sweep）** ：\n\n     * 标记阶段：从根对象出发，递归地标记所有可以被访问到的对象。\n     * 清除阶段：清除未被标记的对象，即不可达对象。\n     * 缺点：产生内存碎片，可能导致内存分配效率降低。\n  2. **复制算法（Copying）** ：\n\n     * 将堆内存分为两个区域：年轻代和老年代。\n     * 年轻代分为Eden区和两个Survivor区。\n     * 对象首先被分配到Eden区，当Eden区满时，触发Minor GC，将存活的对象复制到Survivor区，然后清空Eden区和一个Survivor区，再将存活的对象从另一个Survivor区复制到空的Survivor区。\n     * 优点：不会产生内存碎片，适用于频繁回收对象的场景。\n  3. **标记-整理算法（Mark and Compact）** ：\n\n     * 标记阶段：与标记-清除算法相同，标记所有可达对象。\n     * 整理阶段：将所有存活的对象向一端移动，然后清理掉不可达对象，从而消除内存碎片。\n     * 优点：不会产生内存碎片，可以提高内存分配效率。\n  4. **分代收集算法（Generational Collection）** ：\n\n     * 将堆内存分为年轻代和老年代两部分，使用不同的GC算法。\n     * 年轻代通常使用复制算法，因为大多数对象在这里很快变得不可达，适合频繁进行垃圾收集。\n     * 老年代通常使用标记-清除或标记-整理算法，因为老年代存活的对象较多，适合采用更加成熟的算法来进行垃圾收集。\n  5. **G1算法（Garbage-First）** ：\n\n     * 将堆内存分成多个大小相等的区域（Region），包括年轻代、老年代和Metaspace等。\n     * 将整个堆内存划分为多个Region，通过标记-复制和标记-整理的方式来执行垃圾收集。\n     * G1算法通过优先收集垃圾最多的Region来提高垃圾收集效率，因此称为“Garbage-First”。\n\n## 6、G1 垃圾回收器了解吗?\n\nG1（Garbage-First）垃圾回收器是Java虚拟机（JVM）中一种现代的垃圾回收器，引入自Java 7 Update\n4版本。G1垃圾回收器旨在替代CMS（Concurrent Mark-Sweep）垃圾回收器，并且在大内存堆上表现更加稳定和高效。\n\nG1垃圾回收器具有以下特点：\n\n  1. **区域化内存管理** ：G1将堆内存划分为多个固定大小的区域（Region），每个区域可以是Eden区、Survivor区或Old区。这种区域化的内存管理有助于更好地控制垃圾回收过程，减少停顿时间。\n\n  2. **分代收集** ：虽然G1并不是一个传统的分代收集器，但它仍然将堆内存划分为年轻代和老年代，并且使用不同的垃圾回收策略来处理这两个代。\n\n  3. **并发标记清除** ：G1使用了并发标记（Concurrent Marking）来减少垃圾回收暂停时间。在标记阶段，G1通过并发标记线程来标记活动对象，而在应用程序运行的同时，也会继续标记操作。这样可以减少标记阶段对应用程序的影响。\n\n  4. **整理内存** ：G1使用了复制算法来清理内存，不再使用传统的压缩算法。在垃圾收集过程中，G1会选择一些区域进行垃圾收集，并将存活对象复制到其他区域中，从而实现内存的整理和碎片整理。\n\n  5. **垃圾优先收集** ：G1根据垃圾回收需求来选择优先回收的区域，以此来提高垃圾回收效率。它会优先选择包含垃圾最多的区域进行回收，从而最大程度地减少垃圾对象。\n\nG1垃圾回收器在大内存堆上表现更加稳定和高效，尤其适用于需要低停顿时间和更加可控的垃圾回收的应用场景。\n\n## 7、什么时候会触发 GC?\n\n在Java虚拟机中，垃圾回收（GC）会在以下几种情况下触发：\n\n  1. **系统内存不足** ：当Java虚拟机检测到系统内存不足时，会触发垃圾回收来释放内存空间，以确保应用程序的正常运行。这通常是通过监视堆内存的使用情况来检测的。\n\n  2. **调用System.gc()方法** ：虽然调用System.gc()方法并不会立即触发垃圾回收，但它会向Java虚拟机发出建议性的垃圾回收请求。Java虚拟机可以选择是否立即响应这个请求。\n\n  3. **长时间停顿** ：当应用程序执行时间较长，而且没有进行垃圾回收时，Java虚拟机可能会为了避免堆内存耗尽而触发垃圾回收。这种情况下，垃圾回收通常会引起一段较长的停顿时间，称为Full GC。\n\n  4. **Young Generation满** ：在分代垃圾回收器中，当Young Generation区域满时，会触发一次Minor GC。这会导致Eden区和Survivor区的垃圾回收。\n\n  5. **Old Generation满** ：如果Old Generation区域满了，会触发一次Major GC（也称为Full GC）。这种情况下，整个堆内存都会进行垃圾回收。\n\n  6. **永久代/元空间满** ：对于HotSpot虚拟机，如果永久代（Java 7之前）或者元空间（Java 8及之后）满了，会触发一次垃圾回收。这种情况下，垃圾回收主要针对类的元数据和常量池。\n\n需要注意的是，具体触发垃圾回收的时机和方式取决于Java虚拟机的实现，不同的虚拟机可能有不同的行为。此外，开发人员可以通过调整垃圾回收相关的参数来影响垃圾回收的行为，以优化应用程序的性能和资源利用率。\n\n## 8、线程安全和线程不安全是什么意思?\n\n\"线程安全\"和\"线程不安全\"是描述在多线程环境中并发操作的状态的术语。\n\n  1. **线程安全** ：\n\n     * 线程安全指的是在多线程环境下，对共享数据的访问操作能够保证在并发情况下不会导致数据的不一致性或损坏。一个线程安全的操作或数据结构能够在并发访问时维持其内部状态的一致性。\n     * 线程安全的实现通常会采用同步机制（例如锁、信号量等）来保护共享资源的访问，以确保在任意时刻只有一个线程能够访问共享资源，从而避免竞态条件（Race Condition）和其他并发问题。\n  2. **线程不安全** ：\n\n     * 线程不安全指的是在多线程环境下，对共享数据的访问操作可能会导致数据的不一致性或损坏。线程不安全的操作或数据结构在并发访问时无法保证其内部状态的一致性，可能会导致意外的结果或程序错误。\n     * 线程不安全的实现通常没有考虑到并发访问的情况，没有采取适当的同步措施来保护共享资源的访问，因此可能会出现竞态条件和其他并发问题。\n\n举例来说，如果多个线程同时尝试向同一个数组中添加元素，而该数组的添加操作没有进行适当的同步控制，那么就可能导致线程不安全的情况，如数据覆盖、越界访问等。为了保证线程安全，需要在并发访问共享资源时使用适当的同步机制来确保数据的一致性。\n\n## 9、场景:有一个 key 对应的 value 是一个json,结构，json,当中有好几个子任务，这些子任务如果对 key\n进行修改的话,会不会存在线程安全的问题?如何解决?如果是多个节点的情况，应该怎么加锁?\n\n在这个场景中，如果多个线程同时对同一个 key 对应的 JSON\n结构中的子任务进行修改，就有可能出现线程安全的问题，因为多个线程同时对同一个数据结构进行修改可能导致数据不一致或损坏。\n\n要解决这个问题，可以采用以下方法：\n\n  1. **使用线程安全的数据结构** ：可以选择使用线程安全的数据结构来存储 JSON 数据，例如 `ConcurrentHashMap` 或 `CopyOnWriteArrayList`，它们内部提供了并发访问的安全保证，能够在多线程环境下安全地进行操作。\n\n  2. **使用同步机制** ：可以使用同步机制（例如锁）来保护对 JSON 数据的修改操作，确保在任意时刻只有一个线程能够修改数据。比如，在对 JSON 数据进行修改之前，先获取一个锁，并在操作完成后释放锁。\n\n  3. **粒度控制** ：可以考虑将 JSON 数据的不同部分分别进行锁定，以减小锁的粒度，提高并发性能。比如，可以为不同的子任务或不同的节点设置不同的锁。\n\n如果是多个节点的情况，需要在分布式环境下进行考虑。可以选择分布式锁机制来实现跨节点的数据同步和并发控制，比如使用 ZooKeeper、Redis\n等分布式系统提供的分布式锁服务来确保在不同节点上对数据的并发修改操作是安全的。\n\n## 10、Setnx,知道吗? 用这个加锁有什么问题吗?怎么解决?\n\n`SETNX` 是 Redis 中的一个命令，用于设置键的值，但仅当键不存在时才设置成功。在分布式环境中，可以利用 `SETNX`\n命令来实现分布式锁。具体步骤如下：\n\n  1. 客户端通过 `SETNX` 命令尝试将一个特定的键作为锁的标识，并设置一个唯一的值作为锁的持有者标识。\n  2. 如果 `SETNX` 命令成功执行（返回值为 1），表示当前客户端成功获取了锁，可以执行后续操作。\n  3. 如果 `SETNX` 命令执行失败（返回值为 0），表示当前锁已被其他客户端持有，当前客户端未获取到锁，需要等待一段时间后重新尝试获取锁。\n\n虽然 `SETNX` 命令在某些情况下可以用来实现简单的分布式锁，但是它也存在一些问题：\n\n  1. **无法设置过期时间** ：`SETNX` 命令本身不支持设置键的过期时间，因此当持有锁的客户端发生异常或程序出现问题时，可能导致锁无法被释放，造成死锁或锁泄露问题。\n\n  2. **非原子性操作** ：尽管 `SETNX` 命令本身是原子性的，但是获取锁和释放锁通常需要多个命令的组合，例如获取锁时需要执行 `SETNX`，释放锁时需要执行 `DEL`。这种组合操作不是原子性的，可能会导致锁的不一致性问题。\n\n为了解决这些问题，可以采用以下方法：\n\n  1. **配合`EXPIRE` 命令设置过期时间**：在获取锁成功后，使用 `EXPIRE` 命令为锁设置一个合理的过期时间，确保即使持有锁的客户端发生异常，锁也能在一定时间后自动释放。\n\n  2. **使用 Lua 脚本确保原子性** ：将获取锁和释放锁的操作封装在 Lua 脚本中执行，Lua 脚本可以在 Redis 中以原子性的方式执行多个命令，确保获取锁和释放锁的操作是原子性的，避免了竞态条件的发生。\n\n  3. **考虑使用 Redlock 算法等更复杂的分布式锁方案** ：如果应用场景要求更高的分布式锁安全性和可靠性，可以考虑使用 Redlock 算法等更复杂的分布式锁方案，这些方案通常基于多个 Redis 实例，并结合超时机制和复制机制来保证分布式锁的安全性和可靠性。\n\n## 11、层次遍历一个 DAG 图，有向无环图。\n\n以下是用 Java 实现层次遍历（BFS）一个有向无环图（DAG）的代码示例：\n\n    \n    \n    import java.util.*;\n    \n    public class TopologicalSort {\n        public List<Integer> topologicalSort(int numCourses, int[][] prerequisites) {\n            List<Integer> result = new ArrayList<>();\n            if (numCourses <= 0 || prerequisites == null || prerequisites.length == 0) {\n                return result;\n            }\n    \n            // 创建入度数组和邻接表\n            int[] indegree = new int[numCourses];\n            List<List<Integer>> adjacencyList = new ArrayList<>();\n            for (int i = 0; i < numCourses; i++) {\n                adjacencyList.add(new ArrayList<>());\n            }\n    \n            // 构建入度数组和邻接表\n            for (int[] prerequisite : prerequisites) {\n                int course = prerequisite[0];\n                int prerequisiteCourse = prerequisite[1];\n                indegree[course]++;\n                adjacencyList.get(prerequisiteCourse).add(course);\n            }\n    \n            // 使用队列进行拓扑排序\n            Queue<Integer> queue = new LinkedList<>();\n            for (int i = 0; i < numCourses; i++) {\n                if (indegree[i] == 0) {\n                    queue.offer(i);\n                }\n            }\n    \n            while (!queue.isEmpty()) {\n                int course = queue.poll();\n                result.add(course);\n                for (int neighbor : adjacencyList.get(course)) {\n                    indegree[neighbor]--;\n                    if (indegree[neighbor] == 0) {\n                        queue.offer(neighbor);\n                    }\n                }\n            }\n    \n            // 如果有环，则无法完成拓扑排序\n            if (result.size() != numCourses) {\n                return new ArrayList<>();\n            }\n    \n            return result;\n        }\n    \n        public static void main(String[] args) {\n            int numCourses = 4;\n            int[][] prerequisites = {{1, 0}, {2, 0}, {3, 1}, {3, 2}};\n            TopologicalSort solution = new TopologicalSort();\n            List<Integer> result = solution.topologicalSort(numCourses, prerequisites);\n            System.out.println(\"Topological order: \" + result); // Output: [0, 1, 2, 3]\n        }\n    }\n    \n\n在这个示例中，定了一个 `TopologicalSort` 类，其中包含 `topologicalSort`\n方法用于对有向无环图进行层次遍历（拓扑排序）。在 `topologicalSort`\n方法中，我们首先构建了入度数组和邻接表，然后使用队列进行拓扑排序，并将排序结果保存在 `result`\n中。最后，我们检查排序结果是否完整，如果存在环则返回空列表。\n\n在 `main` 方法中，我们定义了一个示例的有向无环图，然后调用 `topologicalSort` 方法进行层次遍历，并输出排序结果。\n\n## 12、leetcode 岛屿数量\n\n以下是用 Java 实现 LeetCode 上「岛屿数量」问题的代码示例：\n\n    \n    \n    public class NumIslands {\n        public int numIslands(char[][] grid) {\n            if (grid == null || grid.length == 0 || grid[0].length == 0) {\n                return 0;\n            }\n    \n            int numIslands = 0;\n            int rows = grid.length;\n            int cols = grid[0].length;\n    \n            for (int i = 0; i < rows; i++) {\n                for (int j = 0; j < cols; j++) {\n                    if (grid[i][j] == '1') {\n                        numIslands++;\n                        dfs(grid, i, j);\n                    }\n                }\n            }\n    \n            return numIslands;\n        }\n    \n        private void dfs(char[][] grid, int i, int j) {\n            int rows = grid.length;\n            int cols = grid[0].length;\n    \n            if (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] == '0') {\n                return;\n            }\n    \n            grid[i][j] = '0'; // Mark the current cell as visited\n    \n            // Explore the four neighboring cells\n            dfs(grid, i - 1, j);\n            dfs(grid, i + 1, j);\n            dfs(grid, i, j - 1);\n            dfs(grid, i, j + 1);\n        }\n    \n        public static void main(String[] args) {\n            char[][] grid = {\n                {'1', '1', '0', '0', '0'},\n                {'1', '1', '0', '0', '0'},\n                {'0', '0', '1', '0', '0'},\n                {'0', '0', '0', '1', '1'}\n            };\n            NumIslands solution = new NumIslands();\n            int numIslands = solution.numIslands(grid);\n            System.out.println(\"Number of islands: \" + numIslands); // Output: 3\n        }\n    }\n    \n\n在这个示例中，定义了一个 `NumIslands` 类，其中包含 `numIslands` 方法用于计算岛屿数量。在 `numIslands`\n方法中，我们使用深度优先搜索（DFS）来遍历二维网格，并统计岛屿的数量。具体的深度优先搜索逻辑由 `dfs` 方法实现。在 `main`\n方法中，我们定义了一个示例的二维网格 `grid`，并调用 `numIslands` 方法计算岛屿数量。\n\n## 13、 有一个主任务，它有四个子任务，分别存在下面几种状态:wait,running，success，fail。用if-else\n的形式写出所有可能发生的情况。\n\n以下是使用 Java 实现主任务及其四个子任务可能的状态组合的代码示例：\n\n    \n    \n    public class MainTask {\n        public static void main(String[] args) {\n            String mainTaskStatus = \"wait\"; // 主任务状态\n            String subTask1Status = \"wait\"; // 子任务1状态\n            String subTask2Status = \"running\"; // 子任务2状态\n            String subTask3Status = \"success\"; // 子任务3状态\n            String subTask4Status = \"fail\"; // 子任务4状态\n    \n            if (mainTaskStatus.equals(\"wait\")) {\n                if (subTask1Status.equals(\"wait\")) {\n                    System.out.println(\"主任务等待，子任务1等待\");\n                } else if (subTask1Status.equals(\"running\")) {\n                    System.out.println(\"主任务等待，子任务1运行中\");\n                } else if (subTask1Status.equals(\"success\")) {\n                    System.out.println(\"主任务等待，子任务1成功\");\n                } else if (subTask1Status.equals(\"fail\")) {\n                    System.out.println(\"主任务等待，子任务1失败\");\n                }\n            } else if (mainTaskStatus.equals(\"running\")) {\n                // 类似处理其他状态组合...\n            } else if (mainTaskStatus.equals(\"success\")) {\n                // 类似处理其他状态组合...\n            } else if (mainTaskStatus.equals(\"fail\")) {\n                // 类似处理其他状态组合...\n            }\n        }\n    }\n    \n\n这段 Java 代码中，定义了一个 `MainTask` 类，其中包含了 `main()` 方法作为程序入口。在 `main()`\n方法中，定义了主任务和四个子任务的状态变量，并使用嵌套的 `if-else`\n条件语句来处理不同的状态组合。根据实际需求，可以在每个条件分支中添加相应的逻辑处理。\n\n[分享者：@我真的很帅阿](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Ffeed%2Fmain%2Fdetail%2Fd57903ad1e2447699c59f2ecb570f419)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594271412144132096?sourceSSR=users",
        "title": "2024京东春招3.2笔试真题解析",
        "content": "第三题是个sql题，就不贴了，整体难度不大，第二题需要学一下欧拉筛/线性筛\n\n## T1 字符串查找\n\n塔子哥是一个善于寻找快乐的人。\n\n对于一个字符串，塔子哥认为它是“快乐的”当且仅当其包含以下任意一个连续子串:\n\n  * cheerful\n  * glad\n  * happy\n  * pleased\n\n对于输入的字符串，请你判断这个字符串是否是“快乐的”。\n\n## 输入描述\n\n本题中，每个测试点包含多组测试数据。\n\n第一行一个整数 ，表示数据的组数。\n\n对于每组数据:\n\n输入仅一行，包含一个字符串。\n\n数据保证字符串的长度不超过10000，且仅由小写字母构成。\n\n## 输出描述\n\n对于每组数据，如果 是“快乐的”，请输出Yes，否则请输出No。\n\n## 示例1\n\n**输入**\n\n    \n    \n    2\n    happydays\n    saddays\n    \n\n**输出**\n\n    \n    \n    Yes\n    No\n    \n\n## 思路：枚举\n\n由于字符串![](https://www.nowcoder.com/equation?tex=s&preview=true)的长度不超过![](https://www.nowcoder.com/equation?tex=10%5E4&preview=true)，因此我们可以枚举每一个位置![](https://www.nowcoder.com/equation?tex=i&preview=true)，来判断以![](https://www.nowcoder.com/equation?tex=i&preview=true)开头的子串是否可以构成满足题目条件的字符串之一，如果可以，则输出Yes，否则循环遍历完之后，输出No\n\n**Java**\n\n    \n    \n    import java.util.*;\n    // 注意类名必须为Main\n    class Main {\n        public static void main(String[] args) {\n            Scanner sc = new Scanner(System.in);\n            int num = sc.nextInt();\n            sc.nextLine();\n            String[] happyList={\"cheerful\",\"glad\",\"happy\",\"pleased\"};\n            for(int i=0;i<num;i++){\n                String tmpString=sc.nextLine();\n                boolean flag=false;\n                for(int j=0;j<tmpString.length();j++){\n                    for(String tmpHappy:happyList){\n                        if(j+tmpHappy.length()<tmpString.length()){\n                            if(tmpHappy.equals(tmpString.substring(j,j+tmpHappy.length()))){\n                                flag=true;\n                                break;\n                            }\n                        }\n                    }\n                    if(flag){\n                        break;\n                    }\n                }\n                if(flag){\n                    System.out.println(\"Yes\");\n                }\n                else{\n                    System.out.println(\"No\");\n                }\n            }\n        }\n    }\n    \n\n**Python**\n\n    \n    \n    t = int(input())\n    arr = [\"cheerful\", \"glad\", \"happy\",\"pleased\"]\n    for _ in range(t):\n        s = input()\n        flag = False\n        for i in arr:\n            if i in s:\n                flag = True\n                break\n        if flag:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n    \n\n## T2 素数三元组\n\n塔子哥希望你找出满足![](https://www.nowcoder.com/equation?tex=A%2BB%3DC%5E2&preview=true),且A,B,C均小于等于N的素数三元组（A,B,C)的数量。\n\n素数三元组：A,B,C都是素数。\n\n## 输入描述\n\n输入的第一行给出正整数N。\n\n![](https://www.nowcoder.com/equation?tex=1%3C%3DN%3C%3D5*10%5E5&preview=true)\n\n## 输出描述\n\n一行中输出答案。\n\n## 示例1\n\n**输入**\n\n    \n    \n    8\n    \n\n**输出**\n\n    \n    \n    3\n    \n\n**说明**\n\n2,2,2\n\n7,2,3\n\n2,7,3\n\n## 思路：筛质数\n\n首先，我们需要筛选出![](https://www.nowcoder.com/equation?tex=5%5Ctimes%2010%5E5&preview=true)以内的所有素数，其实总数量约为![](https://www.nowcoder.com/equation?tex=10%5E4&preview=true)左右\n\n然后问题就变成了两数之和的变型，但是我们如果暴力枚举![](https://www.nowcoder.com/equation?tex=A%2CB&preview=true),总复杂度为![](https://www.nowcoder.com/equation?tex=O\\(n%5E2\\)&preview=true)，也会超时\n\n因此可以考虑枚举![](https://www.nowcoder.com/equation?tex=C&preview=true)，![](https://www.nowcoder.com/equation?tex=C&preview=true)对应的复杂度应为![](https://www.nowcoder.com/equation?tex=%5Csqrt%20n&preview=true)\n\n我们先枚举![](https://www.nowcoder.com/equation?tex=C&preview=true),再去枚举![](https://www.nowcoder.com/equation?tex=A&preview=true)，然后把所有的素数存入哈希表中，因此只需要判断哈希表中是否有B即可\n\n![](https://www.nowcoder.com/equation?tex=B%3DC%5E2-A&preview=true)\n\n整体时间复杂度为![](https://www.nowcoder.com/equation?tex=O\\(n%5Csqrt%20n\\)&preview=true)，其中![](https://www.nowcoder.com/equation?tex=n%5Cle%204%5Ctimes%2010%5E4&preview=true)，不会超时\n\n**Java**\n\n    \n    \n    import java.util.*;\n    class Main{\n        public static void main(String[]args){\n            Scanner sc=new Scanner(System.in);\n            int n=sc.nextInt();\n            List<Integer> primes = new ArrayList<>();\n            boolean[] isPrime = new boolean[n + 1];\n            for (int i = 2; i <= n; i++) {\n                isPrime[i] = true;\n            }\n            isPrime[0] = isPrime[1] = false;\n            \n            for (int i = 2; i <= n; i++) {\n                if (isPrime[i]) {\n                    primes.add(i);\n                    for (int j = 2 * i; j <= n; j += i) {\n                        isPrime[j] = false;\n                    }\n                }\n            }\n            \n            Set<Integer> s = new HashSet<>(primes);\n            int cnt = 0;\n            for (int i = 0; i < primes.size(); i++) {\n                int x = primes.get(i) * primes.get(i);\n                if (x > primes.get(primes.size() - 1) * 2) {\n                    break;\n                }\n                for (int j = 0; j < primes.size(); j++) {\n                    int y = x - primes.get(j);\n                    if (s.contains(y)) {\n                        cnt++;\n                    }\n                }\n            }\n            \n            System.out.println(cnt/2+1);\n        }\n    }\n    \n\n**Python**\n\n    \n    \n    n = int(input())\n    primes = []\n    is_prime = [True] * (n+1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, n+1):\n        if is_prime[i]:\n            primes.append(i)\n            for j in range(2*i, n+1, i):\n                is_prime[j] = False\n    s = set(primes)\n    cnt = 0\n    for i in range(len(primes)):\n        x = primes[i] * primes[i]\n        if x > primes[-1] * 2:\n            break\n        for j in range(len(primes)):\n            y = x - primes[j]\n            if y in s:\n                cnt += 1\n    print(cnt)\n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594268071712272384?sourceSSR=users",
        "title": "Java软件开发笔试题3",
        "content": "[上一篇](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F594180567697014784%3FsourceSSR%3Dusers)\n\n1.给定Java代码如下所示，在A处新增下列（）方法，不是对cal方法的重载。\n\nA. public void cal(int z, int y, int x){}\n\nB. public int cal(int x, int y, float z){return 0;}\n\nC. public float cal(float y, float x_{return y+x;}\n\nD. public String cal(String x, String y, String z){return x+y+z;}\n\n在这种情况下，选项 A 不会导致对cal方法的重载，因为它与现有的cal方法具有相同的参数类型和数量。因此，选项 A 是符合要求的\n\n2.以下两个事务并行执行，下面说法正确的是：\n\n事务1:\n\nSTART TRANSACTION;\n\nUPDATE students SET name=\"张三\" WHERE id=123;\n\nCOMMIT;\n\n事务2:\n\nSTART TRANSACTION;\n\nUPDATE students SET name=\"李四\" WHERE id=123;\n\nCOMMIT\n\nA.两个事务均执行成功，name最终为后提交事务修改后的值\n\nB.以上说法均错误\n\nC.产生冲突, 两个事务均无法执行成功\n\nD.先提交的事务执行成功，name最终为先提交事务修改后的值\n\nC. 产生冲突，两个事务均无法执行成功。因为两个事务都试图更新相同的行，数据库会阻止其中一个事务成功提交，以避免数据的不一致性。\n\n3.关于下面的SQL说法正确的是\n\nselect * from test where a=1 and b=1;\n\nselect * from test where b=1;\n\nselect * from test where b=1 order by time desc;\n\n若只建一个索引，则下列选项中最优的建法是：\n\n(这题我不太懂，求大神给我解答下）\n\n4.判断说法正确性 “即将正式发布的HTTP3前身为QUIC协议，基于UDP协议”。 √\n\n5.hset tmp val 123\n\nincr tmp\n\nhincrby tmp val 123\n\n上述redis命令执行结束后，tmp的内容是\n\nhset tmp val 123：这个命令在哈希 tmp 中设置了一个字段 val，其值为 123。如果 tmp 之前不存在，那么它会被创建。\n\nincr tmp：这个命令试图对 tmp 进行自增操作。但是，这里有一个问题。incr\n命令是用于对整数键进行操作的，而不是哈希。所以，这个命令会失败，并返回一个错误。\n\nhinxrby tmp val 123：该命令用于对哈希中的某个字段进行自增操作。如果 val 字段在 tmp 中不存在，它会被创建并初始化为 0，然后增加\n123。如果它已经存在，那么它的值会增加 123。\n\n因此最终答案是 246\n\n6.判断说法正确性 “fopen等方法打开文件时可以指定二进制方式打开，是因为文件在文件系统里被分成了二进制文件和文本文件两种类型” ❌\n\n文件在文件系统里并不被分成二进制文件和文本文件两种类型。实际上，所有文件在底层都是以二进制形式存储的。无论是文本文件、图像文件、音频文件还是其他任何类型的文件，它们最终都是以二进制形式存储在磁盘上的。\n\n当我们说“以二进制方式打开文件”时，我们实际上是指文件的内容应当被原封不动地读取，而不对其中的字符进行任何转换或解释。这在处理非文本文件（如图像、音频、视频等）时尤为重要，因为这些文件的内容通常不能被简单地解释为文本。\n\n另一方面，当我们说“以文本方式打开文件”时，我们通常是指文件的内容应当按照某种字符编码（如UTF-8、ASCII等）进行解释，以便能够正确地读取和写入文本数据。在这种情况下，操作系统或编程语言可能会对文件中的字符进行某些转换，如换行符的转换（在Windows中为\\r\\n，在Unix/Linux中为\\n）。\n\n因此，打开文件时指定二进制方式并不是因为文件在文件系统里被分成了二进制文件和文本文件两种类型，而是因为我们想要以不同的方式处理文件内容。\n\n7.关于Redis，说法正确的是\n\nA.list类型的数据可以用于模拟简单的优先队列\n\nB.Redis的存储引擎是单线程的，无论多少个连接同时发起请求，其内部都会按照顺序执行命令，所以每个客户端只需要一个连接即可\n\nC.DEL prefix* 命令会删除所有以 prefix开头的key\n\nD.hash类型的数据的每个子项都可以单独设置过期时间\n\n正确的选项是A。\n\nB：Redis确实使用单线程来处理命令，这保证了命令执行的原子性。但是，每个客户端可能需要多个连接，这取决于应用程序的需求。例如，如果一个客户端需要执行多个不相关的操作，那么使用多个连接可能会更有效。\n\nC：DEL命令在Redis中用于删除一个或多个key。当你使用DEL\nprefix*这样的模式时，它不会删除所有以prefix开头的key。你需要使用UNLINK命令或者编写脚本来批量删除匹配的key。\n\nD：在Redis中，你不能为hash类型的数据的每个子项单独设置过期时间。你只能为整个hash设置一个过期时间。如果你需要为每个子项设置不同的过期时间，你可能需要考虑使用其他数据结构或方法。\n\n8.写算法时遇到的一些不太熟的API复习补充：\n\nArrayList添加数字： list.add()\n\nArrayList逆序： import java.util.Collections; Collections.reverse(list);\n\nArraysList转为数组： for(int i=0 ; i<list.size() ; i++){ int[i] = (int)list.get(i);\n}\n\n查看数据类型： A instanceof Integer; //返回boolean\n\n判断字符串是否包含某个字串： textStr.contains(\"字串\"); //返回boolean\n\n将字符串中的字母全部转为小写： originalString.toLowerCase();\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594264057033605120?sourceSSR=users",
        "title": "校招被某大厂捞了五次，每次都挂在三面上!",
        "content": "最近辅导了一个同学，面某大厂被捞起来五次，可惜的是每次面试都挂在三面上，这位同学有其他大厂一年的实习经历，理论上拿个合适的offer是不成问题的，但同一家大厂五个业务部门面试，都挂在三面上，面的怀疑人生，很是郁闷。\n\n**五次挂掉的情况**\n\n一二面基础和项目面都顺利通过，但到了三面总监面试总是各种原因挂掉。\n\n第一次简历写了熟悉高可用，高并发技术原理。三面面试官询问高可用，高并发相关内容回答的不够好。项目缺乏此方便积累。\n\n第二次被某数据库部门团队捞起来。但到三面面试官明显感觉技术背景不对口，他们需要DBA数据库运维相关背景，该同学后端开发背景，故三面面试官认为对口度比较低。\n\n第三次被某c端业务捞起，三面面试官提问，说说某项目有哪些不足，改如何改进。由于之前没准备过，讲的磕磕绊绊，对自己项目的系统理解不深入，思考不深入没通过。\n\n第四次三面过程中，感觉面试官不是很认真，走过场，二十分钟草草结束。\n\n第五次三面面试官聊到工作地点，因要去上海与个人规划不符，透露出地点倾向性，最后未通过结果。\n\n**综合总结分析原因**\n\n除了上面提到的表面内容，经过跟HR的打听，总结分析三面核心挂掉的其他原因。\n\n总结提炼能力不足，陈述问题条理性一般。对问题的陈述比较散，比较啰嗦，不能一下子说到点子上。叙述问题过程缺乏条理性。\n\n性子比较急，回答问题急于表达自己观点，很着急的样子。\n\n思考不够深入细致，对于问题理解和分析，感觉像是背过的，但讲解又比较浅。\n\n**第三轮综合能力面试要点**\n\n责任心：回答问题诚实、负责，办事自信，对以往工作负责。通过对问题及项目考察，交流中考察或察觉候选人的责任心状态。\n\n抗压能力：有耐心，韧劲，在遇到批评、指责、压力或受到冲击时，能够克制、容忍、理智对待。\n\n此处考察主要体现在两方面，一方面通过对问题及项目考察，交流中考察候选人此方面的状态。另一方面通过抗压考察，如轮番提问，打击式提问等考察候选人的现场抗压能力。\n\n自我认知：能够客观、正确评价自己的优势和不足，并努力改进。\n\n适应性：能够根据变化灵活采取应对方式，达成目标。管理经验及职业意识，是否具有大局观，领导力，判断力，执行力等。\n\n总之就是从各方面考察候选人在性格、做事，抗压、责任心、自我认识等各个详细方面，候选人是否符合公司选人标准。\n\n面试官希望看到的是一个责任心强，做事自信认真，抗压能力强，客观认识自我，努力上进，有很强适应能力等等的一个完美的候选人，\n\n同学们在准备和面试过程中要尽可能摆事实讲道理，展现自己这些方面的能力。\n\n**如何克服这些问题**\n\n这位同学就差临门一脚，三面一般是总监面，领导具有一票否决权，而软性能力在这里异常重要。\n\n同学们要刻意练习，很多同学不同的特点有的容易紧张，性格内向，说话条理性差等等，自己对着镜子刻意练习准备是很有必要的。\n\n给自己信心，面试只是短短的一小时，逼迫自己换个人一样，变得外向，声音洪亮，积极思考，说话调理是可以做到的。\n\n**求职环环相扣，每一环节都不能马虎**\n\n这位同学的遭遇比较少见，不过很形象的说明了求职不是找不到，而是能力模型没匹配到。如果这位同学三面软性能力比较好，可能已经拿到三个部门的offer了。\n\n简历，笔试，三轮面试环环相扣，每一轮都需要达标，每一个环节都不能马虎。同学们要针对性准备好自己每个环节的能力模型。\n\n我是涛哥，曾任某互联网大厂技术总监，十年面试过500人，培养新人超百人。专注技术培训/简历辅导/面试辅导/求职咨询等，24年目标帮助1000人求职和成长。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594260087649157120?sourceSSR=users",
        "title": "（一面）腾讯游戏客户端开发（光子工作室）",
        "content": "一面面经：\n\n时常：1h\n\n  1. 手撕算法：奇偶链表（力扣328题），ACM模式（ac了）\n  2. 说一下C++中如何实现多态的？\n  3. 那你说的父类指针指向子类引用，解释一下底层是怎么实现的（为什么能找到子类对应的func）？\n  4. 智能指针有用过吗，说一下他们的实现原理？\n  5. shared_ptr的计数器底层是怎么实现的？（我不知道，面试官说没关系按照你自己的理解你会怎么设计，我就回答，用一个哈希表，存放资源地址和对应的指针）\n  6. 那这个哈希表是全局的吗？是线程安全的吗？（是全局的，关于线程安全，我就说给他加锁）\n  7. shared_ptr的循环引用问题怎么解决的？\n  8. 当weak_ptr怎么判断对象是否被销毁，底层怎么实现的？（我就接着这个哈希表继续说下去了）\n  9. 知道STL中的deque容器吗，底层怎么实现的？\n  10. deque是怎么实现扩容的？\n  11. vector和deque的区别是什么？\n  12. 反问：我问了如果我进去能做什么？然后就聊到了游戏相关的他就问我：你对一个游戏的场景你的理解是什么？（胡乱说一通）\n  13. 问我如果游戏中有一面墙，墙的背后有一个球，然后你如果事先知道这个球是看不到的，然后你怎么设计这个场景？（一脸懵逼）\n\n刚刚面完，感觉答得不好，不知道能不能过，5555，求求了让我过吧，等后续！\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594245825417457664?sourceSSR=users",
        "title": "郑州 数字马力 测开",
        "content": "一面\n\n自我介绍\n\n深挖项目\n\n支付宝登录测试用例\n\nAPP端测试经验\n\n2024/3/4\n\n耗时15min，凉，说部门是证券的，我缺乏APP端经验，把简历释放掉看看其他部门要不要[牛泪]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594237379766947840?sourceSSR=users",
        "title": "字节测开 国际商业化面经",
        "content": "1、拷打实习经历，介绍业务（tob业务真不容易描述），百度的自动化测试平台 比如自动化case架构（没太懂）\n\n2、java基础，常见集合类\n\n3、线程池工作原理\n\n算法题\n\n4、给定一个递增数组（元素均为正整数），如[2,3,6,7,10]，输入n，找出缺失的第n大整数\n\n如n=1时，输出1；n=2时，输出4；n=3时，输出5； n=100时，输出105\n\n5、表名为test，有id（主键自增）和email两个字段，找出email重复的email\n\n实习经历叙述不太好，基本挂了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594232739134476288?sourceSSR=users",
        "title": "字节懂车帝后端日常实习一面面经【详细】",
        "content": "* 时间：2024-03-04 14:00(GMT+08:00) China Standard Time - Beijing\n\n  * 耗时：1h3min\n\n### 自我介绍\n\nMe：双非本科，大三在读，自学Java，前来面试\n\n面试官:这块儿对语言有要求吗?因为我们这块儿可能对java开发基本没有\n\nMe：明白的，语言不是问题，我了解过字节主要都是golang，自己也会一点\n\n### 实习经历\n\n……\n\n### 项目经历\n\n面试官:你讲一个你比较印象深刻的一个项目吧，然后其中一再做项目过程中遇到了一些哪些问题，然后这些问题是怎么解决的\n\nMe:水泥熟料巴拉巴拉……\n\n面试官:介绍系统功能\n\nMe:巴拉巴拉……\n\n面试官:项目底层实现\n\n面试官:项目中的搜索功能\n\nMe:基于MySQL的like搜索\n\n面试官:项目中的redis作用\n\nMe:作为缓存，用户发起同样的查询请求时，先访问缓存，缓存不命中再去走MySQL并放置一份到redis\n\n面试官:项目中的minIO作用\n\nMe:用作文件存储服务\n\n……………………项目细节询问……………………\n\n### 八股文\n\n面试官开始对MySQL进行拷问\n\n##### 事务的四个特性\n\n应该是问ACID\n\n  * Atomicity（原子性）： 事务是一个不可分割的工作单元，事务中的所有操作要么全部成功执行，要么全部不执行。如果事务中的任何操作失败，则整个事务将回滚到事务开始前的状态。\n\n例如，在银行转账操作中，从账户A向账户B转账100元，这个过程应该被视为一个事务。要么转账完全成功，使得账户A减少100元，账户B增加100元；要么转账完全失败，两个账户余额都不变。\n\n  * Consistency（一致性）： 事务完成后，系统状态应从一个有效状态变为另一个有效状态，确保事务前后数据遵循预定义的业务规则和约束条件。\n\n比如转账的例子，事务执行前后，两个账户的总金额必须保持一致，这就是一种一致性要求。\n\n  * Isolation（隔离性）： 同一时刻多个事务并发执行时，每个事务之间的操作相互独立，互不影响，仿佛每个事务都是系统唯一运行的事务。为实现这一目标，数据库通常提供了不同的隔离级别（如读未提交、读已提交、可重复读、序列化等）来控制并发事务之间的影响程度。\n  * Durability（持久性）： 一旦事务成功提交，对数据库的修改将会永久保存，即使发生系统崩溃或电源故障等情况，已经提交的事务结果也必须得到保留。\n\n##### 索引\n\n###### innodb引擎数据结构\n\nB+树存储，叶子节点存数据，非叶子节点存索引\n\n###### 对比其他数据结构怎么样，B树，红黑树，哈希表\n\n我就答了更好的支持范围查询，因为B+树的叶子节点链表链接且和索引有序排列\n\n###### MySQL的聚簇索引和非聚簇索引是什么\n\n不知道，知道联合索引\n\n    \n    \n    在MySQL中，聚簇索引（Clustered Index）和非聚簇索引（Non-Clustered Index）是两种不同的索引类型，它们的主要区别在于数据行的存储方式以及索引结构与实际数据的关系。\n    \n    聚簇索引（Clustered Index）：\n    \n    定义：在InnoDB存储引擎中，默认情况下每个表都有一个聚簇索引，如果用户没有显式创建，则MySQL会自动为表中的主键创建聚簇索引。若未定义主键，则会选择唯一且非空的列作为聚簇索引，否则自动生成隐藏的rowid作为聚簇索引。\n    结构：聚簇索引决定了数据行在磁盘上的物理存储顺序。表的数据行就是按照聚簇索引的顺序进行排序和存储的，换句话说，数据行就直接存储在叶子节点上，因此访问非常高效。\n    特点：\n    聚簇索引的叶子节点包含行的所有数据。\n    表只能有一个聚簇索引，因为数据只能有一种物理排序方式。\n    范围查询时，由于数据物理上连续存放，性能较高。\n    非聚簇索引（Non-Clustered Index）：\n    \n    定义：非聚簇索引也称为二级索引或辅助索引，可以由用户根据需要创建在任何列上，包括主键之外的列。\n    结构：非聚簇索引的叶子节点不包含行的所有数据，而是存储了行的主键值或其他唯一标识符（如聚集索引键），用于指向对应的数据行位置。\n    特点：\n    非聚簇索引的叶子节点仅存储索引列的值以及指向相应行的指针。\n    一个表可以有多个非聚簇索引。\n    当通过非聚簇索引查找数据时，首先找到索引对应的记录，然后根据索引中的指针回表查找到对应的行数据，这个过程被称为“回表”。\n    总结来说，聚簇索引对于基于主键或者聚簇索引字段的查询性能较好，而非聚簇索引则提供了对其他字段进行快速搜索的能力，但其本身并不能直接提供数据行的内容，需要结合主键信息才能定位到完整的数据行。\n    \n\n###### 建立联合索引如何判断这个索引的优劣性能\n\n有联合索引abc，ac，c，select 时 where a=xx and c = xx 走哪个索引\n\n我答应该是ac\n\n有联合索引abc，c，select 时 where a=xx and c = xx 走索引吗\n\n我觉得走abc，根据最左匹配原则也是满足的\n\n##### SQL拷打\n\n一个表有学生的信息（学号、姓名），课程信息（课程号，课程名），课程成绩\n\n要求写SQL查出学生选的所有课都及格（>60）的 总分，学生姓名，总成绩倒序排序\n\n没用sql答好，最后给面试官的解决方案是先找出学生所有课程成绩，通过后端判断这个学生是不是都及格了，是的话记录这个学生，然后通过所有学生名执行sql查询总成绩\n\nps:面试刚到25min\n\n学校教的SQL是MySQL吗\n\n教的欧拉数据库（擦，是高斯openGauss，搞错名字了……）\n\n##### redis用过什么数据结构\n\n哈希\n\n##### redis的哈希底层实现\n\n不了解……\n\n##### redis缓存一致性\n\n先删缓存后更新数据库方案（没继续追问延迟双删）\n\n##### git的常用操作\n\n……\n\ngit rebase的原理\n\n……不懂\n\n##### Linux常用命令\n\n    \n    \n    ls -lh\n    top\n    cat\n    vim\n    kill\n    grep\n    \n\n面试官:查看日志和搜索\n\ncat和grep\n\n##### Docker的使用\n\n##### HTTP状态码\n\n2xx：没问题\n\n3xx：重定向\n\n4xx：客户端的问题\n\n5xx：服务端的问题\n\n面试官:比如说500的时候我们怎么排查，502？504？\n\nMe:如果使用nginx反向代理后端可能会常见502，502指网关错误\n\n进入服务器看看Java程序是不是不见了，重新运行\n\n504的话不知道含义是什么了，没见过，如果是Java程序抛出来的，那我们可以看Java的日志跟踪是哪段代码的问题\n\n“504”通常是指HTTP状态码中的“504 Gateway\nTimeout”，这是一个由服务器端（如代理服务器或网关）返回的错误代码，表示服务器在尝试完成请求时未能及时从上游服务器（例如源站服务器）收到响应。具体来说：\n\n  * 504 Gateway Timeout：这意味着作为客户端与目标服务器之间的中介服务（如负载均衡器、反向代理或其他网关设备）在等待来自后端服务器的响应时超出了预设的等待时间限制。\n\n简单来说，在网络通信中，如果一个中间服务器在转发客户端请求到最终服务器的过程中，由于某种原因没有及时接收到响应并转发给客户端，则会返回504错误。这个错误通常与服务器配置、网络延迟、服务器过载或后端服务器无响应等因素有关。\n\n### 算法\n\n  * 岛屿数量\n\n![](https://uploadfiles.nowcoder.com/images/20240304/53365513_1709547920336/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n时间复杂度O(2n)\n\n空间复杂度O(n)\n\n### 回到八股\n\n##### 设计模式\n\n###### 单例模式，设计一个单例模式\n\n在次感谢牛客的面经\n\nhttps://www.nowcoder.com/feed/main/detail/6f9c1639046f413197051eeede6b8233\n\n让我看到了，答的和gpt差不多\n\n在Java中，单例模式（Singleton\nPattern）保证一个类仅有一个实例，并提供全局访问点。这里展示两种常见的实现单例模式的方式：懒汉式（懒加载）和饿汉式（静态初始化）。\n\n1\\. 懒汉式（线程不安全）\n\nJava\n\n    \n    \n    public class Singleton {\n        private static volatile Singleton instance;\n    \n        // 防止通过构造函数直接创建对象\n        private Singleton() {}\n    \n       public static Singleton getInstance() {\n            if (instance == null) {\n                instance = new Singleton();  // 这里在多线程环境下可能导致多个实例被创建\n            }\n            return instance;\n        }\n    }\n    \n\n这个版本的懒汉式单例在多线程环境下并不安全，可能会创建多个实例。\n\n2\\. 懒汉式（线程安全，使用同步方法）\n\nJava\n\n    \n    \n    public class Singleton {\n        private static volatile Singleton instance;\n    \n        private Singleton() {}\n    \n        public static synchronized Singleton getInstance() {\n            if (instance == null) {\n               instance = new Singleton();\n            }\n            return instance;\n        }\n    }\n    \n\n在这个版本中，我们添加了synchronized关键字来确保多线程环境下的安全性，但这样会影响性能，因为每次调用getInstance()都会进行同步锁操作。\n\n3\\. 双重检查锁定（线程安全，更优）\n\nJava\n\n    \n    \n    public class Singleton {\n        private static volatile Singleton instance;\n    \n        private Singleton() {}\n    \n        public static Singleton getInstance() {\n            if (instance == null) { \n                synchronized (Singleton.class) {\n                    if (instance == null) {  // 第二次检查，避免不必要的同步开销\n                        instance = new Singleton();\n                    }\n                }\n            }\n            return instance;\n        }\n    }\n    \n\n双重检查锁定既保证了线程安全，又尽可能地减少了同步的开销。只有在实例未创建时才进行同步，创建后就不再需要同步，提高了效率。\n\n4\\. 饿汉式（静态初始化，线程安全）\n\nJava\n\n    \n    \n    public class Singleton {\n        // 类加载时即初始化实例，保证线程安全\n        private static final Singleton instance = new Singleton();\n    \n        private Singleton() {}\n    \n        public static Singleton getInstance() {\n            return instance;\n       }\n    }\n    \n\n饿汉式的实现方式是在类加载时立即创建并初始化单例实例，因此天生就是线程安全的，但无法做到按需加载（lazy initialization）。\n\n以下是第三种实现方式——双重检查锁定（Double-Checked Locking）的Java单例模式代码解释：\n\nJava\n\n    \n    \n    public class Singleton {\n        // 使用volatile关键字确保多线程环境下的可见性和有序性\n       private static volatile Singleton instance;\n    \n        // 私有化构造函数以防止外部实例化\n        private Singleton() {}\n    \n        // 提供获取实例的方法\n        public static Singleton getInstance() {\n            // 第一次检查：如果instance已非空，则直接返回\n           if (instance == null) { \n                // 否则同步块内进行第二次检查，并创建实例\n                synchronized (Singleton.class) {\n                   // 在同步块内部再次检查实例是否已经被其他线程创建过\n                    if (instance == null) {  \n                        // 如果未被创建，则创建并初始化\n                        instance = new Singleton();\n                   }\n                }\n            }\n            return instance;\n        }\n    }\n    \n\n这段代码的工作原理是这样的：\n\n  1. 当调用 getInstance() 方法时，首先会进行一个非同步的检查，查看 instance 是否已经初始化。如果已经初始化，则直接返回该实例，无需进入同步块。\n  2. 如果第一次检查发现 instance 为 null，那么代码进入 synchronized 块，在这里进行第二次检查。这是因为在多线程环境下，可能有多个线程同时发现 instance 为空并尝试创建实例，所以需要通过锁来保证只有一个线程能够执行初始化操作。\n  3. 只有在 instance 确实为空的情况下，才会在同步块中创建并初始化 Singleton 类的一个新实例。\n  4. 由于两次检查的存在，可以避免每次调用 getInstance() 方法都进行不必要的同步操作，从而提高了性能。\n\n通过这种方式，我们既保证了单例对象在多线程环境下的唯一性，又尽可能减少了使用同步操作带来的性能开销。\n\n##### 并发操作中调用第三方API或RPC\n\n##### 线程创建的三种方式\n\n##### 浏览器输入百度网址到浏览器展示网页的过程\n\nDNS …… HTTP/HTTPS ……\n\n### 反问环节\n\n比较紧张，就问了一共是不是三面，啥时候知道面试结果\n\n是三面，面试结果面试官不能确定什么时候知道，得问hr\n\n### 感想\n\n面试体验十分良好，面试官有耐心倾听，语言清晰\n\n面过懂车帝IOS的一二，挂了，一面也是面试官很亲切，二面的面试官说话又不清楚，还挺不耐烦的，体验极差\n\n希望有二面，希望二面面试官也要好好的\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594231245303746560?sourceSSR=users",
        "title": "今日份面试",
        "content": "上午快手二面  \n项目问了半个小时，从一个功能问到另一个功能，最后哑口无言，汗流浃背。好处：知道了项目隐藏的一个重难点，桀桀桀  \n手写：树的深度与广度遍历  \n  \n  \n下午淘天简历面  \n十分钟左右，秒挂，无语，又被KPI了  \nservice work  \n别的都是一些基础八股  \n  \n继续加油了[打call]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594230158995787776?sourceSSR=users",
        "title": "攀登者1 - 华为OD统一考试",
        "content": "> OD统一考试\n>\n> 分值： 100分\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n攀登者喜欢寻找各种地图，并且尝试攀登到最高的山峰。\n\n地图表示为一维数组，数组的索引代表水平位置，数组的元素代表相对海拔高度。其中数组元素0代表地面。\n\n例如：[0,1,2,4,3,1,0,0,1,2,3,1,2,1,0]，代表如下图所示的地图，地图中有两个山脉位置分别为 1,2,3,4,5 和\n8,9,10,11,12,13，最高峰高度分别为 4,3。最高峰位置分别为3,10。\n\n一个山脉可能有多座山峰(高度大于相邻位置的高度，或在地图边界且高度大于相邻的高度)。\n\n![alt](https://uploadfiles.nowcoder.com/images/20240304/644248237_1709547138604/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n## 输入描述\n\n输入为一个整型数组，数组长度大于1。\n\n## 输出描述\n\n输出地图中山峰的数量。\n\n## 示例1\n\n    \n    \n    输入：\n    0,1,4,3,1,0,0,1,2,3,1,2,1,0\n    \n    输出：\n    3\n    \n    说明：\n    山峰所在索引分别为3，10，12\n    \n    \n\n## 题解\n\n> 简单模拟题。\n>\n> ### 解题思路\n>\n>   1. 使用一个计数器`cnt`记录符合条件的山峰数量。\n>   2. 遍历数组，对于每个位置，判断是否满足山峰条件，即左右两侧的海拔均小于自身。\n>   3. 如果满足条件，则增加计数器`cnt`。\n>   4. 最终返回`cnt`作为结果。\n>\n\n### Java\n\n    \n    \n    import java.util.Arrays;\n    import java.util.Scanner;\n    /**\n     * @author code5bug\n     */\n    public class Main {\n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n    \n            int[] heights = Arrays.stream(scanner.nextLine().split(\",\"))\n                                   .mapToInt(Integer::p\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594203586163195904?sourceSSR=users",
        "title": "韶音科技 深圳软开 HR一面",
        "content": "3/4号 一面HR 时长30分钟\n\n主要问了如下内容\n\n1 高考成绩，本科成绩，数学成绩\n\n2 在校期间担任体育部部长做了什么\n\n3 实习内容，遇到的困难\n\n4 最近在读什么书，哪个情节最深刻\n\n5 家里情况，父母是做什么的\n\n6 手上有offer吗，考研成绩怎么样\n\n7 平时运动吗，跑步每次几公里\n\n8 业务与开发的关系\n\n9 问项目 个人小程序怎么开发的\n\n10 如何准确了解项目经理的需求\n\n反问 薪资本科25万能达到吗，回答不太能实现，本科大概16-20， 说接下来如果通过一周内会通知，如果通过还会有两轮技术面。\n\n攒攒人品，希望能过。\n\n更新\n\n3月7号二面，30分钟左右，部门的领导和一个年轻的面试官提问一些技术问题\n\n内容是一些很简单的Java八股\n\nlist map set区别\n\n进程线程区别\n\nhashmap怎么实现\n\n针对项目问了一些简单的问题\n\nhttp和https区别，说了加密更安全以后问怎么加密知道吗？答不上来\n\n然后就是领导根据项目与实习简单问了一下，平时怎么学习新东西，为什么去银行的实习。\n\n领导全程都很温柔面带微笑，年轻的面试官也很友好，最好的一次面试体验了，哈哈哈，希望还有后续。\n\n应该是没了，三月20号了都，不过也不打算去了，听前员工讲了一些东西，感谢sy挂我哈哈哈\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594202339582423040?sourceSSR=users",
        "title": "微派二面",
        "content": "最近面试比较多，很多面完都没机会复盘，今天闲下来了，总结一场\n\n1.自我介绍\n\n2.你实习项目中微服务是拆了几个服务啊，详细说一下\n\n3.一些实习项目中的功能问题\n\n4.现在有一个抖音直播场景，你需要设计那些表，那些字段啊\n\n5.抖音直播间人数过多，对服务器压力过大有什么解决方案\n\n6.抖音直播用什么数据库，有些不同功能要选用不同的数据库吧，你说一下\n\n7.算法：全排列\n\n8.还有其他写法吗\n\n9.按照你第二种写法再写出来\n\n10,如果全排列目标数组有重复数字怎么办\n\n总共47min\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594227953991503872?sourceSSR=users",
        "title": "API集群负载统计 - 华为OD统一考试",
        "content": "> OD统一考试 （C卷）\n>\n> 分值： 100分\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n某个产品的RESTful\nAPI集合部署在服务器集群的多个节点上，近期对客户端访问日志进行了采集，需要统计各个API的访问频次，根据热点信息在服务器节点之间做负载均衡，现在需要实现热点信息统计查询功能。\n\nRESTful API是由多个层级构成，层级之间使用 / 连接，如 /A/B/C/D 这个地址，A属于第一级，B属于第二级，C属于第三级，D属于第四级。\n\n现在负载均衡模块需要知道给定层级上某个名字出现的频次，未出现过用0表示，实现这个功能。\n\n## 输入描述\n\n第一行为N，表示访问历史日志的条数，0 ＜ N ≤ 100。\n\n接下来N行，每一行为一个RESTful API的URL地址，约束地址中仅包含英文字母和连接符 / ，最大层级为10，每层级字符串最大长度为10。\n\n最后一行为层级L和要查询的关键字。\n\n## 输出描述\n\n输出给定层级上，关键字出现的频次，使用完全匹配方式（大小写敏感）。\n\n## 示例1\n\n    \n    \n    输入：\n    5\n    /huawei/computing/no/one\n    /huawei/computing\n    /huawei\n    /huawei/cloud/no/one\n    /huawei/wireless/no/one\n    2 computing\n    \n    输出：\n    2\n    \n    说明：\n    在第二层级上，computing出现了2次，因此输出2\n    \n\n## 示例2\n\n    \n    \n    输入：\n    5\n    /huawei/computing/no/one\n    /huawei/computing\n    /huawei\n    /huawei/cloud/no/one\n    /huawei/wireless/no/one\n    4 two\n    \n    输出：\n    0\n    \n    说明：\n    存在第四层级的URL上，没有出现two，因此频次是0\n    \n\n## 题解\n\n> 题目要求统计给定层级上某个名字出现的频次。\n>\n> 我们可以使用一个二维列表 `levels`，其中 `levels[i]` 表示第 i 层级上的名字频次计数器。\n>\n> 然后，遍历历史日志，对每个路径进行分割，更新对应层级的名字频次计数器。最后，根据给定的层级和关键字输出频次。\n>\n> ### 代码描述\n>\n>   1. 初始化一个二维列表 `levels`，其中 `levels[i]` 为第 i 层级上的名字频次计数器。\n>   2. 遍历历史日志，对每个路径进行分割，更新对应层级的名字频次计数器。\n>   3. 根据给定的层级和关键字输出频次。\n>\n\n### Java\n\n    \n    \n    import java.util.HashMap;\n    import java.util.Map;\n    import java.util.Scanner;\n    /**\n     * @author code5bug\n     */\n    public class Main {\n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            int n = scanner.nextInt();\n    \n            // 层级上某个名字出现的频次计数器\n            Map<String, Integer>[] levels\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594202175589404672?sourceSSR=users",
        "title": "英伟达 自动驾驶实习二面面经",
        "content": "本来有3个面试官，一人一小时面试的，后面因为第三个面试官有会要开就只面了两个..强度还是有点大的\n\n面试官1 (1h)\n\n1、中文自我介绍\n\n2、说了熟悉C++，问了C++相关的八股，new和malloc区别，万能引用和右值引用等，手写一个类来实现lambda表达式，又给了3个C++程序(都和指针相关的)，不能调试，问输出结果是什么\n\n3、后序遍历二叉树非递归写法(用栈秒了)\n\n4、解释中断，以及底层发生的操作细节(说了保存PC指针和现场环境)\n\n面试官2 (1h)\n\n1、英文自我介绍\n\n2、英文问题，大概意思是介绍一下LLM和机器学习的经历(人麻了..英文完全说不出来)\n\n3、英文问题，介绍一下嵌入式和linux操作系统的东西(后面看我实在不会说就换成中文了)\n\n4、介绍腾讯实习中LLM的应用\n\n5、解释预处理、编译、汇编、链接，以及它们在linux操作系统上是如何运作的\n\n6、c++多线程在操作系统上如何运作的\n\n7、信号量在操作系统中如何实现和运作的\n\n8、线程和进程之间通信的方式\n\n9、写题，题目意思是给定一个chargeTimes 数组和runningCosts ，求一个最大的连续子数组使得tot_cost<=budget：\n\nchargeTimes = [3,6,1,3,4],\n\nrunningCosts = [2,1,3,4,5],\n\nbudget = 25\n\nOutput: 3\n\ntot_cost=max(chargeTimes) + k * sum(runningCosts)\n\n要求用O(n)的算法实现，用单调队列+前缀和+双指针秒了，但可能还有边界的问题没调试好。。\n\n总体感受就是真的被拷打麻了。。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594197314479099904?sourceSSR=users",
        "title": "AI深度学习算法推理加速CUDA HPC类岗位-英伟达面经",
        "content": "前几天才面了下nvidia，面试官问了一堆底层问题，好多没答上来...\n\n这次记录下，欢迎大家一起讨论...\n\n哈哈标题党了，我其实不是学生，分享一下我作为一名面试官常问的AI推理加速HPC岗位的问题~仅分享通用知识部分，项目部分因人而异这里省略\n\n**C++部分**\n\n1、为什么我们做C++项目的时候，需要写头文件？\n\n2、讲出static关键字的一种应用场景\n\n3、单例模式如何实现？\n\n4、讲讲四种类型转换\n\n5、拷贝构造函数中浅拷贝和深拷贝的区别？\n\n6、一个类要去访问另一个类的private数据成员，该如何操作？\n\n###\n\n量化quantization部分\n\n1、说说你知道的那些针对LLM的量化技法？\n\n2、smoothquant为什么可以解决int8 LLM的accuracy问题？\n\n3、bfloat16和fp16(half float point)同样内存大小，那么它们可以节约的内存大小应该是一样的吗？他们的优缺点主要有哪些？\n\n4、量化怎么平衡精度和速度？\n\n###\n\nCUDA部分\n\n1、讲讲shared memory bank conflict的发生场景？以及你能想到哪些解决方案？\n\n2、CUDA里面如何分配GPU显存？为什么里面的参数是二级指针？\n\n3、优化CUDA程序的访存效率，你可以想到哪些？\n\n4、优化CUDA程序的计算效率，你又可以想到哪些？\n\n###\n\n大模型部分\n\n1、有哪些encoder-only、decoder-only、encoder-decoder的模型？\n\n2、随着seqlen的增加，你觉得encoder-only的模型和decoder-only的模型的计算量和访存量会是哪些变化趋势？为什么？\n\n3、说说你知道的大模型训练or推理的常用优化手段\n\n4、一般会对哪些大模型里面的算子做算子融合，说说你知道的\n\n5、flash attention的原理讲讲？你认为为什么flash attention极大提升了训练速度？\n\n6、paged attention的原理讲讲？你认为为什么paged attention极大提升了推理速度？它和flash attention的区别是什么？\n\n以上呢，起始都是非常经典的问题，足够看出大家对AI推理加速HPC岗位的基础。\n\n本人知道最近大家忙着准备实习面试和几个月后的秋招面试\n，同时很多学弟学妹深陷AI算法和后端开发的泥沼，认为只存在这俩职位，本人当初作为应届生的时候也是这样，但其实不然，AI深度学习推理加速HPC类岗位随着nvidia的股价暴涨，需求也是越来越大的，我从去年开始就帮助了很多同学了解这方面、加入这方面、着手实践项目，很多去年都成功拿到了offer，因此欢迎大家ping我，祝大家龙年工作如意~附一些截图\n\n![](https://uploadfiles.nowcoder.com/images/20240304/893471267_1709518837364/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n![](https://uploadfiles.nowcoder.com/images/20240304/893471267_1709518136648/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n![](https://uploadfiles.nowcoder.com/images/20240304/893471267_1709518157219/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594194819413479424?sourceSSR=users",
        "title": "百度在线 一面",
        "content": "  1. 写个三栏布局\n  2. 数组去重 \n  3. mixin\n  4. $nextTick\n  5. $set\n  6. Map()的遍历方法\n\n    \n    \n    setTimeout(function () {\n        console.log('1')\n    });\n    new Promise(function (resolve) {\n        console.log('2');\n        resolve();\n        console.log('3');\n    }).then(function () {\n        console.log('4')\n    });\n    console.log('5');\n    \n    \n\n将hidden不为true的值过滤出来使用递归\n\n    \n    \n    const menus = [\n        {\n            name: 'menu1',\n            hidden: false,\n            children: [\n                {\n                    name: 'menu1-1',\n                    hidden: false,\n                },\n                {\n                    name: 'menu1-2',\n                    hidden: () => {return Math.random() * 10 > 5},\n                },\n            ]\n        },\n        {\n            name: 'menu2',\n            hidden: true,\n        }\n    ]\n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594180567697014784?sourceSSR=users",
        "title": "Java软件开发笔试题2",
        "content": "[上一篇](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F593481186010238976%3FsourceSSR%3Dusers)\n\n[下一篇](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F594268071712272384)\n\n1.MySQL什么时候不可以用索引？什么时候可以？\n\n①只有 Where、Group By、Join 这些后面的字段如果没有加索引，才能够利用索引覆盖。\n\n②索引并不是越多越好，因为变动过程中需要维护，这部分时间也需要进行考虑。\n\n③对于小型表而言，直接扫描整个表可能更为高效，此时不需要索引。\n\n2.Redis数据库的底层原理了解吗？\n\n①底层使用C语言实现\n\n②核心思想是将数据存储在内存中，以提供快速的读写访问\n\n③采用单线程模型来处理客户端请求，通过异步I/O和事件驱动机制来实现高并发性能\n\n3.Redis字符串的 SDS，对比原有 C 语言字符串有什么好处\n\n①SDS可以根据需要自动扩展内存空间，而C语言原生字符串需要手动管理内存，容易导致内存溢出或者内存泄漏\n\n②SDS内部存储了字符串的长度信息，获取字符串长度的操作是O(1)的时间复杂度。而C语言是O(n)\n\n③SDS在进行字符串操作时，会检查缓冲区是否有足够的空间，避免了缓冲区溢出的问题，而C语言原生字符串需要程序员手动进行边界检查，容易出错\n\n④SDS可以存储任意二进制数据，而C语言原生字符串是以'\\0'结尾的字符数组，不能存储包含'\\0'的二进制数据\n\n⑤支持字符串的追加、截取、拷贝等操作，并且这些操作的时间复杂度都是O(1)\n\n4.Redis的缓存策略简要说明一下。\n\n①淘汰策略：当内存不足时，Redis会根据设置的淘汰策略来删除部分键值对，以释放内存空间。常见的淘汰策略包括LRU（最近最少使用）、LFU（最不经常使用）和随机等\n\n②过期策略：Redis支持为键值对设置过期时间，在过期时间到达后，键值对会被自动删除。常见的过期策略包括定时删除和惰性删除\n\n5.Redis的持久化策略简要说明下\n\n①RDB，将当前Redis服务器中的所有数据以快照的形式保存到硬盘上。Redis会周期性地将内存中的数据保存到磁盘上，生成一个压缩过的二进制文件（默认名为dump.rdb）。\n\n②AOF，以日志的形式记录Redis服务器所处理的每个写操作命令。Redis会将每个写命令追加到一个文件（默认名为appendonly.aof）的末尾。\n\n6.有哪些常用的设计模式？\n\n创建型模式：单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。\n\n结构型模式：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。\n\n行为型模式：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。\n\n7.什么时候用单例模式？\n\n①当一个类只需要一个实例，并且客户端需要一个全局访问点来访问该实例时。\n\n②当希望限制类的实例化次数为一个的情况。\n\n③当需要控制某些资源的分配，或者需要跨越多个部分共享状态时。\n\n④在需要频繁创建和销毁实例的场景中，单例模式可以提高系统的性能和节省资源。\n\n8.简述下Docker\n\n①Docker解决了应用程序打包、交付和运行的问题\n\n②Docker是一种容器化平台，可以将应用程序及其所有依赖项打包成一个独立的容器，从而实现应用程序在任何环境中都能以相同的方式运行。\n\n③特性：环境一致性、快速部署、资源利用率、隔离性\n\n9.http1.1和 http2.0的区别\n\nhttp1.1 每个请求都需要单独建立和维护一个TCP连接、每个请求和响应的头部信息都需要重复发送、使用的是文本格式\n\nhttp2.0\n引入了多路复用机制，允许在同一个TCP连接上同时发送多个请求和响应、对头部信息进行压缩，减少了数据传输量，提高了网络性能、支持服务器推送机制、允许客户端和服务器动态调整数据流的传输速率、采用了二进制格式来编码和传输数据\n\n总的来说，HTTP/2.0相比HTTP/1.1在性能、效率和安全性方面有了显著的提升\n\n10.MySQL的引擎，InnoDB和MyIsam的区别？\n\nInnoDB：支持事务、使用行级锁, 可以提高并发性能、支持崩溃恢复和数据恢复、支持外键约束、支持全文索引,\n可以进行全文搜索、表空间可以动态调整，支持自动扩展和缩小\n\nMyIsam：不支持事务、使用表级锁、不支持崩溃恢复、不支持外键约束、仅在MySQL 5.6之后开始支持全文索引、表空间固定，无法动态调整\n\n总之——\n\nInnoDB适合于对事务支持要求较高、并发性要求较高、需要保证数据一致性的应用场景；\n\n而MyISAM适合于读操作较多、写操作较少、对事务支持要求不高的应用场景。\n\n11.介绍下布隆过滤器的原理\n\n①初始化：首先，布隆过滤器会初始化一个位数组，所有位都被设置为0。\n\n②添加元素：当要将一个元素加入到布隆过滤器中时，将该元素通过多个哈希函数计算出多个哈希值，然后将位数组中对应的位置设置为1。\n\n③查询元素：当要查询一个元素是否存在于布隆过滤器中时，将该元素通过相同的哈希函数计算出多个哈希值，然后检查对应的位数组位置是否都为1。如果所有位置都为1，则该元素可能存在于布隆过滤器中；如果存在任何一个位置为0，则该元素一定不存在于布\n\n隆过滤器中。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594174701979602944?sourceSSR=users",
        "title": "币安钱包部门面筋，oc",
        "content": "1.在别的交易所写的业务\n\n有什么难度，是什么架构，如果中间有什么是面试官熟的会问很深的细节，我面的这个面试官估计是做cosmos的，问了cosmos提案的作用和hub的作用\n\n2.btc生态熟吗？ordinals有了解吗？brc20基于什么判断账户余额，要转一笔铭文需要怎么操作。sol生态熟吗？sol的铭文和brc20有什么差别\n\n3.寿司代码，经典反转链表\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594137693991219200?sourceSSR=users",
        "title": "网易有道前端 一面",
        "content": "  1. 你在vue项目中主要使用哪些生命周期干了什么\n  2. 如何组织我们vue项目目录\n  3. 你们项目的首屏渲染是如何做的\n  4. requestAnimationframe使用\n  5. vue中如何定义一个全局的方法\n  6. 父组件如何拿到子组件的值\n  7. v-if和v-show的区别\n  8. v-model的源码\n  9. watch的使用\n  10. <template>的使用场景\n  11. 封装过组件吗 问什么要封装 如果封装的组件功能点不够使用了，你们是重新封装一个组件，还是在原有的组件上更新内容\n  12. 在原有的组件上封装，需要考虑什么问题\n  13. 将下面代码更加type归类\n\n    \n    \n    let list2 = [\n      {\n        \"name\": \"古风\",\n        \"type\": \"风格\",\n      },\n      {\n        \"name\": \"放松\",\n        \"type\": \"情感\",\n      },\n      {\n        \"name\": \"民谣\",\n        \"type\": \"风格\",\n      },\n      {\n        \"name\": \"电子\",\n        \"type\": \"风格\",\n      },\n      {\n        \"name\": \"轻音乐\",\n        \"type\": \"风格\",\n      },\n      {\n        \"name\": \"欧美\",\n        \"type\": \"语种\",\n      },\n      {\n        \"name\": \"华语\",\n        \"type\": \"语种\",\n      }\n    ]\n    \n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594131014834802688?sourceSSR=users",
        "title": "蔚来前端实习二面",
        "content": "第一次二面碰到小姐姐面试官，问的都不难，没有手撕，答的不太好[牛泪][牛泪]\n\n1.自我介绍\n\n2.怎么判断一个数据类型是null\n\n3.事件循环\n\n4.闭包的应用场景，除了返回函数其他的实现方法\n\n5.react组件什么时候重新渲染，事件流的方式\n\n6.useContext，memo\n\n7.为什么要用状态管理库，主要解决了什么问题，和本地缓存的区别\n\n8.说一下发布订阅模式\n\n9.redux和zustand比较一下\n\n10.react项目可以做哪些优化\n\n11.usecallback缓存函数的目的是什么\n\n12.说说vue2中什么时候用到$set\n\n13.说一个遇到的项目难点，怎么解决的\n\n14.接触了解过ai吗，大模型，gpt，了解涉及什么\n\n15.了解我们这边的业务吗\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594128025206210560?sourceSSR=users",
        "title": "海康威视测试实习一面",
        "content": "1.自我介绍\n\n2.测试流程\n\n3.详细介绍自己是怎么测试项目的\n\n4.你认为你能否胜任APP测试（因为面试官介绍业务主要负责APP的自动化测试）\n\n5.如何看待加班问题\n\n电话面，整体没问什么八股，基本在问如何针对项目的测试（问题范围太广，感觉没答好）\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594122008930111488?sourceSSR=users",
        "title": "竹云科技-前端实习-面经（25min）",
        "content": "自我介绍\n\n1.接触前端多久了，什么时候开始系统性的学习\n\n2.怎么学习的\n\n3.项目开发流程？\n\n4.怎么进行项目的开发\n\n5.跨域问题\n\n6.闭包，然后我谈到了内存泄露和溢出\n\n7.怎么避免内存泄露溢出\n\n8.原型和原型链，到达顶部没找到属性和方法返回什么\n\n9.原型链的顶部\n\n10.vue的响应式原理\n\n忘记说了怎么对数组进行响应式原理的？\n\n11.vue2和vue3的区别\n\n12.computed和watch的区别\n\n13.路由的hash模式和history模式\n\n14.常用通信方式\n\n15.vuex。。×\n\n不太了解，然后面试官引导了持久化存储的缺点\n\n16.自己定义的组件\n\n最后开始反问\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594109075609174016?sourceSSR=users",
        "title": "AI深度学习推理加速HPC类岗位-Nvidia面经",
        "content": "哈哈标题党了，我其实不是学生，分享一下我作为一名面试官常问的AI推理加速HPC岗位的问题~仅分享通用知识部分，项目部分因人而异这里省略\n\n**C++部分**\n\n1、为什么我们做C++项目的时候，需要写头文件？\n\n2、讲出static关键字的一种应用场景\n\n3、单例模式如何实现？\n\n4、讲讲四种类型转换\n\n5、拷贝构造函数中浅拷贝和深拷贝的区别？\n\n6、一个类要去访问另一个类的private数据成员，该如何操作？\n\n###\n\n量化quantization部分\n\n1、说说你知道的那些针对LLM的量化技法？\n\n2、smoothquant为什么可以解决int8 LLM的accuracy问题？\n\n3、bfloat16和fp16(half float point)同样内存大小，那么它们可以节约的内存大小应该是一样的吗？他们的优缺点主要有哪些？\n\n4、量化怎么平衡精度和速度？\n\n###\n\nCUDA部分\n\n1、讲讲shared memory bank conflict的发生场景？以及你能想到哪些解决方案？\n\n2、CUDA里面如何分配GPU显存？为什么里面的参数是二级指针？\n\n3、优化CUDA程序的访存效率，你可以想到哪些？\n\n4、优化CUDA程序的计算效率，你又可以想到哪些？\n\n###\n\n大模型部分\n\n1、有哪些encoder-only、decoder-only、encoder-decoder的模型？\n\n2、随着seqlen的增加，你觉得encoder-only的模型和decoder-only的模型的计算量和访存量会是哪些变化趋势？为什么？\n\n3、说说你知道的大模型训练or推理的常用优化手段\n\n4、一般会对哪些大模型里面的算子做算子融合，说说你知道的\n\n5、flash attention的原理讲讲？你认为为什么flash attention极大提升了训练速度？\n\n6、paged attention的原理讲讲？你认为为什么paged attention极大提升了推理速度？它和flash attention的区别是什么？\n\n以上呢，起始都是非常经典的问题，足够看出大家对AI推理加速HPC岗位的基础。\n\n本人知道最近大家忙着准备实习面试和几个月后的秋招面试\n，同时很多学弟学妹深陷AI算法和后端开发的泥沼，认为只存在这俩职位，本人当初作为应届生的时候也是这样，但其实不然，AI深度学习推理加速HPC类岗位随着nvidia的股价暴涨，需求也是越来越大的，我从去年开始就帮助了很多同学了解这方面、加入这方面、着手实践项目，很多去年都成功拿到了offer，因此欢迎大家ping我，祝大家龙年工作如意~附一些截图，**（本人大号为:\n1987我不知会遇见你）**\n\n****![](https://uploadfiles.nowcoder.com/images/20240304/893471267_1709518837364/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n![](https://uploadfiles.nowcoder.com/images/20240304/893471267_1709518136648/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n![](https://uploadfiles.nowcoder.com/images/20240304/893471267_1709518157219/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594103101452201984?sourceSSR=users",
        "title": "虎彩-前端实习面经(23min)",
        "content": "1.自我介绍\n\n然后面试官先问了一下对vue了解的多吗？我说了解简单的原理\n\n2.说说vue的生命周期，以及你在项目中用这些钩子干过什么事\n\n当我说到在mounted用this的时候，又问了具体干了啥？\n\n3.在组件中，你定义数据用了什么关键字？有什么区别\n\n刚开始我没听懂，然后问他是不是想说let const var，他应该说是的，然后我开始了吟唱。。。。\n\n4.你封装过哪些组件，举具体的业务模块来说？\n\nsvgIcon，el-menu二次封装\n\n5.说说组件通信方式，你在项目中用了些什么通信方式，举具体的业务板块\n\n6.跨域了解吗\n\n我说了解一点，然后开始吟唱。。。当我吟唱到后端可以设置*号来允许跨域时，面试官问这样有什么后果，我说对服务器不安全巴拉啦\n\n7.了解dos攻击吗？×\n\n8.你以后对前端有什么职业规划吗\n\n9.了解uinapp，react吗×\n\n10.了解3Dxx技术吗×\n\n11.对原型链了解吗？\n\n12.刚才问的都是大学和研究生课程没学过的把，你是怎么了解的这些呢？\n\n13.最后反问了面试官认为我应该提升的地方\n\n\\--基础还是比较扎实的，就是技术面有点窄，建议多了解下移动端开发，3Dxx技术\n\n面试官还是挺好的，到最后给的建议也是比较真诚的\n\n面试通过！\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594095271965966336?sourceSSR=users",
        "title": "华为春招-终端BG-软件开发（过经）",
        "content": "11月中旬投的简历，然后HR一直拖，1月初做过了上机考试，然后说会尽快安排面试，因为我想选上海，后来过了半个月说上海没有HC，我就拒绝别的城市没面。\n过完年说上海又有一批HC。\n\n2.28 一面\n\n1.问熟悉的技术栈，选了Java，Java的是否存在内存泄漏\n\n2.Java的内存分配，垃圾回收\n\n3.Java的堆栈是什么，有什么特点\n\n4.Hashmap的原理和特点\n\n5.Hashmap存储100万数据，有什么优化的想法\n\n6.说一下实习做的事情，困难点是什么，你怎么解决的\n\n7.做题：lc38 Count and Say\n\n2.29 二面 + 主管面 连着一起面了\n\n1.什么是面向对象\n\n2.面向对象的特点\n\n3.什么是多态，什么是继承\n\n4.学校的项目做了什么，用了什么技术栈，有什么困难点，你怎么优化的\n\n5.从前端发请求到后端获得相应这整个阶段环节里有哪些优化的方式\n\n6.Http和https的区别\n\n7.做题：接雨水\n\n主管面 24分钟\n\n就是常规的行为面试+个人情况（问了华为的企业文化你了解吗）\n\n总体很常规，做题需要共享屏幕，使用自己电脑里的IDE。总体很常规，面试官人也挺好的，很友善，技术面结束最后1-2秒，面试官会告诉你有没有通过✅。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593945236179603456?sourceSSR=users",
        "title": "虾皮Java秋招面经",
        "content": "一面\n\n  1. Bean Singleton Prototype\n  2. Spring Bean初始化流程，Bean之后的流程\n  3. 循环依赖，问题和解决，e.g a和b\n  4. 为什么有的配置支持热更新有的不行，配置监听\n  5. rpc怎么切换节点，服务通信，本地缓存\n  6. Java 继承重载\n  7. 读写锁实现，CopyOnWrite实现\n  8. coding 瞄了\n\n当时高烧，听录音都把自己逗笑了，有不少当时会的，没打上，有时候没get到面试官的意思\n\n问了挺细的，一个问题追问细节直到答不上\n\n二面\n\n  1. 乐观锁和悲观锁，具体后端整个的流程实现\n  2. 设计索引需要考虑的点\n  3. 为什么要设计最左匹配原则\n  4. 主键和二级索引流程，回表\n  5. MySQL怎么实现事务，binlog，undolog，redolog\n  6. redis为什么高性能，持久化\n  7. redis实现分布式锁\n  8. kafka在项目中的应用，consumer group，rebalance\n  9. rpc中一致性哈希原理\n  10. reactor模型\n  11. https更安全在哪儿，哈希可以用作加密吗，证书原理\n  12. 常见排序算法，流程，时空复杂度\n  13. 什么是data race\n  14. go sync\n  15. coding：go并发打印个啥\n  16. coding：第k大的数\n\n反问：中间件DB深度不够，排序算法不太熟，忘了，已挂\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593905980593680384?sourceSSR=users",
        "title": "阿里云网络提前批 暑期实习面经",
        "content": "一面 50min\n\n  1. 研究生的研究方向是什么？\n  2. 为什么科研不合适？\n  3. 项目怎么实现幂等？\n  4. 存在一张表里？还是多张表？\n  5. 场景题：不同数据类型（XML、json）插入到不同的表，设计一个方案实现统一的幂等 网关层：\n  6. 在网关层为每个请求生成全局唯一ID，这个ID需要在请求中传递到后端服务。\n  7. 在网关层，首先检查请求是否已经被处理过（根据标识符来判断，标识符存入redis设置过期时间）。\n  8. 如果请求已经被处理过，则丢弃。\n  9. 如果请求未被处理过，则将请求转发给后端服务，并记录请求的处理状态。 后端：\n  10. 在处理请求的时候，需要考虑并发请求的情况，确保同一个请求不会被同时处理多次。\n  11. 可以使用分布式锁（根据这个ID来加锁）等机制来保证同一时刻只有一个请求能够被处理。 全局的前期过滤，分布式缓存，不同表的全局的ID、\n  12. ID的生成逻辑：雪花算法。放在客户端还是服务端？有什么好处和坏处？\n  13. 本科课程\n  14. 数据库mysql?\n  15. 行锁的sql语法。查询语句 不知道？\n  16. mysql存储引擎，区别\n  17. ORM框架 开发时间？\n  18. 场景题：请求和入库，监控调用了哪些DAO层的接口次数。\n  19. 代码行数？代码行数和能力没关？\n  20. 最痛苦的事情。\n  21. 碰到问题怎么解决？\n  22. 熬夜？熬的多吗？\n  23. 软考证书，时间?一个月拿下了？\n  24. 女孩IT行业很苦，怎么理解？\n  25. 算法：0移到数组的末尾，不复制数组\n  26. 反问 \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593904314330943488?sourceSSR=users",
        "title": "美好医疗    实验助理工程师      面经",
        "content": "1面   1位HR   腾讯会议面试45分钟  \n1.自我介绍  \n2.宝洁八大问  优缺点，遇到什么困难，解决什么问题，乱七八糟的的  \n3.对岗位了解程度  \n4.为什么想来公司  \n5.在学校表现怎么样，挂科，四六级情况  \n6.是否单身，家庭情况，是否独生子女  \n7.做过什么实验，项目，要求仔细说明  \n8.着重对我简历的校园社团经历进行了拷问  \n9.反问  \n10.介绍了公司的大概，岗位薪资福利，工作地点啥的  \n  \n2面     1位HR，2位部门经理    腾讯会议面试20分钟  \n1.自我介绍  \n2.对岗位看法，理解程度  \n3.问我岗位要用的仪器原理，构造，如何使用  \n4.问我工作同事不认可，咋搞  \n5.做过什么实验，使用仪器时间，经验  \n6.反问\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593900624656240640?sourceSSR=users",
        "title": "康方生物   QC工程师   面经分享",
        "content": "  \n\n一面   线上视频面试，大概15分钟，两个面试官\n\n1.自我介绍\n\n2.为什么想来公司\n\n3.问了我问什么不做销售\n\n4.在学校有做过什么实验用到什么仪器仪器的原理\n\n5.为什么想来广州\n\n6.对加班是什么看法\n\n7.在学校成绩怎么样，有没有挂科，有没有考研考公8.学的最好的一门课什么，简要说下为什么\n\n9.对岗位的了解程度\n\n10.在学校有做过什么项目\n\n  \n\n二面   线上视频面试，两位面试官\n\n1.是否单身\n\n2.能提前来公司实习吗，学校的事情都忙完了吗\n\n3.为什么不考研考公\n\n4.父母同意来广州吗\n\n5.未来的执业规划\n\n  \n\n总结，面试比较简单，提前准备了解岗位内容，表现的很想去，拿到offer不难\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593858103477547008?sourceSSR=users",
        "title": "春招收到e签宝的意向书",
        "content": "base:杭州 前端开发\n\n2.21 进行的一面 进行了一个小时的面试\n\n自我介绍\n\n主要以项目为主，进行介绍和提问\n\n还有一些八股文\n\n输入一个url到浏览器中，页面如何进行解析\n\n本地存储有哪些 他们的区别以及使用的场景\n\n还有其他的一些问题时间有点久已经忘了\n\n2.29 进行二面和hr的面试 大概进行了45分钟左右\n\n主管面试主要还是以项目和实习经历为主\n\n为什么要选择前端\n\n为什么对前端感兴趣\n\n对于未来的职业发展的有什么想法\n\n你觉得你做项目最大的困难是什么\n\n3.3 收到意向通知\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593849621798014976?sourceSSR=users",
        "title": "腾讯——移动客户端日常实习面经",
        "content": "1.是否有接触过安卓\n\n2.智能指针\n\n3.多态\n\n4.sizeof\n\n5.引用和指针的区别\n\n6.tcp四次挥手，为什么要4次不是3次\n\n7.tcp滑动窗口\n\n8.post和get的区别\n\n9.二分查找的时间复杂度\n\n10.二分查找的具体操作\n\n11.n个数中找出最小的k个数\n\n12.数组和链表的区别\n\n13.问项目\n\n14.对qt或者其他ui的了解\n\n15.反问\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593827583557451776?sourceSSR=users",
        "title": "杭州某国企 Java 面经",
        "content": "# 杭州某国企 Java 面经\n\n面试官：这边收到你的xxx简历，现在方便做一个简单的面试沟通吗？\n\n我：方便的方便的，内心OS：面经+1。\n\n1）\n\n面试官：先做个自我介绍吧\n\n我：常规操作，比八股背的熟多了，主要突出我全栈的一个学习过程，并且做了一个开源项目，我这边给大家的建议，尤其是双非同学，如果没啥亮点的话，个人博客和喜欢写一些笔记，画一些思维导图，喜欢看技术书籍，是比较好的亮点，如果不是电话面，可以直接给面试官共享屏幕，或者让他访问你的博客，这是一个很大的加分项，92\n的同学直接学历碾压了，本身学历就是亮点，所以可能没有什么产出的话，问题也不是很大，千万别说自己的缺点...\n\n2）\n\n面试官：把你的项目给我简单介绍一下\n\n我：阿巴阿巴，介绍项目的主要两个亮点功能，从需求分析、技术选型、业务实现，一步步讲下来，在重点和难点的时候再多加以阐述即可。\n\n3）\n\n面试官：你的数据是存在哪里的？\n\n我：MySQL 数据库，面试官追问查询优化方面，我主要阐述了慢查询日志的使用，和利用索引覆盖的特性，加快查询速度，这块结合具体的业务场景去讲就好了，可以把\nJemter 的参数跑出来会更可信。\n\n4）\n\n面试官：所有的情况都可以用索引覆盖吗？\n\n我：no，只有 Where、Group By、Join\n这些后面的字段如果没有加索引，才能够利用索引覆盖，而且索引并不是加的越多越好，阐述下索引在变动过程中需要维护，这部分时间也需要进行考虑。\n\n5）\n\n面试官：缓存你用过哪些？\n\n我：我的项目主要是用了 Redis，然后面试官追问 Redis 的数据结构底层原理，比如字符串的 SDS，对比原有 C 语言字符串的好处，比如 O(1)\n获取长度，不会缓冲区溢出，二进制安全，减少修改字符串的内存重新分配次数（惰性空间释放，空间预分配）\n\n6）\n\n面试官：缓存过期策略了解吗？\n\n我：惰性删除机制在取出 key 时进行过期检查，对 CPU 友好，定期删除机制会每隔一段时间抽取一批 key 执行删除过期 key 操作，对内存更加友好，\nRedis 采用的是定期删除+惰性删除，此外利用内存淘汰机制进行兜底，数据淘汰策略在 Redis 4 版本以前有 6 种，4 以后新增了两种 LFU\n的算法。\n\n7）\n\n面试官：你用过哪些设计模式？\n\n我：阿巴阿巴，主要包括门面模式（外观）、适配器模式、注册器模式、模版方法模式、策略模式等等，结合业务代码区讲就好了。\n\n8）\n\n面试官：你觉得什么时候需要用到单例模式？\n\n我：频繁实例化被销毁，频繁 new 对象，保证全局只有一个对象实例，创建对象耗时过多或者耗费资源过多，经常使用该对象，频发访问 IO\n的对象，比如数据库连接池，SpringBean 的单例注册表也是有一个缓存池。\n\n9）\n\n面试官：解释下线程安全和不安全\n\n我：阿巴，多线程竞争一个共享资源，这边可以介绍下临界区等，操作系统的知识，还可以介绍下死锁等等，可以结合具体的超卖问题。\n\n10）\n\n主要问了下能多久到岗，实习多久等等，我反问了工作时间和待遇，然后直接拒了，实习生还要加班，而且待遇太低了，直接面经+1。\n\n开源 AI 项目 Gitee 地址：[https://gitee.com/falle22222n-leaves/vue_-book-manage-\nsystem](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgitee.com%2Ffalle22222n-leaves%2Fvue_-\nbook-manage-system)\n\n欢迎老铁们 Star 下！累计总后端 700 + Star ，最近在写详细的文档，后续将会推出。⭐⭐⭐\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593799768803938304?sourceSSR=users",
        "title": "2024.03.01 字节跳动 商业化 一面",
        "content": "  * 自我介绍\n  * 项目难点介绍\n  * 像 websocket 这种服务器和本地长时间通信的，还有什么？\n  * 如果让你实现一个短轮询的方法，你怎么处理这个方法？\n  * 会有多少个状态？\n  * 如何处理状态呢？\n  * React Hook 和 Vue Compostion API 有什么区别，具体是解决什么问题的？\n  * React Hook 为什么不能在条件语句中使用？\n  * Hook 管理内部是用什么数据结构？\n  * React 组件通信方式\n  * Context 是如何实现的？\n  * Vue2 和 Vue3 的区别\n  * 为什么Object.defineProperty监听不到数组里面的变化？\n  * Vue 选项式 API，为什么可以通过this访问到data里面的数据？\n  * 读 Promise\n\n    \n    \n    async function a() {\n      console.log(\"1\");\n      await b();\n      console.log(\"2\");\n    }\n    \n    async function b() {\n      new Promise((resolve, reject) => {\n        console.log(3);\n        resolve(\"4\");\n        console.log(\"5\");\n      })\n        .then(value => {\n          console.log(value);\n          throw new Error(\"6\");\n        })\n        .catch(r => {\n          console.log(JSON.stringify(r));\n        });\n    }\n    \n    console.log(\"7\");\n    \n    a();\n    \n    setTimeout(() => {\n      console.log(\"8\");\n    }, 0);\n    \n    const p = new Promise((resolve, reject) => {\n      console.log(\"9\");\n      resolve(\"10\");\n    }).then(value => {\n      console.log(value);\n    });\n    \n    p.then(value => {\n      console.log(\"p:then\", value);\n    });\n    \n    console.log(\"script end\");\n    \n\n  * 作用域相关\n\n    \n    \n    var a = 1;\n    function b() {\n      a = 10;\n      return;\n      function a() {};\n    }\n    b()\n    console.log(a); // 1\n    \n\n  * 列表转树结构：https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/139\n  * 实现发布订阅：https://juejin.cn/post/6844903850105634824\n  * bind 返回的函数可以改变 this 指向吗？\n  * bind 函数返回的函数里面是什么\n  * 微前端：简单讲一下微前端\n  * Monorepo：\n  * 讲一下 Monorepo\n  * 为什么采用 pnpm + workspace，pnpm 有什么好处呢？\n  * yarn 也有 workspace，为什么不使用 yarn 呢？\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593774459169882112?sourceSSR=users",
        "title": "信息搜索 - 华为机试真题题解",
        "content": "> 考试平台：\n> [时习知](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fshixizhi.huawei.com%2F)\n>\n> 分值： 100分（第一题）\n>\n> 考试时间： 两小时（共3题）\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n### 题目描述\n\n请你设计一个程序，在给定消息中，搜索是否存在关心的信息。消息是有固定格式，具体格式如下:\n\n  * 消息为字符串，以TLV格式存储 (即Tag+Length+Value方式)，T占两个字符，L占两个字符，V即为指定长度L的字符串，其中T和L的每个字符均为0到9的数字字符，一个消息中可以有多个TLV，但每个TLV的Tag不能重复;\n  * 一个消息中可以存在多个TLV，但不会嵌套TLV;\n  * 消息格式可能不正确，即不符合给定格式规范，如:不是TLV格式(T和L不是数字字符)、Value按照Len指定的长度计算超过了字符串末尾、Tag重复等场景。\n\n示意说明:\n\n并列的TLV格式(本题中只存在这种场景)\n\n![alt](https://uploadfiles.nowcoder.com/images/20240229/644248237_1709193591649/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n说明:\n\n  * 对于给定待查找的消息，只在value中查找匹配 (区分大小写)Tag和Length不是消息内容，只是标记，如果在value中能查到该消息，输出对应TLV的Tag;\n  * 如果存在多个TLV都包括待查找的字符串，则只输出最后一个TLV的Tag;\n  * Length可以为0，如2200是一个合法的TLV单元。\n\n### 输入\n\n输入信息为两行字符串\n\n第一行:TLV消息字符串，总长度范围为[1,1000]。\n\n第二行:待查找的字符串\n\n### 输出\n\n输出三个字符串形式信息，中间以空格间隔\n\n  1. 给定消息是否格式合法。合法消息输出字符串true，非法输出字符串false;\n  2. 给定消息存在几个TLV单元。如果消息格式合法，按照实际TLV个数输出，如果消息格式非法，则输出0;\n  3. 待查找的字符串所在的Tag(如果多个TLV均含有对应消息，返回最后一个TLV的Tag)，如果消息非法或者合法消息中未找到字符串则输出字符串null。\n\n### 示例1\n\n    \n    \n    输入：\n    2202ab23042223\n    22\n    \n    输出：\n    true 2 23\n    \n    解释： \n    2202ab23042223是TLV格式，存在2个TLV单元，分别为:2202ab和23042223，给定22串在第二个TLV的Value中能找到，对应Tag为23\n    \n\n### 示例2\n\n    \n    \n    输入：\n    2202ab2304aaa\n    22\n    \n    输出：\n    false O null\n    \n    解释： \n    给定字符串不是合法的TLV格式，第二个TLV单元不对，Len为04，但是对应Value为aaa，长度为3，不匹配所以输出为false0\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593762341670391808?sourceSSR=users",
        "title": "金山前端笔试",
        "content": "单选题：20道\n\n  * js:call函数;promise:resolve, reject, .then, .catch;\n  * css: fixed,relative,absolute；\n  * 操作系统：LRU；不发生死锁的最小资源数\n  * 数据结构：哈夫曼树最小加权路径\n\n算法题：3道\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593797815239786496?sourceSSR=users",
        "title": "2024.02.28 腾讯 PCG QQ 一面",
        "content": "  * 自我介绍\n  * 实习项目交流\n  * React 函数组件和类组件的区别\n  * React Diff 说一下\n  * Vue2 Vue3 区别\n  * Pinia Vuex 区别\n  * Vue Router 如何实现的？如何匹配路径分发组件的\n  * `<keep-alive></keep-alive>`保存的是啥\n  * 假如说 keep-alive 内部有很多子组件，那子组件的状态也会保留吗？\n  * 不会保留，直接包裹的才会保留状态\n  * 那子组件内部会执行生命周期吗？\n  * computed的值什么时候会变？\n  * 如何优化 Vue 项目的性能\n  * Webpack 打包的流程\n  * 小程序、Node 用过吗？\n  * 没怎么写过，没问问题\n  * 手写题：大数相减\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593737426548375552?sourceSSR=users",
        "title": "代表团坐车 - 华为OD统一考试",
        "content": "> OD统一考试（B卷）\n>\n> 分值： 100分\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n某组织举行会议，来了多个代表团同时到达，接待处只有一辆汽车可以同时接待多个代表团，为了提高车辆利用率，请帮接待员计算可以坐满车的接待方案输出方案数量。\n\n**约束：**\n\n  1. 一个团只能上一辆车，并且代表团人数(代表团数量小于30，每个代表团人数小于30)小于汽车容量(汽车容量小于100)。\n  2. 需要将车辆坐满。\n\n## 输入描述\n\n第一行 代表团人数，英文逗号隔开，代表团数量小于30，每个代表团人数小于30。\n\n第二行 汽车载客量，汽车容量小于100。\n\n## 输出描述\n\n坐满汽车的方案数量，如果无解输出0\n\n## 示例1\n\n    \n    \n    输入：\n    5,4,2,3,2,4,9\n    10\n    \n    输出：\n    4\n    \n    说明：\n    以下几种方式都可以坐满车，[2,3,5]、[2,4,4]、[2,3,5]、[2,4,4]\n    \n\n## 题解\n\n> 这个问题是经典的**01背包** 问题可以使用**动态规划** 来解决。\n>\n> 定义一个一维数组`dp`，其中`dp[cap]`表示容纳`cap`人的方案数。\n>\n> 初始时，将`dp[0]`设为1，因为不带走任何代表团也是一种方案。\n>\n> 然后，对于每一个代表团人数 `x`，遍历数组`dp`，更新`dp[cap]`。具体的更新方式是，对于每一个 `cap`，如果 `cap >=\n> x`，则更新`dp[cap] += dp[cap - x]`。这表示当前容量为`cap`的方案数等于之前容量为`cap -\n> x`的方案数加上带上当前代表团的方案数。\n>\n> 最终，`dp[capacity]`即为坐满汽车的方案数量。\n\n### Java\n\n    \n    \n    import java.util.Arrays;\n    import java.util.Scanner;\n    /**\n     * @author code5bug\n     */\n    public class Main {\n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n    \n            // 读取代表团人数\n            String[] groupsStr = scanner.nextLine().spl\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593735925021028352?sourceSSR=users",
        "title": "线下面试（顺序不分先后)：",
        "content": "软件是什么\n\n产品开发全流程\n\njava 基本数据类型\n\nfor 和 foreach\n\nString StringBuilder StringBuffer\n\nredis默认最大内存\n\nredis常用数据结构\n\nredis突然宕机 数据会咋样\n\nSpring IOC\n\n个人优势\n\nmysql 倒序查询 count 多表联查\n\n项目自己做的那部分\n\n项目中遇到的技术上和代码上的难点\n\n10G大的文件如何传输\n\n英语能力，阅读官方文档\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593551956270993408?sourceSSR=users",
        "title": "快手 Java 面经，根据项目一顿拷打 | 0302",
        "content": ">\n> ![](https://git.acwing.com/Hasity/interview_hunter/-/raw/master/2024/image/%E9%9D%A2%E7%BB%8F6_%E5%AD%97%E8%8A%82java.png)\n\n## 1\\. 负载均衡是怎么做的，如何实现一直均衡给一个用户\n\n负载均衡实现的一般步骤：\n\n  1. **识别负载均衡的需求：** 首先需要确定在网络中的哪些资源需要进行负载均衡，如 Web 服务器、应用服务器或数据库服务器等。\n  2. **选择负载均衡算法：** 根据具体的需求选择合适的负载均衡算法，常见的算法包括轮询（Round Robin）、加权轮询（Weighted Round Robin）、最小连接数（Least Connection）等。\n  3. **配置负载均衡器：** 配置负载均衡器，设置负载均衡的规则和算法。这包括指定要均衡的服务器、配置健康检查（Health Check）机制以及设置负载均衡策略等。\n  4. **请求分发：** 当用户发送请求时，负载均衡器会根据选定的算法将请求分发到相应的服务器上。\n  5. **监控和调整：** 监控服务器的负载情况，根据需要动态调整负载均衡策略，以确保各服务器的负载保持均衡。\n\n实现一直均衡给一个用户可能涉及不同的需求和场景，可以通过一些特定的策略来实现：\n\n  * **基于 IP 地址的持续连接（IP Stickiness）：** 通过将用户的请求路由到同一台服务器，以确保用户的会话状态在同一服务器上保持。这通常通过在负载均衡器上配置 IP 地址和服务器的映射关系来实现。\n  * **会话保持（Session Affinity）：** 类似于 IP Stickiness，但是更加灵活，可以基于用户的会话信息（如 Cookie）来实现，以确保用户的会话状态在同一服务器上保持。\n  * **动态负载均衡策略：** 除了静态配置的负载均衡策略外，还可以根据用户的负载情况和服务器的负载情况动态调整负载均衡策略，以实现持续的均衡。\n\n>\n> **[面经专栏直通车](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fcreation%2Fmanager%2FcolumnDetail%2F0xKkDM)**\n\n>\n> **[面经专栏下载](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgit.acwing.com%2Flicw%2F24_job_hunter)**\n\n## 2\\. 服务熔断\n\n服务熔断（Circuit\nBreaker）是一种用于构建分布式系统的设计模式，用于增强系统的稳定性和可靠性。服务熔断的核心思想是在出现服务故障或异常时，及时地中断对该服务的请求，防止故障进一步扩散，并且允许系统在出现问题时快速失败而不是无限期地等待响应。\n\n服务熔断的用途和优势包括：\n\n  1. **防止级联故障：** 当某个服务或组件出现故障时，服务熔断可以快速地停止对该服务的请求，防止故障扩散到其他部分，从而保护整个系统的稳定性。\n  2. **快速失败：** 服务熔断允许系统在出现问题时快速失败，而不是等待超时，这可以减少用户等待时间，并快速释放资源以减轻系统负担。\n  3. **降级处理：** 当服务熔断触发时，可以采取降级处理策略，例如返回预先定义的默认值、执行备用逻辑或者从缓存中获取数据，以保证系统的基本功能继续可用。\n  4. **自我修复：** 当服务熔断一段时间后，可以尝试重新发起请求，如果服务恢复正常，则关闭熔断器，继续正常提供服务。\n\n常见问题和挑战包括：\n\n  1. **熔断器状态管理：** 需要有效地管理熔断器的状态，包括打开、关闭和半开状态的切换，以及对状态的监控和调整，确保熔断器的行为符合预期。\n  2. **故障诊断和处理：** 需要及时地检测和诊断服务的故障，并采取相应的措施进行处理，例如记录错误日志、发送警报通知等。\n  3. **降级策略设计：** 需要设计合适的降级处理策略，以保证在服务熔断时系统依然能够提供基本的功能，而不影响用户体验。\n  4. **性能影响：** 在服务熔断时，可能会增加系统的负载和响应时间，因此需要合理评估熔断器的触发条件和恢复机制，以减少性能影响。\n\n总的来说，服务熔断是一种重要的分布式系统设计模式，通过及时地中断对故障服务的请求，可以提高系统的稳定性和可靠性，但同时也需要综合考虑各种因素，合理设计和管理熔断策略，以确保系统的正常运行。\n\n## 3\\. 服务降级\n\n服务降级（Service\nDegradation）是一种在面对系统资源不足或者系统负载过大时，为了保证系统的核心功能或者关键服务的可用性而采取的一种策略。服务降级的核心思想是在系统压力过大时，有选择性地降低非核心或次要功能的服务质量，以确保系统的核心功能仍然能够正常运行。\n\n服务降级的目的在于保证系统在遇到异常或高负载情况下仍能够提供基本的服务能力，从而提高系统的稳定性和可用性。在实际应用中，服务降级通常伴随着一些特定的策略和实践，例如：\n\n  1. **优先级划分：** 将系统中的功能和服务按照其重要性和优先级进行划分，确保核心功能拥有更高的优先级，并在资源不足时优先保证核心功能的运行。\n  2. **限流和限速：** 通过限制对系统的访问速率或者并发请求数量，以防止系统过载，从而减轻系统负载压力。\n  3. **降级策略设计：** 设计合适的降级策略，当系统资源不足或者系统负载过大时，有选择性地降低非核心功能或次要功能的服务质量，例如降低服务响应时间、减少服务数据的返回量等。\n  4. **实时监控和调整：** 实时监控系统的负载情况和性能指标，根据实际情况动态调整降级策略，以确保系统的稳定性和性能表现。\n\n服务降级的优点包括：\n\n  * **提高系统的稳定性：** 在面对异常情况或者高负载情况时，通过降级非核心功能或次要功能的服务质量，可以确保系统的核心功能仍能够正常运行，从而提高系统的稳定性。\n  * **保证核心功能的可用性：** 通过有选择性地降级非核心功能或次要功能，可以确保系统的核心功能在异常或高负载情况下仍能够提供基本的服务能力，从而保证核心功能的可用性。\n  * **减少系统压力：** 通过降级非核心功能或次要功能的服务质量，可以减少系统的负载压力，从而提高系统的整体性能和响应速度。\n\n服务降级也存在一些潜在的缺点\n\n  * 可能影响用户体验\n  * 需要精细的策略设计和实时监控\n  * 可能引起业务方面的不满等。 因此，在实施服务降级策略时，需要综合考虑各种因素，并设计合理的降级策略，以确保系统的整体性能和用户体验。\n\n## 4\\. Spring的IOC\n\nSpring框架中的IOC（Inverse of\nControl，控制反转）是一种设计原则，也是Spring框架的核心之一。IOC的概念是指控制权的转移，即将对象的创建、依赖注入和生命周期管理等控制权交给了容器来管理，而不是由对象自己来控制。这种控制反转的思想使得应用程序的组件之间的关系变得更加灵活、可维护和可测试。\n\n在Spring框架中，IOC的实现主要通过依赖注入（Dependency\nInjection，DI）来实现。依赖注入是指容器负责在对象创建的同时，自动将对象所依赖的其他对象注入到它们之中，而不是由对象自己来创建或查找依赖的对象。\n\nSpring框架通过XML配置文件、注解或Java代码来描述对象之间的依赖关系，然后由Spring容器在运行时根据这些配置来实现依赖注入。通过IOC容器管理对象之间的依赖关系，使得应用程序的组件解耦，提高了代码的灵活性和可维护性。\n\nSpring的IOC容器通过控制对象之间的依赖关系，实现了对象之间的解耦，提高了代码的灵活性和可测试性，是Spring框架的核心特性之一。\n\n## 5\\. 为什么依赖注入不适合使用字段注入\n\n依赖注入有三种主要的方式：构造函数注入、Setter方法注入和字段注入。虽然字段注入是最简洁的一种方式，但它也存在一些问题，这就是为什么在某些情况下不推荐使用字段注入的原因。\n\n  1. **可测试性差：** 字段注入使得依赖关系被硬编码到了类的字段中，这导致在进行单元测试时很难对这些依赖进行模拟或替换。因为字段注入的依赖是直接赋值给类的字段，而不是通过构造函数或Setter方法来传递，所以在测试时很难通过传入不同的依赖实例来进行测试。\n  2. **难以追踪依赖关系：** 使用字段注入时，依赖关系是通过字段直接注入到类中的，这使得依赖关系不够明确，很难追踪类与其依赖之间的关系。这可能导致代码的可读性和可维护性下降。\n  3. **耦合性高：** 字段注入使得依赖关系与类的实现紧密耦合在一起，从而增加了类与其依赖之间的耦合性。当需要修改依赖关系时，可能需要修改类的字段定义，这违反了开闭原则。\n\n相比之下，构造函数注入和Setter方法注入提供了更好的解耦性和可测试性。构造函数注入将依赖关系通过构造函数传入，而Setter方法注入则通过Setter方法设置依赖。这两种方式都能够清晰地标识出类与其依赖之间的关系，提高了代码的可读性和可维护性，同时也更易于进行单元测试和模拟依赖。因此，在使用依赖注入时，推荐优先考虑使用构造函数注入或Setter方法注入，而尽量避免使用字段注入。\n\n## 6\\. Spring的aop\n\nSpring框架中的AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，它允许开发者通过将横切关注点（Cross-\ncutting\nConcerns）从核心业务逻辑中分离出来，从而提高了代码的模块化程度和可维护性。横切关注点包括日志记录、事务管理、安全检查等与核心业务逻辑无关的功能。\n\nAOP的核心概念是切面（Aspect），切面是一个模块化单元，它封装了横切关注点，并定义了在何处、何时应用这些关注点。在Spring框架中，切面通常以Java类的形式存在，并且通过特定的注解或XML配置来定义切面。\n\nSpring框架提供了几种实现AOP的方式：\n\n  1. **基于代理的AOP：** Spring使用动态代理来实现AOP。当一个类被AOP代理后，方法调用会被拦截，从而允许切面在方法调用前、后或者出现异常时执行额外的逻辑。Spring中的基于代理的AOP主要使用JDK动态代理和CGLIB动态代理来实现。\n  2. **切点和通知：** 切点（Pointcut）用于定义在哪些连接点（Join Point）应用切面逻辑，通知（Advice）用于定义切面的行为。Spring框架提供了几种通知类型，包括前置通知（Before Advice）、后置通知（After Advice）、返回通知（After Returning Advice）、异常通知（After Throwing Advice）和环绕通知（Around Advice）。\n  3. **切面表达式：** Spring提供了切面表达式语言（AspectJ Expression Language），通过切面表达式可以更精确地定义切点，并在切面中应用通知。切面表达式支持基于方法签名、参数、注解等方式来定义切点。\n\n通过AOP，开发者可以将横切关注点模块化，避免代码重复和耦合度增加，从而提高代码的可维护性和可重用性。在Spring框架中，AOP常用于日志记录、事务管理、安全检查等方面，使得这些与核心业务逻辑无关的功能可以被统一管理和应用。\n\n## 7\\. Spring的事务，使用this调用是否生效\n\n在Spring中，使用`this`调用方式调用类的方法时，事务是生效的。Spring的事务是基于代理实现的，当一个类被Spring的事务代理包装后，所有对该类的方法的调用，包括通过`this`调用方式，都会被代理拦截。因此，即使使用`this`调用方式，Spring的事务管理仍然能够生效。\n\n这是因为Spring的事务是通过AOP实现的，通常使用基于代理的AOP来处理事务。在基于代理的AOP中，Spring会为目标对象创建一个代理对象，而调用该代理对象的方法时，会触发AOP的通知，从而实现事务的管理。因此，无论是直接调用目标对象的方法，还是通过`this`调用方式调用目标对象的方法，Spring都能够正确地拦截并管理事务。\n\n总之，Spring的事务是基于代理实现的，因此无论通过何种方式调用目标对象的方法，Spring的事务管理都会生效。\n\n## 8\\. Spring的循环依赖\n\n在 Spring 中，循环依赖是指两个或多个 Bean 之间互相依赖的情况，导致 Bean\n的创建发生循环，从而无法完成依赖注入的过程。这种情况可能会导致应用程序启动失败或者出现不可预测的行为。\n\nSpring 框架提供了一些解决循环依赖的机制：\n\n  1. **提前曝光（Early Exposure）：** Spring 容器在创建 Bean 的过程中，会提前暴露正在创建的 Bean 实例，以解决循环依赖的问题。当一个 Bean A 依赖另一个 Bean B，而 Bean B 又依赖 Bean A 时，Spring 在创建 Bean A 的过程中，会提前暴露一个代理对象，用于处理 Bean B 对 Bean A 的依赖。这样，Bean A 可以在被完全创建之前，通过代理对象来访问 Bean B。这种方式需要使用 CGLIB 来创建代理对象。\n  2. **构造函数注入：** 使用构造函数注入来解决循环依赖问题。Spring 容器在创建 Bean 的过程中，会首先将依赖项通过构造函数传递进去，从而避免了循环依赖的问题。这种方式需要谨慎使用，因为构造函数注入会将循环依赖暴露在类的构造函数中，可能导致代码不够清晰。\n  3. **Setter 方法注入：** 使用 Setter 方法注入来解决循环依赖问题。与构造函数注入类似，通过将依赖项通过 Setter 方法注入，可以避免循环依赖的问题。与构造函数注入相比，Setter 方法注入更加灵活，可以在 Bean 创建完成后再进行依赖注入，但也需要注意循环依赖可能带来的问题。\n\n虽然 Spring\n提供了这些解决循环依赖的机制，但是在设计应用程序时，尽量避免出现循环依赖是更好的选择。循环依赖会导致代码的复杂性增加，降低程序的可维护性和可读性。\n\n## 9\\. Spring MVC的工作流程；如果是传输文件呢\n\nSpring MVC（Model-View-\nController）是一个基于Java的Web框架，用于开发Web应用程序。它遵循经典的MVC设计模式，将应用程序划分为模型（Model）、视图（View）和控制器（Controller）三个部分，以实现松耦合和模块化开发。\n\n**Spring MVC的工作流程：**\n\n  1. **客户端发起请求：** 客户端（通常是浏览器）向服务器发起请求，请求由Servlet容器（如Tomcat）接收。\n  2. **DispatcherServlet拦截请求：** 请求被DispatcherServlet拦截，DispatcherServlet是Spring MVC的核心控制器，负责统一管理请求的调度和分发。\n  3. **HandlerMapping确定处理器：** DispatcherServlet通过HandlerMapping将请求映射到对应的处理器（Controller）上。\n  4. **处理器执行请求：** 处理器根据请求的映射，执行相应的业务逻辑，并返回一个ModelAndView对象，其中包含了处理结果数据和视图名称。\n  5. **ViewResolver解析视图：** ModelAndView中的视图名称被ViewResolver解析为具体的视图对象，视图对象可以是JSP页面、Thymeleaf模板等。\n  6. **视图渲染：** 视图对象将处理结果数据渲染到具体的视图中。\n  7. **响应返回客户端：** 渲染后的视图最终以响应的形式返回给客户端。\n\n**传输文件时的工作流程：**\n\n如果在Spring MVC中需要传输文件，通常使用multipart/form-data类型的表单来上传文件。工作流程与上述流程类似，但有一些不同之处：\n\n  1. **客户端发送包含文件的请求：** 客户端通过表单提交包含文件的请求。\n  2. **DispatcherServlet拦截请求：** 请求被DispatcherServlet拦截。\n  3. **MultipartResolver解析请求：** DispatcherServlet使用MultipartResolver解析包含文件的请求，将请求中的文件内容解析为MultipartFile对象。\n  4. **HandlerMapping确定处理器：** 请求被映射到相应的处理器（Controller）上。\n  5. **处理器处理文件上传：** 处理器接收到请求后，处理文件上传操作，通常会将文件保存到服务器本地或进行其他操作。\n  6. **处理器返回响应：** 处理器返回处理结果。\n  7. **视图渲染或直接返回响应：** 如果需要，视图渲染将处理结果渲染到视图中；如果不需要，直接返回响应给客户端。\n\n## 10\\. Kafka如何保证消息不丢失\n\nKafka 是一个分布式流处理平台，它使用一些机制来确保消息不丢失：\n\n  1. **持久化到磁盘：** Kafka 将消息持久化到磁盘上的文件中，这样即使在消息被处理之前，它们也可以被持久化和存储。因此，即使发生系统故障或者重启，消息也不会丢失。\n  2. **复制机制：** Kafka 通过副本机制来提供高可用性和容错性。在 Kafka 集群中，每个分区的数据都会被复制到多个 Broker 上。这些副本中的一个被选为 Leader，负责处理所有的读写请求，其他副本作为 Followers，用于备份数据。如果 Leader 失效，Kafka 将自动从 Followers 中选举出新的 Leader，从而保证数据的可用性和一致性。\n  3. **消息确认机制：** Kafka 提供了消息确认机制，可以确保消息被成功写入到 Broker 中。生产者可以选择等待 Broker 的确认信息，以确保消息被成功复制到指定数量的副本中后再发送下一条消息。这样可以避免消息丢失，但可能会降低消息的发送速度。\n  4. **持久化日志：** Kafka 使用持久化日志来存储消息，这使得即使在发生异常情况下，消息也不会丢失。Kafka 的存储机制允许在消息被消费之前将其保留在日志中。\n\nKafka 使用持久化、复制机制、消息确认和持久化日志等多种机制来确保消息不丢失。这些机制使得 Kafka\n成为一个可靠的消息系统，适用于处理关键业务数据和高吞吐量的场景。\n\n## 11\\. Kafka如何保证消息不重复消费\n\nKafka 使用消费者组（Consumer Group）来确保消息不重复消费的机制，具体方式如下：\n\n  1. **分区和偏移量：** Kafka 将每个主题（Topic）划分为多个分区（Partition），每个分区包含一个有序的消息序列。消费者在消费消息时，会按照分区的顺序消费消息。而每个分区中的消息都有一个唯一的偏移量（Offset），用来标识消息在分区中的位置。\n  2. **消费者组：** 消费者可以组成消费者组，一个消费者组中可以包含一个或多个消费者。每个消费者组对于一个主题的每个分区都可以有一个或多个消费者，但是一个分区只能被同一个消费者组中的一个消费者消费。消费者组中的消费者之间协调消费任务，每个消费者负责消费分区中的一部分消息。\n  3. **偏移量的管理：** 每个消费者都会记录自己消费的分区和偏移量，以便在重启或者重分配分区时能够继续消费之前的消息。消费者将消费的最新偏移量保存在 Kafka 中的内部主题（__consumer_offsets）中。\n  4. **消费者组协调器：** Kafka 集群中的一个特殊的 Broker 会负责充当消费者组的协调器（Consumer Group Coordinator），它负责分配分区给消费者组中的消费者，并确保每个分区只被一个消费者消费。\n\n通过以上机制，Kafka 确保了消息不重复消费的原则：\n\n  * 消费者组内的每个消费者负责消费不同的分区，确保了分区内消息的顺序性。\n  * 消费者组中的消费者协调分配分区，避免了多个消费者同时消费同一个分区的情况。\n  * 消费者记录消费的偏移量，以便在重启或者重分配分区时能够继续消费之前的消息。\n\nKafka 通过消费者组、分区和偏移量的管理机制来保证消息不重复消费，从而确保了消息处理的准确性和一致性。\n\n## 12\\. MySQL的三大日志\n\n  1. **二进制日志（Binary Log）：** 二进制日志记录了数据库中所有的修改操作，以二进制格式保存。这些操作包括数据的插入、更新、删除以及数据结构的更改（如表结构的修改）。二进制日志对于数据库的备份、复制和恢复非常重要。\n\n  2. **重做日志（Redo Log）：** 重做日志是InnoDB存储引擎特有的日志类型。它记录了数据库中每个事务所做的修改操作，但与二进制日志不同，重做日志以物理格式记录。重做日志用于数据库的恢复，以保证事务的持久性和一致性。\n\n  3. **撤销日志（Undo Log）：** 撤销日志也是InnoDB存储引擎特有的日志类型。它记录了事务执行过程中所做的修改操作的逆操作，用于回滚事务、处理并发事务和提供数据库的一致性视图。\n\n## 13\\. ElasticSearch如何进行全文检索\n\nElasticsearch 是一个分布式、RESTful 风格的搜索和分析引擎，它提供了强大的全文检索功能。下面是 Elasticsearch\n如何进行全文检索的简要流程：\n\n  1. **创建索引（Index）：** 在 Elasticsearch 中，数据被组织在索引中。索引类似于关系型数据库中的数据库，用于存储一类相关的数据。在进行全文检索之前，首先需要为数据创建一个索引。\n  2. **添加文档（Document）：** 在索引中添加文档，文档是 Elasticsearch 中存储的基本单位。文档通常是 JSON 格式的数据，可以包含一个或多个字段，每个字段包含一个或多个值。\n  3. **建立映射（Mapping）：** 映射定义了文档中每个字段的数据类型和分析方式。在创建索引时，可以自定义字段的映射，或者让 Elasticsearch 根据文档的结构自动推断映射。\n  4. **执行搜索请求：** 通过发送搜索请求来进行全文检索。搜索请求可以包含一个或多个查询条件，Elasticsearch 将根据这些条件来匹配文档，并返回符合条件的结果。\n  5. **分析查询条件：** Elasticsearch 会对查询条件进行分析，将查询条件解析为一个或多个查询子句。查询子句包括词项查询、短语查询、范围查询等，用于匹配文档中的字段值。\n  6. **执行查询：** Elasticsearch 执行查询操作，并使用倒排索引来快速定位匹配的文档。倒排索引是一种将文档中的每个词项映射到包含该词项的文档列表的数据结构，可以高效地进行全文检索。\n  7. **评分和排序：** Elasticsearch 根据匹配度对搜索结果进行评分，并按照评分对结果进行排序。评分是根据文档与查询条件的匹配程度来计算的，匹配度越高的文档排名越靠前。\n  8. **返回搜索结果：** Elasticsearch 返回符合查询条件的文档结果，通常包括文档的 ID、分数和其他字段值等信息。\n\nElasticsearch\n的全文检索流程包括创建索引、添加文档、建立映射、执行搜索请求、分析查询条件、执行查询、评分和排序以及返回搜索结果等步骤。通过这些步骤，Elasticsearch\n可以高效地进行全文检索，并返回符合查询条件的文档结果。\n\n## 14\\. 除了IK分词器还用到哪些分词器\n\n除了 IK 分词器外，Elasticsearch 还有其他常用的分词器，例如：\n\n  1. **Standard 分词器：** 标准分词器是 Elasticsearch 默认的分词器，它是一个基于 Unicode 标准的分词器，按照单词边界进行分词，支持多种语言。\n  2. **Whitespace 分词器：** 空格分词器根据空格字符将文本分割成单词，适合处理英文文本或者不需要分词的场景。\n  3. **Simple 分词器：** 简单分词器是一个非常简单的分词器，根据非字母字符将文本分割成单词，适用于处理非结构化文本数据。\n  4. **Lowercase 分词器：** 小写分词器将文本转换为小写，然后使用标准分词器进行分词，适用于处理不区分大小写的场景。\n  5. **Keyword 分词器：** 关键字分词器将整个文本作为一个单词，适用于不需要分词的场景，通常用于对字段进行精确匹配或者聚合操作。\n  6. **Pattern 分词器：** 模式分词器根据指定的正则表达式将文本分割成单词，适用于需要根据特定规则进行分词的场景。\n  7. **Stop 分词器：** 停止词分词器将指定的停止词（如常见的连接词、介词等）从文本中移除，适用于需要去除停止词的场景。\n  8. **Snowball 分词器：** 雪球分词器支持多种语言的词干提取，可以将单词转换为其词干形式，适用于需要进行词干提取的场景。\n\n## 15\\. 分词器的底层实现\n\n分词器（Tokenizer）在 Elasticsearch 中的底层实现通常是基于 Lucene 的分词器实现的。Lucene\n是一个开源的全文搜索引擎库，Elasticsearch 是基于 Lucene 构建的分布式搜索和分析引擎，因此它继承了 Lucene 强大的分词器功能。\n\n在 Lucene\n中，分词器负责将文本按照一定规则进行分词，生成一个个词项（Term）。词项是搜索的基本单位，是搜索引擎索引中的最小单元。分词器根据具体的语言、词汇、文法等规则将文本分割成不同的词项，然后进行索引和搜索。\n\n分词器的底层实现通常包括以下几个方面：\n\n  1. **字符解析：** 分词器首先将输入的文本字符流进行解析，识别出文本中的单词、标点符号、数字等字符。\n  2. **词项生成：** 根据一定的规则，分词器将解析后的字符流进行分割，生成一个个词项。词项的生成方式可以根据具体的分词器实现而不同，例如基于词典、规则、统计信息等。\n  3. **词项过滤：** 在生成词项的过程中，分词器可能会对词项进行过滤，去除一些不需要的词项，例如停止词（Stop Words）等。\n  4. **词干提取：** 有些分词器会对词项进行词干提取，将词项转换为其原始形式，以提高搜索的准确性和召回率。\n  5. **标记位置和偏移量：** 分词器还会为每个词项记录其在文本中的位置和偏移量，以便后续索引和搜索操作。\n  6. **分词器链：** 在 Elasticsearch 中，可以通过配置多个分词器来构建一个分词器链（Tokenizer Chain），每个分词器依次对输入的文本进行处理，生成词项序列。\n\n分词器的底层实现是基于 Lucene\n的分词器实现的，它通过对文本进行解析、分割、过滤、词干提取等操作，生成词项序列，为搜索引擎的索引和搜索提供了基础支持。在 Elasticsearch\n中，分词器的实现可以根据具体的需求和场景进行自定义和配置。\n\n## 16\\. 线性的数据结构（链表和数组），有什么区别\n\n链表和数组是两种常见的线性数据结构，它们之间有一些区别，主要包括以下几个方面：\n\n  1. **内存分配方式：**\n     * 数组在内存中是一段连续的内存空间，每个元素都占据固定大小的内存空间，可以通过索引直接访问任意位置的元素。\n     * 链表中的元素在内存中不是连续存储的，每个元素包含一个指向下一个元素的指针，通过指针将各个元素连接起来，因此在链表中访问元素需要从头节点开始遍历。\n  2. **插入和删除操作：**\n     * 数组的插入和删除操作比较低效，因为需要移动大量元素来维持连续的内存空间。在最坏情况下，时间复杂度为 O(n)。\n     * 链表的插入和删除操作相对高效，只需要修改相邻元素的指针，时间复杂度为 O(1)。\n  3. **查找操作：**\n     * 数组的查找操作比较高效，可以通过索引直接访问元素，时间复杂度为 O(1)。\n     * 链表的查找操作比较低效，需要从头节点开始遍历链表，直到找到目标元素或者到达链表末尾，时间复杂度为 O(n)。\n  4. **空间复杂度：**\n     * 数组需要一块连续的内存空间来存储所有元素，因此需要预先分配足够的空间，如果空间不足需要进行扩容操作。\n     * 链表不需要预先分配连续的内存空间，可以动态分配内存，因此可以灵活地处理不同大小的数据集。\n\n数组和链表各有优缺点，选择使用哪种数据结构取决于具体的应用场景和需求。如果需要频繁进行插入和删除操作，且数据量不确定，可以选择链表；如果需要频繁进行查找操作，且数据量相对稳定，可以选择数组。\n\n## 17\\. 如何使用两个栈实现队列\n\n使用两个栈实现队列的基本思路是，利用一个栈作为入队栈，用于存储入队的元素；另一个栈作为出队栈，用于存储出队的元素。具体实现如下：\n\n  1. **入队操作：**\n     * 将元素压入入队栈中即可。\n  2. **出队操作：**\n     * 如果出队栈为空，将入队栈中的所有元素依次弹出并压入出队栈中，然后从出队栈中弹出栈顶元素；\n     * 如果出队栈不为空，直接从出队栈中弹出栈顶元素。\n\n使用两个栈实现队列的关键在于在出队操作时将入队栈的元素倒序压入出队栈中，从而实现队列的先进先出（FIFO）的特性。\n\n下面是使用 Python 语言实现的示例代码：\n\n    \n    \n    class MyQueue:\n        def __init__(self):\n            self.in_stack = []  # 入队栈\n            self.out_stack = []  # 出队栈\n    \n        def push(self, x: int) -> None:\n            self.in_stack.append(x)\n    \n        def pop(self) -> int:\n            if not self.out_stack:\n                while self.in_stack:\n                    self.out_stack.append(self.in_stack.pop())\n            return self.out_stack.pop()\n    \n        def peek(self) -> int:\n            if not self.out_stack:\n                while self.in_stack:\n                    self.out_stack.append(self.in_stack.pop())\n            return self.out_stack[-1]\n    \n        def empty(self) -> bool:\n            return not self.in_stack and not self.out_stack\n    \n\n这样实现的队列的时间复杂度为：\n\n  * 入队操作的时间复杂度为 O(1)；\n  * 出队操作的平均时间复杂度为 O(1)；\n  * 空间复杂度为 O(n)。\n\n## 18\\. Dns基于什么协议实现，为什么是udp\n\nDNS（Domain Name System，域名系统）是基于 UDP（User Datagram Protocol，用户数据报协议）实现的。\n\nUDP 是一种无连接的、不可靠的传输层协议，它不提供数据包的可靠性、流量控制和拥塞控制等功能，但它具有简单、轻量、低延迟的特点。而 DNS\n的设计目标是快速响应用户查询，并且要求尽可能地减小网络通信的延迟，因此选择了 UDP 作为 DNS 协议的传输层协议。\n\nDNS 之所以选择 UDP 而不是 TCP，主要是出于以下考虑：\n\n  1. **低延迟：** UDP 相对于 TCP 更加轻量，不需要建立连接、维护连接状态和进行错误重传等操作，因此可以减小网络通信的延迟，适合对延迟要求较高的场景。\n  2. **简单快速：** UDP 头部较小，没有 TCP 那样的连接管理和流量控制机制，因此可以更快速地发送和接收数据，减小数据包的大小，降低网络负载。\n  3. **高并发：** UDP 不需要维护连接状态，每个 UDP 数据包都是独立的，因此可以支持更高的并发连接数，适合于 DNS 服务器处理大量并发的查询请求。\n\n尽管 UDP 存在丢包和数据包损坏的风险，但在 DNS 的设计中，这些风险是可以被容忍的。DNS\n使用了一些机制来提高可靠性，例如查询超时重传、请求重试、缓存等，以确保数据传输的可靠性和正确性。\n\n总的来说，DNS 选择 UDP 作为传输层协议，是为了追求更低的延迟、更高的性能和更好的并发能力，同时通过其他机制来提高数据传输的可靠性。\n\n## 19\\. http的特点\n\nHTTP（Hypertext Transfer Protocol，超文本传输协议）是一种用于传输超文本数据（如 HTML）的应用层协议，它是现代 Web\n通信的基础。HTTP 的特点包括以下几个方面：\n\n  1. **无连接性（Connectionless）：** HTTP 是一种无连接的协议，每次请求-响应周期都是相互独立的，服务器在收到客户端请求并发送响应后立即断开连接。这种特点使得 HTTP 的连接开销较小，适用于短时交互的通信场景。\n  2. **无状态性（Stateless）：** HTTP 是一种无状态的协议，即服务器不会维护客户端的状态信息。每个请求都是独立的，服务器不能识别两个请求是否来自同一个客户端。这种特点简化了服务器的设计和实现，但也限制了 HTTP 在一些需要保持状态的场景下的应用。\n  3. **基于文本（Text-based）：** HTTP 使用文本格式的请求和响应消息进行通信，消息头部包含了一系列的键值对，用于描述消息的属性和特征，消息体则包含了具体的数据内容。这种基于文本的格式使得 HTTP 的消息易于阅读和理解，并且可以使用简单的文本编辑器进行调试和修改。\n  4. **支持多媒体类型（Media-independent）：** HTTP 不仅可以传输 HTML 文档，还可以传输各种不同类型的多媒体数据，如图片、音频、视频等。HTTP 使用 MIME（Multipurpose Internet Mail Extensions）标准来描述和传输多媒体数据。\n  5. **灵活性（Flexibility）：** HTTP 是一种灵活的协议，支持多种不同的请求方法（如 GET、POST、PUT、DELETE 等）、状态码（如 200 OK、404 Not Found、500 Internal Server Error 等）和头部字段（如 Content-Type、Content-Length、Cache-Control 等），可以根据具体的需求和场景进行定制和扩展。\n\nHTTP 是一种简单、灵活、文本化的应用层协议，具有无连接性、无状态性、基于文本、支持多媒体类型和灵活性等特点，适用于传输超文本数据和多媒体数据的通信场景。\n\n## 20\\. http无状态体现在哪\n\nHTTP 的无状态性体现在服务器不会在请求之间保存客户端的状态信息。具体来说，无状态性表现在以下几个方面：\n\n  1. **每个请求独立性：** HTTP 是一种无连接的协议，每个请求-响应周期都是相互独立的，服务器在收到客户端请求并发送响应后立即断开连接。因此，服务器不能识别两个请求是否来自同一个客户端，也无法知道这两个请求之间是否存在关联性。\n  2. **不保存客户端状态：** 服务器不会保存客户端的状态信息，即服务器在处理每个请求时都是无状态的。客户端发送的每个请求都必须包含足够的信息来描述其自身的状态，服务器在处理请求时不能依赖之前的请求状态。\n  3. **状态信息在客户端：** 为了维护客户端的状态信息，客户端通常会在请求中包含一些标识符或者会话令牌（如 Cookie 或者 Session ID），服务器在接收到请求后会解析这些信息并根据需要进行处理。这种方式使得客户端的状态信息保存在客户端而不是服务器端，从而实现了无状态性。\n  4. **灵活性：** HTTP 的无状态性提供了灵活性，允许服务器在处理请求时不受之前请求的影响，可以根据当前请求的情况来进行处理。这种灵活性使得服务器可以更好地应对不同客户端的请求，并且使得 HTTP 协议更易于扩展和部署。\n\nHTTP 的无状态性意味着服务器在处理每个请求时都是独立的、无状态的，不会保存客户端的状态信息，从而提高了服务器的灵活性和可伸缩性。\n\n## 21\\. Cookie和session的区别\n\nCookie 和 Session 都是用来在客户端和服务器之间保存状态信息的机制，但它们有一些区别：\n\n  1. **存储位置：**\n     * Cookie 是存储在客户端的一小段文本信息，以键值对的形式保存在客户端的浏览器中。\n     * Session 是存储在服务器端的一种会话状态，通常存储在服务器内存、数据库或者其他持久化存储介质中。\n  2. **安全性：**\n     * Cookie 存储在客户端的浏览器中，因此相对不安全，可能被篡改或者盗用。\n     * Session 存储在服务器端，相对安全，客户端无法直接访问或修改。\n  3. **容量限制：**\n     * Cookie 的大小通常有限制，一般不超过 4KB。\n     * Session 的大小没有明确限制，受服务器资源和配置的影响，可以存储更多的信息。\n  4. **生命周期：**\n     * Cookie 可以设置过期时间，在设置的过期时间之前一直保存在客户端，可以长期保存。\n     * Session 的生命周期由服务器控制，通常在客户端关闭后自动失效，也可以手动设置过期时间。\n  5. **存储内容：**\n     * Cookie 可以存储任意类型的数据，但是由于存储在客户端，不适合存储敏感信息。\n     * Session 可以存储任意类型的数据，因为存储在服务器端，可以存储敏感信息。\n  6. **传输方式：**\n     * Cookie 在 HTTP 头部中通过 Set-Cookie 和 Cookie 字段进行传输。\n     * Session 通常通过在 Cookie 中保存 Session ID 来实现，客户端每次请求时将 Session ID 发送给服务器，服务器根据 Session ID 查找对应的会话状态。\n\nCookie 和 Session\n是两种不同的状态管理机制，它们在存储位置、安全性、容量限制、生命周期、存储内容和传输方式等方面存在一些区别，开发人员需要根据具体的需求和场景选择合适的机制来管理状态信息。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593537083117940736?sourceSSR=users",
        "title": "中电子公司 Java实习 面经",
        "content": "## 1.我的后端提交代码跨域2.0->3.0主要是优化了什么\n\n## 2.MYSQL的底层结构\n\nB+树\n\n## 3.B+树是怎么保证排序的\n\n主键是有序的\n\n## 4.微服务架构有了解吗\n\n聊了最近写的项目里的dubbo ,RPC\n\n## 5.轻量级，重量级锁的概念，以及他们怎么变化的\n\n## 6.jdk21新特新有了解吗\n\n## 7.Redisson有什么优势\n\n这里我没有把自己了解到的全部说出来，不太好\n\n## 8.缓存雪崩的概念，以及解决方法\n\n答了设置失效时间分散\n\n追问失效时间怎么设置分散\n\n## 9.有了解到一些代码规范吗\n\n## 10.问到了六级，刚好昨天查了过了哈哈哈\n\n## 11.git是二月份才更新的，是不是才做完项目\n\n## 12.问了一道算法题\n\n力扣上接水最大值\n\n答的暴力的解法，当时没想到双指针\n\n## 13.怎么理解贪心的算法\n\n## 14.前端界面加快百分之五十的速度不太可能\n\n我在简历上写我用了缓存等方法，让页面加载快了百分之50，然后提到了我一开始要加载十几秒。面试官说我加载十几秒应该我别的地方有问题，可能不只是缓存的原因。\n\n## 15.Linux查询当前所在目录的语句，创建文件夹的语句，jmap\n\n## 16.负载均衡的算法怎么实现的\n\n反问：\n\n问了他们公司是干什么的\n\n问了面试官觉得宽度和深度哪个重要。面试官说都挺重要的，但是一开始会问深度（我也感觉到了，答缓存雪崩的时候，面试官会追问怎么实现过期时间分散\n），如果不行，就会尝试问广度。（很明显我现在两者都不行）\n\n总结：面试官很和善，也一直在问一些基础，而且结合我的git代码以及简历发问的。问的很详细，引发了我很多思考。面试官说我的简历其实项目很一般，主要是看到我有竞赛经历，然后面试官也着重问了我一些算法实现，（但是很多我都不了解，对不起）后面就赶紧补基础，同时多思考，多想想怎么实现，不要局限于背过。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593523297271238656?sourceSSR=users",
        "title": "最大子数组和",
        "content": "> Problem:\n> [***********](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fmaximum-\n> subarray%2Fdescription%2F)\n\n# 今日头条Android开发一面算法题\n\n时间复杂度:O(n)\n\n    \n    \n    class Solution {\n        public int maxSubArray(int[] nums) {\n            //总结：这里使用到了动态规划算法的思想：先求解重叠子问题的解并存储，以便下一个子问题求解之时直接查表\n            \n            //res为最大子数组之和\n            int res=nums[0];\n            //存储每一阶段求得的res\n            ArrayList<Integer> list=new ArrayList<>();\n            for(int i=1;i<nums.length;i++){\n                //在进行下一步操作的时候，要先保存当前的res\n                list.add(res);\n                //如果前面的连续子数组之和加当前索引下数字的和小于当前索引下数字，\n                //这表示前面连续的子数组和为负数那么就没有留下的必要了，直接从当前数字开始取新的子数组\n                if((res+nums[i])<nums[i]){\n                    res=nums[i];             \n                }else{\n                    //反之，将当前索引下数字加入到该子数组中\n                    System.out.println(res);\n                    res=nums[i]+res;\n                }\n            }\n            //存入最后一次的res\n            list.add(res);\n            //最后返回的是list里面res快照的最大值\n                res=Collections.max(list);\n                return res;\n        }\n    }\n    \n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593505630011273216?sourceSSR=users",
        "title": "分割数组的最大差值 - 华为OD统一考试",
        "content": "> OD统一考试\n>\n> 分值： 100分\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n给定一个由若干整数组成的数组nums\n，可以在数组内的任意位置进行分割，将该数组分割成两个非空子数组(即左数组和右数组)，分别对子数组求和得到两个值.计算这两个值的差值，请输出所有分割方案中，差值最大的值。\n\n## 输入描述\n\n第一行输入数组Q中元素个数n，1< n < 100000\n\n第二行输入数字序列，以空格进行分隔，数字取值为4字节整数\n\n## 输出描述\n\n输出差值的最大取值\n\n## 示例1\n\n    \n    \n    输入：\n    6\n    1 -2 3 4 -9 7\n    \n    输出：\n    10\n    \n\n## 题解\n\n> 简单**模拟题** ，需要小心的是数据范围。\n\n### Java\n\n    \n    \n    import java.util.Scanner;\n    /**\n     * @author code5bug\n     */\n    public class Main {\n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n    \n            int n = scanner.nextInt();\n            int[] nums = new int[n];\n            long sum = 0;\n    \n            for (int i = 0; i < n; i++) {\n                int num = scanner.nextInt();\n                sum += num;\n                nums[i] = num;\n            }\n    \n            long maxAbs = 0, leftSum = 0;\n            for (int i = 0; i < n - 1; i++) {\n                leftSum += nums[i];\n    \n       \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593481186010238976?sourceSSR=users",
        "title": "Java软件开发笔试题1",
        "content": "[下一篇](https://www.nowcoder.com/discuss/594180567697014784 )\n\n\"abcde\" 执行 substring(3,4) 返回什么\n\n\"d\"\n\nQ 抽象类可以实现接口吗\n\n可以\n\n    \n    \n    interface MyInterface {  \n        void interfaceMethod();  \n    }  \n      \n    abstract class MyAbstractClass implements MyInterface {  \n        // 实现接口中的方法  \n        @Override  \n        public void interfaceMethod() {  \n            System.out.println(\"Interface method implemented in abstract class\");  \n        }  \n      \n        // 抽象方法  \n        public abstract void abstractMethod();  \n    }  \n      \n    class MyClass extends MyAbstractClass {  \n        // 实现抽象方法  \n        @Override  \n        public void abstractMethod() {  \n            System.out.println(\"Abstract method implemented in MyClass\");  \n        }  \n      \n        public static void main(String[] args) {  \n            MyClass myObject = new MyClass();  \n            myObject.interfaceMethod();  // 调用接口方法  \n            myObject.abstractMethod();  // 调用抽象方法  \n        }  \n    }\n    \n\n哪种类型的文件可以在java虚拟机运行\n\n.class\n\ndefault String s 合法吗\n\n在Java中，\"default\"是一个关键字，不能用作变量名或标识符。因此，\"default String s\"不是合法的语法。\n\n被default修饰的方法有什么特点\n\n1.可以在接口中提供默认实现。这意味着实现该接口的类可以选择性地覆盖该方法，而不是强制实现所有方法。\n\n2.接口中的默认方法可以在不破坏现有实现的情况下添加新方法。\n\n3.默认方法是公共的，因此它们可以被接口之外的类调用。\n\n4.默认方法可以调用接口中的其他默认方法，甚至可以调用抽象方法（在Java 9之前是不允许的）。\n\nstatic int i 默认初始化为多少\n\n0\n\n将java打包成Test.jar的命令是哪个\n\njar cf Test.jar [要打包的文件或目录]\n\n介绍下位移以及符号\n\n算术位移：对于有符号整数，算术位移在右移时，在左侧用原来的符号位填充。在左移时，右侧用零填充。\n\n逻辑位移（无符号位移）：逻辑位移无论是左移还是右移，都在移动的过程中用零填充。\n\n在Java中，>> 是算术右移，>>> 是无符号右移\n\njava类中的方法可以定义在类体外吗\n\nJava类中的方法不能定义在类体外部。所有方法必须在类体内部定义。\n\njava实现接口的类可以是抽象类吗\n\n可以。抽象类是一种不能被实例化的类，它可以包含抽象方法以及非抽象方法。当一个抽象类实现一个接口时，它可以选择性地提供接口中定义的方法的实现，也可以将这些方法声明为抽象方法而留给它的子类来实现。\n\nservlet的生命周期中，int()方法只能被调用一次吗\n\n在Servlet的生命周期中，init()\n方法只会被容器调用一次。当Servlet第一次被请求时，容器会调用init()方法来进行初始化操作。在这个方法中，可以进行一些初始化工作，例如读取配置文件、创建资源等。\n\n一旦init()方法被调用，Servlet实例就会被创建并初始化，随后会一直保持在内存中，处理来自客户端的请求，直到容器关闭或卸载该Servlet为止。在Servlet的生命周期中，即使有多个客户端请求，init()方法也只会被调用一次。\n\n需要注意的是，如果在init()方法中抛出异常，则Servlet的实例将被销毁，并且容器不会再次尝试调用init()方法。\n\nceil() floor() round() 方法返回的都是double类型的数吗\n\n是的。分别返回大于或等于参数的最小double值、小于或等于参数的最大double值、最接近参数的 long 型整数值\n\nfinal finally finalize有什么区别\n\n`final`用于声明不可变属性、不可重写的方法和不可继承的类；`finally`用于确保某些代码块无论是否发生异常都会被执行；而`finalize`则提供了一种对象在被垃圾收集前的清理机制，但通常不建议使用。\n\n下列说法正确的有：\n\nA.Java类可以同时用abstract和final声明\n\nB.HashMap中，使用get(key)==null可以判断该HashMap是否包含这个key\n\nC.volatile关键字不保证对变量操作的原子性\n\nD.StringBuilder是线程不安全的\n\n正确选项：\n\nB. HashMap中，使用 get(key) == null 可以判断该 HashMap 是否包含这个 key。这是因为 HashMap 的 get\n方法会返回键对应的值，如果键不存在，则返回 null。\n\nC. volatile 关键字不保证对变量操作的原子性。volatile\n关键字只能确保线程之间对变量的可见性，但不能保证复合操作的原子性，例如递增或递减操作。\n\n错误选项：\n\nA.abstract 关键字用于声明抽象类或抽象方法，它表示类或方法是不完整的，需要子类来实现。而 final\n关键字用于表示类、方法或变量是最终的，不能被继承、重写或修改。由于抽象类和最终类之间存在矛盾，Java 不允许同时使用 abstract 和 final\n修饰同一个类。\n\nD.StringBuilder 是 Java\n中的一个用于处理字符串的可变对象，它的操作都是非线程安全的。为了在多线程环境下安全地使用可变的字符串操作，可以使用其线程安全的替代类\nStringBuffer，或者在必要时进行适当的同步PV操作。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593478972436918272?sourceSSR=users",
        "title": "字节跳动（今日头条Android开发）二面",
        "content": "时间：2024.2.26\n\n时长：1个小时\n\n1、自我介绍\n\n2、对客户端开发有什么想法\n\n3、对项目中的session永不过期功能如何实现的，现在设计的话会怎么设计\n\n4、什么样的情况下需要建立索引，索引有没有什么不适用的情况\n\n5、索引内部是怎么实现的\n\n6、B+数相对B树的三大优点是什么\n\n7、前后台为什么要使用MVC的架构，有什么好处\n\n8、外卖库存只有5个了，什么时候让库存减1比较合适\n\n9、https怎么建立安全连接的\n\n10、https的抓包工具怎么设计\n\n12、代码运行的时候cpu是如何读取内存中的数据的\n\n13、用基本的数据结构去设计LRU，你会怎么设计\n\n14、手撕算法：给定一个三角形的数组，数组长度为n,返回从上至下,相加和最小的值。路径说明:每一次可以运动到临近的行和列\n\n二面总结：一二面难度层次递进是相当明显了，二面几乎没答上几题，计算机网络和操作系统真的是我的硬伤啊，一问一个不吱声！另外一二面面试官都是女生，还是挺特别的，之前遇到的面试官几乎都是男生，距离二面已经过去好几天了应该是寄了，不过没关系有机会参加二面我已经非常满足了。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593467348468715520?sourceSSR=users",
        "title": "腾讯IEG 天美 后台开发面经",
        "content": "#\n\n  * 实习经历介绍\n  * 实习负责的项目架构介绍，各层存储\n  * 项目QPS能抗住多少，如何进行压测\n  * 分布式锁怎么做的\n  * 如何保证接口幂等性\n  * 如何保证领券不超发\n  * 如何排查内存泄漏问题，pprof如何使用\n  * 设计模式使用场景，解决什么问题\n  * 排查gc问题思路\n  * 一个服务器，cpu利用率很低，但是执行的某个简单计算逻辑经常超时，如何排查（没有任何调用链路）\n  * Clickhouse 如何解决高qps下查询性能差的问题\n  * golang内存逃逸概念，如何解决\n  * GMP模型概念，作用\n  * Golang map如何解决并发安全问题\n  * Golang 如何设计无锁map\n  * Golang interface底层如何实现\n  * Golang channel底层实现\n  * Golang channel关闭了，读写这个channel会发生什么\n  * Golang select使用场景\n\n很久以前暑期实习面的 J1工作室\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593442378820653056?sourceSSR=users",
        "title": "高顿教育 测开面经",
        "content": "自我介绍\n\n对测试的了解？\n\n有没有进行过测试？\n\n算法 只需要讲思路 151. 反转字符串中的单词\n\n如何设计测试 反转字符串中单词？\n\n如何对上述api进行性能测试？如何进行安全测试？\n\n垂直鉴权是什么，和你说的token鉴权有什么区别？\n\n你的项目是自己设计的吗，还是借鉴了别人的？\n\n你的职业规划是什么？\n\n近期的压力有什么，是如何调节的？学业压力有什么，如何调节？\n\n能否接受加班？\n\nhr面\n\n大部分是聊天\n\n自我介绍\n\n本科期间最有成就的一次比赛经历\n\n是如何学习新技术的\n\n反问：\n\n公司的主要业务\n\n公司的日常工作时间分布\n\n公司的开发技术栈\n\n第一场面试，面hr的时候自然了很多，技术面的时候很紧张，继续加油\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593439685566828544?sourceSSR=users",
        "title": "招银网络科技java面经内推",
        "content": "分享一下之前招银一面的一些流程和问题\n\n笔试通过后一面二面的一些问题\n\n  \n\n先自我介绍\n\n  \n\n一面一般比较看基础\n\n  1. Start  run  区别\n  2. Hashtable\n  3. Hashset\n  4. 布控过滤器 \n  5. Redis 持久化 key失效策略 为什么快 \n\n二面一般设计到项目：\n\n  1. 秒杀项目设计\n  2. 项目内容设计技术 \n\n3.多线程sys lock\n\n  \n\n后面顺利的话静待HR面吧\n\n  \n\n下面是个内推码\n\n  \n\n  \n\n  \n\n![BCV1fE1aeEQFITsTZI7Wfdg7IKBesSGI.jpg](https://uploadfiles.nowcoder.com/images/20240302/458050676_1709358962269/6744D7583BA95498973CA89C7A808E6F)  \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593466235547893760?sourceSSR=users",
        "title": "字节抖音直播 后端开发 秋招面经",
        "content": "# 一面\n\n  * Flink批流一体相关\n  * 数据增全量同步链路\n  * 商品库存储设计讨论\n  * 为什么只用MySQL数据库 （跨库事务、一致性、元数据能力）\n  * RPC接口性能优化相关\n  * 营销中台能力 如何应对高QPS场景\n  * QPS提高到100w 除了加机器 还能怎么做 \n  * 知道的所有HTTP状态码 499状态码是啥\n  * HTTPS怎么做的 CA认证流程\n  * 读写已关闭的channel会发生什么\n  * make和new的区别\n  * 算法：重排链表\n\n# 二面\n\n  * 高流量场景下 营销链路如何优化\n  * 应对双十一大促 全链路应该做哪些准备和优化\n  * 如何预估流量和QPS\n  * 全链路压测怎么实现\n  * 如果业务不成熟 无法传递全链路压测标怎么做\n  * 只有测试用户，怎么做全链路压测，且保证流量隔离\n  * Java内存管理机制\n  * Java双亲委派机制\n  * Redis跳表实现 默认多少层 添加的具体流程 元素在第k层怎么操作\n  * 红黑树原理\n  * MySQL索引结构 B+树 每层有多少个节点\n  * MySQL为什么不用跳表来做索引\n  * 算法：二叉树的最近公共祖先\n\n后续：问题都回答出来了 看起来没hc了给我挂了[尴尬]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593437450945511424?sourceSSR=users",
        "title": "最大花费金额 - 华为OD统一考试",
        "content": "> OD统一考试\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n双十一众多商品进行打折销售，小明想购买自己心仪的一些物品，但由于受购买资金限制，所以他决定从众多心仪商品中**购买三件** ，而且**想尽可能的花完资金**\n现在请你设计一个程序帮助小明计算尽可能花费的最大资金数额。\n\n## 输入描述\n\n第一行为一维整型数组M，数组长度Q小于100，数组元素记录单个商品的价格,单个商品价格小于1000。\n\n第二行为购买资金的额度R，R小于100000。\n\n## 输出描述\n\n输出为满足上述条件的最大花费额度\n\n如果不存在满足上述条件的商品，请返回-1。\n\n## 示例1\n\n    \n    \n    输入：\n    23,26,36,27\n    78\n    \n    输出：\n    76\n    \n    说明：\n    金额23、26和27相加得到76，而且最接近且小于输入金额78。\n    \n\n## 示例2\n\n    \n    \n    输入：\n    10,2,3,4,5,6,7,30\n    20\n    \n    输出：\n    20\n    \n\n## 题解\n\n> **解题思路：**\n>\n> 该问题可以通过排序数组，然后使用**双指针** 和**二分**\n> 查找的方法来求解。首先，对商品价格进行排序。然后，使用两个循环遍历可能的商品组合（三个商品），并使用二分查找找到第三个商品，使得总花费最接近但不超过购买资金限制。\n>\n> **时间复杂度：** 两个循环的嵌套加二分总体时间复杂度为 O(n^2 log n)。\n\n### Java\n\n    \n    \n    import java.util.Arrays;\n    import java.util.Scanner;\n    /**\n     * @author code5bug\n     */\n    public class Main {\n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n    \n            // 读取输入数组\n            String[] pricesString = scanner.nextLine().split(\",\");\n            int[] prices = Arrays.stream(pricesString).mapToInt(Integer::parseInt).toArray();\n    \n            // 读取输入的 R\n            int R = Integer.parseInt(scanner.nextLine());\n    \n            // 排序数组\n            Arrays.sort(prices);\n    \n            int n = prices.length, maxCost = -1;\n            // 遍历组合\n            for (int i = 0; i < n - 2; i++) {\n                for (int j = i + 1; j < n - 1; j++) {\n                    int cost = prices[i] + prices[j];\n                    if (cost + prices[j + 1] > R) {\n                        break;\n                    }\n    \n                    // 二分查找\n                    int left = j + 1, right = n;\n                    while (left + 1 < right) {\n                        int mid = (right + left) / 2;\n                        if (co\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593429222161395712?sourceSSR=users",
        "title": "嵌入式面经111题答案汇总(含技术答疑)_嵌入式项目源码分享",
        "content": "> 111道嵌入式面试题答案汇总专栏链接（承诺免费技术答疑） -->\n> [《嵌入式/C++面试题解析大全》](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.nowcoder.net%2Fzhuanlan%2F3m2ONj)\n\n# 1、简介\n\n本人是2020年毕业于广东工业大学研究生：许乔丹，有国内大厂CVTE和世界500强企业工作经验，整理**超全面111道嵌入式面试题目答案解析（承诺提供专栏内容免费技术答疑）**\n，本专栏内容主要有：\n\n  * 面试过程口头提问的问题答案汇总，承诺提供免费技术答疑，以及其他的交流，如要怎么入门c++，简历如何写，算法题如何刷等等，**实现校招全陪伴** ！！\n\n# 2、项目经验\n\n如果你找的是单片机，那就只要单片机的项目，如果你是嵌入式linux，你可以最多写一个单片机项目，其他都要写嵌入式linux的项目。\n\n如果你找嵌入式linux应用开发工作，也可以写linux驱动项目，但必须有一个应用层的项目。\n\n如果你找嵌入式linux驱动开发项目，最好也要有一个应用层项目，突出你对多进程多线程那些知识点有所了解。\n\n项目数量2-4个，此时就需要靠过往的经验积累了，如果确实没有项目，可以向身边做嵌入式的同学请教一下，快速掌握，同时也分享几个项目供参考：\n\n### 2.1 基于人脸属性识别的嵌入式电影推荐系统（嵌入式人工智能项目、可提供源码）\n\n1）情况：为解决“信息过载”问题，提出基于人脸属性识别的广告推荐系统。\n\n2）目标：独立负责，摄像头捕捉人脸并预测年龄、性别，显示屏可输入用户职业，系统根据此三大信息推荐8部电影并在显示屏显示。\n\n3）行动：搭建RK3399开发板开发环境，通过OpenCV获取摄像头图像，Dlib检测人脸，采用WRN神经网络预测年龄、性别，结合基于用户的协同过滤以及决策树模型进行电影推荐。使用PyQt5设计人机交互界面实现职业获取和电影信息显示。\n\n4）成果：在RK3399开发板可实时获取被推荐人年龄、性别、职业，据此推荐8部电影并将其电影名字和海报图显示在屏幕上。\n\n![alt](https://uploadfiles.nowcoder.com/images/20230830/545613072_1693410727968/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n### 2.2 基于Linux6818开发板的视频播放器（最好的入门项目，可提供源码）\n\n本项目基于嵌入式linux6818开发板，制作一个音视频播放器。开发板移植安装好mplayer，我提前下载了5个mv，使用mplayer命令分别在5个视频里截取某一秒的画面，共得到5张图片，也就是所谓的视频缩略图，将5个缩略图显示在显示屏的右边，当作是播放列表，支持上下滑动浏览播放列表，点击其中某个图片，即可播放对应视频，并实现播放器常见的开始、停止、上下首、音量调节、进度调节、全屏、静音等功能。使用到多进程技术：有名管道、消息队列、信号量；使用到多线程技术：互斥锁、条件变量。\n\n![alt](https://uploadfiles.nowcoder.com/images/20230830/545613072_1693410608066/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n### 2.3 基于Linux6818开发板的智能车库项目（进阶项目，可提供源码）\n\n没错，也是粤嵌6818开发板，搭配触摸屏、USB摄像头、音响，模拟实现真实场景中的智能车库常见功能:\n\n  * 实时视频监控\n  * 自动识别车牌\n  * 自动语音播报\n  * 停车计费\n\n需要使用到V4L2子系统，FrameBuffer子系统、OpenCV、多进程多线程编程、ALSA子系统、智能语音引擎、网络编程、数据库编程等。\n\n![alt](https://uploadfiles.nowcoder.com/images/20230831/545613072_1693411280940/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n# 3、嵌入式111道高频面试题\n\n> **八股文不在于量多，熟悉以下111道题就够啦** 。\n\n整理**超全面111道嵌入式面试题目答案解析（承诺提供专栏内容免费技术答疑）** ，本专栏内容主要有：\n\n  * 面试过程口头提问的问题答案汇总，承诺提供免费技术答疑，以及其他的交流，如要怎么入门c++，简历如何写，算法题如何刷等等，实现校招全陪伴！\n\n## 第一章 进程线程\n\n### 1.1 进程线程的基本概念\n\n  * 1.1.1 什么是进程，线程，彼此有什么区别⭐⭐⭐⭐⭐\n  * 1.1.2多进程、多线程的优缺点⭐⭐⭐⭐\n  * 1.1.3什么时候用进程，什么时候用线程⭐⭐⭐\n  * 1.1.4多进程、多线程同步（通讯）的方法⭐⭐⭐⭐⭐\n  * 1.1.5进程的空间模型⭐⭐⭐⭐\n  * 1.1.6进程线程的状态转换图 什么时候阻塞，什么时候就绪⭐⭐⭐\n  * 1.1.7父进程、子进程的关系以及区别⭐⭐⭐⭐\n  * 1.1.8什么是进程上下文、中断上下文⭐⭐\n  * 1.1.9一个进程可以创建多少线程，和什么有关⭐⭐\n\n### 1.2 并发，同步，异步，互斥，阻塞，非阻塞的理解\n\n  * 1.2.1什么是线程同步和互斥⭐⭐⭐⭐⭐\n  * 1.2.2线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？⭐⭐⭐⭐\n  * 1.2.3并发，同步，异步，互斥，阻塞，非阻塞的理解⭐⭐⭐⭐⭐\n\n### 1.3 孤儿进程、僵尸进程、守护进程的概念\n\n  * 1.3.1基本概念⭐⭐⭐⭐⭐\n  * 1.3.2如何创建守护进程：⭐⭐\n  * 1.3.3正确处理僵尸进程的方法⭐⭐⭐⭐\n\n## 第二章 C/C++高频面试题\n\n### 2.1 c和c++区别、概念相关面试题\n\n  * 2.1.1 new和malloc的区别⭐⭐⭐⭐⭐\n  * 2.1.2 malloc的底层实现⭐⭐⭐⭐\n  * 2.1.3在1G内存的计算机中能否malloc(1.2G)？为什么？⭐⭐\n  * 2.1.4指针与引用的相同和区别；如何相互转换？⭐⭐⭐⭐⭐\n  * 2.1.5 C语言检索内存情况 内存分配的方式⭐⭐⭐\n  * 2.1.6 extern”C” 的作用⭐⭐⭐\n  * 2.1.7头文件声明时加extern定义时不要加 因为extern可以多次声明，但只有一个定义⭐⭐⭐⭐\n  * 2.1.8函数参数压栈顺序，即关于__stdcall和__cdecl调用方式的理解⭐⭐⭐\n  * 2.1.9重写memcpy()函数需要注意哪些问题⭐⭐\n  * 2.1.10数组到底存放在哪里⭐⭐⭐\n  * 2.1.11 struct和class的区别 ⭐⭐⭐⭐⭐\n  * 2.1.12 char和int之间的转换；⭐⭐⭐\n  * 2.1.13 static的用法（定义和用途）⭐⭐⭐⭐⭐\n  * 2.1.14 static的用法（定义和用途）⭐⭐⭐⭐⭐\n  * 2.1.15const常量和#define的区别（编译阶段、安全性、内存占用等） ⭐⭐⭐⭐\n  * 2.1.16 volatile作用和用法 ⭐⭐⭐⭐⭐\n  * 2.1.17有常量指针 指针常量 常量引用 没有 引用常量⭐⭐⭐\n  * 2.1.18没有指向引用的指针，因为引用是没有地址的，但是有指针的引用⭐⭐⭐\n  * 2.1.19c/c++中变量的作用域⭐⭐⭐⭐⭐\n  * 2.1.20 c++中类型转换机制？各适用什么环境？dynamic_cast转换失败时，会出现什么情况？⭐⭐⭐\n\n### 2.2 继承、多态相关面试题 ⭐⭐⭐⭐⭐\n\n  * 2.2.1继承和虚继承 ⭐⭐⭐⭐⭐\n  * 2.2.2多态的类，内存布局是怎么样的 ⭐⭐⭐⭐⭐\n  * 2.2.3被隐藏的基类函数如何调用或者子类调用父类的同名函数和父类成员变量 ⭐⭐⭐⭐⭐\n  * 2.2.4多态实现的三个条件、实现的原理 ⭐⭐⭐⭐⭐\n  * 2.2.5对拷贝构造函数 深浅拷贝 的理解 拷贝构造函数作用及用途？什么时候需要自定义拷贝构造函数？⭐⭐⭐\n  * 2.2.6析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？⭐⭐⭐\n  * 2.2.7什么情况下会调用拷贝构造函数（三种情况）⭐⭐⭐\n  * 2.2.8析构函数一般写成虚函数的原因⭐⭐⭐⭐⭐\n  * 2.2.9构造函数为什么一般不定义为虚函数⭐⭐⭐⭐⭐\n  * 2.2.10什么是纯虚函数⭐⭐⭐⭐⭐\n  * 2.2.11静态绑定和动态绑定的介绍⭐⭐⭐⭐\n  * 2.2.12 C++所有的构造函数 ⭐⭐⭐\n  * 2.2.13重写、重载、覆盖的区别⭐⭐⭐⭐⭐\n  * 2.2.14成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？⭐⭐⭐⭐\n  * 2.2.15如何避免编译器进行的隐式类型转换；（explicit）⭐⭐⭐⭐\n\n## 第三章 网络编程\n\n### 3.1 TCP UDP\n\n  * 3.1.1 TCP、UDP的区别 ⭐⭐⭐⭐⭐\n  * 3.1.2 TCP、UDP的优缺点⭐⭐⭐\n  * 3.1.3 TCP UDP适用场景⭐⭐⭐\n  * 3.1.4 TCP为什么是可靠连接⭐⭐⭐⭐\n  * 3.1.5典型网络模型，简单说说有哪些；⭐⭐⭐\n  * 3.1.6 Http1.1和Http1.0的区别⭐⭐⭐\n  * 3.1.7 URI（统一资源标识符）和URL（统一资源定位符）之间的区别⭐⭐\n\n### 3.2 三次握手、四次挥手\n\n  * 3.2.1什么是三次握手⭐⭐⭐⭐⭐\n  * 3.2.2为什么三次握手中客户端还要发送一次确认呢？可以二次握手吗？⭐⭐⭐⭐\n  * 3.2.3为什么服务端易受到SYN攻击？⭐⭐⭐⭐\n  * 3.2.4什么是四次挥手⭐⭐⭐⭐⭐\n  * 3.2.5为什么客户端最后还要等待2MSL？⭐⭐⭐⭐\n  * 3.2.6为什么建立连接是三次握手，关闭连接确是四次挥手呢？⭐⭐⭐⭐\n\n## 第四章 常见算法\n\n### 4.1 排序算法\n\n  * 4.1.1各种排序算法的时间空间复杂度、稳定性⭐⭐⭐⭐⭐\n  * 4.1.2各种排序算法什么时候有最好情况、最坏情况（尤其是快排） ⭐⭐⭐⭐\n  * 4.1.3冒泡排序⭐⭐⭐⭐\n  * 4.1.4选择排序⭐⭐⭐⭐\n  * 4.1.5插入排序⭐⭐⭐⭐\n  * 4.1.6希尔排序⭐⭐⭐⭐\n  * 4.1.7归并排序⭐⭐⭐⭐\n  * 4.1.8快速排序⭐⭐⭐⭐⭐\n  * 4.1.9快排的partition函数与归并的Merge函数⭐⭐⭐\n\n### 4.2 STL库相关\n\n  * 4.2.1 vector list异同⭐⭐⭐⭐⭐\n  * 4.2.2 vector内存是怎么增长的vector的底层实现⭐⭐⭐⭐\n  * 4.2.3 vector和deque的比较⭐⭐⭐⭐\n  * 4.2.4为什么stl里面有sort函数list里面还要再定义一个sort⭐⭐⭐\n  * 4.2.5 STL底层数据结构实现⭐⭐⭐⭐\n  * 4.2.6利用迭代器删除元素会发生什么？⭐⭐⭐⭐\n  * 4.2.7 map是如何实现的，查找效率是多少⭐⭐⭐⭐⭐\n  * 4.2.8几种模板插入的时间复杂度 ⭐⭐⭐⭐⭐\n\n## 第五章 Linux操作系统常见面试题\n\n### 5.1 Linux内核相关\n\n  * 5.1.1 Linux内核的组成⭐⭐\n  * 5.1.2用户空间与内核通信方式有哪些？⭐⭐⭐⭐⭐\n  * 5.1.3系统调用read()/write()，内核具体做了哪些事情⭐⭐\n  * 5.1.4系统调用的作用⭐⭐⭐⭐⭐\n  * 5.1.5内核态，用户态的区别⭐⭐⭐⭐⭐\n  * 5.1.6 bootloader内核 根文件的关系⭐⭐⭐⭐\n  * 5.1.7 Bootloader多数有两个阶段的启动过程：⭐⭐⭐\n  * 5.1.8 linux的内核是由bootloader装载到内存中的？⭐⭐⭐\n  * 5.1.9为什么需要BootLoader⭐⭐⭐⭐\n  * 5.1.10 Linux内核同步方式总结⭐⭐⭐⭐\n  * 5.1.11为什么自旋锁不能睡眠 而在拥有信号量时就可以？⭐⭐⭐⭐\n  * 5.1.12 linux下检查内存状态的命令⭐⭐⭐\n\n### 5.2 其他操作系统常见面试题\n\n  * 5.2.1大小端的区别以及各自的优点，哪种时候用⭐⭐⭐⭐⭐\n  * 5.2.2 一个程序从开始运行到结束的完整过程（四个过程）⭐⭐⭐⭐⭐\n  * 5.2.3什么是堆，栈，内存泄漏和内存溢出？⭐⭐⭐⭐\n  * 5.2.4堆和栈的区别⭐⭐⭐⭐⭐\n  * 5.2.5死锁的原因、条件 创建一个死锁，以及如何预防⭐⭐⭐⭐⭐\n  * 5.2.6硬链接与软链接的区别；⭐⭐⭐⭐⭐\n  * 5.2.7虚拟内存，虚拟地址与物理地址的转换⭐⭐⭐⭐\n  * 5.2.8计算机中，32bit与64bit有什么区别⭐⭐⭐\n  * 5.2.9中断和异常的区别⭐⭐⭐⭐⭐\n  * 5.2.10中断怎么发生，中断处理大概流程⭐⭐⭐⭐\n  * 5.2.11 Linux 操作系统挂起、休眠、关机相关命令⭐⭐\n  * 5.2.12数据库为什么要建立索引，以及索引的缺点⭐⭐\n\n## 第六章 单片机常见面试题\n\n  * 6.1 CPU 内存 虚拟内存 磁盘/硬盘 的关系⭐⭐⭐\n  * 6.2 CPU内部结构⭐⭐⭐⭐\n  * 6.3 ARM结构处理器简析 ⭐⭐\n  * 6.4波特率是什么，为什么双方波特率要相同，高低波特率有什么区别；⭐⭐⭐⭐\n  * 6.5arm和dsp有什么区别⭐⭐\n  * 6.6 ROM RAM的概念浅析⭐⭐⭐\n  * 6.7 IO口工作方式：上拉输入 下拉输入 推挽输出 开漏输出⭐⭐⭐⭐\n  * 6.8扇区 块 页 簇的概念⭐⭐⭐⭐\n  * 6.9简述处理器在读内存的过程中，CPU核、cache、MMU如何协同工作？画出CPU核、cache、MMU、内存之间的关系示意图加以说明⭐⭐\n  * 6.10请说明总线接口USRT、I2C、USB的异同点（串/并、速度、全/半双工、总线拓扑等）⭐⭐⭐⭐⭐\n  * 6.11什么是异步串口和同步串口⭐⭐⭐⭐⭐\n  * 6.12 I2C时序图⭐⭐⭐⭐⭐\n\n![alt](https://uploadfiles.nowcoder.com/images/20230206/545613072_1675674726255/0761E04C9A30D48C6C719FF49D3CC5ED)\n\n## 高级系列专栏：\n\n## 安卓（安卓系统开发也要掌握）\n\n  * 想通关安卓面试，请看：[《150道安卓高频面试题目录及答案链接》](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F396383934924292096)\n  * 想通关安卓系统面试，请看：[《140道安卓系统Framework面试题目录及答案链接》](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F456922214454091776)\n  * 想进阶安卓开发，请看：[《Android进阶知识体系解析_15大安卓进阶必备知识点》](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F462666906584043520)\n  * 想了解安卓APP完整开发流程，请看：[《安卓APP完整开发流程》](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.nowcoder.net%2Fzhuanlan%2FMQ2yE0)\n  * 想掌握安卓App性能优化，请看：[《安卓性能优化讲解和实战专栏》](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F483578208504250368)\n  * 想掌握Gradle语法，制作Gradle插件，请看：[《安卓Gradle语法解析和实践大全》](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F483578554362380288)\n\n## 嵌入式\n\n  * 想通关嵌入式面试，请看： [《111道嵌入式面试题目录及答案链接》](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F419423154676789248)\n  * 想多掌握几个嵌入式项目，请看：[《6个嵌入式项目交流分享（附源码）》](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F389554189238751232)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593394381629960192?sourceSSR=users",
        "title": "越疆 | 测开 | 一面 | 0228",
        "content": "> 攒人品\n\n## 越疆 测试开发 一面技术面+hr面 40min\n\n1\\. 介绍一下机械臂的项目\n\n2\\. 说说信号与槽 connect\n\n3\\. 一个信号可以有多个槽吗？一个槽可以对应多个信号吗？\n\n4\\. 说一说心跳检测机制是如何实现的？\n\n5\\. connect失败了怎么办 。。。没遇到过 -->应该说界面上会显示\n\n6\\. 介绍机械臂\n\n7\\. 如何确定测试需求？\n\n8\\. flask框架的特性？\n\n9\\. 为什么选择flask 不选其他的框架？\n\n10\\. 测试界面sdk？了解sdk吗。。不太了解\n\n11\\. 知道哪些Linux的命令？sudo和root。。。没听出来。。扣分了\n\n12\\. git提交本地仓库流程\n\n13\\. C++多态\n\n14\\. 指针和智能指针\n\n15\\. 内存泄漏的后果\n\n16\\. tcp是哪个层？上面是哪个层？IP是哪个层？ 传输层 应用层 网络层\n\n17\\. tcp和udp的区别？ 哪个更快？\n\n主管\n\n18\\. 为什么来深圳？\n\n19\\. 为什么参加春招，没有参加秋招吗？\n\n20\\. 学过哪些硬件课程？\n\n21\\. 平时是更认真还是更游刃有余？。。。理解错了，以为问我努不努力😓\n\n22\\. 职业规划和行业选择？\n\n23\\. 为什么选择这个岗位？\n\n24\\. 对我们公司的了解？\n\n25\\. 深圳工作节奏快，可以适应吗？\n\n反问\n\n26\\. 公司业务和岗位所需要的技能？\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593229929051885568?sourceSSR=users",
        "title": "字节跳动（今日头条Android开发）一面",
        "content": "**一面**\n\n时间：2024.2.2\n\n时长：1个小时\n\n1、自我介绍\n\n2、介绍一下自己比较了解的项目、问了一下项目的部分功能的实现过程\n\n3、网页输入url后，浏览器后面会发生什么\n\n4、网络协议了解哪些\n\n5、react和vue框架各自的核心优势是什么\n\n6、MVVM单词的每个字母代表什么含义\n\n7、介绍一下java面向对象三大特征，多态的举例\n\n8、继承和接口的区别，为什么有了继承还要创造接口\n\n9、final修饰的方法可以被重载吗\n\n10、项目里用到的封装、继承、多态举例\n\n11、Java写项目一般用到什么数据结构\n\n12、多线程如何保证线程是安全的\n\n13、死锁的场景\n\n14、类加载的步骤\n\n15、讲一下jvm内存结构\n\n16、手撕算法：最大子数组和:给你一个整数数组\nnums，请你找出一个具有最大和的连续子数组(子数组最少包含一个元素)，返回其最大和。子数组是数组中的一个连续部分。\n\n一面总结：都是Java基础都答上来了，本来以为今日头条面试会很难的面试前就没报什么希望告诉自己尽力就好，没想到挺简单的，算法也写出来了，两天后收到的二面时间约在了年后2.26。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593195258402390016?sourceSSR=users",
        "title": "不开心的小朋友 - 华为OD统一考试",
        "content": "> OD统一考试\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n游乐场里增加了一批摇摇车，非常受小朋友欢迎，但是每辆摇摇车同时只能有一个小朋友使用如果没有空余的摇摇车，需要排队等候，或者直接离开，最后没有玩上的小朋友会非常不开心。请根据今天小朋友的来去情况，统计不开心的小朋友数量。\n\n1、摇摇车数量为N，范围是: 1<=N<=10:\n\n2、每个小朋友都对应一个编码，编码是不重复的数字，今天小朋友的来去情况可以使用编码表示为: 1 1 2 3 2 3。\n(若小朋友离去之前有空闲的摇摇车则代表玩要后离开:不考虑小朋友多次玩的情况)。小朋友数量<=100\n\n3、题目保证所有输入数据无异常目范围满足上述说明\n\n## 输入描述\n\n第一行: 摇摇车数量\n\n第二行:小朋友来去情况\n\n## 输出描述\n\n返回不开心的小朋友数量\n\n## 示例1\n\n    \n    \n    输入:\n    1\n    1 2 1 2\n    \n    输出:\n    0\n    \n    说明:\n    第一行，1个摇摇车\n    第二行，1号来 2号来(排队) 1号走 2号走(1号走后摇摇车已有空闲，所以玩后离开)\n    \n\n## 示例2\n\n    \n    \n    输入:\n    1\n    1 2 2 3 1 3\n    \n    输出:\n    1\n    \n    说明:\n    第一行，1个摇摇车\n    第二行，1号来 2号来 (排队) 2号走 (1号还没走，所以2号没玩3号来，1号走，3号走(1走后摇摇车有空闲，所以玩后离开)。只有2没玩\n    \n\n## 题解\n\n> **模拟题**\n>\n> 这个问题可以用队列来模拟小朋友玩摇摇车的过程。使用一个集合 `playing` 来记录当前正在玩摇摇车的小朋友，一个集合 `unpappy`\n> 来记录因为没有玩到而不开心的小朋友，一个队列 `waiting_queue` 来记录排队的小朋友。\n>\n> 遍历输入的小朋友的来去情况，对每个小朋友进行如下操作：\n>\n>   1. 如果小朋友在 `playing` 中，代表小朋友玩了一次后离开，此时需要检查排队队列 `waiting_queue`\n> 是否有小朋友在排队，有的话让其中一个小朋友去玩，然后将其从排队队列中移除。\n>   2. 如果小朋友在 `waiting_set` 中，代表小朋友离开前排在摇摇车前排但是没有玩到，将其添加到 `unpappy` 中。\n>   3. 如果小朋友在 `playing` 和 `waiting_set`\n> 中都不存在，说明小朋友是第一次来摇摇车。如果当前摇摇车有空位，直接让小朋友玩，并将其添加到 `playing` 中；否则，将小朋友添加到排队队列\n> `waiting_queue` 和排队集合 `waiting_set` 中。\n>   4. 最后输出 `unpappy` 集合的大小，即不开心的小朋友数量。\n>\n\n>\n> 这个算法的时间复杂度是 O(N)，其中 N 为小朋友的数量。\n\n### Java\n\n    \n    \n    import java.util.*;\n    /**\n     * @author code5bug\n     */\n    public class Main {\n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            int N = scanner.nextInt();\n            Set<Integer> playing = new HashSet<>(), unpappy = new HashSet<>();\n            Set<Integer> waitingSet = new HashSet<>();\n            Deque<Integer> waitingQueue = new LinkedList<>();\n            while (scanner.hasNext()) {\n                int boy = scanner.nextInt();\n                if (playing.contains(boy)) {  // 玩后离开\n                    playing.remove(boy);\n                    while (!waitingQueue.isEmpty()) {  // 检测是否有在排队，有排队则可让一个小朋友去玩\n                        int nextBoy = waitingQueue.poll();\n                        if (waitingSet.contains(nextBoy)) {  // 小朋友任然在排队\n               \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593163206265155584?sourceSSR=users",
        "title": "网易后端日常实习(已OC)",
        "content": "===一面 2.22===  \n1\\. 实习拷打  \n2\\. 项目拷打  \n3\\. 八股狂轰(包含了多线程，jvm，mysql，redis，其中多线程拷打得非常狠，有点招架不住)  \n4\\.\n场景题：现在有一个线程池，里面的核心线程正在执行相关任务，阻塞队列里面还有一些任务等待执行，现在如果我的系统断电重启了，如何继续执行当前未完成的任务，并且之后也能执行原先阻塞队列中的待执行任务  \n5\\. sql 题(口述)：记不太清了，反正有好几个小问，主要就是考 group by，having，where，聚合函数的使用  \n6\\. 算法题(口述)：LRU  \n总体感受：强度挺大，感觉面试官很有水平，非常稳重，我描述完实习和项目的内容面试官基本就能说出我做的东西的主要流程[牛泪]，然后针对一些难点进行提问，真的感觉非常强[赞][赞]  \n  \n===二面 2.27===  \n感觉这个面试官水平更高，可以用高屋建瓴，纵横捭阖来形容[赞][赞][赞]  \n  \n1\\. 实习拷打  \n2\\.\n项目拷打(我感觉这个项目拷打和之前的面试都不一样，对于一些具体的技术细节问的比较少，都是问为什么要这样设计，然后对于当前设计提出一些场景，问现在这个系统如何应对，如何扩展，我答的时候都是先从数据库入手，讲一下为什么设计这种数据结构，然后后端如何如何做，面试官一个大体的意思就是所有的设计都应该是由具体业务驱动，一些数据结构最好是在运行时动态编排组合，而不是提前把数据结构定死，这样能够保证系统的高度灵活可扩展[牛泪][牛泪])  \n3\\. 一些八股(这里主要是 redis，主要拷打了 zset 底层的跳表[牛泪][牛泪]，有点招架不住)  \n4\\.\n最后问你如果拿到一个项目，或者一个框架源码，你会怎么阅读(扯了一堆，然后面试官也给了一些建议，比如一开始我们要对整个框架有一个总体的认识，所以这个时候只需要抓主干，一些细小的分支不用去深入研究，比如可以画出整体的流程图，调用顺序图等等;\n之后需要深入研究某个模块就需要去深入研究细节等等，受益匪浅[赞])  \n  \n===3.1===  \n早上问 hr 结果，问了一天都没回，估计凉了[牛泪][牛泪][牛泪]  \n  \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593204269935792128?sourceSSR=users",
        "title": "掌上先机（慧策）一面",
        "content": "不能摆了要用心开始备战春招了，要在牛客里每天记录我的战况！\n\n今天是北京掌上先机一面\n\n时间：2024.3.1\n\n时长：1小时\n\n1、问过往哪些经历比较能证明自己的实力\n\n2、java到字节码文件到类的这个过程中经历了什么（我理解应该是问的类加载机制）\n\n3、jvm虚拟机的分区和功能\n\n4、怎么识别一个对象是否被回收\n\n5、强引用和弱引用的理解\n\n6、﻿threadlocal的理解、使用场景\n\n7、Linkedlist和ArraysList插入角度看各自的优劣势，插入量大的时候ArraysList的劣势是什么\n\n8、hashmap数据迁移怎么能提高效率\n\n9、加锁的维度怎么取舍\n\n10、锁加在方法上和加在代码块上有什么区别吗\n\n11、可见性问题如何解决，volatile如何保证即时可见性的、指令重排的机制\n\n12、可重入锁的目的：解决在递归调用或嵌套代码中的锁定问题\n\n13、spring的代理机制用过哪些，jdk代理的局限性，代理类的创建过程\n\n14、查询按学号作为索引正序排第100万条的数据，什么设计效率比较高\n\n15、索引为什么能那么快的定位到该行数据\n\n16、开a，b两个事务，a事务对一行数据进行了更改并提交，b事务没有提交此时读到的数据是新值还是旧值\n\n17、a事务更新了一行数据未提交，b事务可以对该行数据进行修改吗，为什么\n\n18、手撕算法：二叉树任意两节点之间最大边长和\n\n19、二叉树的算法题不是很理解，面试官又给我换了一题：返回两有序数组合并后的中位数\n\n20、职业规划\n\n虽然算法没写出来但是面试官说我前面答的挺好的，不知道是不是在给我安慰[疑惑]但是还是期待有后续[打call]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593138225028354048?sourceSSR=users",
        "title": "知乎测开面经",
        "content": "  1. 自我介绍\n  2. 项目相关（项目流程、怎么保证项目质量、项目的质量现况等 盘了15分钟\n  3. 服务端和客户端测试的区别\n  4. 用例设计：微信语音识别功能\n  5. 算法题：合并两个有序数组\n  6. 反问:\n  7. 部门业务内容\n  8. 测试工作使用到哪些工具\n  9. 遇到线上问题怎么进行定位和责任划分 （这里被反反问了 那你觉得定位线上问题呢[牛泪][牛泪]，并给出来场景：IOS环境下，APP的某个版本之后所有的ios机型都出现了这个问题\n\n全程40分钟左右，有些问题没想起来，用例设计和最后的问题排查回答不太好，估计是凉了[笑cry]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593155744384454656?sourceSSR=users",
        "title": "快手垂直业务中心后端日常实习(已Offer)",
        "content": "===一面 2.27===\n\n1\\. 实习拷打\n\n2\\. 项目拷打\n\n3\\. 八股狂轰[牛泪]\n\n算法：合并区间\n\n===二面 2.29===\n\n1\\. 实习拷打\n\n2\\. 项目拷打\n\n3\\. 系统设计：\n\n在线考试系统，面试官口述需求场景，让我说一下作为一个后端开发人员如何承接这个需求，并且给出详细的技术方案。(和上学期上的一门课的课程作业类似，终于感觉学校的课还是有点用的😅，当然这个系统比较传统，所以说了很多😂，如果说设计一个分布式系统鼠鼠就投降了😖)\n\n===3.1 hr面===\n\n1\\. 讲一下上一份实习主要干了什么事，业务场景是什么(感觉像是技术面😢)\n\n2\\. 什么时候到岗\n\n3\\. 能实习多长时间\n\n4\\. 个人信息相关问题\n\n===3.4===\n\n许愿今天发 Offer\n\n[来个offer][来个offer][来个offer][来个offer][顺利实习][顺利实习][顺利实习][顺利实习]\n\n已发Offer!\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593137045019594752?sourceSSR=users",
        "title": "航天宏图一面 3.1  已oc",
        "content": "27min\n\n1.自我介绍，介绍项目\n\n2.垂直居中布局\n\n3.设置透明度用opacity和rgba的区别\n\n4.项目如何做的适配\n\n5.防抖和节流概念区别和使用场景\n\n6.var let const 区别\n\n7.对堆和栈的了解\n\n8.用到过哪些es6的语法\n\n9.promise的原理，它的出现解决了什么问题\n\n10.数组去重的方法\n\n11.splice和slice的区别\n\n12.js的隐式转换\n\n13.深浅拷贝\n\n14.vue和react的区别\n\n15.单项数据流和双向数据流的区别具体讲一下\n\n16.项目难点\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593153489983803392?sourceSSR=users",
        "title": "美团到店酒旅研发部后端日常实习(已offer)",
        "content": "===一面 2.28===\n\n1\\. 实习拷打\n\n2\\. 常规八股，主要是mysql 和 redis 相关\n\n3\\. 算法：原地归并数组\n\n===二面 3.1===\n\n1\\. 实习拷打\n\n2\\. 项目拷打\n\n3\\. 常规八股，包涵 java 基础， jvm， redis，mysql\n\n4\\. 算法：无重复的全排列\n\n二面后半小时 oc(mentor 加微信)\n\n感受：面试体验很好[赞][赞][赞]，比较简单，估计是很缺人，誓死效忠美团😋😋😋\n\n===3.4===\n\n许愿今天发\nOffer[来个offer][来个offer][来个offer][来个offer][来个offer][顺利实习][顺利实习][顺利实习][顺利实习][顺利实习]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593135607380004864?sourceSSR=users",
        "title": "小鹏行为预测算法面试",
        "content": "平台在飞书，时长约一个小时十分左右，没开摄像头～  \n上来先自我介绍  \n为什么选择这个岗位  \n在技术和实际中如何实现预测(被评答的有点空)  \n业务建模：直线行驶的车和要左转弯的车要避免碰撞，列出数学模型并尝试求解(我给的优化模型，但面试官倾向于博弈模型)  \n个体最优和全局最优的关系，在博弈论里又是怎么样的  \n项目询问：多智能体强化学习NashQ，FFQ算法介绍  \n反问：需要进一步学习哪些知识(面试官认为技术够了，但是要会把理论落在业务上[赞])  \ncoding：二叉树的深度和宽度(面试官提示了深度优先或广度优先，苯人写了个动态规划[尴尬][尴尬][尴尬])  \n大概就这些，数学建模真的意想不到😥  \n总体感觉还是错的😃\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593117563622604800?sourceSSR=users",
        "title": "小黑盒二面",
        "content": "  * 项目学习情况\n  * 项目难点 为什么选择做这个项目\n  * acm经历 为什么想打 学习时长 平时怎么学\n  * 周末学吗\n  * kmp算法\n  * ac自动机\n  * 后缀自动机 (怎么全问字符串算法......)\n  * 学习技术带来的能力\n  * 担任的角色 起的任务作用\n  * 工作or读研 为什么\n  * 兴趣爱好\n  * 优点缺点\n  * 为什么投我们公司\n  * (想到再补)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593110072893456384?sourceSSR=users",
        "title": "阿里国际数字商业平台一面面经(社招)",
        "content": "## 楼主背景\n\n应届被裁。学历985本，一年大厂工作经验。\n\n这里效率很高，昨天直接官网投的简历，今天就来联系了。\n\n自己投了个只要一年经验的岗位，不敢找人内推了，这些内推人怎么竟给我推些三年经验起步的岗位，进去被面试官拷打。\n\n## 面试方式\n\n上午约的下午面试。电话面试，中间发邮件笔试链接做题。\n\n## 面试过程\n\n  1. 自我介绍\n  2. 答：毕业学校，实习项目，工作公司项目\n  3. 详细问了业务，不是技术层面的那种，是很业务的那种\n  4. 答：说了一些，然后后面问的东西和我做的项目都没啥关系了，我也说不上来，只能说建议去问我前公司的客服。\n  5. 我项目中提到国际化，问怎么个实现方法\n  6. 答：巴拉巴拉，就是文本拆字符串，维护个字符串管理，能获取其中不同翻译的版本。\n  7. 然后是说他们那边项目是Java的，问我会不会Java，然后问Java八股\n  8. 答：会一些\n  9. Java里创建线程的方式\n  10. 经典八股，上网搜\n  11. 线程池参数\n  12. 经典八股，上网搜\n  13. 线程池怎么工作的\n  14. 经典八股，上网搜\n  15. 怎么去分析Full GC\n  16. 经典八股，上网搜\n  17. 你之前用的都是自研数据库，会不会Mysql，然后问Mysql八股\n  18. 答：会一些\n  19. 说一说Mysql索引\n  20. 经典八股，上网搜\n  21. 说一说聚簇索引和非聚簇索引\n  22. 经典八股，上网搜,(我刚才介绍索引的时候已经说了，怎么又问一遍？)\n  23. 做题，给一个整数，判断是不是回文数\n  24. 反问\n\n## 总结\n\n面试的时候紧张还是无法克服，简单题自己都磕磕绊绊。这次面试前看了一堆系统设计题，完全没用上。面试官和面试官问的问题还是区别挺大的，有的追着项目挖，有的问八股\n\n另外感觉社招不太好找面经啊。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593109600363098112?sourceSSR=users",
        "title": "<春招提前批已开>搜狐畅游各岗位笔试真题上线！",
        "content": "[**春季刷题节活动正在进行中，限量周边/****100元****京东卡等你哦，和牛牛一起刷真题进大厂！**](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Flink%2Fchunjishauti2)\n\n[![](https://uploadfiles.nowcoder.com/images/20240228/999991353_1709091127200/45F820A377D8F6816998CB7A61BDB83B)](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Flink%2Fchunjishauti2)\n\n[MARK][MARK]搜狐畅游春招提前批已开，准备笔试的友友看过来！\n\n[格局打开][格局打开]软开、游戏策划，运营&营销、职能等岗位共12份试卷上线~\n\n🎺是24届不久前考过的原题噢！！！\n\n软开：\n\n[https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=100&selectStatus=0&tagIds=814](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FcurrentTab%3Drecommand%26jobId%3D100%26selectStatus%3D0%26tagIds%3D814)\n\n非技术：\n\n[https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=104&selectStatus=0&tagIds=814](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FcurrentTab%3Drecommand%26jobId%3D104%26selectStatus%3D0%26tagIds%3D814)\n\n[https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=110&selectStatus=0&tagIds=814](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FcurrentTab%3Drecommand%26jobId%3D110%26selectStatus%3D0%26tagIds%3D814)\n\n> 小贴士：电脑端使用Ctrl+F快捷键更方便查找\n\n![](https://uploadfiles.nowcoder.com/images/20240301/999991353_1709280181758/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n※※搜狐畅游提前批启动[https://mp.weixin.qq.com/s/W4UlIJ0Ktyv4OzvjyRaQ1A](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FW4UlIJ0Ktyv4OzvjyRaQ1A)\n\n  * 25届也可以投递噢，有转正机会~\n  * 网申招满即止\n  * 暂无统一笔试，以邮件通知为准，及时刷题噢！\n\n**✨✨更新更多更全校招信息请关注**[**牛客校招日程**](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgw-c.nowcoder.com%2Fapi%2Fsparta%2Fjump%2Flink%3Flink%3Dhttps%253A%252F%252Fgw-c.nowcoder.com%252Fapi%252Fsparta%252Fjump%252Flink%253Flink%253Dhttps%25253A%25252F%25252Fgw-c.nowcoder.com%25252Fapi%25252Fsparta%25252Fjump%25252Flink%25253Flink%25253Dhttps%2525253A%2525252F%2525252Fgw-c.nowcoder.com%2525252Fapi%2525252Fsparta%2525252Fjump%2525252Flink%2525253Flink%2525253Dhttps%252525253A%252525252F%252525252Fgw-c.nowcoder.com%252525252Fapi%252525252Fsparta%252525252Fjump%252525252Flink%252525253Flink%252525253Dhttps%25252525253A%25252525252F%25252525252Fwww.nowcoder.com%25252525252Flink%25252525252Fstxzrc)\n\n[**https://www.nowcoder.com/link/stxzrc**](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgw-c.nowcoder.com%2Fapi%2Fsparta%2Fjump%2Flink%3Flink%3Dhttps%253A%252F%252Fgw-c.nowcoder.com%252Fapi%252Fsparta%252Fjump%252Flink%253Flink%253Dhttps%25253A%25252F%25252Fgw-c.nowcoder.com%25252Fapi%25252Fsparta%25252Fjump%25252Flink%25253Flink%25253Dhttps%2525253A%2525252F%2525252Fgw-c.nowcoder.com%2525252Fapi%2525252Fsparta%2525252Fjump%2525252Flink%2525253Flink%2525253Dhttps%252525253A%252525252F%252525252Fgw-c.nowcoder.com%252525252Fapi%252525252Fsparta%252525252Fjump%252525252Flink%252525253Flink%252525253Dhttps%25252525253A%25252525252F%25252525252Fwww.nowcoder.com%25252525252Flink%25252525252Fstxzrc)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593107787886923776?sourceSSR=users",
        "title": "北京某科技数字有限公司 Java 面经",
        "content": "# 北京某科技数字有限公司 Java 面经\n\n1）\n\n面试官：先讲一下 RESTFUL 风格怎么使用？\n\n我：阿巴阿巴，四种方法讲一下，然后配合 @PathVariable 注解讲一下，路径占位符讲一下，RESTFUL\n的好处讲一下，比如路径更简洁、安全（不暴露参数），高效（支持缓存），差不多就行。\n\n2）\n\n面试官：Post 请求的数据是放在哪里？\n\n我：呃呃呃，表单用一个对象存，然后请求有请求头，请求行，请求体，请求体存储表单数据，简单的前端问题，可以对比下 GET 和 POST\n区别，比如安全方面，数据长度限制方面等等，只要你会的，都可以按逻辑进行阐述，简单的问题其实去做一个完整的阐述，表达这块建议大家多面试练练。\n\n3）\n\n面试官：文件这块是怎么传输的？\n\n我：我项目是上传过 Excel 文件主要利用了，MultiPartFile 这个工具类 SpringMVC 提供的，用 IO 读取就可以了，我写了个\nExcel 工具类读取。\n\n4）\n\n面试官：你项目的安全框架用了什么？\n\n我：阿巴阿巴，这边没用 SpringSecurity、Shrio、Sa-Token ，我就简单用了 AOP 底层代理模式+适配器+一个 JWT，主要用\nToken 令牌进行一个，Token 存 Redis，然后动态刷新 Token 机制，用户无感知，这边要听 Redis\n的过期策略和内存淘汰机制就更好了，能输出一波。\n\n5）\n\n面试官：JWT 密钥放在哪里？\n\n我：服务端配置文件编写，我这边每个用户注册有 AK，SK，SK 就是密钥，可以根据密钥生成不同的 Token。\n\n6）\n\n面试官：Token 的参数构成有哪些？\n\n我：Header（签名算法和令牌类型），PayLoad 负载包含用户信息、令牌颁发时间、过期时间等等，Signature\n是根据头部、负载、密钥加密后合成的结果，一般的 xxx.xxx.xxx。\n\n7）\n\n面试官：Token 存放在哪里？\n\n我：LocalStorage 这边，发送 Axios 请求时，多一个 Authorization 请求头携带 Bearer 空格 + Token\n\n8）\n\n面试官：Token 是怎么生成的？\n\n我：JWT 工具类，用户登录之后，前端会得到一个我后端 Generate 的一个参数，前端获取后存下来就好。\n\n9）\n\n面试官：ArrayList,LinkedList,HashMap 各自的优缺点和使用场景讲一下\n\n我：这边不作赘述了，常见的八股文，按自己的实践和单列集合和双列集合使用场景就可以了，考源码也无所谓都是简单题，比如 Map 的 Put\n流程，为什么链表大于等于 8 并且数组长度>=64 树化，为什么从 8 到 6 后退化，Hash 冲突有几种解决方案，各自有什么好处，多线程 HashMap\n安全吗，Key Value 为 Null 问题等等，可以讲的东西太多了，可能一个问题讲好几分钟也是正常，只要面试官想听，其实可以一直讲。\n\n10）\n\n面试官：ArrayList 和 LinkedLIst 获取数据的时间复杂度\n\n我：O(1) 和 O(N)，数组和链表....\n\n11）\n\n面试官：你数据库掌握能力怎么样？\n\n我：比较弱，只做过几个多表连接，然后说一下，左右连接的区别，内连接，再说一下实际项目怎么写的 SQL，怎么做 SQL\n优化等等，索引数据类型，索引失效，事务，隔离级别，三大日志，刷盘时机，MVCC 怎么实现的？行锁，表锁，意向锁，共享锁，独占锁，InnoDB 引擎对比\nMyISAM 的优势等等，数据库要是问起来半小时起步了。\n\n12）\n\n面试官：输入 URL 后的一系列流程是什么？\n\n我：URL 检查、缓存查询（计算机网络）、DNS 解析、获取 MAC 地址、TCP 三握、HTTPS 握手、返回数据、页面渲染（DOM)、TCP\n四挥，其实这里面每一个都可以阐述，基本是计算机网络的基础知识。\n\n13）\n\n反问技术栈、主要做的业务，以及工作时间和待遇，总体来说面试比较简单，比较浅层，没啥深度考究，过了一天电话说 OC 了，然后是经典流程，拒了...未完待续\n\n开源 AI 项目 Gitee 地址：[https://gitee.com/falle22222n-leaves/vue_-book-manage-\nsystem](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgitee.com%2Ffalle22222n-leaves%2Fvue_-\nbook-manage-system)\n\n欢迎老铁们 Star 下！累计总后端 700 + Star ⭐⭐⭐\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593105391890812928?sourceSSR=users",
        "title": "北森云-后端应届-一面",
        "content": "面试官很好，回答不出来会引导一会。面了四十分钟左右，这次问的大多是八股文。\n\n  1. JVM内存模型？JVM堆里面的结构？一个对象从new出来，再到生命结束，在堆里面具体是怎么样的？\n  2. 讲一下老年代CMS？这个我没答上来\n  3. 死锁是什么？这个我也没答上来\n  4. CAS？说了几次没说对\n  5. HashMap底层实现？\n  6. 什么是哈希冲突？\n  7. 继承，封装，多态是什么？封装没说好，继续背\n  8. 常见的异常\n  9. java怎么处理异常？try-catch那些\n  10. 1w数据，怎么找出最大值？遍历，如果能有二叉树维护有序状态更好\n  11. 10亿数据，怎么找出最大值？遍历，多线程\n  12. 线程安全是什么？概念没背下来，面试官换了问法，多个线程对同一个数据进行+1，为什么最后数据结果不对？回答的是时间片，缓存刷新，数据可见性等等方面。解决方法可以有volatile 关键字什么的\n  13. 红黑树的特点？\n  14. finally是什么？\n  15. 两个栈怎么实现队列？如果想要同时进和出呢？画图演示，然后又详细问了关于锁的范围。\n  16. 其他的忘了\n\n最后厚着脸皮，让面试官点评一下我的今天的面试表现。哈哈，哪不行补哪。\n\n两天后，收到邮件，被拒了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593104748941684736?sourceSSR=users",
        "title": "阿里云暑期实习提前批一面（技术服务平台）|讲解｜0301",
        "content": "上一篇讲解了一位同学的快手一面面经，今天继续挑选他0229的阿里云一面面经进行**讲解分析，参考回答和学习资料指引**\n。主要是Java八股和少量数据库Mysql的考察。\n\n本文也是 **《热门面经讲解》专栏** 系列文章之一，大家可以**点个关注** ，我会持续更新\n\n>\n> [原贴链接](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F592751787405217792)\n>\n>\n> ![alt](https://uploadfiles.nowcoder.com/images/20240301/7538287_1709278808319/D2B5CA33BD970F64A6301FA75AE2EB22)\n> ![alt](https://uploadfiles.nowcoder.com/images/20240301/7538287_1709278830735/D2B5CA33BD970F64A6301FA75AE2EB22)\n>\n> **感谢这位同学的分享，预祝顺利offer！！**\n\n## 1.你的技术栈是Java，讲一下Java面向对象的特点？\n\n  * 你实际应用过“多态”吗，举一个具体例子，和重载有什么关系？\n\n**讲解：** 基础面试题。考察封装继承多态，并且需要举例子。估计大家回答都没问题，就是举例可能有点懵。\n\n**参考回答：**\n\n> **1\\. 面向对象的三大基本特性：封装、继承和多态。**\n>\n>   *\n> 封装：封装是把对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类提供的方法进行操作。封装的主要目的是增加安全性和简化编程，用户只需要知道对象提供哪些方法，而不需要了解内部细节。\n>   *\n> 继承：继承是从已有的类派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。继承实现了代码的复用，提高了软件开发的效率，也便于创建更为复杂的类。\n>   * 多态：多态是指允许不同类的对象对同一消息作出响应。即同一操作作用于不同的对象，可以产生不同的结果。多态的实现依赖于继承、接口和重写。\n>\n\n> **2.多态示例:**\n>\n>   *\n> 比如在一个绘图系统中，可能会有圆形、矩形、三角形等多种图形，每种图形都有自己的绘制方法。我们可以定义一个Shape接口或抽象类，其中包含一个draw方法，然后让各种具体的图形类去实现或继承这个接口/抽象类，并覆盖draw方法。\n>\n\n    \n    \n    public interface Shape {  \n        void draw();  \n    }  \n      \n    public class Circle implements Shape {  \n        @Override  \n        public void draw() {  \n            System.out.println(\"Drawing a circle\");  \n        }  \n    }  \n      \n    public class Rectangle implements Shape {  \n        @Override  \n        public void draw() {  \n            System.out.println(\"Drawing a rectangle\");  \n        }  \n    }\n    \n\n>   *\n> 在主程序中，我们可以创建一个Shape类型的数组或列表，将不同种类的图形对象添加进去，然后遍历这个集合，调用每个对象的draw方法。由于每个对象都是Shape接口的实现类，所以它们都可以响应draw消息，但具体的实现方式是不同的，这就体现了多态。\n>\n\n    \n    \n    public class Main {  \n        public static void main(String[] args) {  \n            List<Shape> shapes = new ArrayList<>();  \n            shapes.add(new Circle());  \n            shapes.add(new Rectangle());  \n              \n            for (Shape shape : shapes) {  \n                shape.draw();  \n            }  \n        }  \n    }\n    \n\n> **3.多态与重载的关系**\n>\n>   * **多态:**\n> 主要关注的是不同对象对同一消息的响应不同，它依赖于继承、接口和方法重写（Overriding）。在上面的例子中，Circle和Rectangle都实现了Shape接口的draw方法，但具体的实现不同，这就是多态的体现。\n>\n>   * **重载:**\n> 则是在同一个类中，方法名相同但参数列表不同（包括参数个数、类型或顺序），与返回值类型无关。重载是编译时多态的一种表现，它在编译时就能确定调用哪个方法，而多态是运行时多态，只有在运行时才能确定调用哪个实现的方法。\n>\n>\n\n**学习指引：**\n\n面试学习： [《JavaGuide》：面向对象三大特征 ](https://javaguide.cn/java/basis/java-basic-\nquestions-02.html#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81)\n\n## 2.Java中的HashMap了解吗？\n\n  * 聊聊HashMap的底层结构\n  * 为什么要引入红黑树，而不用其他树？\n  * 红黑树和二叉搜索树、AVL树有什么区别？\n  * HashMap会出现红黑树一直增高变成无限高的情况吗？\n  * HashMap读和写的时间复杂度是多少？\n\n**讲解：** 直接问HashMap的结构，那就选Java8版本来讲解就行，如果面试官想问Java8之前的，那就等他问了再答。\n\n**参考回答：**\n\n> **1\\. 聊聊HashMap的底层结构：** Java\n> 8中的HashMap底层结构主要由数组和链表（或红黑树）组成。这个数组被称为“桶数组”，其中每个元素是一个桶（Bucket），桶中存放的是链表或红黑树。当HashMap中的元素较少且分布均匀时，主要使用链表存储元素；但当链表长度超过一定阈值时，外加数组长度大于64时，链表会转换为红黑树以提高查询效率。\n\n> **2\\. 为什么选红黑树，和二叉搜索树、AVL树有什么区别？**\n>\n>   * **二叉搜索树**\n> ：在二叉搜索树中，左子节点的值小于根节点的值，右子节点的值大于根节点的值。这使得二叉搜索树在查找操作上具有优势。然而，二叉搜索树可能退化为线性结构，即链表，当数据插入顺序有序或接近有序时，其查找效率会大大降低，时间复杂度可能达到O(n)。\n>   * **AVL树**\n> :是一种高度平衡的二叉搜索树，它要求每个节点的左右子树的高度差不超过1。这种严格的平衡条件使得AVL树在查找操作上具有很高的效率，时间复杂度为O(log\n> n)。然而，为了维护这种严格的平衡，AVL树在插入和删除操作时需要进行频繁的旋转调整，这增加了维护成本。因此，AVL树适合用于查找操作频繁但插入和删除操作较少的场景。\n>   * **红黑树**\n> ：红黑树是一种近似平衡的二叉搜索树，它通过一系列性质（如节点颜色、黑高）来维护树的平衡。与AVL树相比，红黑树的平衡条件相对宽松，因此在插入和删除操作时的维护成本较低。虽然红黑树的查找效率略低于AVL树，但其综合性能较好，适用于各种操作（插入、删除和查找）都较频繁的场景。此外，红黑树的高度近似为2log\n> n，在实际应用中表现出良好的性能。\n>\n\n> **3\\. HashMap会出现红黑树一直增高变成无限高的情况吗？**\n> 不能无限增长。当集合中的节点数超过了阈值，HashMap会进行扩容，这时原始的红黑树节点会被打散，可能会退化成链表结构。\n\n> **4\\. HashMap读和写的时间复杂度是多少？** 理想情况下是O(1)常数时间复杂度。hash冲突严重的情况下可能会退化为O(n)或者O(log\n> n)，即链表和红黑树的复杂度。 但采用高质量的哈希函数、扩容机制和链表转换为红黑树等优化策略，大多数情况下是可以保证常数时间复杂度的。\n\n**学习指引：**\n\n面试学习： [《JavaGuide》| HashMap\n源码分析](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjavaguide.cn%2Fjava%2Fcollection%2Fhashmap-\nsource-code.html)\n\n## 3.HashMap是线程安全的吗？怎么解决？\n\n**讲解：**\n\n一般这个面试题会作为一个引子，引导到ConcurrentHashMap的考察上面去。但是这里好像面试官没有细问了。\n\n**参考回答：**\n\n> 不是。\n\n> 解决：\n>\n>   * 使用Collections.synchronizedMap()方法\n>   * 使用ConcurrentHashMap\n>\n\n**学习指引：** 面试学习\n[《JavaGuide》|HashMap为什么线程不安全](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjavaguide.cn%2Fjava%2Fcollection%2Fjava-\ncollection-\nquestions-02.html%23hashmap-%25E4%25B8%25BA%25E4%25BB%2580%25E4%25B9%2588%25E7%25BA%25BF%25E7%25A8%258B%25E4%25B8%258D%25E5%25AE%2589%25E5%2585%25A8)\n\n## 4.解决线程安全问题还有哪些办法？\n\n**讲解：**\n\n这个题面试官的目的就是想引导话题到并发的考察上，通过你的举例，追问具体并发知识点的考察上。比如你说synchronized，那有可能就继续接着问，这里其实太多了，你就该可以说些你熟悉的，故意引导面试官去你熟悉的领域。\n\n**参考回答：**\n\n>\n> 使用synchronized关键字;使用volatile关键字;使用Lock接口及其实现类;使用原子变量类;使用并发容器;使用ThreadLocal;使用并发工具类，如信号量（Semaphore）；使用阻塞队列；使用线程池等。\n\n**学习指引：**\n\n面试学习：[《JavaGuide》|\n并发编程面试题](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjavaguide.cn%2Fjava%2Fconcurrent%2Fjava-\nconcurrent-questions-01.html)\n\n系统学习：书籍《Java并发编程艺术》，讲得不错但有点老；\n\n## 5.volatile关键字是如何保证内存可见性的？底层是怎么实现的？\n\n  * 为什么需要保证内存可见性？\n  * volatile为什么要禁止指令重排，能举一个具体的指令重排出现问题的例子吗\n\n**讲解：**\n\nvolatile关键字和Synchronized关键字考察点都挺多的，需要重点掌握。\n\n**参考回答：**\n\n> **1.如何保证内存可见性的?:**\n> Java的内存模型中，每个线程会有一个私有本地内存的抽象概念，正常情况下线程操作普通共享变量时都会在本地内存修改和读取，那就导致别的线程感知不到，出现可见性问题。而当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主内存，当有其他线程需要读取时，它也会去主内存中读取新值。这样就解决的可见性问题。\n\n> **2.底层实现** ：\n>\n>   * 内存屏障（Memory\n> Barriers）：内存屏障确保处理器按照程序指定的顺序执行指令，防止编译器和处理器对指令进行重排序，从而保证了volatile变量的读写操作对其他线程立即可见。\n>   *\n> 缓存一致性协议（如MESI）：缓存一致性协议确保多个处理器核心之间的缓存数据保持一致。当某个处理器修改了volatile变量的值时，该协议会确保其他处理器能够看到这个修改，从而保证了内存可见性。\n>   *\n> lock前缀指令（针对某些架构）：在某些架构下，volatile变量的访问会被转换为带有lock前缀的指令。这些指令会锁定内存总线，确保对volatile变量的操作是原子的，并且会立即将变量的值写回到主内存，从而实现了内存可见性。\n>\n\n> **3.volatile为什么要禁止指令重排，能举一个具体的指令重排出现问题的例子吗？**\n    \n    \n    public class Singleton {\n    \n        private volatile static Singleton uniqueInstance;\n    \n        private Singleton() {\n        }\n    \n        public  static Singleton getUniqueInstance() {\n           //先判断对象是否已经实例过，没有实例化过才进入加锁代码\n            if (uniqueInstance == null) {\n                //类对象加锁\n                synchronized (Singleton.class) {\n                    if (uniqueInstance == null) {\n                        uniqueInstance = new Singleton();\n                    }\n                }\n            }\n            return uniqueInstance;\n        }\n    }\n    \n\n> 例子中，uniqueInstance 采用 volatile 关键字修 饰也是很有必要的， uniqueInstance = new\n> Singleton(); 这段代码其实是分为三步执行：\n>\n>   1. 为 uniqueInstance 分配内存空间\n>   2. 初始化 uniqueInstance\n>   3. 将 uniqueInstance 指向分配的内存地址\n>\n\n>\n> 但是由于 JVM 具有指令重排的特性，执行顺序有可能变成\n> 1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时\n> T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时\n> uniqueInstance 还未被初始化。\n\n**学习指引：**\n\n面试学习：[《JavaGuide》|\nVolatile关键字](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjavaguide.cn%2Fjava%2Fconcurrent%2Fjava-\nconcurrent-\nquestions-02.html%23volatile-%25E5%2585%25B3%25E9%2594%25AE%25E5%25AD%2597)\n\n系统学习：书《Java并发编程艺术》｜3.4 volatile内存语义｜3.8 双重检查锁定\n\n## 6.Synchronized的底层原理是什么，锁升级的过程了解吗？\n\n  * 线程是怎么确定拿到锁的？锁信息具体放到哪的？\n\n**讲解：** Synchronized原理，Java并发考察重点，着重掌握。\n\n**参考回答：**\n\n> **Synchronized的底层原理是什么?**\n>\n>\n> Synchronized的底层实现依赖于JVM的Monitor机制。每个Java对象都有一个与之关联的Monitor，它控制对该对象的访问。线程通过执行monitorenter指令尝试获取Monitor锁，若成功则执行同步代码；若失败则阻塞。执行完毕后，通过monitorexit指令释放锁。这种机制确保了同一时间只有一个线程能执行synchronized保护的代码，实现线程同步。\n\n> **锁升级的过程了解吗？**\n>\n>\n> Synchronized的锁升级过程是为了优化同步性能，在Java虚拟机中，锁会经历无锁、偏向锁、轻量级锁和重量级锁这几个状态。当线程首次访问synchronized代码块时，会尝试使用偏向锁来减少同一线程重复获取锁的开销；如果有多个线程竞争，偏向锁会升级为轻量级锁，通过自旋等待来减少线程挂起的次数；当竞争进一步加剧时，轻量级锁会升级为重量级锁，这时会通过操作系统级别的互斥量来实现严格的线程同步，以确保线程安全。整个升级过程是根据锁的竞争激烈程度来动态调整的，以提高程序的并发性能。\n\n> **线程是怎么确定拿到锁的？锁信息具体放到哪的？**\n>\n>   1.\n> 线程确定拿到锁的过程:是通过检查锁的状态并尝试获取锁来实现的。在JVM中，锁信息具体是存放在Java对象头中的。当一个线程尝试进入synchronized代码块或方法时，JVM会检查对应对象的锁状态。如果对象的锁未被其他线程持有，即锁状态为可获取，那么该线程将成功获取锁并进入临界区执行代码。\n>   2.\n> 锁的状态信息是Java对象头中的：包括锁是否被持有、持有锁的线程标识等。JVM通过操作对象的头部信息来实现锁的获取、释放以及等待队列的管理。当线程成功获取锁后，对象的头部信息会被更新为当前线程的标识，表示该线程拥有了这个锁。其他线程在尝试获取同一个锁时，会检查对象的头部信息，如果锁已经被其他线程持有，它们将会被阻塞直到锁被释放。\n>\n\n**学习指引：**\n\n面试学习：[《JavaGuide》|synchronized关键字](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjavaguide.cn%2Fjava%2Fconcurrent%2Fjava-\nconcurrent-\nquestions-02.html%23synchronized-%25E5%2585%25B3%25E9%2594%25AE%25E5%25AD%2597)\n\n理解学习：[《网课：Java并发编程78讲》｜如何看到 synchronized 背后的“monitor\n锁”？](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Flearn.lianglianglee.com%2F%25E4%25B8%2593%25E6%25A0%258F%2FJava%2520%25E5%25B9%25B6%25E5%258F%2591%25E7%25BC%2596%25E7%25A8%258B%252078%2520%25E8%25AE%25B2-%25E5%25AE%258C%2F21%2520%25E5%25A6%2582%25E4%25BD%2595%25E7%259C%258B%25E5%2588%25B0%2520synchronized%2520%25E8%2583%258C%25E5%2590%258E%25E7%259A%2584%25E2%2580%259Cmonitor%2520%25E9%2594%2581%25E2%2580%259D%25EF%25BC%259F.md)\n\n系统学习：书《并发编程艺术》｜2.2 synchronized的实现原理与应用\n\n## 7.Synchronized加锁和ReentrantLock加锁有什么区别？\n\n**讲解：** Synchronized系列常考面试题。\n\n**参考回答：**\n\n>   * 底层实现不同：synchronized 是依赖于 JVM 实现的，具体实现并没有直接暴露给我们；ReentrantLock 是 JDK\n> 层面实现的，所以我们可以通过查看它的源代码，来看它是如何实现的。\n>   * ReentrantLock 比 synchronized 增加了一些高级功能:\n> 等待可中断;可实现公平锁;可实现选择性通知（锁可以绑定多个条件Condition）\n>\n\n**学习指引：**\n\n面试学习：[《JavaGuide》|synchronized-和-reentrantlock-\n有什么区别](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjavaguide.cn%2Fjava%2Fconcurrent%2Fjava-\nconcurrent-\nquestions-02.html%23synchronized-%25E5%2592%258C-reentrantlock-%25E6%259C%2589%25E4%25BB%2580%25E4%25B9%2588%25E5%258C%25BA%25E5%2588%25AB)\n\n理解学习：[《网课：Java并发编程78讲》｜synchronized 和 Lock\n孰优孰劣，如何选择？](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Flearn.lianglianglee.com%2F%25E4%25B8%2593%25E6%25A0%258F%2FJava%2520%25E5%25B9%25B6%25E5%258F%2591%25E7%25BC%2596%25E7%25A8%258B%252078%2520%25E8%25AE%25B2-%25E5%25AE%258C%2F21%2520%25E5%25A6%2582%25E4%25BD%2595%25E7%259C%258B%25E5%2588%25B0%2520synchronized%2520%25E8%2583%258C%25E5%2590%258E%25E7%259A%2584%25E2%2580%259Cmonitor%2520%25E9%2594%2581%25E2%2580%259D%25EF%25BC%259F.md)\n\n## 8.线程池了解过吗？有哪些核心参数？\n\n  * 为什么核心线程满了之后是先加入阻塞队列而不是直接加到总线程？\n  * 核心线程数一般设置为多少？\n  * IO密集型的线程数为什么一般设置为2N+1？\n\n**讲解：** Java并发编程，据统计，线程池是最高频的考察点！\n\n**参考回答：**\n\n> **有哪些核心参数？**\n> ![](https://files.mdnice.com/user/54801/df34bf1a-e0ec-4893-9801-645c40c02f44.png)\n\n> **为什么核心线程满了之后是先加入阻塞队列而不是直接加到总线程？**\n> 将任务加入阻塞队列可以起到缓冲的作用，使得任务的处理更加平滑。如果直接创建新线程来处理任务，可能会导致线程数过多，从而增加系统的开销和复杂性.\n\n> **核心线程数一般设置为多少？IO密集型的线程数为什么一般设置为2N+1?**\n> 核心线程数的设置并没有固定的公式或标准值，它取决于具体的应用场景、任务类型、系统资源等多个因素。一般来说，核心线程数应该根据CPU的核心数、任务的性质（CPU密集型还是IO密集型）、以及期望的响应时间等因素来进行调整。\n>\n>\n> 对于CPU密集型任务，核心线程数通常设置为接近或等于CPU的核心数，以避免过多的线程上下文切换导致性能下降。而对于IO密集型任务，线程数可以设置得更多一些，因为IO操作通常不需要占用CPU的全部计算能力，更多的线程可以提高任务的并发处理能力。\n>\n>\n> 这里的“2N+1”可能是一个经验值或者特定场景下的优化建议，但并不是普遍适用的规则。实际上，线程数的设置应该根据具体的任务特性、系统资源和性能目标来进行调整和优化。\n> 最好是结合监控策略+动态配置策略进行动态调优。\n\n**学习指引：**\n\n面试学习：[《JavaGuide》|\n线程池](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjavaguide.cn%2Fjava%2Fconcurrent%2Fjava-\nconcurrent-questions-03.html%23%25E7%25BA%25BF%25E7%25A8%258B%25E6%25B1%25A0)\n\n理解学习：[《美团技术团队》｜Java线程池实现原理及其在美团业务中的实践](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Ftech.meituan.com%2F2020%2F04%2F02%2Fjava-\npooling-pratice-in-meituan.html)\n\n## 9.聊聊MySQL的索引结构，为什么使用B+树而不用B树？\n\n  * 你是怎么建立索引的？一般是建立哪些字段的索引呢？\n  * 怎么确定语句是否走了索引？\n  * 如果要建立联合索引，字段的顺序有什么需要注意吗？\n\n**解析：** ： 考察mysql InnoDB引擎的数据结构B+树，需要回答出来为什么要选用B+树，而不是B树，也不是二叉树。\n为什么B+树比他们合适，比他们块。\n\n**参考回答：**\n\n> MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：\n>\n> 1.B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B\n> 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。（为什么不选二叉树也有类似原因)\n>\n> 2.B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B\n> 树那样会发生复杂的树的变化；\n>\n> 3.B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O\n> 操作，范围查询效率不如 B+ 树。\n\n> **你是怎么建立索引的？一般是建立哪些字段的索引呢？**\n>\n>   * 字段有唯一性限制的，比如商品编码；\n>   * 经常用于 WHERE 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。\n>   * 经常用于 GROUP BY 和 ORDER BY 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在\n> B+Tree 中的记录都是排序好的。\n>\n\n> **怎么确定语句是否走了索引？** 最常用的是使用EXPLAIN命令\n\n> **如果要建立联合索引，字段的顺序有什么需要注意吗？**\n>\n>   * 查询频率和过滤性： 将查询中最常用作过滤条件的字段放在索引的前面。选择具有高区分度（即唯一值多）的字段放在前面，这样索引可以更快地缩小搜索范围。\n>   * 排序和分组： 如果查询经常需要按照某个字段排序或分组，考虑将该字段包含在索引中，并根据排序的顺序来确定字段在索引中的位置。\n>   * 范围查询： 如果查询中包含范围查询（如 BETWEEN, <, <=, >,\n> >=），则应该将范围查询涉及的字段放在索引的最后，因为一旦MySQL在索引中遇到范围查询，它就不会再继续使用索引中的后续字段。\n>   * 覆盖索引 ：\n> 如果查询只需要访问索引中的信息，而无需访问表中的行（即覆盖索引查询），则确保索引包含查询所需的所有字段。在这种情况下，字段的顺序应该根据查询的需要来确定。\n>\n\n**学习指引：**\n\n面试学习\n\n[《小林 coding》｜为什么 MySQL 采用 B+\n树作为索引？](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxiaolincoding.com%2Fmysql%2Findex%2Fwhy_index_chose_bpuls_tree.html%23%25E6%2580%258E%25E6%25A0%25B7%25E7%259A%2584%25E7%25B4%25A2%25E5%25BC%2595%25E7%259A%2584%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2593%25E6%259E%2584%25E6%2598%25AF%25E5%25A5%25BD%25E7%259A%2584)\n\n[《掘金专栏：全解Mysql数据库》｜（五）MySQL索引应用篇：建立索引的正确姿势与使用索引的最佳指南！](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjuejin.cn%2Fpost%2F7149074488649318431)\n\n> **关联阅读** ：\n>\n\n>> **阿里云相关** ：\n\n>>\n\n>> [阿里云 实习面经（已OC）\n一面面经｜讲解](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F590576768491216896%3F)\n\n>>\n\n>> [阿里云 实习面经\n二面｜讲解｜0227](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F592128174994075648)\n\n>\n\n>> **该同学相关** ：\n\n>>\n\n>>\n[【快手】电商Java日常实习一面｜讲解｜0229](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F590576768491216896%3F)\n\n本文也是 **《热门面经讲解》专栏** 系列文章之一，大家可以**点个关注** ，\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593098900697788416?sourceSSR=users",
        "title": "Go后端日常实习面经 (深维智讯、螣龙安科、成都好未来)",
        "content": "### 深维智讯 2.27（OC已拒）\n\n笔试1h：逻辑题、语言特性、三大件、算法题\n\n面试1h：\n\n自我介绍\n\n项目选一个介绍\n\n项目提问\n\nMySQL事务隔离级别\n\n覆盖索引\n\nSQL执行慢，如何排查\n\nB+树和跳表的查询的时间复杂度\n\nRedis持久化\n\n打开笔试题抽问思路：\n\n1024&1023\n\n三次握手四次挥手\n\nTime-Wait和Closed-Wait\n\nchmod751\n\n数组和链表的查询、插入时间复杂度\n\n算法：找两个交会链表的第一个交点\n\n### 螣龙安科 2.28（OC已拒）\n\n自我介绍项目介绍\n\n项目相关提问\n\nRedis string底层\n\nGin特性\n\nsync.map\n\nJWT单点登录\n\nSlice并发访问\n\nSlice扩容\n\nmap底层实现 B的作用\n\nMySQL事务\n\n事务提及如何保证一致性\n\nBufferPool\n\n口述算法：\n\n三数之和\n\n最长回文子串\n\n### 好未来 2.28一面\n\nmysql：\n\n事务隔离级别、索引优化、查看SQL使用索引(explain)\n\nredis：\n\n数据类型\n\nString和Hash区别\n\n过期策略\n\n如何让一个key过期\n\n主要结合项目拷打redis、mysql\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593086171970809856?sourceSSR=users",
        "title": "#华为od面经#前端js（已获权）",
        "content": "# 23双非且非科班 华为OD前端 已offer\n\n2023.06毕业后在公司工作没多久，公司倒闭了。后面参加考研然后重新出来找工作，投了华为OD。不得不说\nOD在简历筛选方面还是挺宽松的，本人双非非科班且gap半年的简历也过了。\n\nHR\n\n在牛客上找一个hr内推能够省去很多麻烦。我找的是这个[诶嘿]@华为HR(OD)郑经理(240308510)本人在此。hr会给一些辅导资料以及面试注意事项，对机试面试帮助都很大，而且能够帮忙催对面的进度，约面试等。\n\n机试(375)\n\n一开始没什么信心，毕竟考研备考完已经忘记怎么写代码了，hr给的题库里面有些题真挺难的，感觉都有hard难度。后面硬着头皮报了机试，没想到自己运气好，抽到的机试题目挺简单的，两道字符串相关，一道图相关。\n\n后面查了一下 有一道题目在CSDN上是有原题的，不过不知道也不影响做出来就是了。基本上只要把hr给的题库过一遍 机试的问题就不是很大了。\n\n性格测试\n\n这个还挺重要的，不过按照hr给的指示选就行了。听说这个挂的话一年半不能再报OD，还是谨慎一点比较好。\n\n资面\n\n主要就是聊聊天 问问大学做了什么 之前工作是什么 为什么离职 gap半年在干啥之类的 考研上岸跟工作怎么规划的。\n\n第二天通过 然后约技术面 技术一二面是同时约的 就是一面不太好也得继续二面就是了。\n\n技术一面\n\n主要还是问项目，自己在上一家公司的项目。然后就是问一些简单的前端八股。\n\n最后就是做题环节，给我选了道回文串相关的题目，不过我没做出来，跟面试官申请换题，面试官说自己还特意挑了简单题（压力山大啊）。\n\n后面问了我比较擅长什么，给我出了道单调栈的经典题目。一开始用暴力解做，时间复杂度太高，然后用单调栈的方法做，面试官人很好还给我很多提示，最后勉勉强强做出来。\n\n第二天通过。\n\n技术二面\n\n主要也还是问项目，以及一些自己解决的技术案例。感觉面试官不是前端方向的，没有问很多前端相关问题。面试官知道我学过数据结构后\n问了挺多经典算法以及复杂度的问题。（其中一个感觉自己没答好的问题：”js底层是怎么做垃圾回收的“）\n\n最后做题，题目跟青蛙跳台阶类似，简单的动态规划，不过我是用的回溯+剪枝，属于是暴力取巧，面试官也没多追究，就是说我时间复杂度太高，也教我怎么分解问题，用动态规划来解决。\n\n第二天通过，而且中午就约了主管面，据说主管比较难约。\n\n主管面\n\n刚好当天出门，还是在车上面的。主要聊了大学以及后续规划，还有就是加班，主管说加班很严重，怕我接受不了。当时面完，感觉压力超大，已经不抱过的希望了。没想到下午跟我说通过了。\n\n个人感觉(2024.03.01)\n\n算了下自己的流程，去除掉中间过年放假的几天，也就一个月不到，还算是比较快的。帮忙内推的hr也全程在帮忙催进度，给指导，面试官的人也很不错。\n\n#华为od##华为OD面经##前端面经#\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593081913565335552?sourceSSR=users",
        "title": "We are a team - 华为OD统一考试",
        "content": "> OD统一考试\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n总共有 n 个人在机房，每个人有一个标号 (1<=标号<=n) ，他们分成了多个团队，需要你根据收到的 m 条消息判定指定的两个人是否在一个团队中，具体的:\n\n  1. 消息构成为 a b c，整数 a、b 分别代表两个人的标号，整数 c 代表指令。\n  2. c== 0 代表a和b在一个团队内。\n  3. c == 1 代表需要判定 a 和b 的关系，如果 a和b是一个团队，输出一行\"we are a team\",如果不是，输出一行\"we are not a team\"。\n  4. c 为其他值，或当前行a或b 超出 1~n 的范围，输出 \"da pian zi\"。\n\n## 输入描述\n\n  1. 第一行包含两个整数 n，m(1<=n.m<=100000).分别表示有n个人和 m 条消息。\n  2. 随后的 m 行，每行一条消息，消息格式为: a b c (1<=a,b<=n, 0<=c<=1)\n\n## 输出描述\n\n  1. c ==1.根据 a 和 b 是否在一个团队中输出一行字符串,在一个团队中输出 \"we are a team\", 不在一个团队中输出 \"we are not a team\"。\n  2. c 为其他值，或当前行 a 或 b 的标号小于 1 或者大于 n 时，输出字符串 \"da pian zi\"。\n  3. 如果第一行 n 和 m的值超出约定的范围时，输出字符串\"NULL\"。\n\n## 示例1\n\n    \n    \n    输入\n    5 6\n    1 2 0\n    1 2 1\n    1 5 0\n    2 3 1\n    2 5 1\n    1 3 2\n    \n    输出\n    we are a team\n    we are not a team\n    we are a team\n    da pian zi\n    \n\n## 题解\n\n> **并查集** 的简单模板套用\n>\n> 如果对并查集不会，可以通过\n> [https://zhuanlan.zhihu.com/p/93647900](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F93647900)\n> 来学习。\n\n### Java\n\n    \n    \n    import java.util.Scanner;\n    public class Main {\n    \n        private static boolean checkRange(int a, int b, int c) {\n            return 1 <= a && a <= 100000 && 1 <= b && b <= 100000 && 0 <= c && c <= 1;\n        }\n    \n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            int n = scanner.nextInt(), m = scanner.nextInt();\n            if (!checkRange(n, m, 0)) {\n                System.out.println(\"NULL\");\n                return;\n            }\n    \n            UnionFind uf = new UnionFind(n);\n            for (int i = 0; i < m; i++) {\n                int a = scanner.nextInt(), b = scanner.nextInt(), c = scanner.nextInt();\n                if (checkRange(a, b, c)) {\n                    if (c == 0) {\n                        uf.merge(a, b);\n                    } else if (uf.find(a) == uf.find(b)) {\n                        System.out.println(\"we are a team\");\n                    } else {\n                        System.out.println(\"we are not a team\");\n                    }\n                } else {\n                    System.out.println(\"da pian zi\");\n                }\n            }\n        }\n    \n    }\n    \n    /**\n     * 并查集\n     *\n     * @Descr\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593081296784494592?sourceSSR=users",
        "title": "23双非且非科班 华为OD前端 已offer",
        "content": "2023.06毕业后在公司工作没多久，公司倒闭了。后面参加考研然后重新出来找工作，投了华为OD。不得不说\nOD在简历筛选方面还是挺宽松的，本人双非非科班且gap半年的简历也过了。\n\n### HR\n\n在牛客上找一个hr内推能够省去很多麻烦。我找的是这个@华为HR(OD)郑经理(240308510)。hr会给一些辅导资料以及面试注意事项，对机试面试帮助都很大，而且能够帮忙催对面的进度，约面试等。\n\n### 机试(375)\n\n一开始没什么信心，毕竟考研备考完已经忘记怎么写代码了，hr给的题库里面有些题真挺难的，感觉都有hard难度。后面硬着头皮报了机试，没想到自己运气好，抽到的机试题目挺简单的，两道字符串相关，一道图相关。\n\n后面查了一下 有一道题目在CSDN上是有原题的，不过不知道也不影响做出来就是了。基本上只要把hr给的题库过一遍 机试的问题就不是很大了。\n\n### 性格测试\n\n这个还挺重要的，不过按照hr给的指示选就行了。听说这个挂的话一年半不能再报OD，还是谨慎一点比较好。\n\n### 资面\n\n主要就是聊聊天 问问大学做了什么 之前工作是什么 为什么离职 gap半年在干啥之类的 考研上岸跟工作怎么规划的。\n\n第二天通过 然后约技术面 技术一二面是同时约的 就是一面不太好也得继续二面就是了。\n\n### 技术一面\n\n主要还是问项目，自己在上一家公司的项目。然后就是问一些简单的前端八股。\n\n最后就是做题环节，给我选了道回文串相关的题目，不过我没做出来，跟面试官申请换题，面试官说自己还特意挑了简单题（压力山大啊）。\n\n后面问了我比较擅长什么，给我出了道单调栈的经典题目。一开始用暴力解做，时间复杂度太高，然后用单调栈的方法做，面试官人很好还给我很多提示，最后勉勉强强做出来。\n\n第二天通过。\n\n### 技术二面\n\n主要也还是问项目，以及一些自己解决的技术案例。感觉面试官不是前端方向的，没有问很多前端相关问题。面试官知道我学过数据结构后\n问了挺多经典算法以及复杂度的问题。（其中一个感觉自己没答好的问题：”js底层是怎么做垃圾回收的“）\n\n最后做题，题目跟青蛙跳台阶类似，简单的动态规划，不过我是用的回溯+剪枝，属于是暴力取巧，面试官也没多追究，就是说我时间复杂度太高，也教我怎么分解问题，用动态规划来解决。\n\n第二天通过，而且中午就约了主管面，据说主管比较难约。\n\n### 主管面\n\n刚好当天出门，还是在车上面的。主要聊了大学以及后续规划，还有就是加班，主管说加班很严重，怕我接受不了。当时面完，感觉压力超大，已经不抱过的希望了。没想到下午跟我说通过了。\n\n### 个人感觉(2024.03.01)\n\n算了下自己的流程，去除掉中间过年放假的几天，也就一个月不到，还算是比较快的。帮忙内推的hr也全程在帮忙催进度，给指导，面试官的人也很不错。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593074725786566656?sourceSSR=users",
        "title": "江西天华新瑞 技术面",
        "content": "**笔试**\n\n只记得大概\n\ntry{}finaly{}的知识\n\n有一个list的集合装着【4，3，1】经过list.add(6),list.add(0,6) list.remove(1)后集合中的结果\n\nMysql中undo 和redo，哪个添加数据执行前作用执行后作用（有些忘了）\n\n中间还有一些选择题，单项选择多项选择，有几个是英语面试的题目\n\n说一下你对Spring的理解\n\n说一下转发和重定向的区别\n\n讲一下你对AOP的理解\n\n写一个程序四个数字输出由这四个数字中的三个组成的互不相同的三位数\n\n****\n\n**面试**\n\n1.介绍一下你的毕设项目\n\n2.你的项目中有什么技术可以说一下聊一下的吗？\n\n3.你的项目中redis那些问题是用的什么解决方案呢？\n\n4.讲一下双写一致性\n\n5.介绍一下关于String的一些常用API\n\n6.如果先实现字符串的判空，你会用哪些方式\n\n7.介绍一下你对集合的了解\n\n8.如果现在给你一个集合，我先想让你实现去重和排序你有什么方案可以提供\n\n9.多线程你可以介绍一下多线程的生命周期，状态吗\n\n10.你能介绍一下get和post的区别吗？\n\n11.Bean的生命周期可以介绍一下吗？\n\n12.在bean的生命周期里面我想动态的获取bean的生命周期的相关信息比如什么时候创建什么时候填充的参数，动态获取bean的信息你可以提供一些方案给我吗？\n\n13.你对于spring的AOP有了解吗\n\n14.你能讲一下AOP记录日志的这个实现过程吗？\n\n15.在那个切面中接口出现异常你怎么做去记录呢\n\n16.介绍一下SpringMVC的这个执行过程\n\n17.如何实现接口的响应数据的二次封装，就比如接口返回的是一个String然后封装一下比如说框架里什么东西对String封装一下加一些时间戳加一些其他的信息\n\n18.讲一下Mybatis的插件原理\n\n19.Mybatis在处理这种映射关系的话比如一对多怎么去处理的\n\n20.反问\n\n整体面试下来也问了一下面试官感觉怎么样，总体还是可以\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593068477863202816?sourceSSR=users",
        "title": "腾讯ieg  后端日常实习  一面",
        "content": "面试流程是固定的，3~5分钟自我介绍，15分钟问项目和八股，15分钟代码考察。\n\n1.项目业务流程\n\n2.代码对数据解析失败或者避让算法出现问题怎么处理\n\n3.发生碰撞系统出现问题怎么处理\n\n4.数据丢失或数据解析失败会不会有消息重发机制\n\n5.快排的时间复杂度？最好情况和最差情况分别是什么？如何保证平均时间复杂度为O(nlogn)？\n\n6.编程：leetcode 56\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593040318958678016?sourceSSR=users",
        "title": "乐曼多 游戏客户端暑期实习（已OC）",
        "content": "**hr面（30min）**\n\n聊项目内容和自我的职业规划\n\n**技术面（60min）**\n\n1、内存对齐（c/c++）\n\n2、C#的内存对齐有什么不同？（C#的结构体上可以选择特性`LayoutKind，控制是否使用内存对齐`）\n\n3、Dictionary的底层（红黑树）和获取Key的时间复杂度（O(1)）\n\n4、list边遍历边删除（倒序遍历或者删除时i--）\n\n5、A星算法及其优化、最小堆的实现思路（最小堆去在openlist中查询F值最小的点）\n\n6、点乘和叉乘\n\n7、设计模式（单例、观察者）\n\n8、TCP和UDP的区别\n\n9、协程和线程的区别\n\n之后就是问项目里的一些东西了，总体来说问的不难，因为本人不会c++，所以问的更多的是C#的知识点。问的侧重点更在于一些基础知识，之后还是需要针对性复习八股。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/593036111606198272?sourceSSR=users",
        "title": "阿里云   暑期实习面经   三面",
        "content": "## 写在前面\n\n这是本人去年找暑期实习时候的面经，java后端方向。以下是相关文章链接：[阿里云一面](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F590218714595721216)、[阿里云二面](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F591740699846926336)、[秋招总结](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F578953210505732096)。\n\n## 面试时长\n\n50min\n\n## 面试形式\n\n视频面试\n\n## 面试内容\n\n  1. 自我介绍；\n  2. 项目相关：面试官挑了其中一个项目让介绍，主要是问了项目的技术栈、实现效果和创新点；\n  3. 实习经历相关：概述一下完成了哪些具体需求，以及这些需求所涉及的业务流程。在实现这些需求的过程中，遇到了哪些挑战和困难？又是如何有效地解决这些问题的？具体的解决方案和应对策略。\n  4. 场景题：不考虑系统限制，如何快速在大量字符串中统计出现次数前10的字符串？如果考虑内存限制，应该采取什么措施在海量数据中进行统计？\n  5. 场景题：设计实现一个高可用、高并发的系统，讲讲有哪些需要注意的地方？对于突发的大流量有哪些处理方法？热点数据有哪些处理方法？\n  6. Redis：刚刚场景题中用到了redis，为什么redis是单线程但速度依旧很快？\n  7. 操作系统：介绍下IO多路复用？select、poll和epoll各自的区别？\n  8. 操作系统：磁盘快照有了解吗？介绍下COW和ROW？\n  9. 操作系统：进程、线程和协程各自的作用和区别？进程和线程的组成？\n  10. 操作系统：CPU数量为1的进程执行死循环会发生什么？如何解决？\n  11. 计算机网络：有哪些网络攻击方式？在项目中针对可能的网络攻击采取了哪些相应的防范措施？\n  12. 计算机网络：cookie、session和token的区别？各自的使用场景？\n  13. 数据库：项目中使用了NoSQL和MySQL，说说NoSQL和关系数据库的区别？\n  14. 其他：最近在看什么书？有哪些收获？\n  15. 其他：大学以来最有成就感的一件事？\n  16. 其他：有多家公司的offer根据什么标准进行选择权衡？\n\n## 总结\n\n三面没有算法题，相比一面二面主要增加了场景题的询问。在整个面试过程中，感觉面试官比较看重个人的思考，比如场景题中你说了一种设计思路，面试官会问你觉得目前的设计还有没有可以提升的地方，这种时候即使回答的不是标准答案，面试官也很高兴地会和你进行探讨。此外，一些其他问题也会在三面和后续的hr面多起来，这些也可以稍微准备准备。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/592865094707482624?sourceSSR=users",
        "title": "腾讯-WXG-后台实习 一二三面（3.7更新）",
        "content": "一面 2.29（45min）\n\n1.项目\n\n  * 为什么用springcloud\n  * zookeeper的使用场景\n  * 对Flink的了解\n  * 如何计算词语相似度和语义相似度（NLP）\n  * 场景题\n\n2.算法\n\n  * 手写令牌桶\n\n3.开放\n\n  * 了解的新技术\n\n投的后端，但被问了很多大数据相关的，面试官说进去后端、数开、基架都会做（业务部门都是这样吗）\n\n\\--------------------------------------------------------------------------------------------------------------------------------------\n\n二面 3.4（50min）\n\n1.项目和实习拷打\n\n  * 出了很多场景题，问的比较深（问的是分布式存储的实习和项目以及共识协议的论文，没问后端）\n\n2.算法\n\n  * 二叉树最大路径和\n\n3.八股\n\n  * 计网：http和https的区别；http和TCP的关系；长连接和短连接；网页解析过程。（都是很基础的八股）\n\n\\--------------------------------------------------------------------------------------------------------------------------------------\n\n三面 3.7 （50min）\n\n1.项目\n\n  * 高可用、高并发分别是怎么做的\n  * 分布式锁：ZK和Redis各自的优势；redisson的底层\n  * 消息队列：怎么实现事务的异步调用；技术选型为什么选RocketMQ而不选Kafka和RabbitMQ\n  * 限流：怎么应对大量请求；微服务化以后压测QPS提高了多少\n  * 项目的收获\n\n2.算法\n\n  * 给定页数和每页字符数（随机数组）的一本书，给一个字符返回该字符在哪页（二分法，应该是微信读书相关的业务场景）\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/592844820058554368?sourceSSR=users",
        "title": "绿盟Go后端一面凉经",
        "content": "自我介绍\n\nQ：你现在在重庆，我们这边在北京，有问题吗？\n\n答：没问题，开始扯谎说没课，巴拉巴拉\n\nQ：我看你是信息安全的，你现在是完全不想做信息安全了吗\n\n答：做开发的，巴拉巴拉\n\nQ：有完整做一个项目吗，然后介绍技术栈\n\n答：大概把业务和技术栈介绍了一下\n\nQ：CI/CD 怎么做的？\n\n答：就是用github action，然后编写yaml文件，运行工作流\n\nQ：整个ELK这部分是自己搭建的吗？\n\n答：就是我是docker先把elk实例部分启动出来嘛，然后利用框架对接elk，做了一些配置啥的\n\nQ：你了解elk吗，简单介绍一下？\n\n答：我没有用logstach用的其他中间件替换，就是首先用filebeat去收集docker日志嘛，然后输出到kafka作为缓冲，然后因为logstash本身是使用java开发的，占用资源是真滴高就，用go-\nstach替换了logstack，go-stach就去过滤日志，然后将过滤后的字段输出到elasticsearch中，最后由kibana负责呈现日志\n\nQ：那你后台数据整个都是es吗？还有mysql和redis，简单介绍一下这几种数据库的区别\n\n答：mysql就是关联型数据库嘛（然后打断问mysql存什么？）然后redis去做的一层缓存嘛，去缓存一些常用的数据，比如点赞数之类的。然后es主要是提供视频标题模糊搜索的服务。\n\nQ：es查询语句，es匹配模式用的哪一种？\n\n答：当时不咋懂es，随便说了一下，就是一个简单的get查询，匹配模式当时随便说了一个前缀\n\nQ: 微服务划分？\n\n答：根据业务，巴拉巴拉\n\nQ：如果一个视频转载功能要增加应该划到哪个服务上门去？\n\n答：直接整合到video feed吧\n\nQ：怎么理解微服务的？\n\n答：我理解微服务就是把一个大型业务上面相对独立的模块拆分成一个个的服务，每个服务是相对独立的，提供一种业务服务，每个服务都独立地进行开发、测试和部署，要尽量做到高内聚和低耦合\n\nQ：那你的mysql算不算一个服务？（懵逼了，Mysql咋算服务去了）\n\n答：Mysql是数据库，提供数据存储\n\nQ：数据持久化存储怎么做的？\n\n答：redis aof和rdb持久化吗？（他好像不想听这个，然后问es和mysql）\n\nQ：为什么学go，介绍一下go\n\n答：巴啦啦\n\nQ：用go写过一些扫描工具吗？跟安全相关的\n\n然后就开始讲业务了，所用python和go两块，巴拉巴拉\n\n最后反问业务\n\n最后，他问我是不是大三的，我说我大二，然后他说：哦，那你大二啊，那你们是不是。。ok，了解，那就这样吧，后面等hr反馈吧\n\n总结：大二身份+不在北京+方向不太对的上，他们想找python然后会用go开发一些工具啥的[笑cry][笑cry][笑cry]。总时间20分钟[掉小珍珠了]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/592818715192803328?sourceSSR=users",
        "title": "蚂蚁-支付宝广告一面面经(社招)",
        "content": "## 楼主背景\n\n应届被裁。985本，一年大厂工作经验\n\n网上找人内推，但他给我推了个3年经验的专家岗!\n\n？？？这位内推老哥就不能给我推个大头兵岗位 ？？？\n\n最离谱的是还进面试了，这不应该简历直接挂？\n\n## 面试方式\n\n前一天下午电话邀约，第二天晚上面试，通过蚂蚁会议视频面，本人开摄像头，面试官未开。\n\n## 面试过程\n\n  1. 自我介绍\n  2. 答：毕业学校，实习项目，工作公司项目\n  3. 问我在上一个公司的项目架构是怎样的\n  4. 答：就正常回答，有什么模块，每个模块是干啥的。好像对我的项目没啥兴趣\n  5. 问高并发下有什么好方式减缓系统压力。\n  6. 答：自己网上搜秒杀系统怎么做，一大堆。我答了静态资源缓存，redis，jvm内存，页面静态化，cdn，然后sql查询优化\n  7. 索引怎么设计\n  8. 答：经典八股，网上到处都是，自己搜\n  9. 做题，[************](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fpartition-equal-subset-sum%2F)。这道题的包装题，加了个广告背景。\n  10. 答：用dp背包做，但写的时候已经紧张的大脑宕机了，磕磕绊绊。\n  11. 系统设计，设计一个根据历史搜索关键词的推荐系统。数据库每个表每个字段啥的都详细设计\n  12. 答：寄，不会\n  13. 反问，问了他上面那个推荐系统你怎么设计\n  14. 面试官答：开放性问题，然后提了两个什么没听过的算法。感觉跟没说一样。\n\n## 总结\n\n寄，面试前还是得学一下岗位相关的东西。另外系统设计这里得赶紧补补\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/592815165809135616?sourceSSR=users",
        "title": "【干货帖】面试的反问环节该问些什么？",
        "content": "楼主24届应届已签三方，大大小小的面试经历了许多，也从一个反问环节大脑完全一片空白没话讲的新手小白蜕变成为能够有条不紊站在选择公司的角度提问的求职者。为了避免还有同学跟最初的我一样迷茫，特将自己先前的经验汇总整理了此帖。如有总结的不完善的地方，欢迎评论区补充~\n\n首先，作为求职者而言，要清楚面试是一个双向选择的过程，刚刚被面试官一通提问过后，权力的棒子就交回你手中了。所以在这个环节，要基于你自身实际的需求，充分挖掘这家公司你在意的点。如果什么也不问，等于你就错失了一次通过内部渠道熟悉公司的好机会，还可能会跳进一些不知道的坑。对于招聘方而言，清晰、有条理的提问不仅会提高你在面试人员心中的好感度，也能让面试方觉得你对他们感兴趣、是真的想来他们公司，而不是把公司当做自己池子里的鱼。\n\n下面我将按照不同轮次的面试去分类，分别介绍一下反问环节的技巧。注意面试之前要还是要通过各种信息途径对公司去有一个基本的了解哦，所谓知己知彼者，百战不殆。\n\n## **技术/主管面：**\n\n该轮面试的特点是面试方对具体的工作业务流程都很熟悉，所以可以问以下内容：\n\n**1.工作内容：**\n主要针对技术面，包括不限于岗位职责、具体工作形式等，可结合自己对部门的了解去问，越详细越好，最好能接着面试官的话题去问，他们会认为你对这份工作有着深入的理解，也方便你判断自己对岗位是否感兴趣、契合度高不高。常见提问形式：\n\n _可以再详细介绍一下这个岗位的具体职责吗？_\n\n _我们部门的工作是预研还是解决现有需求？_\n\n _对接人/乙方/客户主要是谁？_\n\n _（这个问题我觉得问一线员工比问hr靠谱）工作时间如何/是否加班？_\n\n**2.公司层面：** 主要针对主管面，相比于基层员工，主管对于业务和整个公司战略的层面有更深入的理解。常见提问形式：\n\n _（用于试探是不是边缘部门）您能介绍一下我们部门在整个业务环节中扮演的角色吗？_\n\n _公司/部门的氛围如何？工作节奏怎么样？_\n\n _新员工入职的培训流程/培养机制？_\n\n _团队总共有多少人？_\n\n _会逐渐拓展新的业务吗？_\n\n _行业未来前景如何？_\n\n其他也可以接着技术面觉得没问充分的点继续深入。\n\n## **hr面：**\n\n该轮面试的重要性不用我多说了吧，求职者最关注的薪资待遇等关键信息都会在这轮中体现。可以问的:\n\n**1.薪资待遇：**\n\n _工资及工资构成？五险一金基数分别是多少？年终奖情况与绩效评定？年假？食宿/房补餐补？落户政策？_\n\n**2.工作方面：**\n\n _工作时间？工作地点？加班and出差情况？通勤是否方便？办公环境如何？试用期多久？转正要求是什么？试用期工资/年终奖情况？_\n\n**3.个人发展方面：**\n\n _培养机制？晋升渠道？涨薪途径？往年公司营收如何？岗位稳定性如何、是否会裁员？_\n\n鉴于裁员是咱应届生都比较关注的一点，直接问会不会裁员可能得到一个模棱两可的答复，可以像这样问：\n\n _在网上看到一些关于贵司裁员的消息，请问这些消息是否属实？如果属实，方便告知一下是什么原因吗？毕竟我更希望和贵司成为长期的合作伙伴。_\n\n（这样hr就能感受到你的真诚，会给予更多对你有用的信息）\n\n另外，对于手头有多个offer的大佬，面的这家hr对你也很感兴趣的情况下，出于怕你是海投的考虑一般会问为什么没有选择之前的offer？可以这么回答，得体又能给自己加分：\n\n_我觉得找工作是人生的一件大事，所以会深思熟虑，如果随便就签约一个不满足自己期望的公司后面又走违约流程，这样对公司对自己都是极其不负责任的。遇到合适的机会再签约，也是对招聘方的尊重。如果您觉得我满足您这边的招聘要求，麻烦您给我一些考虑的时间。_\n\n码字不易，期待大家的点赞收藏哦，希望这篇经验帖能帮到还奋战在春招一线的各位，也祝大家都能如愿拿到自己理想的offer！\n\n引流：华为，腾讯，阿里，百度，字节，美团\n\n"
    }
]