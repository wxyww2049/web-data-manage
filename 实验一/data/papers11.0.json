[
    {
        "url": "https://www.nowcoder.com/discuss/597077760405716992?sourceSSR=users",
        "title": "美团SaaS技术部-前端开发-二面（60min—进池子了）",
        "content": "一、八股\n\n1.堆和栈的区别\n\n2.get和post的区别\n\n3.浏览器解析Url的步骤\n\n4.栈和堆的内存分配是怎么样的？\n\n5.get的url的限制是多少？\n\n答：浏览器不同，限制长度有所不同\n\n5.1.不同的浏览器具体是多少？（这个太详细了没答上来）\n\n6.HTTP状态码？\n\n7.强缓存和协商缓存？\n\n8.如何实现304？\n\n9.js中有哪些基本数据类型？（没答完）\n\n二、简历项目\n\n根本没问简历上面做过的项目，有点奇怪\n\n三、手撕算法\n\n括号匹配（写出来了，没有让运行），最后问了句什么是栈。\n\n三、其他\n\n1.如何学习前端？\n\n2.为什么想学习前端\n\n3.多久开始学习的前端？\n\n4.有过实习吗？\n\n5.有看过什么书吗？\n\n6.如何系统性的学习前端？\n\n四、反问\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/597059904737685504?sourceSSR=users",
        "title": "蔚来Android实习面经",
        "content": "## 一面（2024/3/11 35min）\n\n  1. 自我介绍\n  2. 聊我的本专业\n  3. 说一说MVP架构，MVVM架构\n  4. MVVM架构中ViewModel为什么在翻转屏幕之后还能保持原来的界面\n  5. 说一说Handler机制，Handler机制的使用场景，Handler机制的标志位\n  6. Looper与线程是如何保证一对一的？ThreadLocalMap\n  7. Glide的三级缓存？三级缓存分别是什么？\n  8. OkHttp的拦截器？\n  9. 算法题，两数之和，acm模式\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/597059584376745984?sourceSSR=users",
        "title": "03.12 【北京某养老中厂】暑期一面 Java 55min",
        "content": "听说标准965，里面很多躺平的北京土著，面试官人很好，一听就是京✌，鼠鼠被狠狠拷打项目了\n\n【八股】\n\n  * 网络四层模型是什么，每层具体干了什么\n  * Java集合架构图，从上至下说说\n  * 说说静态内部类使用场景，原理\n  * ip路由过程详细回答\n  * 说说你知道哪些数据结构\n  * mysql索引结构是什么样\n  * b树和b+树在数据量比较少的情况下谁更好\n\n【项目】\n\n  * 挑一个你觉得有挑战性的项目说下\n  * springboot和spring区别\n  * 为什么springboot简化了配置，配置是不需要了吗\n  * jdk和cglib动态代理分别在什么情况下使用，底层怎么执行的\n  * aop代理失效情况有哪些\n  * 一个类两个方法a和b都做了aop切面增强，a方法内部调用了b方法，那么在调用a方法的时候，是哪个对象在调用b方法，是代理对象吗\n  * spring对bean做了哪些拓展增强功能，展开说说\n  * spring源码中哪些设计你觉得有道理，展开说说\n  * 怎么在ioc容器对所有bean进行属性设置\n\n【算法】\n\n  * 核心代码模式，二叉树层序遍历，不到10min\n\n————————————————————————————————————————————————\n\n更新二面：总共50min\n\n自我介绍后拷打了项目\n\n【项目】\n\n  * 缓存和数据一致性怎么保证，消息队列增加了服务的时间，还有什么别的办法\n  * 消息队列在你项目中哪里还有用到\n  * 项目中秒杀限流怎么做的？\n  * Redis的zset滑动窗口限流怎么做的？\n  * 如果同时多个请求打过来，多个tomcat服务器，zset不会发生问题吗（答：zset单线程，面试官说前面判断是多线程，我不知道怎么回答了，其实没听懂）\n  * 如果让你设计秒杀限流，你会从哪些角度考虑？\n  * mysql索引结构\n\n【算法】\n\n  * 二叉树的最近公共祖先，做的太快了，又让做下一题\n  * LRU缓存，差点忘了，不过还是做出来了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/597053314127224832?sourceSSR=users",
        "title": "ARM/Linux嵌入式面经（二）：芯片原厂",
        "content": "> 点赞关注收藏不迷路~~~\n\n# uart如何进行通信，模块发给uart数据信息后经历了什么\n\nUART（Universal Asynchronous\nReceiver/Transmitter，通用异步收发传输器）是一种用于串行通信的协议，它使用一对传输线（TX和RX）进行双向通信。**UART通信通过串行传输数据，数据以字节为单位进行传输。每个字节由起始位、数据位、校验位和停止位组成。**\n\n当模块向UART发送数据信息时，这些数据会经历以下过程：\n\n  * 1、数据准备：发送模块将要发送的数据准备好，通常这些数据存储在发送缓冲区中。\n  * 2、数据格式化：UART模块根据配置参数（如波特率、数据位、停止位、奇偶校验等）将待发送的数据格式化成符合UART协议的数据帧。数据帧以一个起始位开始，后面跟着数据位（通常为7或8位），然后是可选的奇偶校验位，最后以一个或多个停止位结束。\n  * 3、数据发送：UART模块的发送器将格式化后的数据帧通过TX线发送出去。发送器会控制波特率发生器以设定的波特率将数据串行输出。\n\n在接收端，UART的接收器执行以下操作：\n\n  * 1、信号检测：接收器通过RX线实时检测输入信号，一旦检测到起始位，就知道数据准备发送，并尝试与发送器时钟频率同步。\n  * 2、数据接收：接收器按照设定的波特率接收数据，并将数据存储在接收缓冲区中。\n  * 3、数据校验：接收器根据数据帧中的奇偶校验位对数据进行校验，以检测数据传输中的错误。\n  * 4、数据处理：如果数据校验正确，接收器将接收到的数据从串行转换成并行，并交给上层应用处理。\n\n在整个通信过程中，UART模块还负责处理其他信号，如产生额外的信号来指示发送和接收的状态。例如，如果产生一个奇偶错误，UART会置位奇偶标志。\n\n总的来说，UART通信过程涉及**数据准备、格式化、发送、接收、校验和处理等多个步骤**\n，确保数据的正确性和可靠性。同时，UART模块还负责处理各种信号和状态，以维持通信的顺畅进行。\n\n# pc如何连接入linux系统的，底层原理是什么\n\nPC连接到Linux系统的底层原理主要涉及到**网络通信协议、远程访问技术和服务端配置等多个方面。**以下是具体的解释：\n\n## 网络通信协议：\n\nPC和Linux系统之间的连接是通过网络通信协议实现的。常见的协议包括TCP/IP协议族，它负责在不同设备之间传输数据。\n\n在这个过程中，数据被拆分成数据包，通过网络中的路由器和交换机进行转发，最终到达目标Linux系统。\n\n## 远程访问技术：\n\n常见的远程访问技术有SSH（Secure Shell）和Telnet等。SSH是最常用的方式，因为它提供了加密的数据传输，保证了通信的安全性。\n\n当PC使用SSH连接到Linux系统时，会建立一个加密的通道，通过这个通道，PC可以发送命令到Linux系统，并接收Linux系统的响应。\n\n## 服务端配置：\n\nLinux系统需要配置相应的服务来接受PC的连接请求。对于SSH连接，Linux系统需要运行SSH服务器（如OpenSSH），并监听特定的端口（默认是22端口）。\n服务端还需要配置相应的认证机制，比如密码认证或密钥认证，以确保只有经过授权的用户才能访问系统。\n\n## 会话管理：\n\n一旦连接建立成功，PC和Linux系统之间会建立一个会话。这个会话会维护双方的通信状态，确保数据的正确传输。\n在会话期间，PC可以发送命令给Linux系统执行，Linux系统会将执行结果发送回PC。\n\n## 数据传输：\n\n数据在PC和Linux系统之间的传输是基于底层的网络协议进行的。数据包会按照网络协议的规定进行封装和解封装，确保数据在传输过程中的完整性和安全性。\n\n总结来说，**PC连接到Linux系统的底层原理是通过网络通信协议建立连接** ，利用**远程访问技术实现数据的加密传输和命令的执行**\n，同时需要**服务端进行相应的配置和会话管理来确保通信的顺畅进行** 。这些原理共同构成了PC与Linux系统之间的远程连接和交互的基础。\n\n## 手撕哈希表的建立\n\n手撕哈希表的建立主要包括以下几个步骤：\n\n  * 确定哈希表的大小：首先，你需要确定哈希表的大小，这通常取决于你预计要存储的元素数量以及你希望的哈希表性能。哈希表的大小应该是一个质数，这样可以减少哈希冲突的可能性。\n\n  * 设计哈希函数：哈希函数是将键（key）映射到哈希表中索引的函数。设计哈希函数时，你需要确保它能够将不同的键映射到不同的索引（理想情况），或者至少将冲突的数量最小化。常见的哈希函数包括除法取余法、平方取中法、折叠法等。\n\n  * 初始化哈希表：创建一个数组作为哈希表的底层数据结构，数组的每个元素可以是一个链表或者其他数据结构，用于处理哈希冲突。\n\n  * 插入元素：对于每个要插入的元素，首先使用哈希函数计算其哈希值，然后将该哈希值作为索引在哈希表中查找。如果索引处为空，则直接在该位置插入元素；如果索引处已有元素（即哈希冲突），则使用链表或其他数据结构存储这些元素。\n\n  * 处理哈希冲突**：哈希冲突是哈希表中常见的问题，即两个不同的键通过哈希函数计算得到了相同的哈希值**。处理哈希冲突的方法有多种，如链地址法（将冲突的元素存储在同一索引处的链表中）、开放地址法（当冲突发生时，尝试在哈希表中的其他位置插入元素）等。\n\n下面是一个简单的哈希表插入操作的伪代码示例：\n\n    \n    \n    python\n    class HashTable:  \n        def __init__(self, size):  \n            self.size = size  \n            self.table = [[] for _ in range(size)]  # 初始化哈希表为大小为size的空链表数组  \n      \n        def hash_function(self, key):  \n            # 这里使用简单的除法取余法作为哈希函数  \n            return key % self.size  \n      \n        def insert(self, key, value):  \n            index = self.hash_function(key)  \n            for pair in self.table[index]:  # 遍历链表查找是否存在相同键  \n                if pair[0] == key:  \n                    pair[1] = value  # 如果键已存在，更新值  \n                    return  \n            self.table[index].append([key, value])  # 如果键不存在，添加到链表末尾\n    \n\n这个示例中，我们使用了除法取余法作为哈希函数，并使用链表来处理哈希冲突。\n\n在插入元素时，我们首先计算键的哈希值，然后在对应的索引处查找是否存在相同的键。\n\n如果存在，则更新其值；如果不存在，则将新的键值对添加到链表的末尾。\n\n请注意，这只是一个简单的示例，实际的哈希表实现可能会更加复杂，并需要考虑更多的因素，如动态调整哈希表的大小、优化哈希函数以减少冲突等。\n\n> 质数，又称素数，是指在大于1的自然数中，除了1和此整数自身外，没法被其他自然数整除的数。\n\nC语言实现\n\n    \n    \n    #include <stdio.h>  \n    #include <stdlib.h>  \n    #include <stdbool.h>  \n      \n    #define HASH_TABLE_SIZE 10  \n    #define EMPTY -1  \n      \n    typedef struct {  \n        int key;  \n        int value;  \n    } HashTableItem;  \n      \n    HashTableItem hashTable[HASH_TABLE_SIZE];  \n      \n    // 哈希函数  \n    unsigned int hash(int key) {  \n        return key % HASH_TABLE_SIZE;  \n    }  \n      \n    // 插入元素到哈希表  \n    bool insert(int key, int value) {  \n        unsigned int index = hash(key);  \n        while (hashTable[index].key != EMPTY) {  \n            // 如果键已经存在，则更新其值并返回  \n            if (hashTable[index].key == key) {  \n                hashTable[index].value = value;  \n                return true;  \n            }  \n            // 使用线性探测找到下一个空槽  \n            index = (index + 1) % HASH_TABLE_SIZE;  \n            if (index == hash(key)) { // 如果回到原点，说明表已满  \n                return false;  \n            }  \n        }  \n        // 找到空槽，插入新元素  \n        hashTable[index].key = key;  \n        hashTable[index].value = value;  \n        return true;  \n    }  \n      \n    // 根据键查找值  \n    int lookup(int key) {  \n        unsigned int index = hash(key);  \n        while (hashTable[index].key != EMPTY) {  \n            if (hashTable[index].key == key) {  \n                return hashTable[index].value;  \n            }  \n            index = (index + 1) % HASH_TABLE_SIZE;  \n            if (index == hash(key)) { // 如果回到原点，说明键不存在  \n                return EMPTY;  \n            }  \n        }  \n        return EMPTY; // 键不存在  \n    }  \n      \n    // 初始化哈希表  \n    void initHashTable() {  \n        for (int i = 0; i < HASH_TABLE_SIZE; i++) {  \n            hashTable[i].key = EMPTY;  \n            hashTable[i].value = 0;  \n        }  \n    }  \n      \n    int main() {  \n        initHashTable();  \n      \n        // 插入一些元素  \n        insert(10, 100);  \n        insert(20, 200);  \n        insert(30, 300);  \n        insert(40, 400);  \n      \n        // 查找元素  \n        printf(\"Value for key 20: %d\\n\", lookup(20));  \n        printf(\"Value for key 50: %d\\n\", lookup(50)); // 应该返回 EMPTY  \n      \n        return 0;  \n    }\n    \n\n## 为什么哈希表的大小应该是一个质数，这样可以减少哈希冲突的可能性?\n\n哈希表的大小选择质数作为底层数组的大小有助于减少哈希冲突，原因如下：\n\n  * 均匀分布：**质数在除法运算中更有可能产生均匀分布的结果** 。当使用除法取余法作为哈希函数时，如果哈希表的大小是质数，那么对于大多数键，其哈希值将更均匀地分布在哈希表的各个槽位中。这有助于减少由于某些键具有相同的哈希值而导致的冲突。\n\n  * 周期性避免：非质数，特别是那些包含小因子的数（如偶数或能被小素数整除的数），**在哈希过程中可能引入周期性** 。这意味着某些键的哈希值可能会以某种模式重复出现，导致冲突增加。质数由于只能被1和它本身整除，所以能更好地避免这种周期性。\n\n  * 数学原理：在数学上，**质数具有一些独特的性质，这些性质使得它们在哈希表设计中特别有用** 。尽管不是所有哈希函数都严格依赖于这些数学性质，但使用质数作为哈希表的大小通常是基于这些性质的合理推测。\n\n  * 实践验证：通过大量的实践验证，**人们发现使用质数作为哈希表的大小确实有助于减少冲突，提高哈希表的性能** 。\n\n然而，需要注意的是，虽然质数通常是一个好的选择，**但哈希表的性能并不仅仅取决于其大小是否是质数**\n。**哈希函数的设计、哈希表的扩容策略、处理冲突的方法等因素同样重要。** 因此，在选择哈希表大小时，除了考虑使用质数，还需要综合考虑其他因素。\n\n# 细扣项目\n\n> 写到简历上的项目你一定要非常非常清楚。\n\n# 学过的计算机相关的课程\n\n  * 计算机科学导论：这门课程通常作为计算机专业学生的入门课程，介绍计算机科学的基本概念、发展历程和应用领域。\n\n  * 计算机组成原理：讲解计算机的基本组成部件，如CPU、内存、硬盘等，以及它们之间的交互方式。\n\n  * 操作系统：深入剖析操作系统的原理、功能和设计，包括进程管理、内存管理、文件系统等。\n\n  * 数据结构与算法：学习各种常见的数据结构（如链表、栈、队列、树、图等）和算法（如排序、查找、递归等），以及它们在实际问题中的应用。\n\n  * 计算机网络：介绍计算机网络的基本原理、协议和技术，包括TCP/IP协议族、路由、交换、网络安全等。\n\n  * 数据库系统原理：讲解数据库的基本概念、SQL语言、数据库管理系统（DBMS）的设计和实现，以及数据库安全和性能优化等问题。\n\n  * 编程语言与程序设计：学习一种或多种编程语言（如C、C++、Java、Python等），并通过编写程序来解决实际问题。\n\n  * 软件工程：介绍软件开发的流程、方法和技术，包括需求分析、设计、编码、测试、维护等各个阶段。\n\n  * 计算机图形学：研究计算机生成和处理图形图像的原理和技术，包括三维建模、渲染、动画等。\n\n  * 人工智能：介绍人工智能的基本原理和应用，包括机器学习、深度学习、自然语言处理等热门领域。\n\n此外，还有一些与计算机相关的课程，如**计算机安全、密码学、分布式系统、云计算、大数据技术等** ，这些课程根据学校的设置和学生的兴趣可能会有所不同。\n\n# 用定义性语言描述进程和线程\n\n这个在之前的文章说了：[【ARM/Linux嵌入式面经（一）：海康威视】](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fweixin_45264425%2Farticle%2Fdetails%2F136583871%3Fspm%3D1001.2014.3001.5502)\n\n# 计算机组成原理相关\n\n## 1.1、冯诺伊曼计算机特点\n\n  * 1、硬件系统由五大部件组成：运算器、存储器、控制器、输入设备、输出设备。\n\n  * 2、指令和数据以二进制存放在存储器中，按地址访问。\n\n  * 3、指令在存储器中按顺序存放。\n\n  * 4、指令由操作码和地址码组成。\n\n  * 5、以运算器为中心。（现代计算机以存储器为中心）\n\n## 1.2、存储程序的概念。\n\n将指令以代码的形式事先输入到计算机主存储器中，然后按其在存储器中的首地址执行程序的第一条指令，以后就按照该程序的规定顺序执行其他指令，直至程序执行结束。\n\n存储程序的概念主要包含以下几个要点：\n\n  * 代码存储：程序（即指令序列）被事先以代码的形式输入到计算机的主存储器（如RAM）中。这意味着程序不是以外部实体（如纸带或卡片）的形式存在，而是作为二进制数据存储在计算机的内存中。\n\n  * 自动执行：计算机从程序在存储器中的首地址开始执行第一条指令。这意味着计算机有一个机制（通常是程序计数器）来跟踪当前正在执行的指令的位置。\n\n  * 顺序执行：一旦第一条指令执行完毕，计算机会自动按照程序中规定的顺序执行下一条指令。这个过程是自动且连续的，无需用户手动干预。\n\n  * 控制流：程序中的指令可能包含控制流指令，如条件跳转或循环，这些指令会改变指令执行的顺序。但即使如此，执行的控制流仍然是由程序自身定义的，并由计算机自动执行。\n\n  * 执行结束：程序会按照其定义的逻辑一直执行，直到程序中的所有指令都执行完毕，或者遇到某种终止条件（如遇到错误或程序主动退出）。\n\n存储程序的概念实现了计算机硬件和软件之间的分离，使得软件（即程序）可以被视为数据，并且可以像数据一样被存储和修改。这种分离极大地提高了计算机的灵活性和可编程性，使得计算机可以执行各种不同的任务，只需通过改变其存储的程序即可。\n\n存储程序的概念还促进了计算机的模块化设计，使得不同的硬件部件（如CPU、内存、输入/输出设备等）可以独立设计、制造和升级，而不必改变整个系统的架构。这种模块化设计使得计算机的设计、制造和维护都变得更加容易和高效。\n\n## 1.3、冯诺依曼机中数据为什么用二进制编码表示\n\n  * 1、二进制运算规则简单。（通过0，1转换成加法运算）\n\n  * 2、制造两个稳态的物理器件容易。（只需要高、低电平）\n\n  * 3、便于用逻辑门电路实现算术运算。（0，1对应真假）\n\n## 1.4、指令和数据都以二进制存储，CPU如何区分\n\nCPU根据指令周期的不同阶段来区分，取指阶段取出指令，执行阶段取出数据。\n\n## 1.5、机器语言、汇编语言、高级语言的区别与联系\n\n  * 机器语言：由二进制编码组成，是计算机唯一可以直接识别和执行的语言。\n\n  * 汇编语言：用助记符代替二进制的指令代码，容易记忆；必须经过汇编操作转换为机器语言，才能在硬件上执行。\n\n  * 高级语言：需要经过编译程序编译成汇编语言程序，然后经过汇编得到机器语言程序。（C，C++，Java）也可以直接由高级语言程序翻译成机器语言程序。（Python）\n\n## 1.6、翻译程序是什么，有哪些\n\n翻译程序：把高级语言程序转换成机器语言程序（目标代码）的软件。\n\n翻译程序有三种\n\n  * 1、编译程序：将高级语言源程序一次全部翻译成目标程序，每次执行程序时，只要执行目标程序就行。源程序不变就无需重新编译。\n\n  * 2、解释程序：将一条语句翻译成机器目标代码并立即执行，然后接着翻译下一条，不生成目标程序。\n\n  * 3、汇编程序：将汇编语言程序翻译成机器语言程序。\n\n## 1.7、字长、字、指令字长、存储字长\n\n  * 字长（机器字长）：一次整数运算所能处理的二进制数据位数。（如16位机器，16位即为字长）\n\n字长=CPU内部整数运算器位数=通用寄存器位数\n\n  * 字：被处理信息的单位。\n\n  * 指令字长：一个指令字中二进制代码的位数。\n\n  * 存储字长：一个存储单元中二进制代码长度。\n\n指令字长=存储字长 * k（需要k个访存周期来取出一条指令）。\n\n## 2.1、已知X和Y，如何用补码求X-Y\n\n## 2.2、大端存储、小端存储\n\n大端：先存高位字节（左边部分），再存低位字节（右边部分）。（正常思维方式）\n\n小端：先存低位，后存高位。\n\n## 2.3、计算机什么时候会发生溢出\n\n加减法时超出了所能表示的范围，只有两正数或两负数相加才会发生。\n\n## 2.4、怎么有什么方法判断溢出\n\n1、符号位，如正+正=负 或 负+负=正 则溢出。\n\n2、符号位进位和数值最高位进位，如果只有一个发生了进位则溢出。\n\n3、双符号位，不一致就溢出。\n\n## 2.5、浮点数的表示中为什么要用移码表示阶码\n\n1、为了方便对阶操作，比较大小能直接看出来。阶码=移码=偏移常数+真值。\n\n2、简化了对于“0”的判断，当移码的各位都为0的话，那么该移码对应的数据是能够表示的数据中的最小值。\n\n3、可以提高表示数据的精度。因为没有负数。\n\n## 3.1、半导体存储器有哪些\n\n半导体存储器分为RAM和ROM，其中RAM又分SRAM和DRAM。他们都采用随机存取方式。\n\nSRAM：非破坏性读出，无需刷新。易失性存储器，存取速度快，集成度低，功耗大，常用于Cache。\n\nDRAM：破坏性读出，需要刷新。易失性存储器，集成度高、价位低，容量大、功耗低，速度比SRAM慢，常用于主存。\n\nROM：只能读出，不能写入。非易失性存储器，可作为主存的一部分。\n\n## 3.2、什么是刷新周期，DRAM为什么要刷新，有几种刷新方式，SRAM要刷新吗\n\n刷新周期：从上一次刷新结束到下一次对整个DRAM全部刷新一遍为止，这段时间间隔称为刷新周期。\n\n为什么要刷新：DRAM利用存储元电路中的栅极电容上的电荷来存储信息，电荷一般只能维持1~2ms，所以信息会自动消失。\n\n刷新分为集中式、异步式、分散式。\n\n集中式：用一段固定时间依次对存储器所有行刷新。\n\n分散式：把对每一行的刷新分散到各个工作周期中。\n\n异步式：把对每行的刷新分散到一整个刷新周期中。\n\nSRAM使用双稳态触发器记忆信息，不需要刷新。\n\n## 3.3、Flash存储器有什么特点\n\n支持随机存取，非易失性存储器，集成度高，价格便宜，能快速擦写，写入前需要先擦，所以写比读慢。\n\n## 3.4、Cache有哪些映射方式\n\n直接映射：主存数据块只能装入Cache中唯一位置。\n\n全相联映射：可以装入Cache中任何位置。\n\n组相联映射：将Cache分为若干组，一个主存块可以装入一组内任何位置。\n\n## 3.5、Cache替换策略\n\n1、随机法（RAND）：随机确定块。\n\n2、先进先出（FIFO）：选择最早调入的换。\n\n3、最近最少使用（LRU）：近期最久没用过的。\n\n4、最不经常使用（LFU）：一段时间内最久没用过的。\n\n## 3.6、Cache写策略有哪些\n\n对于写命中\n\n1、全写法（写直通法）：必须同时写入Cache和主存。换出块时，用新块直接覆盖，不必将换出块写入内存。实现简单，保持数据正确性，但增加了访存次数，降低了效率。\n\n2、回写法：只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回内存。减少了访存次数，但存在不一致的隐患。\n\n对于写不命中\n\n1、写分配：写到Cache和主存中。\n\n2、非写分配：只写入主存。\n\n搭配：非写-全写，写-回写。\n\n## 3.7、Cache总容量包括哪些\n\n存储容量、标记阵列容量。\n\n标记阵列容量：有效位（1位）+标记位+一致性维护位（脏位，采用写回法时）+替换算法控制位（若无替换算法则无此位）。\n\n## 3.8、虚拟存储器\n\n（1）虚拟存储器概念 具有调入和扩充功能，能从逻辑上对内存容量加以扩充的一种存储器系统。\n\n（2）虚拟存储器管理方式 分为页式、段式、段页式。\n\n1、页式：虚拟空间和内存空间分成固定大小的页，虚拟页可以装入主存中不同的实际页面位置。页式管理由操作系统完成，对应用程序员透明。\n\n逻辑地址：虚页号+页内地址。 物理地址：页号+页内地址。 页表：页号+每页始址+装入位 等。\n\n2、段式：把主存按段划分管理，每个用户程序分到一个段，只能访问段所对应的主存空间。段长可以任意设定，并且可以放大和缩小。\n\n段表：段名+段起点+装入位+段长 等。段表本身也是一个段。\n\n3、段页式：先按逻辑分成段，再将每段分成若干个页，访存依靠一个段表和若干页表完成。段长必须是页长整数倍，段起点必须是某页起点。\n\n（3）分页分段系统比较，优缺点： 1、分页：内存分为固定的块，按物理结构划分，有内部碎片。\n\n2、分段：内存块大小不固定，按逻辑结构划分，有外部碎片。\n\n3、段页式：先分段后分页，有内部碎片。\n\n## 3.9、页表和快表\n\n页表（Page）：存放在主存中的虚页号和实页号的对照表，将虚页号变换成主存中实页号的内部地址。\n\n快表（TLB）：为了减少访存次数，将页表中最活跃的几个页表项复制到Cache中，这种Cache中的页表项组成起来就是快表。主存中的页表叫慢表。\n\nTLB是Page的一个很小的副本，所以TLB命中则Page一定命中。\n\n## 4.1、指令的基本格式，各字段作用\n\n操作码+地址码\n\n操作码：指出指令应该执行什么操作，有什么功能。\n\n地址码：给出被操作信息的地址或操作数本身，可以有多个地址码。\n\n## 4.2、相对寻址、基址寻址、变址寻址\n\n1、相对寻址：程序计数器（PC）+形式地址（假设为A，相对于PC所指地址的偏移量），所以有效地址为（PC）+ A。\n\n优点：便于一段代码在程序内部浮动，用于转移指令。\n\n2、基址寻址：将CPU中基址寄存器（BR，BR位数大于A的位数）+ A，即（BR）+\nA。基址寄存器面向操作系统，内容由操作系统确定，用户决定用哪个寄存器作为BR。\n\n优点：可以扩大寻址范围，用户不必考虑自己程序位于主存何处，有利于多道程序设计，可用于编制浮动程序。\n\n3、变址寻址：变址寄存器（IX）+\nA。IX可以是专用的变址寄存器，也可以是通用寄存器。变址寄存器面向用户，IX的内容可由用户改变（作为偏移量），A不变（作为基地址）。\n\n优点：可以设定A为数组首地址，不断改变IX，很容易遍历数组，适合编制循环程序。\n\n## 4.3、CISC与RISC\n\n![](https://img-\nblog.csdnimg.cn/img_convert/c7b3910335a9a96944688cc1ee981ed1.png)\n\n## 5.1、CPU的基本结构\n\n![来自王道](https://img-\nblog.csdnimg.cn/img_convert/d4353c9a713717f7d4c8c360ea5fba6d.webp?x-oss-\nprocess=image/format,png) ![](https://img-\nblog.csdnimg.cn/img_convert/902c2596d27a126fff77b5aaa6de5fc3.webp?x-oss-\nprocess=image/format,png)\n\n## 5.2、指令执行过程\n\n![](https://img-\nblog.csdnimg.cn/img_convert/f12545fa8bcaa8fdbf6456258053120d.webp?x-oss-\nprocess=image/format,png)\n\n## 5.3、CPU的功能\n\n指令控制、操作控制、时间控制、数据加工、中断处理。\n\n## 5.4、指令周期、机器周期、时钟周期\n\n指令周期：CPU从主存中取出并执行一条指令的时间。\n\n机器周期（CPU周期）：用从内存读取一条指令字的最短时间来表示。\n\n时钟周期：节拍，T周期，最基本单位。\n\n若干时钟周期表示一个机器周期，若干机器周期表示一个指令周期。\n\n## 5.5、控制器分为哪几种\n\n1、硬布线控制器：微操作控制信号由组合逻辑电路即时产生，即由硬件给出控制信号。\n\n特点：速度快；难以扩充和修改、结构复杂。\n\n2、微程序控制器：采用存储程序的原理，将微操作控制信号以微程序的形式存放在控制存储器中，一条机器指令对应一个微程序，执行指令时只需读出微程序执行，即由软件给出控制信号。\n\n特点：每条指令都要从控制存储器读取，速度慢；可以通过改变控制存储器内容进行扩充和修改，结构规整。\n\n## 5.6、微指令有哪些编码方式\n\n1、直接编码：微指令的控制字段中每一位代表一个微命令。选用或不选用只需将对应位设为1或0。\n\n特点：简单；指令字长太长，n个微命令就要n位操作字段。\n\n2、字段直接编码：将微命令字段分为几个小段，把互斥微命令放在同一段编码，把相容的放不同字段中，每种编码代表一个微命令。\n\n特点：每个小段中包含的信息位不能太多，否则将增加译码复杂性。每个小段需要留出一个状态，表示本字段不发出任何命令。\n\n3、字段间接编码：某些微命令需要另一段的微命令来表示。\n\n## 5.7、微指令和机器指令的关系\n\n一个程序由多条机器指令组成。一条机器指令对应一个微程序。一个微程序由若干条微指令构成。一条机器指令所完成的操作划分成若干条微指令来完成，由微指令进行解释和执行。\n\n一个微指令称为一个微周期，比如取指周期。只有在微程序控制器中，才有微命令的概念。硬布线控制器最小单位是微操作。\n\n## 5.8、影响（阻塞）指令流水线的因素\n\n1、结构相关：多条指令在同一时刻竞争同一资源形成冲突。\n\n解决方法：（1）后面的指令暂停一个时钟周期。（2）单独设置数据存储器和指令存储器。\n\n2、数据相关：必须等前一条指令执行完才能执行后一条指令，称这两条指令数据相关。\n\n解决方法：（1）把数据相关的指令和其后指令都暂停几个时钟周期，直到数据相关问题解决。（2）设置专用通路，直接把前一条指令的计算结果作为自己的输入开始计算。这被称为数据旁路技术。\n\n3、控制相关：流水线遇到转移指令和其他改变PC值的指令而造成断流。\n\n解决方法：（1）尽早生成转移目标地址。（2）预取转移成功和不成功两个控制流方向上的目标指令。（3）加快和提前形成条件码。（4）提高转移方向的猜准率。\n\n## 5.9、流水段越多，指令执行是否越快\n\n并不是，因为流水段缓冲之间的开销会增大，并且控制逻辑变多，更加复杂。\n\n## 6.1、总线的两种基本定时方式\n\n1、同步通信方式：系统采用一个统一的时钟信号来协调发送和接受双方的传送定时关系。\n\n2、异步通信方式：没有统一的时钟，依靠双方相互制约的握手信号来定时控制。分为不互锁、半互锁、全互锁。\n\n## 7.1、I/O端口的编址方式有哪些\n\n1、统一编址：把I/O端口当成存储器单元进行地址分配，采用统一的访存指令访问I/O端口。\n\n优点：不需要专门的I/O指令，可以使端口有较大的编址空间。\n\n缺点：占用了存储器地址，使内存变小，速度慢。\n\n2、独立编址：I/O端口地址与存储器无关，CPU设置专门的I/O指令访存端口。\n\n优点：编程简单清晰。\n\n缺点：I/O指令少，一般只能对端口操作。控制更复杂了。\n\n## 7.2、I/O方式有哪些\n\n1、程序查询方式：利用I/O测试指令测试设备的闲忙。若设备不忙，则执行输入输出指令；若设备忙，则I/O测试指令不断对该设备进行测试，直到设备空闲为止。实现简单，但CPU和IO设备只能串行工作，长期处于忙等状态，CPU利用率低。\n\n2、程序中断方式：引入中断之后，每当设备完成I/O操作，便以中断请求方式通知CPU，然后进行相应处理。但由于CPU直接控制输入输出操作，每传达一个单位信息（字），都要发生一次中断，因而消耗大量CPU时间。\n\n3、DMA方式：用于高速外部设备与内存之间批量数据的传输。CPU只需在传输开始时设置好所需的控制信息，由DMA控制器控制一个数据块的传输。当本次DMA传送的数据全部完成时才产生中断，请求CPU进行结束处理。\n\n## 7.3、程序中断的过程\n\n中断请求、中断判优、响应中断、中断隐指令、中断向量、中断处理\n\n中断隐指令：完成关中断、保存断点、引出中断服务程序。硬件完成。\n\n中断向量：中断服务程序的入口地址。\n\n## 7.4、中断处理过程\n\n![](https://img-\nblog.csdnimg.cn/img_convert/cd6f1b6e5210107880c55b92e6d965c0.webp?x-oss-\nprocess=image/format,png)\n\n## 7.5、DMA和主存访存的方式有哪些\n\n1、停止CPU访存。要求CPU放弃对相关总线的使用权。\n\n2、DMA和CPU交替访存。将一个CPU周期分为两个周期，分别给DMA和CPU，分时控制。\n\n3、周期挪用。DMA挪用一个或几个存取周期。\n\nDMA优先级会高于CPU，因为如果得不到及时响应，传输的数据可能会丢失。\n\n## 7.6、DMA方式和中断方式的区别\n\n1、中断方式是程序的切换，需要保护和恢复现场；而DMA除了预处理和后处理，其他时候不占用CPU资源。\n\n2、对中断请求的响应只能发生在每条指令执行完时；而对DMA请求的响应可以发生在每个机器周期结束时。\n\n3、中断传送过程需要CPU干预；而DMA传送过程不需要CPU干预。\n\n4、DMA优先级高于中断请求。\n\n5、中断方式能处理异常事件；而DMA只能I/O操作。\n\n6、中断方式靠程序传送数据；DMA靠硬件传送数据。\n\n## 7.6、设备管理应具备哪些功能\n\n1、状态跟踪：跟踪外设状态信息。\n\n2、设备存取：对设备的存取操作。\n\n3、设备分配：设备分配与回收。\n\n4、设备控制：设备驱动，故障处理。\n\n>\n> [https://zhuanlan.zhihu.com/p/616972168](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F616972168)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/597029757221462016?sourceSSR=users",
        "title": "小鹅通前端实习一面",
        "content": "全程30分钟左右，很考察基础\n\n  * 自我介绍\n  * 为什么前端学习\n  * 前端学习路径和途径\n  * html，css，JavaScript分别干什么\n  * html结构，每一部分干什么\n  * css样式怎么引入，有什么区别\n  * 选择器优先级\n  * 重绘和重排\n  * 用过什么标签\n  * div和span的区别\n  * div和p的区别\n  * input标签的属性，使用\n  * margin塌陷\n  * input的type属性\n  * input中name和value的作用\n  * 怎么把导航栏固定在顶部\n  * 问项目，怎么回显\n  * axios\n  * promise，状态能不能改\n  * 本地存储，区别\n  * 学vue有什么困难\n  * 组件的理解\n  * 反问\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/597026840561070080?sourceSSR=users",
        "title": "超星 面经2（好杂）",
        "content": "上次以为答得稀巴烂没过，没想到过了，这次问了好多杂七杂八的聊天向，差不多面了一个小时，有些记不太清了\n\n  1. 自我介绍\n  2. 询问之前游戏实习的细节问题\n  3. 策划游戏和其他产品的区别\n  4. 对超星产品有什么建议和改进的地方\n  5. 线上和线下课程的区别（说了互动性不足的缺点）\n  6. 如何改进线上的互动性\n  7. ai的了解\n  8. ai运用教育产品\n  9. 如何将游戏与教育产品结合，娱乐化学习\n  10. 产品的重要技能有哪些\n  11. 我自己认为匹配产品的点\n  12. 如果让我设计一个产品，流程是什么\n  13. 校园中他人对我的印象\n  14. 校内成绩如何\n  15. 还有什么问题（总算反问了，上次都没反问环节，把我整汗流浃背了）\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/597018804786348032?sourceSSR=users",
        "title": "阿里云原厂 一面 58min 还有一个码面",
        "content": "  1. Spring cloud 具体有哪些东西，怎么通信的？NacosOpenfeign网关 spring cloud gateway限流降级分布式锁\n  2. openfeign基于什么协议？怎么判断是TCP？url,肯定是http。\n  3. 负载均衡怎么做的？\n  4. 替换负载均衡器，怎么做？用自己定义的负载均衡，怎么做？\n\n5\\. 调用远程服务的时候，怎么找到远程服务啊？网关根据url的正则表达式匹配寻找到服务，然后由nacos根据服务去找到url\n\n6\\. 有没有了解过dubbo？dubbo是一个RPC框架，没有那么重，可以使用dubbo进行通信，注册中心是zookeeper。Spring Cloud\n的功能很明显比 Dubbo 更加强大，涵盖面更广，是微服务的一站式解决方案，通信是openfeign，注册中心可以是nacos,\n\n7\\. MQ解耦具体指什么呢？为什么使用MQ，使用http调用会有什么问题？\n\n8.分布式锁用什么实现的？\n\n  1. 如果不用redission，redis怎么实现的？setnx，hash的属性，（可重入实现）\n  2. setnx可以设为先查，再set,吗？为什么？\n  3. Xxl-job 是做什么的？\n  4. 失败上链的补偿操作。\n  5. 为什么不用spring的schedule？\n  6. 分布式组件，可能存在多线程冲突问题。\n  7. 分布式锁和xxl-job有配合吗？\n  8. spring的schedule+分布式锁也可以解决，为什么不用？\n  9. ws是哪一层协议，？应用层。\n  10. 第三方登录，登录完成之后，下一次请求怎么知道原来这个用户在使用。token\n  11. 有做跨站攻击的保护？\n  12. XSS攻击就是 添加一些代码嵌入到页面中。用户访问的时候就会执行这个代码。解决1. 前端，可以将重要的cookie标记为httponly,这样cookie就不会被访问到了。2. 后端，可以对用户输入的数据做一个过滤，或者对输入进行一个转义，确认数据内容是否为只包含数字、字母和空格符\n  13. CSRF攻击。攻击者获取到用户的cookie然后去访问正常的网站，比如说请求转账。解决；1. 验证http 的referer字段，该字段记录http请求的来源地址。2. 为每个表单添加令牌token并验证。\n  14. SQL注入1. 对用户的输入做一个校验，使用正则表达式过滤传入的参数。2. 使用参数化语句，不要拼接sql3. 重要信息加密。\n  15. minIO自己搭的吗？只是使用了？\n  16. 数据中台有多少数据？一天有几万条数据。最终的数据会汇集到mysql数据吗？\n  17. 是否支持批量？\n  18. 单表的效率很低，同步数据要同步多久？\n  19. 有自动映射吗？批量、自动化（同名映射，不同名自己去选）、（数据策略）定期、增量、\n  20. 周期增量同步怎么做的？实现了scheduleconfigure接口。最大的ID。\n  21. 怎么判断当前表是否有同步过？\n  22. 对于一样的源表，是不能在这里出现多次的。如果说想要重新同步，就需要修改，具体是修改什么？\n  23. 大数据的同步不止有数据，还有同步的过程，自定义函数、班栈。大数据相关的体系。\n  24. docker的原理了解吗？ 其他服务怎么去访问到docker里面的服务？端口映射怎么实现的？怎么映射过去，不同网络类型，有几种实现方式，网桥的实现方式。\n  25. mysql数据库存了多少数据。每天几万条。\n  26. 数据量很大，还要存储数据库表的信息，怎么考虑。怎么去做性能优化？\n  27. 不停增长的数据量怎么控制？怎么优化？\n  28. 优化可以做一个冷热数据分离。数据迁移到不同的库。\n  29. 表和字段的信息呢？数据量？\n  30. 数据字段的表怎么办？不停增加新的数据源。\n  31. 怎么做索引？\n  32. 经常where order group\n  33. 字符串前缀索引\n  34. 覆盖索引\n  35. 联合索引。\n  36. 如果有索引没有达到预期，怎么分析这个索引？\n  37. Explain分析。\n  38. 你能分析一下Explain里面的关键字段？\n  39. 使用了索引一定会快吗?\n  40. 执行计划可以再去理解一下，还有其他场景。命中索引不一定快，全索引扫描也不一定快。命中索引的级别，级别高才会快，还有额外的信息。下推，回表。\n  41. map,hashmap hashtable concurrenthashmap的区别\n  42. 字符串拼接，+ ,stringbuilder ，stringbuffer 有什么区别？\n  43. 深拷贝和浅拷贝。A=list<Object>,B=A ，C=A的浅拷贝、D的深拷贝。B C D怎么变？B和C有什么区别？\n  44. 如果说我要并发写mysql，怎么解决这个数据错乱问题？使用行锁，加锁。\n  45. 反问\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/597000574252400640?sourceSSR=users",
        "title": "【OD统一考试机试C卷】构成指定长度字符串的个数",
        "content": "> OD统一考试（C卷）\n>\n> 分值： 100分\n>\n> 题解： Java / Python / C++\n\n![](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n# 题目描述：构成指定长度字符串的个数 (本题分值100)\n\n给定 M（0 < M ≤ 30）个字符（a-z），从中取出任意字符（每个字符只能用一次）拼接成长度为 N（0 < N ≤ 5）的字符串，\n\n要求相同的字符不能相邻，计算出给定的字符列表能拼接出多少种满足条件的字符串，\n\n输入非法或者无法拼接出满足条件的字符串则返回0。\n\n# 输入描述\n\n给定的字符列表和结果字符串长度，中间使用空格(\" \")拼接\n\n# 输出描述\n\n满足条件的字符串个数\n\n# 用例1\n\n输入\n\n    \n    \n    aab 2\n    \n    \n\n输出\n\n    \n    \n    2\n    \n    \n\n说明\n\n只能构成ab,ba。\n\n# 用例2\n\n输入\n\n    \n    \n    abc 2\n    \n    \n\n输出\n\n    \n    \n    6\n    \n    \n\n说明\n\n可以构成：ab ac ba bc ca cb 。\n\n# 解题思路\n\n使用递归和回溯的思想来生成不同的字符串。具体的逻辑如下：\n\n  1. 首先，我们定义一个函数generateDistinctStrings，这个函数接收以下参数：可用字符集s，目标字符串长度length，当前已生成的字符串current，已生成的结果集result，以及一个标记数组used，用来记录每个字符是否已被使用。\n  2. 在generateDistinctStrings函数中，首先检查当前已生成的字符串current的长度是否等于目标长度length。如果等于，说明我们已经生成了一个满足长度要求的字符串，将其添加到结果集result中，然后返回。\n  3. 如果当前字符串current的长度还未达到目标长度length，我们就需要继续添加字符。此时，我们遍历可用字符集s中的每一个字符。对于每一个字符，我们首先检查它是否已经被使用（通过查看used数组），以及它是否与current的最后一个字符相同。如果字符已经被使用，或者与current的最后一个字符相同，我们就跳过这个字符，继续检查下一个字符。\n  4. 如果一个字符未被使用，且与current的最后一个字符不同，我们就将它添加到current的末尾，然后标记这个字符为已使用，接着递归调用generateDistinctStrings函数，以生成下一个字符。\n  5. 在递归调用返回后，我们需要取消对当前字符的使用标记，以便在后续的遍历中可以再次使用这个字符。这就是回溯的思想，即撤销之前的选择，尝试其他的选择。\n\n以下是对应的中文伪代码：\n\n    \n    \n    函数 generateDistinctStrings(s, length, current, result, used)\n        如果 current的长度 等于 length\n            将 current 添加到 result\n            返回\n        对于 s中的每一个字符 c\n            如果 c已被使用 或者 c与current的最后一个字符相同\n                继续下一次循环\n            标记 c为已使用\n            generateDistinctStrings(s, length, current + c, result, used)\n            取消标记 c的使用状态\n    \n    \n\n# C++\n\n    \n    \n    #include <iostream>\n    #include <unordered_set>\n    #include <vector>\n    #include <sstream>\n    \n    using namespace std;\n    \n    // 递归生成满足条件的不同字符串\n    void generateDistinctStrings(string s, int length, string current, unordered_set<string>& result, vector<bool>& used) {\n        // 当生成的字符串长度等于指定长度时，将其加入到结果集中\n        if (current.length() == length) {\n            result.insert(current);\n            return;\n        }\n    \n        // 遍历字符串中的字符\n        for (int i = 0; i < s.length(); i++) {\n            // 判断字符是否已经被使用，或者当前字符与前一个字符相同\n            if (used[i] || (current.length() > 0 && current.back() == s[i])) {\n                continue;  // 如果字符已被使用或与前一个字符相同，则跳过当前字符\n            }\n            used[i] = true;  // 标记当前字符为已使用\n            // 递归调用生成下一个字符\n            generateDistinctStrings(s, length, current + s[i], result, used);\n            used[i] = false;  // 取消标记当前字符的使用状态，以便下一次遍历\n        }\n    }\n    \n    // 计算满足条件的不同字符串的数量\n    int countDistinctStrings(string s, int length) {\n        // 创建一个集合来存储不同的字符串\n        unordered_set<string> distinctStrings;\n        // 创建一个列表来标记字符串中的字符是否已经被使用\n        vector<bool> used(s.length(), false);\n        // 调用generateDistinctStrings方法生成满足条件的不同字符串\n        generateDistinctStrings(s, length, \"\", distinctStrings, used);\n        // 打印生成的所有不同的字符串\n        // for (auto& str : distinctStrings) {\n           // cout << str << endl;\n        // }\n        // 返回不同字符串的数量\n        return distinctStrings.size();\n    }\n    \n    int main() {\n        string input;\n        getline(cin, input);\n        // 将输入的字符串按空格分割为两部分，分别为字符串和长度\n        string str;\n        int length;\n        istringstream iss(input);\n        iss >> str >> length;\n    \n        // 调用countDistinctStrings方法计算满足条件的不同字符串的数量\n        int count = countDistinctStrings(str, length);\n        // 输出计算结果\n        cout <<  count << endl;\n    \n        return 0;\n    }\n    \n    \n    \n    \n    \n    \n\n# Java\n\n    \n    \n    import java.util.*;\n    \n    public class Main {\n        public static void main(String[] args) {\n            // 创建一个Scanner对象来读取用户的输入\n            Scanner sc = new Scanner(System.in);\n            // 读取用户输入的字符串\n            String input = sc.nextLine();\n            // 将输入的字符串按空格分割为两部分，分别为字符串和长度\n            String[] parts = input.split(\" \");\n            String str = parts[0]; // 获取输入的字符串\n            int length = Integer.parseInt(parts[1]); // 将输入的长度部分转换为整数\n    \n            // 调用countDistinctStrings方法计算满足条件的不同字符串的数量\n            int count = countDistinctStrings(str, length);\n            // 输出计算结果\n            System.out.println(count);\n        }\n    \n        // 计算满足条件的不同字符串的数量\n        public static int countDistinctStrings(String str, int length) {\n            // 创建一个HashSet来存储不同的字符串\n            HashSet<String> set = new HashSet<>();\n         \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596995724563197952?sourceSSR=users",
        "title": "2024.3.11 腾讯游戏技术运营一面凉",
        "content": "投的后台开发实习岗但被游戏技术运营的春招岗捞起来面试了。\n\n  1. 有没有百度了解过这个岗位？\n  2. 自我介绍\n  3. 科研方向的介绍\n  4. 对 java 了解多少？\n  5. 对 spring 有了解吗？你觉得它的优势在哪里？能够帮助你解决什么问题？\n  6. 对 spring 的 Ioc 和 Aop 有了解吗？知道基本的原理吗？\n  7. React 整体的生命周期是什么样的？\n  8. Swagger 怎么与项目代码进行集成的？怎么使用它解决项目中的问题的？\n  9. 项目中全局跨域是指什么呢？怎么解决的？\n  10. 快排的基本思想是什么？算法的复杂度是多少？快排算法有没有什么优化的空间？\n  11. 之前学习的数据结构在用 java 代码开发项目的时候有没有被运用到？\n  12. 讲一讲 Arraylist 和 LinkedList。Arraylist 的底层实现是什么？\n  13. 对 Linux 系统有了解吗？\n  14. 对容器、k8s、kubernetes 相关的有了解吗？\n  15. docker 如何彻底删除一个进程？\n  16. 有没有什么想问的问题？\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/597017651591819264?sourceSSR=users",
        "title": "阿里云网络 一面3.4 30min",
        "content": "一面\n\n  1. 简单说一个项目，重点讲亮点。\n  2. 亮点是区块链存储吗？\n  3. 项目是一个人，还是多人合作？你是项目负责人？\n  4. 你是自己写？还是有人带你写？\n  5. 当你接到一个很大的项目？如何从需求转换为落地的一个plan 首先就是对整个项目有一个宏观的认识，分成大的模块。 自己对需求进行消化。 周会和小组其他人沟通对接模块对外的需求 整合上述两部分，制定一个排期。按照整个项目的时间，任务的紧急程度。 从某一个项目来说。首先就是进一步消化需求，画一个流程图。思考主要的问题以及大致上的解决方案。 设计数据库表，写代码。在这个过程及时和同学们沟通。 比如说区块链分为，区块链工具类->自己系统->日志统计分析\n  6. 区块链除了消息的转发，有业务层面的东西吗？\n  7. 数据在线上上链失败的场景？有哪些原因？你是怎么定位的？\n  8. 第三方接口失败了。\n  9. 消息队列堆积满了，要么就扩容，要么就清理文件。 1\\. 文件堆积，可以考虑消费的速度太小了，要不就增加消费者的数量。\n  10. 消息队列服务宕机。\n  11. 调用方调用失败了，调用方是不知道的。那你怎么处理数据上链失败，退回的机制是怎么做的？ 数据上链的过程：先存表、上链、修改表的状态。 如果失败了，则启动定时任务定期检测对失败的数据进行上链。\n  12. 消息队列是你内部的通道，还是对外使用的？\n  13. 内部调第三方接口失败了，会怎么处理？为什么？ 直接写入数据库失败，定时任务补偿。 为什么不考虑调用第三方也使用消息队列呢？第三方提供的是接口。\n  14. 应用服务器是1台还是2台？\n  15. 那你怎么保证两台数据不会对数据进行一个重复的上链？ 使用分布式锁。\n  16. 分布式锁怎么实现的？有没有看过redission的底层，锁的冲突怎么解决的？ 使用setnx+删除key。锁续期\n  17. 两台机器都要上链，一台机器拿到了锁，另一台机器怎么去知道别的机器拿到了锁，怎么去结束这个等待？ 我设置了一个trylock方法。等待时间没有获取就异常。\n  18. 用锁去决定。锁的主键的设计，不能有冲突？锁的key是怎么设计的？ 区块链前缀+业务类型+业务key\n  19. Redissionclient 有注解的方式，有使用过吗？\n  20. transaction注解用过吗？注解生效的原理和机制了解吗？程序编译后的机制。 AOP\n  21. service接口里的a方法加了transaction注解，b方法调用a方法（没有加事务注解）。使用b方法，那b方法里面的a方法是否还有事务。为什么事务失效了？\n  22. map如何保证key是有序的？ 将key抽取出来，然后对key进行排序，遍历，获取其对应的值。\n  23. linkedhashmap用过吗？在哪里用的？\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596985226115538944?sourceSSR=users",
        "title": "字节跳动前端一面解析（关键问题）",
        "content": "嗨～我是可拟雀，一个全栈开发工程师，毕业于某985大学，目前供职于bat某大厂核心部门后端。每天分享最新面经答案，希望在大环境不好的当下能帮到你，让你多积累面试经验。免费分享个人学习2个月速通大厂路线（请看认证标），需要面经合集的请私信我～\n\n1\\. 为什么选择学习前端\n\n2\\. PC端和移动端项目CSS的适配区别\n\n答：设备屏幕尺寸和分辨率：PC端设备通常有较大的屏幕尺寸和较高的分辨率，而移动端设备则屏幕尺寸较小，分辨率也相对较低。因此，在CSS适配时，移动端项目需要更多地考虑屏幕适配和分辨率适配，以确保页面在不同设备上的显示效果一致。\n\n浏览器兼容性：PC端项目需要考虑各种浏览器的兼容性，包括IE、Firefox、Chrome等。而移动端项目则主要关注主流移动设备上的浏览器，如Chrome、Safari和Android的默认浏览器等。因此，在编写CSS时，移动端项目可能不需要考虑像PC端那样多的浏览器兼容性问题。\n\n交互方式：PC端通常使用鼠标和键盘进行交互，而移动端则主要通过触摸屏幕进行交互。因此，在移动端项目中，CSS可能需要更多地考虑触屏事件的处理，如点击、滑动等。\n\n动画和特效：由于移动端设备的性能相对较弱，因此在处理动画和特效时，移动端项目可能需要更多地考虑性能和效率。一般来说，移动端项目更倾向于使用CSS3来实现动画和特效，因为CSS3具有更高的效率和更好的兼容性。\n\n3\\. rem是怎么设置的，手动算的还是用了库\n\n4\\. rem和em的区别？\n\n相对性质：rem是相对于根元素（通常是元素）的字体大小，而em是相对于父元素的字体大小。这意味着，如果你改变了根元素的字体大小，所有使用rem单位的元素都将相应地调整大小。而对于使用em单位的元素，只有当其父元素的字体大小改变时，它们的大小才会改变。利用这个性质可以结合响应式设计思考。\n\n计算方式：rem单位的大小是相对于根元素的字体大小的倍数，而em单位的大小是相对于父元素的字体大小的倍数。因此，使用rem单位进行单位换算时，只需要知道根元素的字体大小即可。而使用em单位时，需要逐级计算每个父元素的字体大小。\n\n简洁性和可维护性：使用rem单位可以简化样式表的编写，因为只需要设置根元素的字体大小，其他元素的大小都可以使用rem单位进行计算。这使得页面的维护更加方便。而使用em单位时，需要逐级设置每个父元素的字体大小，这可能会增加维护的复杂性。\n\n响应式设计：由于rem单位的相对性质是固定的，因此在实现响应式设计方面，rem单位具有更大的优势。只需要在根元素上设置字体大小，就可以影响整个页面的尺寸。而em单位则需要考虑父元素的字体大小，这在实现响应式设计时可能会更加复杂。\n\n兼容性：rem单位在一些旧版本的浏览器中不被支持，而em单位在所有浏览器中都被支持。因此，在使用rem单位时，需要考虑浏览器的兼容性。\n\n5\\. 屏幕大小变化的时候是如何适配的？\n\n多套资源适配：为不同尺寸和密度的屏幕提供多套可选的资源文件，确保应用在各种设备上都有良好的显示效果。\n\n响应式布局：页面元素的位置和大小随屏幕尺寸变化而变化，通常使用百分比定位，预留可压缩空间以适应不同屏幕。\n\n背景图像适配：采用Cover或Contain布局，保持图像宽高比，确保背景图像在各种屏幕上都能合适显示。\n\nFlexbox或Grid布局：使用这些现代CSS布局技术，可以轻松调整元素的对齐、方向和顺序，或定义复杂的行和列结构，以适应不同屏幕尺寸。\n\n6\\. 直接写rem计算屏幕的宽高是怎么获取的\n\n先确定一个基准字体大小（通常是 16px），这将作为 rem 计算的基准。\n\n确定一个比例，该比例将用于计算根元素字体大小与视口宽度的关系。\n\n创建一个函数（如 setRootFontSize），用于计算并设置根元素（<html>）的字体大小。\n\n在这个函数中，获取当前视口的宽度（window.innerWidth）。\n\n使用定义的比例和基准字体大小来计算新的字体大小。\n\n将计算出的字体大小应用到根元素上，使用 CSS 的 fontSize 属性。\n\n初始化设置：\n\n在页面加载完成后（window.onload），调用该函数来设置初始的根元素字体大小。\n\n监听窗口变化：\n\n添加事件监听器，以便在窗口大小发生变化时（resize 事件）重新调用上述函数，更新根元素的字体大小。\n\n7\\. 其他移动端适配的方法？\n\n一般来说rem+@media比较不错的一个方案了。\n\n9\\. 逻辑像素和物理像素的区别\n\n10\\. 浏览器渲染是如何解析渲染html文档的\n\n11\\. css下载的过程会阻塞js的下载吗\n\n12\\. 为什么阻塞？\n\n13\\. 项目性能优化的方式\n\n14\\. tree shaking的限制条件？比如模块化方式commonJS或ES6module的方法能实现吗\n\n15\\. 原生JS 类的实现方法，比如new一个函数的过程\n\n16\\. ES6的class编译完成后产物是什么样的，比如是函数or对象or数组\n\n17\\. 可以用var a = new\n\n18\\. ES6中继承的原理？\n\n19\\. 原型链\n\n20\\. function的prototype是什么\n\n21\\. 闭包原理\n\n22\\. ES5有哪些作用域，ES6呢\n\n23\\. 项目中用过的异步方法怎么实现的\n\n24\\. promise传的参数(resolve，reject)执行时机是异步还是同步的？\n\n答：同步的。\n\n25\\. 函数里有error会怎么样？\n\n答：可以在外层catch或者then第二个参数处理\n\n26\\. 必须catch吗，用then呢。\n\n27\\. then后面再有then，是会进入resolve还是reject的回调\n\n28\\. async await原理？\n\n当一个函数被标记为 async 时，它总是返回一个 Promise 对象。这意味着你可以在 async 函数内部使用 return\n语句返回一个值，这个值会被 Promise 对象解析，并且可以使用 then 方法添加回调函数来处理这个值。如果 async\n函数内部抛出一个错误，那么返回的 Promise 对象会变为 reject 状态，并且这个错误对象会被 .then() 方法的第二个回调函数或者\n.catch() 方法回调函数接收。\n\nawait 关键字只能在 async 函数中使用。它会暂停 async 函数的执行，等待 Promise 对象的解析结果，并且返回这个结果。如果 await\n后面不是一个 Promise 对象，那么它会直接返回对应的值。如果 await 后面是一个非 Promise 对象，那么它会被转换为一个已解析的\nPromise 对象。\n\n29\\. await后面跟一个1或者字符串可以吗？\n\n答：可以，会转为Promise对象。\n\n30\\. Generator函数接触过吗？\n\n答：大家可以思考一下如何实现扩展运算符，就是用到这个的。\n\n31\\. 浏览器的Eventloop和node的Eventloop区别\n\n32\\. 提示：事件循环\n\n33\\. 异步任务挂起之后还可以给下一个用户提供服务吗，(挂起期间有新用户访问)？\n\n答：当异步任务挂起时，它不会阻止为下一个用户提供服务。异步任务的设计目标就是在不阻塞主线程的情况下执行操作，以便程序可以继续处理其他任务。\n\n当异步任务挂起时，通常是因为它在等待某些操作完成，比如等待网络请求、文件读写等。在等待期间，程序可以继续执行其他任务，包括为新的用户提供服务。\n\n在Web中，这种并发处理是非常常见的。当一个用户发起请求时，服务器可能会启动一个异步任务来处理该请求，然后在任务完成之前继续处理其他用户的请求。这样，服务器就可以高效地处理多个用户的并发请求，而不会出现阻塞或延迟的情况。\n\n所以node做后端其实很厉害，处理io密集的场景很不错。\n\n34\\. git用到哪些命令多一些\n\n35\\. merge用过吗\n\n36\\. 跨域问题如何解决\n\n37\\. 跨域请求的时候带cookie怎么带\n\n38\\. react 了解过吗，如果让你上手做可以做吗\n\n39\\. hook听过吗\n\n[免费专栏地址，每日更新，欢迎订阅](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgw-c.nowcoder.com%2Fapi%2Fsparta%2Fjump%2Flink%3Flink%3Dhttps%253A%252F%252Fwww.nowcoder.com%252Fcreation%252Fmanager%252FcolumnDetail%252FMJ4LAm)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596991340550938624?sourceSSR=users",
        "title": "2024.3.9 美团暑期实习第一场笔试",
        "content": "图片转自小红书：[https://www.xiaohongshu.com/explore/65ec038500000000030354ab](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.xiaohongshu.com%2Fexplore%2F65ec038500000000030354ab)\n\n# 第一题\n\n![](https://uploadfiles.nowcoder.com/images/20240314/235802090_1710388687880/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n100%\n\n# 第二题\n\n![](https://uploadfiles.nowcoder.com/images/20240314/235802090_1710388713656/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n![](https://uploadfiles.nowcoder.com/images/20240312/235802090_1710205678878/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n16.67%\n\n# 第三题\n\n![](https://uploadfiles.nowcoder.com/images/20240314/235802090_1710388806861/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n0%\n\n# 第四题\n\n![](https://uploadfiles.nowcoder.com/images/20240314/235802090_1710388828078/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n![](https://uploadfiles.nowcoder.com/images/20240312/235802090_1710205760115/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n26.67%\n\n# 第五题\n\n![](https://uploadfiles.nowcoder.com/images/20240314/235802090_1710388853383/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n![](https://uploadfiles.nowcoder.com/images/20240312/235802090_1710205813631/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n0%\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596975450232991744?sourceSSR=users",
        "title": "腾讯云一面凉经解析",
        "content": "嗨～我是可拟雀，一个全栈开发工程师，毕业于某985大学，目前供职于bat某大厂核心部门后端。每天免费分享最新面经答案，希望在大环境不好的当下能帮到你，让你多积累面试经验。免费分享个人学习2个月速通大厂路线（请看认证标），需要面经合集的请私信我～\n\n1:2道算法 LRU和二进制求和\n\n2:为什么要用中间件\n\n答：解耦：中间件能够将应用程序的不同部分隔离开来，使得各部分之间的依赖关系降低，从而实现解耦。这样，当某一部分发生变化时，不会影响到其他部分，提高了系统的可扩展性和可维护性。\n\n抽象化：中间件能够提供一种抽象化的机制，将底层操作系统的复杂性屏蔽掉，使得应用程序开发人员能够面对一个简单而统一的开发环境。这样，开发人员就可以专注于自己的业务逻辑，而不需要关心底层的细节。\n\n功能扩展：中间件可以方便地添加新的功能，而不需要修改原有的应用程序代码。例如，可以通过添加新的中间件来实现身份验证、授权、日志记录等功能。\n\n提高性能：一些中间件，如缓存中间件、消息队列中间件等，可以提高系统的性能。缓存中间件可以减少对数据库的访问次数，消息队列中间件可以实现异步处理，从而提高系统的响应速度和吞吐量。\n\n统一接口：中间件可以在不同的技术组件之间提供一个统一的接口层，使得系统各部分能够无缝协作，实现跨系统的数据交换和通信。\n\n3:为什么要用redis\n\n高性能：Redis基于内存存储数据，因此其读写速度远超许多传统的关系型数据库，如MySQL。这使得Redis在处理大量数据时能够提供非常快的响应速度。\n\n丰富的数据结构：Redis支持多种数据结构，如字符串、哈希、列表、集合、有序集合等。这些丰富的数据结构可以满足开发过程中各种常见的数据存储需求。\n\n易扩展：Redis支持分布式集群化扩展，这使得它能够在需要处理大量数据时保持高可用性和稳定性。同时，Redis的扩展性极高，只要硬件支持，就可以支撑大量的数据吞吐。\n\n缓解数据库压力：通过将部分数据存储在Redis中，可以作为缓存层，减少对关系型数据库的访问压力。当需要读取数据时，可以先判断Redis中是否有缓存，如果有则直接从Redis中读取，如果没有再去请求数据库，并将数据加入Redis缓存，这样可以大大提高系统访问效率。\n\n持久化保证数据安全性：虽然Redis主要基于内存存储，但它也支持数据持久化，可以将数据写入磁盘，从而在一定程度上保证数据的安全性。\n\n4:你知道redis的底层实现原理吗？\n\n答：先从数据结构回答。可以参考上文。\n\n内存管理：Redis使用jemalloc作为默认的内存分配器，它提供了高效的内存分配和回收机制，可以减少内存碎片和提高内存利用率。此外，Redis还支持内存共享，即多个键值对可以共享相同的值对象，以减少内存占用。\n\n持久化：Redis支持两种持久化方式，即RDB（快照）和AOF（追加日志文件）。RDB是在指定的时间间隔内生成数据集的时间点快照，它可以将数据持久化到磁盘上。AOF则是记录服务器接收到的所有写操作命令，并在服务器启动时通过重新执行这些命令来重建数据集。这两种持久化方式可以单独使用，也可以同时使用，以保证数据的可靠性和完整性。\n\n网络IO：Redis使用单线程模型处理网络IO，这避免了多线程之间的竞态条件和锁开销，从而提高了性能。Redis使用epoll作为默认的IO多路复用技术，它可以高效地处理大量的并发连接和请求。\n\n5:Java线程池的原理？\n\nJava线程池的工作原理主要涉及到两个核心组件：工作线程和任务队列。\n\n当一个新任务被提交到线程池时，线程池会首先检查当前运行的线程数是否少于核心线程数。如果是，那么线程池会创建一个新的工作线程来执行任务，即使其他工作线程处于空闲状态。\n\n如果当前运行的线程数等于或超过核心线程数，线程池会将新提交的任务放入任务队列中。这个队列是一个阻塞队列，用于在执行之前存储任务。\n\n如果任务队列已满，但运行的线程数少于最大线程数，线程池会创建新的线程来处理任务。\n\n如果任务队列已满，且运行的线程数已达到最大线程数，线程池会根据其拒绝策略来处理无法执行的任务。\n\n6:线程池怎么调度线程的？\n\n提交任务：当有新任务提交到线程池时，线程池会首先检查当前运行的线程数是否少于核心线程数。\n\n核心线程处理：如果当前运行的线程数少于核心线程数，线程池会创建新的工作线程来处理任务。即使其他核心线程处于空闲状态，也会创建新线程来处理新任务。\n\n任务队列存储：如果当前运行的线程数等于或超过核心线程数，线程池会将新提交的任务放入任务队列中。任务队列是一个阻塞队列，用于在执行之前存储任务。\n\n非核心线程处理：如果任务队列已满，但运行的线程数少于最大线程数，线程池会创建新的线程（非核心线程）来处理任务。\n\n拒绝策略：如果任务队列已满，且运行的线程数已达到最大线程数，线程池会根据其拒绝策略来处理无法执行的任务。拒绝策略可以是抛出异常、直接丢弃任务、丢弃队列中最旧的任务或执行其他自定义策略。\n\n线程回收：当线程完成任务后，它会变成空闲状态。如果线程池中的线程数量超过核心线程数，并且这些线程在一段时间内（如60秒）没有执行任务，那么这些非核心线程会被销毁，以节省系统资源。\n\n学习的时候应该思考java中的几种线程池及区别。如何用到不同类型的任务队列？核心线程和最大线程的数量关系？都应该能秒答。\n\n[免费专栏地址，每日更新，欢迎订阅](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgw-c.nowcoder.com%2Fapi%2Fsparta%2Fjump%2Flink%3Flink%3Dhttps%253A%252F%252Fwww.nowcoder.com%252Fcreation%252Fmanager%252FcolumnDetail%252FMJ4LAm)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596865907796787200?sourceSSR=users",
        "title": "腾讯后台开发暑期实习一面｜讲解｜0312",
        "content": "最近腾讯火力全开，收到面试邀请的同学也很多，没有收到面试的同学也不用太焦虑，暑期实习说是金3银4，但根据往年状态来看，56月都是有机会的，很多同学也在那个时候才找到实习的。所以不用焦虑，随时做好准备就行,\n大家加油～～\n\n那我们今天继续挑选一篇腾讯的后台开发实习一面，给大家做**讲解分析，参考回答和学习资料指引** ，期望对大家有所帮助～\n\n**考察重点：Redis+计算机网络**\n\n>\n> [原贴链接](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F596743063414816768)\n>\n>\n> ![alt](https://uploadfiles.nowcoder.com/images/20240312/7538287_1710175290069/D2B5CA33BD970F64A6301FA75AE2EB22)\n> ![alt](https://uploadfiles.nowcoder.com/images/20240312/7538287_1710175308095/D2B5CA33BD970F64A6301FA75AE2EB22)\n> **感谢这位同学的分享，预祝顺利offer！！**\n\n## 1.Redis:说一下如何解决缓存穿透，缓存击穿（缓存雪崩）\n\n**解析：** 缓存本省是一个优化利器，也是面试当中的重点。引入缓存之后，缓存本身也会带来一些问题，缓存穿透、缓存击穿就是需要解决的问题。\n\n**参考回答：**\n\n> **缓存穿透**\n> ：指查询一个一定不存在的数据，由于缓存不命中时需要从数据库查询，而数据库中也无此数据，因此无法写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，给数据库带来压力。对于恶意利用此漏洞的攻击，甚至可能压垮数据库。其**解决方案**\n> 包括但不限于：\n>\n>   1. 对查询的key进行合法性校验，比如长度、格式等，对不合法的key直接拒绝服务。\n>   2. 对不存在的key也进行缓存，设置一个较短的过期时间即可。\n>   3. 使用布隆过滤器，将所有可能存在的key预先加载到过滤器中，在查询前先进行过滤，如果不存在则直接返回，避免对数据库的查询。\n>\n\n> **缓存雪崩** ：当缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至宕机。**解决方案** 包括：\n>\n>   1. 给缓存的失效时间加上一个随机值，避免集体失效。\n>   2. 使用互斥锁，当缓存失效的时候，不是立即去load\n> db，而是先使用缓存工具的某个机制，比如Redis的SETNX去设置一个锁，当操作返回成功时，再去load db并放入缓存；否则，就重试获取缓存值。\n>   3. 采用双缓存策略，即设置两级缓存，原始缓存和拷贝缓存，原始缓存失效时，可以访问拷贝缓存，原始缓存与拷贝缓存，定期同步数据，保证一致。\n>\n\n> **缓存击穿**\n> ：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。其**解决方案**\n> 包括：\n>\n>   1. 设置热点数据永远不过期。\n>   2. 使用互斥锁，当缓存失效的时候，不是立即去load\n> db，而是通过缓存工具的某个机制（如Redis的SETNX）去设置一个锁，当操作返回成功时，再去load db并放入缓存；否则，就重试获取缓存值。\n>\n\n**学习指引**\n\n面试学习：\n[《小林Coding》｜什么是缓存雪崩、击穿、穿透？](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxiaolincoding.com%2Fredis%2Fcluster%2Fcache_problem.html%23%25E7%25BC%2593%25E5%25AD%2598%25E9%259B%25AA%25E5%25B4%25A9)\n\n## 2.Mysql:项目中用到了数据库分区，讲一下分区分表\n\n  1. 你知道idb,frm都存储什么吗？\n  2. 分区类型有哪些？\n  3. 分区的优缺点？ **解析：** 考察Mysql分区分表，需要掌握，另外还有分库等相关概念也要一起掌握。 **参考回答：**\n\n> **讲一下分区分表**\n>\n> **1\\. 分区**\n>\n>   * **概念：** 分区是将一个大表在物理上分割成多个较小的、更易于管理的片段，但从逻辑上来看，它们仍然被视为同一个表。\n>   * **类比理解：**\n> 你可以想象一个大书架，上面摆满了书，很难管理。如果我们将这些书按照类别（比如小说、历史、科学等）分到不同的小书架上，每个小书架就更容易管理了。这就是分区的基本思想。\n>   * **示例：** 假设有一个销售表，记录了多年的销售数据。我们可以按照年份进行分区，这样查询某一年的数据时，只需要扫描该年份的分区即可。\n>   * **实现**\n> ：在分区策略中，尽管表在物理存储上被分成了多个部分（每个部分有自己的.ibd文件），但在逻辑上它们仍然被视为一个整体，并且只与一个.frm文件相关联（**1个.frm文件对应多个.ibd文件**\n> ）\n>\n\n>\n> **2\\. 分表**\n>\n>   * **概念：** 分表是将一个大表拆分成多个具有相同结构的小表，每个小表存储不同的数据子集。\n>   * **类比理解：** 这有点类似于将一个大班级分成多个小班，每个小班管理起来更加容易。\n>   * **示例：** 假设有一个用户表，用户数量巨大。我们可以按照用户ID的范围进行分表，比如用户ID 1-1000在表1，用户ID\n> 1001-2000在表2，以此类推。\n>   * **实现**\n> ：在分表策略中，每个分表都有自己独立的.frm和.ibd文件，这些分表在逻辑和物理存储上都是完全独立的。（**1个.frm文件对应1个.ibd文件**\n> ）\n>\n\n> **你知道idb,frm都存储什么吗？**\n>\n>   * .frm文件用于存储表的结构定义，包括列名、数据类型等\n>   * .ibd文件用于存储表的数据和索引\n>\n\n> **分区类型有哪些？**\n>\n>   * RANGE分区：基于列的值范围来分区。\n>   * LIST分区：基于列的枚举值来分区。\n>   * HASH分区：基于用户定义的表达式的哈希值来分区。\n>   * KEY分区：类似于哈希分区，但基于MySQL提供的哈希函数。\n>\n\n> **分区的优缺点？**\n>\n> **优点：**\n>\n>   * 性能提升：通过只查询或操作感兴趣的分区，可以显著提高查询性能。\n>   * 管理便利：可以独立地备份、恢复或优化单个分区，而不是整个表。\n>   * 数据归档：可以轻松地将旧数据移到只读分区中，确保数据安全性同时提高性能。\n>   * 可用性增强：如果某个分区发生故障，其他分区的数据仍然可以访问。\n>   * 存储优化：可以将不同分区放在不同的物理存储上，以优化I/O性能。\n>\n\n>\n> **缺点：**\n>\n>   * 复杂性增加：设计和维护分区策略需要额外的知识和工作。\n>   * 可能的性能问题：如果查询或操作跨多个分区，可能会导致性能下降。\n>   * 管理开销：需要定期监控和维护分区，确保其性能和可用性。\n>   * 数据迁移挑战：在重新分区或更改分区策略时，可能需要大量的数据迁移工作。\n>\n\n**学习指引**\n\n两篇一起看\n\n[搞懂MySQL分区](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.cnblogs.com%2FGrimMjx%2Fp%2F10526821.html)\n\n[MySql分库分表与分区的区别和思考\n](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.cnblogs.com%2FGrimMjx%2Fp%2F10526821.html)\n\n## 3.Redis:数据类型有哪些？\n\n**解析：**\n\n回答最常用的5种就行，其他数据类型等面试官追问再答也可以。\n\n**参考回答：**\n\n>   1. **String（字符串）**\n> ：这是Redis最基本的数据类型，一个key对应一个value。它是二进制安全的，可以包含任何数据，如jpg图片或序列化的对象。一个键最大能存储512MB的数据。\n>   2. **Hash（哈希）**\n> ：Redis的哈希是一个键值对集合，是string类型的field和value的映射表。它特别适合用于存储对象，可以像数据库中更新一个属性一样只修改某一项属性值，而不需要取出整个字符串反序列化成对象修改再序列化存回去。\n>   3. **List（列表）**\n> ：Redis的列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边），它的增删操作非常快，且提供了操作某一段元素的API。\n>   4. **Set（集合）** ：Redis的Set是string类型的无序集合。它是通过哈希表实现的，添加、删除和查找的时间复杂度都是O(1)。\n>   5. **Sorted Set（有序集合）** ：与Set相似，但Sorted\n> Set中的每个字符串元素都会关联一个double类型的分数。Redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的，但分数(score)可以重复。\n>\n\n除了以上五种基本数据类型，Redis还支持一些其他的数据结构和功能，如Bitmaps（位图）、HyperLogLog（基数统计）、Geospatial（地理位置）和Streams（流）等。\n\n**推荐学习：** [《小林 coding》Redis\n常见数据类型和应用场景](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxiaolincoding.com%2Fredis%2Fdata_struct%2Fcommand.html%23redis-%25E5%25B8%25B8%25E8%25A7%2581%25E6%2595%25B0%25E6%258D%25AE%25E7%25B1%25BB%25E5%259E%258B%25E5%2592%258C%25E5%25BA%2594%25E7%2594%25A8%25E5%259C%25BA%25E6%2599%25AF)\n\n## 4.Redis: 6.0升级了多线程了解吗？\n\n  1. 为什么6.0要引入多线程？\n  2. IO多路复用讲解下:select/poll/epoll\n\n**分析：**\n\nredis单线程/多线程问题是最高频考题之一，并且结合多线程去追问IO多路复用，也是常见套路，大家一定要掌握。\n\n**参考回答：**\n\n> **了解吗？：** 了解。虽然 Redis 的主要工作（网络 I/O 和执行命令）一直是单线程模型，但是在 Redis 6.0 版本之后，也采用了多个\n> I/O 线程来处理网络请求。\n\n> **为什么6.0要引入多线程？**\n>\n>   * 这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上。 所以为了提高网络 I/O 的并行度，Redis\n> 6.0 对于网络 I/O 采用多线程来处理。但是对于命令的执行，Redis 仍然使用单线程来处理，所以大家不要误解 Redis\n> 有多线程同时执行命令。Redis 官方表示，Redis 6.0 版本引入的多线程 I/O 特性对性能提升至少是一倍以上。\n>\n\n> **IO多路复用讲解下:select/poll/epoll**\n>\n> 简要介绍\n>\n>   * **select** ：\n> select允许程序同时监控多个文件描述符的读写状态，但受限于位图大小，且每次调用都需从用户空间向内核空间复制位图，性能开销大。\n>   * **poll** ：\n> poll改进了select，使用数组存储文件描述符，无位图大小限制，可处理更多文件描述符。但同样存在每次调用时的用户空间到内核空间的复制开销。\n>   * **epoll** ：\n> epoll是Linux特有的高效IO多路复用机制，基于事件驱动，无需轮询，通过注册感兴趣的事件并在事件发生时通知应用程序，适合处理大量并发连接，性能优越且资源消耗低。\n>\n\n**推荐学习：**\n\n面试学习：[《小林Coding》｜Redis 6.0\n之后为什么引入了多线程？](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxiaolincoding.com%2Fredis%2Fbase%2Fredis_interview.html%23redis-6-0-%25E4%25B9%258B%25E5%2590%258E%25E4%25B8%25BA%25E4%25BB%2580%25E4%25B9%2588%25E5%25BC%2595%25E5%2585%25A5%25E4%25BA%2586%25E5%25A4%259A%25E7%25BA%25BF%25E7%25A8%258B)\n\n面试学习：[《小林Coding》｜I/O\n多路复用：select/poll/epoll](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxiaolincoding.com%2Fos%2F8_network_system%2Fselete_poll_epoll.html%23_9-2-i-o-%25E5%25A4%259A%25E8%25B7%25AF%25E5%25A4%258D%25E7%2594%25A8-select-\npoll-epoll)\n\n## 5.Redis: 持久化了解吗？\n\n  1. 用户写入时是先写数据库还是先写AOF日志？\n  2. 后写AOF有什么风险？\n  3. 听说过write-ahead logging吗？你对这个有什么想法吗？\n\n**分析：**\n\nredis持久化是redis 4-5项核心重点知识之一，属于高频考题，必须掌握。\n\n**参考回答：**\n\n> **1.持久化介绍：**\n>\n> Redis 共有三种数据持久化的方式：\n>\n>   * AOF 日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；\n>   * RDB 快照：将某一时刻的内存数据，以二进制的方式写入磁盘；\n>   * 混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；\n>\n\n> **2.用户写入时是先写执行命令还是先写AOF日志？**\n>\n> 先执行命令，再写AOF日志。\n>\n> **好处：**\n>\n>   * 避免额外的检查开销：因为如果先将写操作命令记录到 AOF\n> 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis\n> 在使用日志恢复数据时，就可能会出错。\n>   * 不会阻塞当前写操作命令的执行：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。\n>\n\n>\n> **风险**\n>\n>   * 数据可能会丢失： 执行写操作命令和记录日志是两个过程，那当 Redis\n> 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。\n>   * 可能阻塞其他操作： 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当\n> Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。\n>\n\n> **3.听说过write-ahead logging（WAL）吗？你对这个有什么想法吗？**\n>\n> 分析：这里估计面试官是想说Mysql redo日志的实现的差别。 _但是我觉得跟这里redis的更新没有本质差别，也算是WAL_\n>\n> **回答：** ：\n>\n>   * **Mysql** :中的redo log相关实现用到了这个WAL策略。WAL 技术指的是， MySQL\n> 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。（**先写内存--\n> >再写日志-->最后更新到磁盘**）所以相对写磁盘来说，是先写的日志，叫write-ahead logging\n>\n>   * **Redis** : 我们再看redis的流程：redis是先执行命令，再更新日志，最后持久化到磁盘。（**执行命令（写内存）--\n> >写AOF日志-->持久化到磁盘**），可以看到，其实没有本质差别的。并不是redis没想到这个策略，应该说它就已经使用了这个策略，那就是在数据持久化到磁盘之前，先写了AOF日志。\n>\n>\n\n**推荐学习：**\n\n面试学习：[《小林Coding》｜图解redis｜AOF\n日志是如何实现的](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxiaolincoding.com%2Fredis%2Fbase%2Fredis_interview.html%23aof-%25E6%2597%25A5%25E5%25BF%2597%25E6%2598%25AF%25E5%25A6%2582%25E4%25BD%2595%25E5%25AE%259E%25E7%258E%25B0%25E7%259A%2584)\n\n面试学习：[《小林Coding》｜图解mysql｜为什么需要 redo log\n](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxiaolincoding.com%2Fmysql%2Flog%2Fhow_update.html%23%25E4%25B8%25BA%25E4%25BB%2580%25E4%25B9%2588%25E9%259C%2580%25E8%25A6%2581-redo-\nlog)\n\n## 6.计算机网络：HTTP常用状态码？\n\n**分析：** ：\n\n不用多说，必须掌握。\n![alt](https://uploadfiles.nowcoder.com/images/20240312/7538287_1710175555695/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n**参考回答：** ：\n\n>   * 「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。\n>   * 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。\n>\n\n**学习指引：** ：\n\n面试学习：[《小林Coding》｜HTTP\n常见的状态码有哪些？](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxiaolincoding.com%2Fnetwork%2F2_http%2Fhttp_interview.html%23http-%25E5%25B8%25B8%25E8%25A7%2581%25E7%259A%2584%25E7%258A%25B6%25E6%2580%2581%25E7%25A0%2581%25E6%259C%2589%25E5%2593%25AA%25E4%25BA%259B)\n\n## 7.计算机网络：TCP 三次握手？\n\n**分析：** ：\n\n不用多说，必须掌握。\n\n![alt](https://uploadfiles.nowcoder.com/images/20240312/7538287_1710175585665/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n**参考回答：** ：\n\n> **过程**\n> ：首先客户端向服务器发送连接请求（SYN报文），然后服务器接收到请求后发送确认信息（ACK报文）并同时向客户端发送连接请求（SYN报文），最后客户端接收到服务器的确认和连接请求后，再向服务器发送确认信息（ACK报文）。完成这三次握手后，TCP连接就成功建立，双方可以开始数据传输。\n\n**学习指引：** ：\n\n面试学习：[《小林Coding》｜TCP\n三次握手过程是怎样的？](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxiaolincoding.com%2Fnetwork%2F3_tcp%2Ftcp_interview.html%23tcp-%25E4%25B8%2589%25E6%25AC%25A1%25E6%258F%25A1%25E6%2589%258B%25E8%25BF%2587%25E7%25A8%258B%25E6%2598%25AF%25E6%2580%258E%25E6%25A0%25B7%25E7%259A%2584)\n\n## 8.计算机网络：平时抓过包吗？\n\n**分析：** ： 了解学习\n\n**参考回答：** ：\n\n> 抓过。参考推荐资料\n\n**学习指引：** ：\n\n面试学习：[《小林Coding》｜TCP\n实战抓包分析](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxiaolincoding.com%2Fnetwork%2F3_tcp%2Ftcp_tcpdump.html)\n\n## 9.计算机网络：TCP滑动窗口讲一下？\n\n**分析：** ： TCP是面试重点，滑动窗口是TCP的重点，需要掌握\n\n**参考回答：** ：\n\n>\n> TCP的滑动窗口是一种核心的流量控制机制。它基于窗口的概念，窗口实际上是一个缓冲区，在这个缓冲区内，发送方被允许在未收到确认的情况下连续发送数据。窗口的大小定义了发送方可以发送但还未被确认的数据段的最大数量。\n>\n> 滑动窗口的工作原理可以简要概括为以下几个步骤：\n>\n>   1. **建立连接时的窗口大小协商** ：在TCP三次握手建立连接的过程中，双方会交换窗口大小的信息，以确定初始的窗口大小。\n>   2. **数据的发送与确认**\n> ：发送方根据窗口大小发送数据。每当接收方成功接收到一个数据段，它就会向发送方发送一个确认（ACK）报文，表明已成功接收到数据并准备好接收更多数据。\n>   3. **窗口的滑动**\n> ：随着数据被发送和确认，窗口会“滑动”。具体来说，当发送方收到一个确认报文时，它会将窗口的起始点向前移动到已确认数据的下一个未被确认的数据段。这样，窗口内就包含了新的未发送但可以发送的数据段。\n>   4. **窗口大小的调整**\n> ：滑动窗口的大小可以根据接受放的处理能力来进行流量控制。如果处理能力下降，接收方可能会减小窗口大小；如果状况良好，接收方可能会增大窗口大小，以允许更快的数据传输。\n>   5. **数据的重传**\n> ：如果发送方在一段时间内没有收到某个数据段的确认，它会假设该数据段丢失，并重新发送该数据段。重新发送的触发通常是基于一个计时器，该计时器会在发送数据段时启动，并在未收到确认时超时。\n>\n\n**学习指引：** ：\n\n面试学习：[《小林Coding》|滑动窗口](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxiaolincoding.com%2Fnetwork%2F3_tcp%2Ftcp_feature.html%23%25E6%25BB%2591%25E5%258A%25A8%25E7%25AA%2597%25E5%258F%25A3)\n\n## 10.Spring：Spring IOC讲解下\n\n**分析：** ： Spring IOC/AOP 这两即便你没学过Spring面试都得会吟唱两句才行。\n\n**参考回答：** ：\n\n> Spring\n> IOC，即Spring的控制反转，是一种设计思想，它将对象的创建权反转给Spring容器来管理。通过IOC，程序实现了对象的解耦合，使得对象与对象之间是低耦合的，提高了程序的灵活性和可维护性。简单来说，Spring\n> IOC就是让开发者不再需要手动创建对象，而是通过配置或注解等方式，让Spring容器来负责对象的创建、管理和依赖关系的注入。\n\n**推荐学习：** ：\n\n面试学习：[《JavaGuide》｜谈谈自己对于 Spring IoC\n的了解](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjavaguide.cn%2Fsystem-\ndesign%2Fframework%2Fspring%2Fspring-knowledge-and-questions-\nsummary.html%23spring-ioc)\n\n本文也是 **《热门面经讲解》专栏** 系列文章之一，文末尾有专栏链接，大家可以**点个关注** ，我会持续更新～～\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596855622138716160?sourceSSR=users",
        "title": "传音控股 秋招面经",
        "content": "8.10开\n\n8.15投 java软开-生活\n\n9.10笔试：45min 选择x10、填空x4、问答x2（智力、图形规律、算法、java、操作系统）\n\n9.13一面\n\n腾讯会议 45min\n\n  * 对公司和岗位的了解（面试官：安卓岗）\n  * 籍贯、城市\n  * 复盘笔试（有一道编程题没考虑边界，短路优化）\n  * 在校成绩\n  * c/c++有接触过吗\n  * Int a+c一定大于a吗\n  * 32位编译系统有无符号的int多少字节，最大值最小值是多少，最大值+1是多少，最小值-1是多少\n  * 为什么要有补码\n  * 有看过java的反编译文件吗\n  * java的多态有什么好处，原理是什么\n  * 虚函数表和多态的关系（忘了）\n  * 实习（工作、aigc支持哪些功能、隐私问题、方案优缺点）\n  * 兴趣爱好\n  * 家庭情况\n  * 反问：安卓app上游的开发，java，手机影像部-软件技术部，做算法集成、功能开发、调优\n\nhr：\n\n  * offer情况，为什么不满意，关注哪些点\n  * 感觉对本公司了解比较少？（一开始不知道是手机品牌，以为是做互联网产品的）\n  * 我们在非洲市占率四五十，卖点有针对深肤色人群调优的拍照效果\n  * 公司目前2.5w人，19年在科创板上市\n  * 985，项目交付压力相对软件项目部小一点\n  * 期望薪资\n  * 如果通过还有一轮\n\n后面无消息 问hr说不太匹配（估计看出我对安卓兴趣不大）\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596837494361022464?sourceSSR=users",
        "title": "腾讯实习一面-PCG大数据平台-运营开发面经",
        "content": "前面的IEG秒挂后1天被这个部门捞了，这几天准备了下算法，但是项目有点懈怠了\n\n时间：3月11日 14：40 ，时长45分钟\n\n全程拷打Java项目，掺了一些业务相关的八股\n\n## 拷打查询优化细节：\n\n因为项目亮点手贱，写了用Redis缓存优化前时间、优化后时间。结果疯狂拷打怎么得出的优化时间 `其实是编的数据😭😭，引以为鉴！！`\n\n### ⭕查询时间是怎么测出来的？\n\n`肉眼对比效果 + 查询前时间 对比 查询后时间`\n\n### ❌拷打一连串问题：\n\n数据量多大？ sql查询出多少条记录？ 是什么查询场景？查询条件是什么？小程序端提供哪些查询条件？有哪些类别？一条记录大小是多大呢？\n\n`凭记忆硬答，远古项目以前没想到会问，早知道不写了，还是太天真`\n\n### ❌通过引导得出最终的疑问：你这个查询很小简单，不应该有这么多的性能提升啊？\n\n`寄了，道歉，说不记得了`\n\n### ⭕不带缓存时查询会经过哪些关键节点？\n\n`客户端应用层构建查询语句->网络传输中发送查询请求到服务器->Mysql解析并接受请求 -> 数据库中执行语句`\n\n### ⭕从小程序发起查询请求开始，到最终输出结果，网络层面上，完成一次查询会经过哪些阶段？\n\n`答了计网，tcp连接后->http发起请求->TCP打包->IP寻路和转发->服务器协议栈解包->MySql获取到请求包并得到语句->执行`\n\n### ⭕经过哪些网络上面的硬件和物理的东西？\n\n`硬件和物理：网卡、网络传输路径`\n\n### ❌那么你觉得上面经历的各个环节哪些占用时间的比例比较大?\n\n`答的网络中TCP的连接和传输可能占用时间更长，还是不太理解`\n\n### ⭕假设以20条记录的查询为例去算（假设是千兆网），怎样算出各部分的时间？\n\n`发送时有发送时延=数据包大小/网络传输速度，传播时延利用网络工具可大概知道延时``\n\n### ❌你说不用缓存DB的查询会慢，你有测试DB的耗时是多久吗？\n\n`再次重申真的只是应用层写了两行代码😭`\n\n### ❌DB是怎么配置有注意吗？ 也就是数据库服务器的规格有注意吗？\n\n`没做这方面的考虑，全部都是默认配置`\n\n### ❌时间测试是在本机测试还是在云端测试？\n\n`本地测完，云端只是用docker把后端jar包、mysql、Redis都部署在服务器上了，没再测过`\n\n## 拷打缓存\n\n### ❌缓存是怎么实现的？\n\n`答了放入redis，只是用到了，对原理还在学习`\n\n### ⭕缓存之后，数据有更新怎么处理？\n\n`超时删除 + 更新后主动清除缓存并重新写入`\n\n### ⭕缓存清空是一个什么样的粒度？\n\n`获取当前记录的缓存，清空本次修改的数据缓存`\n\n### ❌缓存更新有没有别的方式？\n\n`道歉并答了Redis还不太懂`\n\n### ⭕为什么放在Redis中会快？\n\n`只答了因为是内存存储的键值对数据库`\n\n### ❌你是Redis部署在多点的网络环境上吗？\n\n`否，和后端环境在同一个服务器机器上`\n\n### ❌真实环境中Redis部署在网络上，还能起到加速的作用吗？\n\n`没懂考察啥知识点，大概是数据库和后端服务分离，怎么保证响应速度吧`\n\n## JWT你可以讲一下吗？\n\n承接上一次的JWT\n\n参考：\n\n> [JSON Web Token\n> 目前最流行、最常见的跨域认证解决方案](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%2Farticle%2F2146047)\n>\n> [JWT 跨域认证详解及应用场景\n> ](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000038434077)\n\n### ❌JWT和普通的直接签名认证有什么区别？\n\n`寄，没听过`\n\n**直接签名认证是什么？**\n\n只包含了签名部分登录后生成token并用共享密钥对其签名，然后发回给客户端，其每次请求时在请求头中放入URL或者字段中，服务器收到请求后利用共享密钥验证\n\n**JWT是直接签名认证的升级**\n\n其除了签名外，规定了 头部.载荷.签名 的标准化格式和内容，使得认证更加通用和安全\n\n总结：\n\nJWT是升级版，在`格式和内容方面进行了拓展`，除了用加密算法签名外规定了`数据的格式：头部、载荷、签名`，以及`内容：使用JSON格式`\n\n**JSON的优势：**\n\n  * `易读性`：结构简单易读，因此代替了XML\n  * `数据结构灵活、易扩展`：可以表达多种类型的数据\n  * `跨平台和通用性`：多平台有JSON解析和生成的工具\n\n###\n\n### ⭕JWT是为了解决什么问题的呢?\n\n`答了跨域，回复:这只是功能之一，又答了比较通用和泛化,回复:对`\n\n**首先是无状态性：**\n\n  * 传统的session-cookies中服务器检查会话信息来识别客户端，并存储客户端的状态信息session_id到cookie，这样服务器负载比较高。\n  * JWT每个请求都包含了完整的认证信息，服务器不需要为验证维护一个session并记录状态，减少了服务器鉴权的负担\n\n**其次是解决跨域问题** ：\n\n  * 传统的session-cookies中浏览器因为安全原因发送请求时只会带上和目标同源的cookies，所以A网站登录过一次后B中不会带上A的cookies，导致`跨域问题：也就是不同源（协议、域名、端口）的cookie限制交互`\n  * JWT因为是无状态的，而且包含有登陆的信息，所以和A网站登录成功后生成的JWT，如果B网站采用`相同的签名和加密`，并且没有过期且密钥安全地保存，那么A网站就可以和B网站发起连接和通讯，解决了跨域问题\n\n**安全性：**\n\n  * 利用签名和共享密钥可以实现登录信息的完整性\n  * 也可以使用对JWT加密或者使用https再放入请求头，来保证安全性\n\n##\n\n## 闲聊\n\n  * Java这方面不是主力语言吧，不考研吗？\n  * 为什么不直接找C++方面的工作呢？ `讲了自己的想法，回复：应该多注意下Java上的业务技术点要更深入进去`\n\n##\n\n## 算法\n\n时间不够了，你10分钟内做完这道题合并两个有序数组\n\n`经典双指针，幸好没忘，秒了基本逻辑，第一次用ACM模式折腾了了一小会儿`\n\n有没有可能优化成一次循环？\n\n`太菜了没看过优化，之后看了题解发现倒序双指针可以`\n\n时间复杂度是多少\n\n`O(m+n)`\n\n## 反问：\n\n  * 当时在捞我的时候参考了哪些方面？ `答:简历是同事推给我的，看到做了一些基础性的东西，但是看起来对Java这方面做的不深（别骂了😭）`\n  * 您个人在面试时侧重于考察哪些方面？`从项目开始引入知识点，看细节有没有深入的思考，一直问看你能回答出的深度和广度`\n\n## 总结：\n\n有点大意了，没想到这个烂项目还有人问，直接没复习，全在凭借残存的记忆硬答，简历上的东西真的不能大意😭😭😭\n\n面试官人超好，说话超温柔（比上一次那位好多了），还闲聊了一下感觉很亲切，不会的地方会换个方式来引导你\n\n对我的建议帮助很大，之前侧重底层的基架方面和算法基础，以为这样可以差异化竞争，Java八股都是死背的，业务开发这方面确实很久没复习了，以前觉得这些CRUD简单，面试不会很考察，**面业务岗还不注重业务项目是真的天真**\n😭😭\n\n要好好搞一下业务项目了，引以为鉴，不可大意\n\n结果还没出，没秒挂已经进步了😢\n\n\\----------------------\n\n一天后3月12日，看了一下流程终止了，果然还是寄了，专心沉淀😭😢\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596828402749923328?sourceSSR=users",
        "title": "腾讯魔方游戏客户端实习面经",
        "content": "3.11更新：\n\n## 一面60min：\n\n先问的什么时候能开始实习（？\n\n  * 项目：\n  * 项目介绍，亮点和困难\n  * 设计模式：\n  * 观察者模式的优缺点\n  * 笔试：\n  * 数组A数组B，无序无重复，A只比B多一个元素，求这个元素。要求 最低复杂度，原地，无数据溢出\n  * C++\n  * 重载重写隐藏\n  * 什么函数可以/不可以声明为虚函数\n  * 堆和栈的区别\n  * 纯虚函数的作用\n  * 各种STL容器底层实现\n  * vector和list的使用场景\n  * stack适配器的底层容器是什么，能不能用vector，为什么\n  * 笔试：\n  * 0-9组成的串，相邻加在一起为10则消掉，问最终串长\n  * 操作系统：\n  * 进程线程\n  * 死锁原因\n  * 银行家算法\n  * Unity \n  * collider trigger区别\n  * 碰撞检测的前置条件\n  * 脚本生命周期\n  * 资源动态加载方式有哪些\n  * 图形学\n  * MVP矩阵的作用\n  * 渲染管线介绍\n  * 裁剪发生在具体哪个阶段\n  * 反问：\n  * 实习生做什么\n  * 有没有端游格斗游戏企划\n  * 我表现的怎么样（？\n\n可能还有5%的内容不记得了，不过基本上是这些。\n\n（面的我胃疼，怎么这么长时间。。跟牛客上说的魔方实习面经内容也差好多，巨大压力。。\n\n\\---\n\n待更新，面完好像立刻就到复试了？不确定，再看看（\n\n3.12更新：面完第二天要二面😰😰😰刚睡了大懒觉起来，感觉要寄\n\n\\---\n\n3.12更新：\n\n## 二面60min：\n\n自我介绍\n\n实习经验介绍，收获心得\n\nC++学习过程，图形学学习过程\n\n比较熟悉算法还是工程（到大学才开始接触编程的无竞赛菜狗落泪\n\n  * C++\n  * 什么情况下需要使用多继承\n  * STL中的多继承\n  * 虚继承原理\n  * 右值引用和移动语义\n  * C++内存管理方式\n  * shared ptr的具体实现（问的很细\n  * 设计模式\n  * 对象池模式的实现以及什么时候使用\n  * 计算机网络\n  * 线程池\n  * Unity\n  * Animator骨骼动画了解过吗\n  * 图形学\n  * 玩过原神吗（？问了原神的渲染，随便扯了点NPR的算法\n  * PBR解释\n  * PBR和NPR有什么区别（虽然做了PBR但是真的没有详细了解过NPR\n  * 描边怎么做（？我已经说过我不懂NPR了😭答了用模板测试描边的流程\n  * 半透明物体绘制流程\n  * 抗锯齿实现\n  * 射线与三角片相交检测\n  * 物理模拟做过吗（有个流体模拟项目，compute shader算的SPH方法模拟，这个我很熟感觉也很有含金量，问到的时候我也特意往并行算法更深层次上引导，结果根本没细问，跪了\n  * 笔试\n  * [53\\. 最大子数组和](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fmaximum-subarray%2F)\n  * [25\\. K 个一组翻转链表](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fleetcode.cn%2Fproblems%2Freverse-nodes-in-k-group%2F)的变体\n  * 反问\n  * 您是做什么工作的（？火影\n  * 有没有端游格斗游戏企划\n  * 我表现的怎么样（😭\n\n可能还有10%的内容不记得了，反正答的比较烂，笔试也写的迷迷糊糊，面试官还说我想的太复杂（。\n\n最后反问面试官说我基础挺好的，但是得多刷leetcode（确实，没咋刷，因为准备时间太少）。感觉差不多是挂了，明天看看结果😔\n\n\\---\n\n3.14更新：似了，真是速速又通通高高又效效啊，但凡去刷点leetcode估计都过了，不过我自己也非常争气，二面脑子宕机加压力爆表，稳稳拿下面试官捏（当天晚一面第二天晚上二面真的吃不消，一面到二面到挂总共不到四天。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596820519089913856?sourceSSR=users",
        "title": "oc相关",
        "content": "文档：[https://www.bczl.xyz/objc/doc-\nzh/1.Introduction.html](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.bczl.xyz%2Fobjc%2Fdoc-\nzh%2F1.Introduction.html)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596813486584356864?sourceSSR=users",
        "title": "孙悟空吃蟠桃 - 华为OD统一考试（C卷）",
        "content": "> OD统一考试（C卷）\n>\n> 分值： 200分\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n孙悟空爱吃蟠桃，有一天趁着蟠桃园守卫不在来偷吃。已知蟠桃园有 `N` 棵蟠桃树，每棵树上都桃子，守卫将在 `H` 小时后回来。\n\n孙悟空可以决定他吃蟠桃的速度 `K` （个/每小时），每个小时选一棵桃树，并从树上吃掉 `K`\n个，如果`K`大于该树上所有桃子个数，则全部吃掉，并且这一小时剩余的时间里不再吃桃。\n\n孙悟空喜欢慢慢吃，但又想在守卫回来前吃完桃子。\n\n请返回孙悟空可以在 `H` 小时内吃掉所有桃子的最小速度 `K` （`K` 为整数）。如果以任何速度都吃不完所有桃子，则返回 0。\n\n## 输入描述\n\n第一行输入为 `N`个数字， `N` 表示桃树的数量，这 `N` 个数字表示每棵桃树上蟠桃的数量。\n\n第二行输入为一个数字，表示守卫离开的时间 `H`。\n\n其中数字通过空格分割， `N`、 `H` 为正整数，每棵树上都有蟠桃，且 0<`N`<10000, 0 < `H` < 10000。\n\n## 输出描述\n\n输出吃掉所有蟠桃的最小速度 `K`，无解或输入异常时输出 0。\n\n## 示例1\n\n    \n    \n    输入：\n    2 3 4 5\n    4\n    \n    输出：\n    5\n    \n\n## 示例2\n\n    \n    \n    输入：\n    2 3 4 5\n    3\n    \n    输出：\n    0\n    \n\n## 示例3\n\n    \n    \n    输入：\n    30 11 23 4 20\n    6\n    \n    输出：\n    23\n    \n\n## 题解\n\n> 结合以上的题目和以下题目代码解法总结一些题解信息。\n>\n> 从以下几点方面： 题目属于什么类型的算法题（例如，动态规划、DFS、BFS、贪心、双指针\n> ...），解题思路，代码大致描述，时间复杂度，空间复杂度，及同类型 leetcode.cn 的题目\n\n### Java\n\n    \n    \n    import java.util.Arrays;\n    import java.util.Scanner;\n    \n    /**\n     * @author code5bug\n     */\n    public class Main {\n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n    \n            // 每棵桃树上蟠桃的数量\n            int[] peachs = Arrays.stream(scanner.nextLine().split(\" \"))\n                    .mapToInt(Integer::parseInt).toArray();\n    \n            // 守卫离开的时间\n            int H = scanner.nextInt();\n    \n            System.out.println(solve(peachs, H));\n        }\n    \n        /**\n         * 每个小时只能选一棵桃树，能否在 H 小时内吃完所有的桃子\n         *\n         * @param peachs 每棵桃树上蟠桃的数量\n         * @param speed  守卫每小时吃的桃子数量\n         * @param H      守卫离开的时间\n         * @return 每个小时只能选一棵桃树，能否在 H 小时内吃完所有的桃子\n         */\n        private static boolean ok(int[] peachs, int speed, int H) {\n            int time = 0;\n            for (int cnt : peachs) {\n                time += (cnt + speed - 1) / speed;  // 向上取整\n            }\n            return time <= H;\n        }\n    \n        /**\n         * 计算守卫在 H 小时内能吃完所有的桃子的最小速度\n         *\n         * @param peachs 每棵桃树上蟠桃的数量\n         * @param H      守卫离开的时间\n         * @return 守卫在 H 小时内能吃完所有的桃子的最小速度\n         */\n        private static int solve(int[] peachs, int H) {\n            int n \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596812297096441856?sourceSSR=users",
        "title": "3.11腾讯客户端一面面经",
        "content": "（看了一大堆cpp的面经，真没想到这个部门用的是java啊，怪不得内存泄露虚函数stl是一点没问[牛泪][牛泪][牛泪][牛泪]）\n\n面试官首先是介绍了自己部门，然后让我做自我介绍。自我介绍完开始聊天。\n\n先聊了操作系统，问线程和进程的区别，提示说线程和进程在内存分配上有什么区别，\n之后又问线程安全问题，线程间在什么情况下会通信，如何实现同步，什么情况下线程不安全，提示了一下全局变量，问的很细很深，回答出一个点后会立即追着这个点往下问。\n\n聊完操作系统又聊了聊计算机网络，问的比较简单，七层模型、tcp和udp在哪一层、tcp和udp最大的区别是什么、https的加密过程（追问如何确保内容安全）、dns劫持。\n\n聊完计算机网络聊了设计模式，问我了不了解单例模式，有哪几种单例模式，着重问了静态变量单例模式的好处和不足（内部类和外部类），以及代理模式中如何对原对象进行修改（不会，后面面试官讲了一下，让我下去再看一下）。\n\n手撕了一道题目：字符串表示的二进制数a和二进制数b的相加。\n\n问了下操作数据库的过程中遇到的最大困难，答的是幻读问题。\n\n最后问我是否还有其他擅长的知识没有问到，我说了下内存泄露，追问遇到的最困难的内存泄露的问题是什么。\n\n反问：本次面试我还有哪些可以改进的空间。\n\n答：准备的过程中可以多思考一下思路的逻辑是否通顺，知识的逻辑是否合理。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596811410567380992?sourceSSR=users",
        "title": "京东YOUNG测试开发日常实习面试记录（3.11，已转推荐）",
        "content": "1.面过一周才想起来写京东的这个面经，我本来是投的Java后端，给我调剂到测开了。上周二进行了业务面，目前到现在接近一周了还是面试中状态。\n\n2.因为是后端的简历，所以问的基本都是Java的八股以及项目中的一些问题。\n\n3.时间太长，具体问题真的是一点都记不起来了，对牛友们表示歉意，下次面完一定来及时发面经。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596810155220656128?sourceSSR=users",
        "title": "腾讯WXG一面凉经",
        "content": "1.Redis脑裂是什么\n\n2.如果一个leader宕机一段时间后恢复，会发生什么\n\n3.什么是跳表\n\n4.跳表和链表有什么区别\n\n5.跳表中有哪些数据结构\n\n6.跳表的数据结构是什么\n\n7.画一下跳表\n\n8.多态在项目中如何实现的\n\n9.虚函数的概念\n\n10.使用父类类型定义的子类对象如何调用到自己的虚函数\n\n11.讲讲TCP的头部\n\n12.为什么要随机初始化序列号\n\n手撕股票买卖日期\n\n太紧张了，算法题条件写错了，最后面试官提醒了一下过了。\n\n面试官人很好，作为咱的处女面真的太温柔了，真的知心大哥哥，虽然他面完我就把我挂了。:<\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596809169685045248?sourceSSR=users",
        "title": "测试开发 - 一面凉经 - 好未来",
        "content": "2024.3.09 约面\n\n2024.3.11 面试\n\n自我介绍\n\n学校地点确认\n\n毕业年份确认\n\n项目介绍 - 聊天平台日志分析\n\n具体分析了哪些指标\n\n没有针对内容做分析吗\n\n可视化展示是展示的什么内容呀\n\n为什么作为一款聊天平台，用户常用词没有分析呢\n\n用户是哪里来的\n\n实习时自动化测试的内容具体讲讲\n\n讲讲测试脚本优化策略，为什么风险降低了7%\n\n提到的相机测试部分，连续拍照多次，具体讲讲\n\n具体一些，如何修改的测试脚本\n\n修改的数据大小具体是改成多少次呢\n\n如何判断你这个测试脚本修改后是没有问题的\n\n日志报错信息是如何查看的\n\nLinux如何查看文件中脚本信息最后10行\n\n如何查看日志信息，如何将每一行信息的行号显示出来\n\n算法题目：连续最长子序列\n\n反问：\n\n所属部门业务情况：Al相关，接口测试，压力测试，功能测试，UI自动化测试，算法模型评估\n\n测试相关岗位中测试开发方向学习规划：多做一些项目，JavaWeb即可，商城之类的也可以\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596791406543364096?sourceSSR=users",
        "title": "字节后端开发实习-Data一面面经（Base上海）",
        "content": "1.自我介绍\n\n2.关于redis怎样保证数据一致性（我简历中说了我的项目用的延迟双删，面试官便让我介绍了一下，并追问延迟双删的可能发生的意外情况）\n\n3.询问ThreadLocal的作用及底层原理\n\n4.为什么Linux和Windows的程序不能通用\n\n5.关于UDP\n\n6.进程和线程的区别\n\n7.数据库的索引的底层结构，为什么用B+树而不用其他的如B树和红黑树\n\n8.锁相关（分布式锁，乐观锁悲观锁这些）\n\n9.HashMap的底层原理\n\n10.如果有10的8次方个数据，只有1G的空间，该怎样找出其中重复的数据\n\n11.Syschronized和Lock的区别\n\n12.TCP建立连接为什么两次握手不行\n\n13.WebSocket的底层原理（项目中提到了）\n\n14.算法题：找出一个字符串中的全部回文子串（运行成功+讲思路）\n\n15.。。。还有其他一些暂时想不起来了\n\n体会：确实大多都是项目相关的，所以面字节自己简历上的项目一定要吃透。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596770840209829888?sourceSSR=users",
        "title": "ARM/Linux嵌入式面经（一）：海康威视",
        "content": "# 海康威视\n\n![](https://img-\nblog.csdnimg.cn/img_convert/64c2956385970185752712c5cee2493d.jpeg)\n\n# 1.函数指针和指针函数区别\n\n## 1.定义的差异\n\n函数指针：函数指针的定义涉及到函数的地址。例如，定义一个指向函数的指针 int (*fp)(int)，**这里 fp 是一个指针**\n，它指向一个接受一个整数参数并返回整数的函数。\n\n指针函数：**指针函数是指其返回类型为指针的函数** 。例如，int* f(int) 表示一个函数 f，它接受一个整数参数\n**并返回一个指向整数的指针。**\n\n## 2.用法的不同\n\n函数指针：在编程中，函数指针主要用于指向和调用不同的函数，特别是在实现策略模式、回调函数或事件驱动程序时。这使得代码更加模块化和可重用。**(挂钩子)**\n\n指针函数：**指针函数通常用于在函数内部动态分配内存** ，并**将其地址返回给调用者** 。这在处理大型数据结构或提供灵活的内存管理方案时非常有用。\n\n## 3.应用场景的区别\n\n函数指针：它们广泛应用于**实现接口、回调机制以及函数作为参数的情况** 。例如，在C标准库中的 qsort 函数使用函数指针来定制排序行为。\n\n指针函数：主要用于当函数需要**返回多个值或大型数据结构时** 。例如，在操作字符串或复杂数据结构时，指针函数可以有效地返回所需的数据。\n\n## 4.语法结构的差异\n\n函数指针：在定义函数指针时，**重点在于指针的位置和它指向的函数类型** 。**正确的语法和理解函数的签名是关键。**\n\n指针函数：其定义类似于常规函数，**只是其返回类型为指针** 。理解如何声明返回指针的函数并确保正确的内存管理是使用指针函数的关键。\n\n# 2.进程与线程的区别\n\n## 0、什么是线程？\n\n线程（英语：thread）**是操作系统能够进行运算调度的最小单位**\n。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，**一个进程中可以并发多个线程**\n，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为**轻量进程（lightweight\nprocesses），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。**\n\n**线程是独立调度和分派的基本单位** 。线程可以为操作系统内核调度的内核线程，如Win32线程；由用户进程自行调度的用户线程，如Linux平台的POSIX\nThread；或者由内核与用户进程，如Windows 7的线程，进行混合调度。\n\n同一进程中的多条线程将共享该进程中的全部**系统资源，如虚拟地址空间，文件描述符和信号处理等等** 。**但同一进程中的多个线程有各自的调用栈（call\nstack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）** 。\n\n一个进程可以有很多线程，每条线程并行执行不同的任务。\n\n在多核或多CPU，或支持Hyper-\nthreading的CPU上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。\n\n## 1、根本区别\n\n**进程是操作系统进行资源分配的最小单元** ，**线程是操作系统进行运算调度的最小单元** 。\n\n进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系**统进行资源分配和调度的基本单位，是操作系统结构的基础。**\n\n线程是操作系统能**够进行运算调度的最小单位** 。它被包含在进程之中，是进程中的实际运作单位。\n\n## 2、从属关系不同\n\n**进程中包含了线程，线程属于进程**\n。一个进程可以有很多线程，每条线程并行执行不同的任务。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。\n\n## 3、开销不同\n\n**进程的创建、销毁和切换的开销都远大于线程** 。由于线程比进程更小，**基本上不拥有系统资源**\n，故对它的调度所付出的开销就会小得多，能更高效的提高系统内多个程序间并发执行的程度，从而显著提高系统资源的利用率和吞吐量。\n\n## 4、拥有资源不同\n\n每个进程有自己的内存和资源，一个进程中的线程会共享这些内存和资源。进程是资源分配的基本单位。\n\n**所有与该进程有关的资源，都被记录在进程控制块PCB中** 。以表示该进程拥有这些资源或正在使用它们。\n\n另外，**进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间** 。\n\n当进程发生调度时，不同的进程拥有不同的虚拟地址空间，**而同一进程内的不同线程共享同一地址空间。**\n\n## 5、控制和影响能力不同\n\n**子进程无法影响父进程，而子线程可以影响父线程** ，如果主线程发生异常会影响其所在进程和子线程。\n\n与进程相对应，线程与资源分配无关，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。\n\n## 6、CPU利用率不同\n\n进程的CPU利用率较低，因为上下文切换开销较大，而线程的CPU的利用率较高，上下文的切换速度快。\n\n在多核或多CPU，或支持Hyper-threading的CPU上使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。\n\n在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。\n\n# 3.malloc和new的区别\n\n> new与malloc的10点区别：[https://www.cnblogs.com/QG-\n> whz/p/5140930.html](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.cnblogs.com%2FQG-\n> whz%2Fp%2F5140930.html)\n\n## 1\\. 申请的内存所在位置\n\nnew操作符从**自由存储区（free store）上为对象动态分配内存空间** ，而**malloc函数从堆上动态分配内存** 。\n\n自由存储区是C++基于new操作符的一个抽象概念，**凡是通过new操作符进行内存申请，该内存即为自由存储区。**\n\n而堆是操作系统中的术语，**是操作系统所维护的一块特殊内存**\n，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。\n\n那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new\n的实现细节。**自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。**\n\n特别的，new甚至可以不为对象分配内存！定位new的功能可以办到这一点：\n\n    \n    \n    new (place_address) type\n    \n    \n\nplace_address为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用new操作符时，new操作符调用特殊的operator\nnew，也就是下面这个版本：\n\n    \n    \n    void * operator new (size_t,void *) //不允许重定义这个版本的operator new\n    \n    \n\n这个operator new不分配任何的内存，它只是简单地返回指针实参，然后右new表达式负责在place_address指定的地址进行对象的初始化工作。\n\n## 2.返回类型安全性\n\nnew操作符内存分配成功时，**返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。**\n\n**而malloc内存分配成功则是返回void *** ，需要通过** 强制类型转换将void*指针转换成我们需要的类型**。\n\n**类型安全很大程度上可以等价于内存安全** ，类型安全的代码不会试图方法自己没被授权的内存区域。关于C++的类型安全性可说的又有很多了。\n\n## 3.内存分配失败时的返回值\n\nnew内存分配失败时，**会抛出bac_alloc异常，它不会返回NULL；**\n\n**malloc分配内存失败时返回NULL。**\n\n在使用C语言时，我们习惯在malloc分配内存后判断分配是否成功：\n\n    \n    \n    int *a  = (int *)malloc ( sizeof (int ));\n    if(NULL == a)\n    {\n        ...\n    }\n    else \n    {\n        ...\n    }\n    \n    \n\n从C语言走入C++阵营的新手可能会把这个习惯带入C++：\n\n    \n    \n    int * a = new int();\n    if(NULL == a)\n    {\n        ...\n    }\n    else\n    {   \n        ...\n    }\n    \n    \n\n**实际上这样做一点意义也没有**\n，因为new根本不会返回NULL，而且程序能够执行到if语句已经说明内存分配成功了，如果失败早就抛异常了。**正确的做法应该是使用异常机制：**\n\n    \n    \n    try\n    {\n        int *a = new int();\n    }\n    catch (bad_alloc)\n    {\n        ...\n    }\n    \n    \n    \n\n> 如果你想顺便了解下异常基础，可以看[http://www.cnblogs.com/QG-\n> whz/p/5136883.htmlC++](https://gw-c.nowcoder.com/api/sparta/jump/link?link=http%3A%2F%2Fwww.cnblogs.com%2FQG-\n> whz%2Fp%2F5136883.htmlC%2B%2B) 异常机制分析。\n\n## 4.是否需要指定内存大小\n\n**使用new操作符申请内存分配时无须指定内存块的大小** ，编译器会根据类型信息自行计算，**而malloc则需要显式地指出所需内存的尺寸。**\n\n    \n    \n    class A{...}\n    A * ptr = new A;\n    A * ptr = (A *)malloc(sizeof(A)); //需要显式指定所需内存大小sizeof(A); \n    \n    \n\n当然了，我这里使用malloc来为我们自定义类型分配内存是不怎么合适的，请看下一条。\n\n## 5.是否调用构造函数/析构函数\n\n使用new操作符来分配对象内存时会经历三个步骤：\n\n第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。\n第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。 第三部：对象构造完成后，返回一个指向该对象的指针。\n\n使用delete操作符来释放对象内存时会经历两个步骤：\n\n第一步：**调用对象的析构函数。** 第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。\n\n总之来说，**new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构** 。而malloc则不会。如果你不嫌啰嗦可以看下我的例子：\n\n## 6.对数组的处理\n\nC++提供了new[]与delete[]来专门处理数组类型:\n\n    \n    \n    \tA * ptr = new A[10];//分配10个A对象\n    \n    \n\n使用new[]分配的内存必须使用delete[]进行释放：\n\n    \n    \n        delete [] ptr;\n    \n    \n\nnew对数组的支持体现在**它会分别调用构造函数函数初始化每一个数组元素** ，**释放对象时为每个对象调用析构函数**\n。**注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。**\n\n至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：\n\n    \n    \n    int * ptr = (int *) malloc( sizeof(int)* 10 );//分配一个10个int元素的数组\n    \n    \n\n## 7.new与malloc是否可以相互调用\n\noperator new /operator delete的实现可以基于malloc，**而malloc的实现不可以去调用new**\n。下面是编写operator new /operator delete 的一种简单方式，其他版本也与之类似：\n\n    \n    \n    void * operator new (sieze_t size)\n    {\n        if(void * mem = malloc(size)\n            return mem;\n        else\n            throw bad_alloc();\n    }\n    void operator delete(void *mem) noexcept\n    {\n        free(mem);\n    }\n    \n    \n\n## 8.是否可以被重载\n\nopeartor new /operator delete可以被重载。标准库是定义了operator new函数和operator\ndelete函数的8个重载版本：\n\n    \n    \n    //这些版本可能抛出异常\n    void * operator new(size_t);\n    void * operator new[](size_t);\n    void * operator delete (void * )noexcept;\n    void * operator delete[](void *0）noexcept;\n    //这些版本承诺不抛出异常\n    void * operator new(size_t ,nothrow_t&) noexcept;\n    void * operator new[](size_t, nothrow_t& );\n    void * operator delete (void *,nothrow_t& )noexcept;\n    void * operator delete[](void *0,nothrow_t& ）noexcept;\n    \n    \n    \n\n我们可以自定义上面函数版本中的任意一个，前提是自定义版本必须位于全局作用域或者类作用域中。\n\n太细节的东西不在这里讲述，总之，我们知道我们有足够的自由去重载operator new /operator delete\n,以决定我们的new与delete如何为对象分配内存，如何回收对象。\n\n而malloc/free并不允许重载。\n\n## 9\\. 能够直观地重新分配内存\n\n使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。\n\nnew没有这样直观的配套设施来扩充内存。\n\n## 10\\. 客户处理内存分配不足\n\n在operator new抛出异常以反映一个未获得满足的需求之前，**它会先调用一个用户指定的错误处理函数，这就是new-\nhandler。new_handler是一个指针类型：**\n\n    \n    \n    namespace std\n    {\n        typedef void (*new_handler)();\n    }\n    \n\n**指向了一个没有参数没有返回值的函数,即为错误处理函数**\n。为了指定错误处理函数，客户需要调用set_new_handler，这是一个声明于的一个标准库函数:\n\n    \n    \n    namespace std\n    {\n        new_handler set_new_handler(new_handler p ) throw();\n    }\n    \n\n**set_new_handler的参数为new_handler指针，指向了operator new 无法分配足够内存时该调用的函数。**\n\n其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要发生替换）的那个new_handler函数。\n\n**对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。**\n\n## 总结\n\n将上面所述的10点差别整理成表格：\n\n特征 new/delete malloc/free  \n分配内存的位置 | 自由存储区 | 堆 |  |  |   \n内存分配成功的返回值 | 完整类型指针 | void* |  |  |   \n内存分配失败的返回值 | 默认抛出异常 | 返回NULL |  |  |   \n分配内存的大小 | 由编译器根据类型计算得出 | 必须显式指定字节数 |  |  |   \n处理数组 | 有处理数组的new版本new[] | 需要用户计算数组的大小后进行内存分配 |  |  |   \n已分配内存的扩充 | 无法直观地处理 | 使用realloc简单完成 |  |  |   \n是否相互调用 | 可以，看具体的operator new/delete实现 | 不可调用new |  |  |   \n分配内存时内存不足 | 客户能够指定处理函数或重新制定分配器 | 无法通过用户代码进行处理 |  |  |   \n函数重载 | 允许 | 不允许 |  |  |   \n构造函数与析构函数 | 调用 | 不调用 |  |  |   \n  \nmalloc给你的就好像一块原始的土地，你要种什么需要自己在土地上来播种\n\n![](https://img-\nblog.csdnimg.cn/img_convert/7282862c8726c46b110afbac39224802.jpeg)\n而new帮你划好了田地的分块（数组），帮你播了种（构造函数），还提供其他的设施给你使用:\n\n![](https://img-\nblog.csdnimg.cn/img_convert/30e679586c709fb31b522821cad9fa73.jpeg)\n当然，malloc并不是说比不上new，它们各自有适用的地方。在C++这种偏重OOP的语言，使用new/delete自然是更合适的。\n\n# 4.TCP的三次握手和四次挥手\n\n> 三次握手，证明对端没问题。四次回收，为了关闭双工\n\n  1. 请画出三次握手和四次挥手的示意图\n\n  2. 为什么连接的时候是三次握手？\n\n  3. 什么是半连接队列？\n\n  4. ISN(Initial Sequence Number)是固定的吗？\n\n  5. 三次握手过程中可以携带数据吗？\n\n  6. 如果第三次握手丢失了，客户端服务端会如何处理？\n\n  7. SYN攻击是什么？\n\n  8. 挥手为什么需要四次？\n\n  9. 四次挥手释放连接时，等待2MSL的意义?\n\n## 1\\. 三次握手\n\n三次握手（Three-way\nHandshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。\n\n刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。进行三次握手：\n\n  * 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_SEND 状态。 首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。\n\n  * 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。 在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。\n\n  * 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。 确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。\n\n发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。\n在socket编程中，客户端执行connect()时，将触发三次握手。\n\n![](https://img-\nblog.csdnimg.cn/img_convert/38f2d2b4f5f78c140753b0553ddca404.webp?x-oss-\nprocess=image/format,png)\n\n### 1.1 为什么需要三次握手，两次不行吗？\n\n弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。\n\n第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。\n\n第二次握手：服务端发包，客户端收到了。\n这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。\n\n第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。\n\n因此，需要三次握手才能确认双方的接收与发送能力是否正常。 试想如果是用两次握手，则会出现下面这种情况：\n\n    \n    \n    如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。\n    \n\n### 1.2 什么是半连接队列？\n\n服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD\n状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。\n\n当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。\n\n这里在补充一点关于SYN-ACK 重传次数的问题： 服务器发送完SYN-\nACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。\n\n注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s......\n\n### 1.3 ISN(Initial Sequence Number)是固定的吗？\n\n当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1\n。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。\n\n三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence\nNumber)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。\n\n### 1.4 三次握手过程中可以携带数据吗？\n\n其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据\n\n为什么这样呢?\n\n大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN\n报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN\n报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。\n\n也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED\n状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。\n\n### 1.5 SYN攻击是什么？\n\n服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN\n攻击是一种典型的 DoS/DDoS 攻击。\n\n检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix\n上可以使用系统自带的 netstats 命令来检测 SYN 攻击。\n\n    \n    \n    netstat -n -p TCP | grep SYN_RECV\n    \n\n常见的防御 SYN 攻击的方法有如下几种：\n\n  * 缩短超时（SYN Timeout）时间\n  * 增加最大半连接数\n  * 过滤网关防护\n  * SYN cookies技术\n\n## 2\\. 四次挥手\n\n建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-\nclose）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。\n\nTCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。 刚开始双方都处于\nESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：\n\n第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。\n即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。\n\n第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK\n报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。\n\n即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。\n\n第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。\n\n即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。\n\n第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于\nTIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK\n报文之后，就处于关闭连接了，处于 CLOSED 状态。\n\n即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。\n\n收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。\n\n在socket编程中，任何一方执行close()操作即可产生挥手操作。\n\n![](https://img-\nblog.csdnimg.cn/img_convert/41314f601be73d61914ed5682b396ded.webp?x-oss-\nprocess=image/format,png)\n\n### 2.1 挥手为什么需要四次？\n\n因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。\n\n但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，\"你发的FIN报文我收到了\"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。\n\n### 2.2 2MSL等待状态\n\nTIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment\nLifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。\n\n对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。\n\n这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。\n\n### 2.3 四次挥手释放连接时，等待2MSL的意义?\n\nMSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。\n\n为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-\nACK的确认报文。服务器会超时重传这个FIN-\nACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。\n\n两个理由：\n\n保证客户端发送的最后一个ACK报文段能够到达服务端。\n\n这个ACK报文段有可能丢失，使得处于LAST-\nACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-\nWAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。\n\n防止“已失效的连接请求报文段”出现在本连接中。\n\n客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。\n\n### 2.4 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？\n\n理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。\n\n## 3\\. 总结\n\n《TCP/IP详解\n卷1:协议》有一张TCP状态变迁图，很具有代表性，有助于大家理解三次握手和四次挥手的状态变化。如下图所示，粗的实线箭头表示正常的客户端状态变迁，粗的虚线箭头表示正常的服务器状态变迁。\n\n![](https://img-\nblog.csdnimg.cn/img_convert/13d17b995892f186d7e226e322ca2a1a.webp?x-oss-\nprocess=image/format,png)\n\n# 5.插入排序的整体实现\n\n## 1.什么是插入排序\n\n  * 每一步将一个待排序的数据插入到前面已经排序好的有序序列里，直到插完所有的元素为止。\n  * 插入排序与打扑克牌很类似，你摸到第一张牌的时候是不需要排序的，后续摸到的牌可以根据第一张牌进行向左或者向右排序。\n  * 算法实现 \n    * 直接插入排序是把无序的序列里的数据插入到有序的序列中去。\n    * 在遍历无序序列的时候，首先拿无序序列里的第一个元素跟有序序列里的每一个元素比较，并且插入到合适的位置，一直到无序序列里的所有元素插入完毕为止。\n\n## 2.插入排序算法图解\n\n• 初始化序列如下所示，分为有序序列（没有任何元素）和无序序列（8,2,6,4,3,7,5），一开始有序序列是没有任何元素的。\n\n![](https://img-\nblog.csdnimg.cn/img_convert/fd42d1426648d2682f5435aa1348a08f.jpg)\n\n  * 第一轮用8和2比较，返现2比8小，交换位置，变成2 8\n\n  * 第二轮用8和6比较，交换位置，然后再用2和6比较，发现6比2大不用交换位置变成 2 6 8\n\n  * 第三轮用8和4比较，交换位置，再用6和4比较交换位置，2和4比较不用交换位置\n\n  * 第四轮8和3比较，交换位置，6和3比较交换位置，4和3比较交换位置，2和3比较不用交换位置\n\n后面以此类推，都是向左比较到第一个元素，也就是当前元素左边都是有序的，右边都是无序的\n\n![](https://img-\nblog.csdnimg.cn/img_convert/b095a15b730e7150cc6d202403985f7b.jpg)\n![](https://img-\nblog.csdnimg.cn/img_convert/cfda8aa5cb85c6c0045fa33727cd8670.jpg)\n![](https://img-\nblog.csdnimg.cn/img_convert/d5315cd22cc8c250cab60b9751541141.jpg)\n\n## 3.插入排序代码实现\n\n### （1）整体编码实现\n\n    \n    \n    public class InsertSort {\n        public static void main(String[] args) {\n            int[] arr = {8,2,6,4,3,7,5};\n            System.out.println(\"排序前：\");\n            System.out.println(Arrays.toString(arr));\n            insertSort(arr);\n            System.out.println(\"排序后：\");\n            System.out.println(Arrays.toString(arr));\n        }\n    \n        public static void insertSort(int[] arr){\n            //第一层循环，把数组分成两部分，左边是已将排好序的，右边是未排序的\n            //当前下表左边的元素已经排好序，右边还未排序\n            for (int i = 1; i < arr.length; i++) {\n                //内层循环，从当前下标开始祥左比较，如果发现比左边元素小就惊醒交换\n                //直到比较到左边第一个元素\n                for (int j = i; j > 0; j--) {\n                    //依次交换，依次比较，如果不比前一个元素小，就跳出\n                    if(arr[j-1]>arr[j]){\n                        int temp = arr[j-1];\n                        arr[j-1] = arr[j];\n                        arr[j] = temp;\n                    }else{\n                        break;\n                    }\n                }\n                System.out.println(\"第 \"+i+\" 轮: \"+Arrays.toString(arr));\n            }\n        }\n    }\n    \n\n### （2）代码测试\n\n![](https://img-\nblog.csdnimg.cn/img_convert/19c242a51ed0881ec63249479f43e4a2.jpg)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596755269460209664?sourceSSR=users",
        "title": "武汉小公司一面凉经（处女面）",
        "content": "# 问题\n\n  1. 有没有看过 ArrayList、HashMap、锁这些源码？ArrayList 的 add 方法进去后，第一步干嘛，第二步干嘛（答了 ArrayList 的扩容机制）\n  2. ArrayList 扩容是怎么扩容的（答了 grow 方法）\n  3. 对HashMap的扩容有了解过吗？（不会，答的 HashMap的数据结构）\n  4. 对Lock锁这一块有了解吗？（答的 voliate 和 synchronized、乐观锁和悲观锁）\n  5. Spring、SpringMVC、SpringBoot、Maybatis 开源框架中了解哪些？看过哪些源码？选一个回答（答的SpringIOC 创建流程）\n  6. 用了这么多技术栈了对哪个比较熟悉，像 Netty、Zookeeper、Redis、Kafka 这些，对哪一个的源码深入了解过？（不会，答了只会用）\n  7. Netty 怎么解决粘包、拆包？（当时只想起来自定义协议）\n  8. RPC 的自定义协议是怎么设计的？（这几天只着重准备第一个项目了，RPC都快忘光了。。。）\n  9. 序列化是怎么做的（因为JDK原生的性能差，用的开源框架 Kyro、Hession这些）\n\n# 反问\n\n  1. 有几次面试（二面）\n  2. 对我有什么建议（简历上写的很丰富，把自己擅长的写上去）\n  3. 以后的学习建议（看个人，要有亮点，比如对某一个集合或者框架有深入的理解）\n  4. 评价：后面好好努力（估计就是寄了，这是委婉的说法），有些地方没有答到点上\n\n# 总结\n\n问的问题并不难，是自己没有好好准备（面试来的太突然，八股就背了三天） 我在做准备的时候全力准备第一个项目了，RPC 项目的内容已经快忘光了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596754574141042688?sourceSSR=users",
        "title": "好未来Android实习面经",
        "content": "## 一面（2024/3/11 65min）\n\n  1. 自我介绍\n  2. 算法题，反转链表II\n  3. 聊实习的工作\n  4. 冷启动的过程？冷启动过程中涉及到了什么进程？\n  5. 进程间如何通信？\n  6. fork进程的时机是怎样的？\n  7. 都学习了什么编程语言？\n  8. 线程的创建方式有哪些？\n  9. Handler机制？消息队列用到的数据结构？单链表\n  10. Looper的死循环不会造成主线程阻塞的原因？\n  11. OKHttp的原理？\n  12. 说一说Http协议？TCP协议？UDP协议？\n  13. TCP的三次握手的过程？\n  14. Activity的启动模式？\n  15. String A=\"a\";String B=new String(\"a\");所存放的内存位置，A==B,A.equals(B)的返回值和原因？\n  16. 说一说类加载机制？\n  17. 说一说事件分发机制？如何自定义View？\n  18. HashMap的底层数据结构和扩容原理？\n  19. 单例模式的应用场景？\n  20. 如何保证线程安全？\n  21. 锁的分类？\n  22. 死锁的条件？\n\n## 二面（2024/3/15 64min）\n\n  1. 自我介绍\n  2. 为什么现在还在实习就在面试了\n  3. App启动到界面展示的流程？\n  4. 聊实习的工作\n  5. 常见的启动优化手段？\n  6. 算法题：输入一个表示整数的字符串，把该字符串转换成整数并输出\n  7. 算法题：输入一个字符串，打印出该字符串中字符的所有排列，讨论算法复杂度\n  8. 口述算法题：从n个数中找到最小的k个数\n  9. 输入baidu.com到显示网页的流程？DNS解析可能出现什么问题？\n  10. HTTP几个版本做了什么样的改进？\n  11. View的渲染流程？\n  12. 是怎么去学习安卓的？有去看源码吗？\n  13. 说一说你比较阅读过的一种语法或者框架的底层实现？说了协程\n  14. 什么时候可以到岗？一周可以到岗几天？可以实习多久？\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596743063414816768?sourceSSR=users",
        "title": "腾讯后台开发方向-暑期实习一面",
        "content": "自我介绍\n\n1、项目中使用redis缓存高频数据，介绍一下\n\n2、介绍中谈到你解决了缓存穿透、缓存击穿，详细讲一下\n\n3、项目中使用数据库分区，讲一下分区、分表\n\n4、刚刚你有讲到分区是底层分成了多个idb，一个数据库都会有一个frm和一个idb文件，你知道idb、frm都存储什么吗\n\n5、分区的类型，hash\\range ,项目中使用的hash，为什么没用range\n\n6、分区的优、缺点。优点答了快，为什么快。缺点呢\n\n7、Redis的数据类型哪些\n\n8、Redis6.0升级了多线程，了解吗\n\n答多线程只应用在处理网络请求，实际命令还是单线程\n\n9、那为什么6.0要引入多线程呢？（答得不好，应该是：随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上）\n\n10、刚刚你回答时提到IO多路复用，可以讲讲吗\n\n11、IO多路复用中select和epoll\n\n12、 Redis持久化了解吗\n\n13、刚刚提到AOF日志，用户操作时先写数据库还是先写AOF日志\n\n答：先写数据库，再加日志\n\n问:那这样不会有风险吗\n\n答：有，并讲了讲三种写入日志（写回硬盘）的规则Always Everysec，No，并讲述每种的优缺点，以及日志损失程度\n\n问：听说过write-ahead logging预写式日志策略吗，就是先写入日志再写入数据库，你对这个有什么想法吗？\n\n答：确实这个原则在宕机时能够损失更少的数据，但是为啥redis没用没想出来\n\n解答：redis需要先先执行指令并检查语法错误，然后再将正确的指令写入日志文件。直接写入日志就无法保证指令正确\n\n14、第二个项目，用户登录怎么做的,登录态相关\n\n15、http常用状态码 200.404~\n\n16、tcp三次握手\n\n17、平时抓过包吗? 没有\n\n18、 项目中实现了令牌桶讲一下，四种限流对比\n\n19、限流方法中有个滑动窗口法，你还记得tcp的滑动窗口吗？答上次了解是在考研时候了，跳过\n\n20、 Spring ioc讲一下\n\n21、项目技术栈有写道git，问个简单的，你查git日志怎么查的？\n\n答：在idea用界面查的~~~~囧\n\n\\---------------------------\n\n22、出个简单的算法，你做一下：题目==leetcode题1\n\n尬住了，思路一下就说出来了，然后写代码出了个小bug卡了15分钟\n\n啊啊啊啊人要疯了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596738776563499008?sourceSSR=users",
        "title": "240309 美团春招笔试代码-ak",
        "content": "很久不做题了，可能上次笔试还是去年10月的事情了。题目总的来说还是挺正常的，就是题面写的不太好，最后一题很多边界情况没解释清楚，需要自己推理尝试。写了一个小时ak了就交了，实习，秋招，春招三次笔试好像都是一个小时做完的。\n\n    \n    \n    int main(){\n        int _t = 1;\n    //    cin>>_t;\n        while(_t--) {\n            int n,k;cin>>n>>k;\n            string s;cin>>s;\n            int left = 0;\n            for(auto &c:s){\n                left += c!='M' && c!='T';\n            }\n            left -= min(left,k);\n            cout<<s.size() - left<<endl;\n        }\n        return 0;\n    }\n    \n    \n    \n    int main(){\n        int _t = 1;\n    //    cin>>_t;\n        while(_t--) {\n            int n,q;cin>>n>>q;\n            int cnt = 0;\n            for(int i = 1;i<=n;i++)scanf(\"%d\",&a[i]),cnt+=a[i] == 0;\n            ll summ = accumulate(a+1,a+1+n,0LL);\n            while(q--){\n                ll l,r;scanf(\"%lld %lld\",&l,&r);\n                cout<<summ + l * cnt <<\" \"<<summ + r *cnt<<endl;\n            }\n        }\n    \n        return 0;\n    }\n    \n\n知识点考的是二维前缀和，真的是好久没写过。因为求的是一个正方形的01数量，所以复杂度是nnn的。\n\n    \n    \n    int main(){\n        int _t = 1;\n    //    cin>>_t;\n        while(_t--) {\n            memset(arr,0,sizeof arr);\n            int n;cin>>n;\n            int res = 0;\n            map<int,int> m;\n            for(int i = 1;i<=n;i++){\n                for(int j = 1;j<=n;j++){\n                    char c;cin>>c;\n                    arr[i][j] = c-'0';\n                    arr[i][j] += arr[i][j-1] + arr[i-1][j] - arr[i-1][j-1];\n                    for(int len = 1;len<=min(i,j);len++){\n                        int cnt = arr[i][j] - arr[i][j - len] - arr[i-len][j]+arr[i-len][j-len];\n                        if(cnt * 2 == len * len)m[len]++;\n                    }\n                }\n            }\n            for(int i = 1;i<=n;i++){\n                cout<<m[i]<<endl;\n            }\n        }\n    \n        return 0;\n    }\n    \n\n老结论了，0的数量由2/5的数量共同决定。所以删除一个区间后，剩下的0的数量可以由2，5数量的最小值确定。我们先求整体的2，5数量。然后用双指针去更新，对于每一个i，找到其左边的合理的最左边的j，使得删除从j到i之间都能使得0的数量足够。\n\n    \n    \n    int main(){\n        int _t = 1;\n    //    cin>>_t;\n        while(_t--) {\n            int n,k;cin>>n>>k;\n            for(int i = 1;i<=n;i++)scanf(\"%d\",&a[i]);\n            vector<pii> v;\n            v.push_back({0,0});\n            int c2tt = 0,c5tt = 0;\n            for(int i = 1;i<=n;i++){\n                int ac = 0,bc = 0;\n                int u = a[i];\n                while((u%2)==0){\n                    ac++;\n                    u/=2;\n                }\n                while((u%5)==0){\n                    bc++;\n                    u/=5;\n                }\n                v.push_back({ac,bc});\n                c2tt += ac,c5tt += bc;\n            }\n            int c2 = 0,c5 = 0;\n            int j = 1;\n            ll res = 0;\n            for(int i = 1;i<=n;i++){\n                c2 += v[i].first,c5+=v[i].second;\n                while(j<=i && min(c2tt-c2,c5tt-c5)<k){\n                    c2-=v[j].first,c5-=v[j].second;\n                    j++;\n                }\n                res += max(i-j+1,0);\n            }\n            cout<<res<<endl;\n        }\n    \n        return 0;\n    }\n    \n\n正难则反，因为传统并查集不支持删除操作（是有这么个数据结构，但是我不会），倒序把删除操作变成添加边的操作。然后正常查询是否连接，最后将结果倒序输出。（其实思路还是挺简单的，就是一个是序号是1-1e9，需要先做离散化。其次是会出现一些不在离散化列表里的数据，和一些无意义的非法操作，需要针对性的特判，这里卡了我挺长时间）\n\n    \n    \n    #include<iostream>\n    #include <cstring>\n    #include <vector>\n    #include <set>\n    #include <map>\n    #include <unordered_map>\n    #include <queue>\n    #include <cmath>\n    #include <list>\n    #include <functional>\n    #include <algorithm>\n    #include <memory>\n    #include <numeric>\n    #include <unordered_set>\n    using namespace std;\n    typedef pair<int,int> pii;\n    typedef long long ll;\n    int a[200010];\n    int p[200010];\n    int find(int x){\n        if(p[x]!=x){\n            p[x] = find(p[x]);\n        }\n        return p[x];\n    }\n    \n    int main(){\n        int _t = 1;\n    //    cin>>_t;\n        while(_t--) {\n    \n            int n,m,q;cin>>n>>m>>q;\n            unordered_map<int,unordered_set<int>> gra;\n            unordered_map<int,unordered_set<int>> old_gra;\n            int id = 1;\n            iota(p+1,p+1+200000,1);\n            unordered_map<int,int> map_person;\n            for(int i = 1;i<=m;i++){\n                int u,v;scanf(\"%d %d\",&u,&v);\n                if(!map_person.count(u))map_person[u] = id++;\n                if(!map_person.count(v))map_person[v] = id++;\n                gra[map_person[u]].insert(map_person[v]);\n                gra[map_person[v]].insert(map_person[u]);\n                old_gra[map_person[u]].insert(map_person[v]);\n                old_gra[map_person[v]].insert(map_person[u]);\n            }\n            vector<vector<int>> actions;\n    \n            for(int i = 1;i<=q;i++){\n                int ty,u,v;scanf(\"%d %d %d\",&ty,&u,&v);\n                actions.push_back({ty,u,v});\n                if(ty==1){\n                    if(map_person.count(u) && map_person.count(v)) {\n                        if (old_gra[map_person[u]].count(map_person[v])) {\n                            gra[map_person[u]].erase(map_person[v]);\n                            gra[map_person[v]].erase(map_person[u]);\n                        }\n                    }\n                }\n            }\n    \n            for(auto &[u,gu]:gra){\n                for(auto &v:gu){\n                    p[find(u)] = find(v);\n                }\n            }\n            vector<string> res;\n            for(int i = actions.size()-1;i>=0;i--){\n                int ty = actions[i][0],u = actions[i][1],v = actions[i][2];\n                if(ty == 2){\n                    if(map_person.count(u) && map_person.count(v)){\n                        int mu = map_person[u],mv = map_person[v];\n                        if(find(mu) == find(mv)){\n                            res.push_back(\"Yes\");\n                        }\n                        else res.push_back(\"No\");\n                    }else{\n                        res.push_back(\"No\");\n                    }\n                }\n                else{\n                    if(map_person.count(u) && map_person.count(v)){\n                        int mu = map_person[u],mv = map_person[v];\n                        if(old_gra[mu].count(mv)){\n                            p[find(mu)] = find(mv);\n                        }\n                    }\n                }\n            }\n    \n            for(int i = res.size()-1;i>=0;i--){\n                cout<<res[i]<<endl;\n            }\n    \n        }\n    \n        return 0;\n    }\n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596728949795766272?sourceSSR=users",
        "title": "深信服前端实习一面",
        "content": "面试官人不错，会进行引导，但是有些知识也太深挖了[牛泪][牛泪][牛泪]\n\n全程40min左右\n\n  * 自我介绍\n  * 项目在实际生活中用到吗\n  * 有没有实习经历\n  * 一道题【find方法会有bug】\n\n> * 给定一个整数数组nums 和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。\n> * 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n> * 给定 nums = [2, 7, 11, 15], target = 9\n> * 因为 nums[0] + nums[1] = 2 + 7 = 9\n> * 所以返回 [0, 1]\n\n  * 那道题的时间复杂度，为什么\n  * 浅拷贝和深拷贝的方法\n  * 用JSON.stringify和JSON.parse进行深拷贝会有什么问题\n  * call、apply、bind使用【区别、应用】\n  * promise的方法，使用，用来解决什么问题【说完了之后面试官说只有all常用[无语子]】\n  * 缓存【知道HTTP，强，弱，说我项目没在实际使用可能不了解这个，然后还问[笑cry]】\n  * 项目中的请求用的是什么【axios】\n  * axios有没有进行封装【有】怎么封装，在哪封装，为什么要封装\n  * 本地存储方法，localStorage的使用场景\n  * cookie，安全性【HttpOnly】\n  * HTTP方法\n  * get和post的区别【说了几个，面试官说有些不常见[牛泪]，让我了解深一点】\n  * 上传文件的时候post的请求体是什么格式【Form-Data】，之前项目中用的是什么格式\n  * vue组件通信方式\n  * provide和inject的使用场景，例子\n  * 问项目【有一个项目是用python写的后端接口，面试官说不问这个了】\n  * vue的生命周期\n  * 一般在Mounted中干什么\n  * beforeDestory的使用场景\n  * token存储在哪，什么时候移除\n  * 怎么移除token，移除token的场景\n  * typeScript了解过吗\n\n问到知识盲区了属于是[牛泪][牛泪][牛泪][摸鱼中]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596726253219004416?sourceSSR=users",
        "title": "高顿教育测开一面",
        "content": "1.自我介绍\n\n2.简单介绍项目，讲讲怎么对项目进行测试的\n\n3.我看到你简历上写了很多开发技能，讲讲在测试过程中能为你带来什么优势\n\n4.讲讲你在对项目进行性能测试时遇到过什么问题\n\n5.讲讲敏捷开发模型\n\n6.什么情况下会去使用自动化测试，自动化测试的优点\n\n7.与面试官聊测试相关问题，主要为我介绍了公司的主要业务和测试相关流程\n\n8.职业规划\n\n总结：面试官人挺好，回答不全的问题也会去解答，整体面试流程25min左右\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596724173200732160?sourceSSR=users",
        "title": "哔哩哔哩后端实习一面",
        "content": "# 前言：\n\n刚放寒假的时候约了B站的面试，一面一开始是一位胖胖的面试官，面了二十多分钟，让我写一个层序遍历算法，秒了，又让写全排列，我试着用了位运算，直接让我等一下，下一位面试官也要面\n\n第二位面试官问的也不多，倒是问了一些offer的情况，面试结束后又约了其他时间一次面试，是个年轻的面试官，视频也没开，闲聊了七八分钟就结束了，啧，只能说很难评～，\n\n可能是因为我已经秋招签了不错的厂还去面实习生吧，而且在问我有没有可能去B站的时候，我说钱多就去，哎应该说誓死效忠B站的~~\n\n# 第一位面试官\n\n讲一下AOP\n\nvolite的使用\n\n讲一下线程池的参数和流程\n\nthreadlocal的用法\n\n讲一讲你熟悉的Java集合\n\nhashmap的底层结构\n\nhashmap扩容机制\n\n讲一下类的加载周期\n\n为什么string通常作为hashmap的key\n\n算法题 层序遍历\n\n算法题 全排列\n\n# 第二位面试官\n\njvm的内存结构\n\noom如何调试\n\nstatic的作用\n\nsql题：sql 表中某一用户最近几天最早登录的日期有一张login表，表中有三个字段，id，\n\ndate, user_id\n\n算法题：链表中的一段进行反转场景题\n\n希望大家最终可以拿到满意的offer！\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596719194318581760?sourceSSR=users",
        "title": "华为OD-21届考研-C++面经",
        "content": "  * **背景：目标院校，21届考研，gap3年**\n\n2023年12月底开始找工作，在牛客上联系上了 @我是栗栗呀(685674902) ，**栗栗姐给了很全面的复习建议和资料（机考，面试，综测等）**\n，刷了栗栗姐给的一些题，之后就开始走流程了。\n\n  * **一、机考（1.31） 370分**\n\n两道简单，一道中等，简单题没什么难度，印象不深了，就不说了，基本上刷过几天题就都能做出了，细心点就好，**中等题是栗栗姐给的题库中的一道原题：部门人力分配**\n，我之前看过，但是没有做，结果想复杂了，有15%用例用例超时了，最终得了370，略微有点遗憾\n\n  * **二、综测（2.1）**\n\n综测因为总共有几十道题，前后可能出现重复的问题，而且问题的形式都是“以下那个选项最符合/最不符合你的情况”这种问题，因而实际上你的每次选择都给三个选项排了一个序，最符合>次之>最不符合。如果你在前面的题目中选择了A>B>C，后面又出现A和B的时候，最好不要得出B>A的结论。\n\n我觉得这个测试最好还是按照自己的基本想法来，给自己定几个基本原则，剩下的凭感觉就好，一般人的思维方式应该是可以通过这个测试的。当然以上都是个人意见，没有任何事实依据，仅供参考\n\n  * **三、一面（2.21上午）--回家过年了，年后开始的面试**\n\n1．上来先给了两端代码，问他们的输出，考察sizeof和len的区别以及内存分配的问题，有一点难度，考察对C/C++基础知识的掌握程度，建议多看看内存分配和内存泄露。\n\n2．讲一讲C++的编译和链接\n\n3．平时会用gdb吗，讲一讲基本用法\n\n4．STL有哪些容器\n\n5．Vector和list的区别是什么\n\n6．如果要在一个循环中将vector中的奇数位元素全部删除，应该怎么做，要注意什么\n\n7．问了一些Linux shell命令行的问题\n\n8．简单介绍以下makefile和CMake\n\n9．一些Git的基本使用\n\n10．最后是手撕代码，原题22.括号生成，不难，回溯法直接解决\n\n总的来说面的一般，大部分问题都答出来了，但是有点紧张，面试时应该放轻松点，这样能发挥的更好\n\n  * **四、二面（2.21晚上）**\n\n1．上来手撕代码，还是原题，最长回文串，题目难度一般，但我还是有点紧张，结果细节不到位，debug了好一会儿才搞定\n\n2．后面问了几道八股，和一面类似，主要集中在进程线程、C++内存分配机制、指针和引用、类的构造与析构等问题上，不再赘述，建议在C++的基本原理上多下功夫。\n\n3．之后问了一下自己做过的一个项目和毕业论文的工作，都是自己做过的东西，讲起来比较得心应手，主要就是概括性的讲一下具体工作，回答几个提问即可\n\n总结：个人感觉二面比一面表现的好一些，可能是有了点经验的缘故。**两轮面试下来，问题集中在C++基本原理、操作系统和计算机网络这几部分，这几部分在栗栗姐提供的八股文资料的2、3、4章讲的比较详细，如果有在栗栗姐这边报名的，可以详细阅读这几章。**\n另外Linux的使用考察的也比较多，熟练使用Linux和Linux下的工具链很重要，既能回答问题，同时能够给面试官留下比较好的印象。\n\n  * **五、主管面，HR面（2.23）**\n\n二面结束后，最快的速度预约了主管面和HR面试，一般不聊技术，主要是了解个人情况，比如家庭情况，之前空窗期的情况，个人职业规划之类的，真诚的回答即可。面完十分钟反馈通过\n\n  * **六、Offer下发（3.7）**\n\n后面就是预约入职时间+体检，过十几天就要入职了\n\n总的来说流程是比较清晰的，栗栗姐给了很多帮助，包括提供复习资料，回答我面试流程中的问题（基本秒回），帮忙追进度等等。栗栗姐有问必答，不会出现已读不回的情况，推荐有意向的同学联系栗栗姐。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596710406878519296?sourceSSR=users",
        "title": "杭州衡泰一面",
        "content": "time：2024/3/11 20min\n\n1、自我介绍\n\n2、HashMap底层实现、扩容机制\n\n3、ConcurrentHashMap底层实现，扩容机制、如何保证线程安全\n\n4、JVM 垃圾回收器，jdk8默认使用哪个，对象什么情况会进入老年代\n\n5、Redis用过吗？两种持久化机制有什么区别？\n\n6、SpringBoot自动装配\n\n7、期望薪资\n\n  \n\n二面  3.14\n\n主要聊项目\n\n  \n\n更新:\n\n3.19交流会\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596691368471216128?sourceSSR=users",
        "title": "橙狮体育 java开发 一面",
        "content": "时间：2024.1.22\n\n时长：45分钟\n\n1、编写一个 SQL 查询，找出每个部门工资最高的员工。且工资最高的不同员工都要显示。\n\n2、java中常见的集合类了解的有哪些\n\n3、新建一个hashmap的初始容量是多少，如果是手动输入初始容量会发生什么，为什么要做临界值的处理\n\n4、ConcurrentHashMap怎么保证线程安全的？解释一下CAS的原理\n\n5、被synchronized修饰方法时指向的对象是谁\n\n6、volatile关键字有了解吗\n\n7、jvm虚拟机内存有了解吗\n\n8、垃圾回收算法了解哪些\n\n9、CMS垃圾回收器了解吗\n\n10、事务隔离级别\n\n11、mysql一定会发生幻读的情况吗？MVCC了解过吗\n\n12、回表有了解过吗？\n\n13、有两个查询语句where a=\"xxx\" and b=\"xxx\" and c=\"xxx\" 和 where a=\"xxx\" and\nc=\"xxx\",你会如何建立索引\n\n总结：这是我1月收到秋招已签三方的公司毁约后重新投简历收到的第一家面试，因为太久没有背八股了，好多都只能说出个大概，连英文单词好多都说不上来了，反正就是在我觉得非常简单的问题我都想不起来的时候我就疯狂抱歉，真的好尬呀，全程说了得有十次以上的“不好意思，我有点不记得了”，这感受谁懂，我再回想起来还是脚趾抠地，幸好现在多面几次稍微找回点状态了。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596682972430905344?sourceSSR=users",
        "title": "WXG 凉经（40m）",
        "content": "投的后台开发，简历写的 Java\n\n两道算法， 合并两个有序数组，链表倒转\n\n没问项目。\n\n网络：\n\n1\\. HTTPS了解吗，讲讲TSL 流程，\n\n2\\. CA 签发流程\n\n3\\. 浏览器缓存内CA 证书哪里来的\n\n4\\. 最后通信的时候，是怎么加密的，是用三个随机数加密吗？\n\n系统：\n\n1\\. 讲讲中断的流程\n\n2\\. 中断的类型\n\n3\\. 中断的作用\n\n4\\. 系统中堆栈的作用，区别\n\n数据库\n\n1\\. 四个特性\n\n2\\. 隔离性怎么实现的\n\n3\\. 锁（意向锁）\n\n4\\. 一致性怎么实现的\n\n5\\. 乐观锁的实现\n\n6\\. sql注入了解吗，怎么防止 sql注入\n\n反问。。\n\n好像还有别的，但是忘了。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596675725718052864?sourceSSR=users",
        "title": "深圳佰维一面 助理软件工程师",
        "content": "感谢面试官，过程还是挺轻松的，春招第一个技术面。\n\n先是介绍自己，然后根据自己的简历中的项目来介绍自己的技术栈。\n\n1.SpringMVC的实现过程（根据简历中的内容提问）\n\n2.web_server中使用的数据结构和算法（根据简历中的内容提问）\n\n3.栈和队列的区别，在进出方式有什么区别，队列和双向链表的区别\n\n4.栈和堆在函数中的内存分配情况，如果让其内存空间不释放的话要怎么做\n\n5.顺序存储和链式存储的区别\n\n6.什么是内存泄漏，内存泄漏的解决方法\n\n7.Epoll方法的具体实现方法和具体的底层逻辑\n\n8.C++中空类的占用字节，添加了构造函数和析构函数之后的占用字节，把析构函数前面加上虚函数之后\n\n9.介绍下自己学到的一些算法，我选择了说dijsktra算法和快排\n\n10.说下new delete malloc() free()的一些区别\n\n11.介绍下STL，我把我知道的基本都说了，面试官没有追问\n\n12.说下进程之间的通信方式有哪些\n\n13.软件设计模式说一个自己最熟悉的，我选的是抽象工厂模式\n\n反问：加班情况，具体工作内容，上班时间和休息情况\n\n薪资构成和公积金面试官让我后面问hr\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596667018984603648?sourceSSR=users",
        "title": "腾讯移动客户端暑期实习一面",
        "content": "1.自我介绍\n\n2.项目经历用到了哪些技术(有一篇论文在投)\n\n3.就论文当中用到的技术和库进行详细解释（intel MKL ，Eigen，octave，arpack，pardiso）等\n\n4.计算机网络 经典tcp、udp\n\n5.操作系统 死锁\n\n6.数据结构(链表的一些用法，树的一些用法)\n\n7.虚函数，虚函数表\n\n8.cpp多态和继承\n\n9.智能指针\n\n10.内存泄漏\n\n11.动态规划\n\n12.手撕算法题(两道）\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596662745152368640?sourceSSR=users",
        "title": "腾讯春招后端一面",
        "content": "# 八股部分:  \n\n1.个人介绍\n\n2.介绍下项目中有挑战的部分\n\n3.讲一下数据库的事物，说一下底层原理\n\n4.讲一下数据库的隔离级别\n\n5.讲一下数据库的的索引机制\n\n6.说一下Redis和MySQL数据同步的方案\n\n7.讲一下向某个网站从发送请求到收到数据这个过程中发生的事情。\n\n8.讲一下tcp协议握手协议\n\n9.讲一下进程与线程的区别，以及你对操作系统的理解\n\n10.线程如何数据交互，进程如何数据交互?\n\n## 算法部分：\n\n算法1：求两个数的最大公约数\n\n算法2：lru算法模拟\n\n算法3：给定一个nums数组，如［a，ab，abc，d］，如果一 个字符串添加一个字母可以在这个数组中被找到，说明他们可以成链，返回最长链条长度。\n\n# 感慨：\n\n感觉八股答得一般般，但是算法都过了。\n\n我反正都写出来，不给过也不是我的问题了吧\n\n话说腾讯会议的笔试页面感觉不太好用，没有高亮，没有自动注释，调试有些麻烦，不过whatever。\n\n感觉挺感慨的，刚开始秋招的时候手撕根本撕不出来，笔试算法也寄了好多场，如今笔试基本没问题，手撕代码也还行，感觉这半年来成长蛮多的。\n\n八股感觉好久没看都忘了，随缘面吧。还在春招的兄弟们加油\n\n春招经验的帖子小红书和微信公众号也会发，搜“肖宜”，小红书更新比较勤\n\ncsdn：“晓宜”，csdn有算法和面试的专栏，都是免费的，兴许会有帮助\n\n几个平台更新速度可能不一致，还请见谅。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596659502007463936?sourceSSR=users",
        "title": "天融信一面(过)",
        "content": "纯八股四十分钟\n\n## 自我项目\n\n## 八股\n\n  1. Java 的基本数据类型有哪些？\n  2. Integer 跟 Int 有什么关系，Integer a = 1 发生了什么？\n  3. JVM 的内存结构？堆和栈有什么区别(没有系统准备过这个问题)？\n  4. 创建线程的方法？\n  5. 线程池的核心参数？线程池是怎么使用的？如果最大线程数满了怎么办？你知道哪些拒绝策略（根据感觉瞎答的）？\n  6. 常用的线程池？（没记牢，答得磕磕巴巴）\n  7. 并发编程的三个特性（第一次听，现在才发现 Javaguide 有）？Volatile 保证了什么特性？\n  8. Synchronized 锁和 ReentrantLock 锁有什么区别？使用上有什么区别(没记住瞎答的)？\n  9. 内连接和外连接（左外连接和右外连接）的区别？join 的关键字筛选字符是(on，这个忘了)？\n  10. Mysql 事务的四种隔离级别？每个隔离级别有什么问题？\n  11. OSI 七层模型都是什么？数据链路层是做什么的(不会，答了交换器)？路由器在哪个层？\n  12. 请求转发和重定向的区别是什么(这个我完全不会，说了对重定向的理解）？\n  13. 用什么命令运行 Java 程序？用什么命令运行 Jar 包？怎么后台运行 Jar 包？\n  14. 怎么看日志的(我答的我用 cat 或者 vim)？怎么动态实时看某个文件的最后 200 行(我答的 watch...，他说还可以用什么 -lf?我不太懂他这个)？\n  15. 怎么看哪些文件的内容中包含了特定的字段(我答的 find)？\n  16. 怎么查看内存(我答的 memfree，记错了，是 free -h)？\n  17. 让我介绍我项目里的难点(我说了消息队列的项目，因为是纯自己做的)，然后问我怎么解决这些问题的(我说查 chatgpt + 谷歌)。\n  18. 反问(他说部门是做网络安全的，一个叫蜜罐的项目)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596616656487571456?sourceSSR=users",
        "title": "腾讯云校招后端一面全方位解析",
        "content": "嗨～我是可拟雀，一个全栈开发工程师，毕业于某985大学，目前供职于bat某大厂核心部门后端。每天免费分享最新面经答案，希望在大环境不好的当下能帮到你，让你多积累面试经验。免费分享个人学习2个月速通大厂路线（请看认证标），需要面经合集的请私信我～\n\n算法给定非递减数组 先求每个数平方 返回平方后的数组，这个数组也要非递减。\n\n1\\. session里存啥 session和cookie区别。\n\n答：存储位置：session是存放在服务器内存中的一个对象；而cookie是存放在客户端电脑中的一个磁盘文件。\n\n存储容量：单个cookie保存的数据一般不超过4KB，一个站点最多保存20个cookie；对于session来说并没有上限，但出于对服务器性能考虑，session内不应存放过多内容。\n\n存储方式：cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据；而session中能够存储任何类型的数据，包括且不限于string、integer、list、map等。\n\n2\\. redis和mysql双写一致性为什么删缓存而不是更新缓存\n\n答：\n\n考虑数据一致性问题：当发生数据更新时，如果先更新缓存而不更新数据库，那么缓存中的数据可能是最新的，但数据库中的数据仍然是旧的。这样，当其他请求从数据库读取数据并更新到缓存时，缓存中的数据又会被覆盖为旧数据，导致数据不一致。而如果先删除缓存，那么后续的请求会从数据库中读取最新数据并更新到缓存，从而保证了数据的一致性。\n\n避免并发：在高并发场景下，如果多个请求同时更新同一份数据，先更新缓存可能会导致数据竞争和并发问题。而删除缓存则可以让每个请求都从数据库中读取最新数据并更新到缓存，避免了并发问题。\n\n避免雪崩：如果缓存中的数据被频繁更新，那么每次更新都需要更新缓存，这可能导致缓存中的数据频繁失效，从而引发缓存雪崩。而删除缓存则可以让缓存中的数据自然过期，避免了缓存雪崩的问题。\n\n简化：删除缓存相对于更新缓存来说，逻辑更加简单和清晰。不需要考虑如何生成缓存中的新数据，只需要保证从数据库中读取的数据是最新的即可。\n\n3\\. 布隆过滤器会不会比较耗内存，添加数据怎么办，删除数据怎么办\n\n答：不会，布隆按bit存储。参考布谷鸟过滤器可以删除。\n\n4\\. 解决缓存穿透其他方法。\n\n答：\n\n  空对象缓存：缓存空对象、空集合、短过期时间。\n\n  布隆过滤器：布隆过滤器、概率型数据结构、误判率、提前判断。\n\n  热点数据缓存：热点数据、缓存、短过期时间、快速返回。\n\n  限流与降级：限流、令牌桶、漏桶、恶意攻击、异常流量、只读模式。\n\n  查询缓存预热：预热、热点数据、常见查询结果。\n\n  数据库层面优化：索引、缓存数据库查询结果、查询性能。\n\n  分布式锁：分布式锁、多实例环境、查询数据库、更新缓存、避免并发查询。\n\n5\\. 缓存击穿解决方案，抛开分布式的话如何解决？\n\n答：热点数据永不过期：热点数据、永不过期、避免击穿。\n\n缓存空值：缓存、空值、短过期时间、避免击穿。\n\n使用互斥锁：互斥锁、同步机制、单线程查询、避免并发击穿。\n\n预加载缓存：预加载、热点数据、常见查询结果、避免启动时的击穿。\n\n6\\. 为什么要分布式事务？\n\n答：数据库分库分表：这是分布式事务产生的一个主要背景，随着业务量的增长，单个数据库可能无法满足性能需求，需要将数据分散到多个数据库或数据表中。\n\n应用服务化（SOA化）：业务被拆分成多个独立的服务，每个服务都有自己的数据库。在这种情况下，跨多个服务的事务处理需要分布式事务的支持。\n\n数据一致性：分布式事务的核心目标是确保多个参与者之间的数据保持一致。这要求所有参与者都遵循相同的操作逻辑，确保数据变更的原子性、一致性、隔离性和持久性（ACID属性）。\n\n两阶段提交（2PC）：一种经典的分布式事务协调协议，分为准备阶段和提交阶段。在准备阶段，协调者询问所有参与者是否可以提交事务；在提交阶段，协调者根据参与者的响应来决定是否提交事务。\n\n三阶段提交（3PC）：两阶段提交的改进版，增加了一个准备阶段，用于解决协调者在准备阶段发生故障导致的问题。\n\n故障恢复：当分布式系统中的某个节点发生故障时，分布式事务机制能够恢复事务的状态，确保数据的正确性和一致性。\n\n扩展性和性能：分布式事务通过将事务操作分散到多个节点上，提高了系统的扩展性和性能，能够处理更多的并发请求。\n\n7\\. 给消息队列发消息失败了怎么办？\n\n答：错误日志：首先，检查应用或系统的错误日志，以获取关于失败原因的详细信息。错误日志通常会提供关于失败原因的线索，例如网络问题、权限问题、队列不存在等。\n\n重试机制：为消息发送实现一个重试机制。在发送消息失败时，你可以尝试重新发送消息。但要注意，重试应该有一定的限制，例如重试次数和重试间隔，以避免无限循环或过多的资源消耗。\n\n死信队列：使用消息队列的死信队列（Dead-Letter-Exchange,\nDLX）功能。当消息无法被正常处理时，可以将其发送到死信队列。然后，你可以从死信队列中分析这些失败的消息，并采取适当的措施。\n\n消息持久化：确保消息队列配置了消息持久化。这样，即使消息队列服务重启，消息也不会丢失。\n\n监控和告警：为消息队列设置监控和告警，以便在消息发送失败时及时获得通知。这有助于你更快地发现问题并采取相应的措施。\n\n网络检查：检查消息队列服务的网络连接是否正常。有时，网络问题可能导致消息发送失败。\n\n资源检查：检查消息队列服务的资源使用情况，如 CPU、内存和磁盘空间。如果资源不足，可能导致消息发送失败。\n\n队列和交换机检查：确保你正在发送消息的队列和交换机存在且配置正确。如果队列或交换机不存在，消息发送会失败。\n\n8\\. 自研网关需要考虑哪些因素（高可用、轻量级、性能）\n\n9\\. 限流是针对什么进行限流？\n\n答：限流（Rate\nLimiting）是针对系统或网络中的流量进行控制和限制的一种技术手段。它通过对流量进行限制，可以控制数据的传输速率，避免网络拥堵和资源浪费。限流可以应用于各种网络环境，包括互联网、局域网以及数据中心等，并可以对不同类型的流量进行限制，如HTTP请求、API调用、数据库访问等。\n\n限流的主要目的是保护系统稳定性、提高服务质量并节约资源成本。通过限制流量，可以防止恶意攻击或过多请求导致服务器负载过高，避免过多的数据库查询导致性能下降，以及防止爬虫或恶意请求对网站造成影响。\n\n后续都是常规八股，不做赘述。\n\n10\\. 限流如何配置然后突然开始问八股了（很多没答上来，问了一堆云原生、go相关的东西）\n\n1\\. docker实现原理\n\n2\\. docker的虚拟网络如何实现\n\n3\\. xss攻击\n\n4\\. sql注入\n\n5\\. 如何防止sql注入\n\n6\\. mysql的prepare 其实就是jdbc里那个prepare statement 一下子没反应过来\n\n7\\. mysql唯一索引和主键索引区别 唯一索引可以空吗 主键索引可以空吗\n\n8\\. redis的pipeline\n\n9\\. 读接口并发量高怎么优化（限流，缓存，数据库查询优化）\n\n10\\. 写接口并发量高怎么优化（异步+批量）\n\n总结：腾讯的面试比较喜欢一上来就做一道算法题，所以题感和心态要好，如果题做不出来基本上就凉了。\n\n对于项目的考察比较充分，需要充分准备各种问题的答案。\n\n八股文比较常规。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596451934198837248?sourceSSR=users",
        "title": "神经网络面试题",
        "content": "第一层是一个1*10*100的，经过一个FC之后，变成一个1*1*2的，请问这个FC的维度是什么？\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596447486202392576?sourceSSR=users",
        "title": "今日打卡！面经八股整理！",
        "content": "今天跟着小林coding还有一些文章把一些上周二面pcg面经的一些题搞懂了，借此机会通过写些文章来给自己打个卡！也借此机会能够加深记忆！这篇文章应该会持续更新，因为还有蛮多没弄完\n\n## 计算机缓存机制的理解\n\n（一开始没想出来，想拿数据库的缓存机制举下例子，后来想起来，是指CPU - 内存 - 硬盘，只简单达到访问缓存读写速度快这样，具体缓存机制，没有提到）\n\n### **要点：**\n\n缓存的原理就是在高速存储介质当中**暂时存储常用的数据** ，以便更快地满足后续的访问请求（为什么利用缓存就能更快提高访问效率？\n![](https://www.nowcoder.com/equation?tex=%5Cto&preview=true)\n局部性原理）。具体缓存机制（**缓存映射策略**）。\n\n### **什么是缓存？**\n\n**局部性原理** 确保了缓存能够提高数据访问效率\n\n> 局部性原理：\n>\n>   * 时间局部性：当前使用的指令和数据会在不久的将来还会被使用到\n>   * 空间局部性：一个元素的周围的元素可能接下来会被访问到\n>\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710074285457/2863E797EF9913E7B970B3F8571E7621)\n\n在一个简单的处理器缓存模型中，CPU通过一个特定的**地址** （Address）去访问内存，内存响应请求将数据进行返回\n\n但是，存储器如果**容量越大，速度就会越慢** 。为了处理CPU和缓存之间的这种差异，我们引入了缓存（Cache），缓存依据**局部性原理**\n来存储一些数据\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710074388272/9F32ACDF479113065FB11D22D03783A4)\n\n**缓存命中** （Cache Hit）：当处理器请求的数据恰好在缓存中时，缓存可以快速地将数据返回给CPU。\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710074480739/5DBE31FD30361538D4CD773F54D13677)\n\n**缓存丢失** （Cache Miss）：当存储的数据不在缓存中，CPU还是得去内存里面拿取数据。\n\n### **块的概念？**\n\n以64字节的内存为例\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710074545819/07F96C120DE5C7479DC5108D50509155)\n\n**按字节Byte编址：**\n\n1个格子（Grid）为一个字节（Byte）\n\n需要**6位二进制** 来访问这64个格子\n\n**按字Word编址：**\n\n1字（Word）= 4字节（Byte）= 4个格子（Grid）= 1行（Line）\n\n需要**4位二进制** 来访问这16行\n\n我们让一个块（Block）= 1字（Word） = 1行（Line）\n\n![](https://www.nowcoder.com/equation?tex=%5Cto&preview=true) 一个内存行（Memory\nLine）= 1块（Block）\n\n**四行的缓存模型：**\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710074590200/76F91E98B2C2907F032E6ADB0849490A)\n\n![](https://www.nowcoder.com/equation?tex=%5Cto&preview=true) 1缓存行（Cache Line）\n= 1块（Block），因此一个内存块就可以放入缓存中的任意一行\n\n### **缓存映射策略？**\n\n内存64B的模型，我们现在让1个块等于两个字，所以也等于两个内存行（Memory Line）\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710074642794/1A95EE399F143B4EA88EE59413E0424B)\n\n如果按照字编址，在我们定义了内存块和缓存块的基础上，我们可以将编址的4位二进制进行区分\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710074732595/896F1035421273D5B19FDF021F306DEB)\n\n  * **偏移量（Offset）** ：对于缓存中的一块，其中包含了两个字（一块=两字=两行），为了定位数据在一块中的哪一行，我们使用一位二进制来表示，叫做偏移量\n  * **索引（Index）** ：为了定位数据在缓存中的哪一块，一共四块，所以需要2位二进制，叫做索引\n  * **标记（Tag）** ：当内存里的数据（8块）映射到缓存（4块）的时候，必定会有两块被映射到相同的内存行当中，为了区分，才有了标记。\n\n这里就出现问题了，如果有不止两个被映射到同一个缓存块，那要怎么处理\n\n#### 直接映射\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710074799262/4619EA869244AFB9F7D0C5E8D1460D6E)\n\n每4个内存块映射到同一个缓存行，这样就保证每一个内存块只存入了两个缓存块\n\n  * 优点：硬件设计简单，查询速度很快（只需要通过索引）\n  * 缺点：冲突概率高（因为对应的内存块只有**固定的位置** 可以存放）\n\n#### 全相联映射\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710074842475/C1ADE8ABBD0682CDFCF92C3BCD4A63D7)\n\n一个内存可以放入**任意** 的缓存行，此时，对于内存地址我们就不需要索引来区分内存块必须放在缓存中的哪个固定位置了\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710074861833/C0152ABF739DF978D6921C8D64F98850)\n\n优点：冲突少（内存块可以映射到缓存的不同位置）\n\n缺点：查询速度特别慢，硬件设计复杂（每次我都要计算内存块放到哪一个缓存块去了）\n\n##### 组相连映射\n\n  * 组中有一个块：1路组相连\n  * 组中有两个块：2路组相连\n\n以2路组相联为例，我们可以通过1位的组索引来访问这两个组，此时标记位2位，那么一个组里面可以放入四个内存块。\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710074901812/7179341912C67DBEDB3D44F830B9A9EB)\n\n  * 一个内存块可以放入组中的任意一个内存块（全相联）\n  * 每个内存块都指定放入对应的组内（组索引）【直接相联】\n\n这样，就很好平衡了冲突发生的频率，查询速度和硬件设计复杂度\n\n### **缓存的结构？**\n\n  * 内存\n\n包含存储空间和地址，一个地址就对应一个存储空间\n\n  * 缓存\n\n同样具有存储空间，但是还有**控制信息**\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710074932595/5B0C14D1CAEC084BAA8FE7EC46400A83)\n\n  * 有效位（V）：标记该行数据是否有效\n  * 脏数据（D）：CPU多级缓存写入机制那里会讲到\n\n一行被称为一个槽（slot）\n\n## CPU里面的多级缓存\n\n### **要点：**\n\n三级缓存（L1,L2,L3），这三个缓存运作的顺序（L1\n![](https://www.nowcoder.com/equation?tex=%5Cto&preview=true) L2\n![](https://www.nowcoder.com/equation?tex=%5Cto&preview=true)\nL3）这三个内存在CPU的位置（L1,L2每个核心独有，L3多核心共享，从L1到L3离CPU核心越来越远，存储器大小越来越大），CPU缓存写入策略（**写直达**\n，**写回** ），写回如何保证缓存一致性？（**写传播** ，**事务的串行化** ），写传播的具体实现（总线嗅探），基于总线嗅探实现的协议MESI\n\n### 存储器的存储结构\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710075060951/9BB6D125C7B084F41E2474E5239F017F)\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710075086563/5F00A845225D8D7331ED55DB3AA92184)\n\n#### 寄存器（大脑所想/处理）\n\n最靠近CPU的CPU的控制单元和逻辑计算单元，就是寄存器\n\n寄存器的访问速度特别快，一般要求在半个CPU时钟周期内完成读写，CPU时钟周期跟CPU主频息息相关，比如 2 GHz主频的CPU，那么他的时钟周期就是\n1/2G，也就是0.5ns（纳秒）\n\nCPU处理一条指令的时候，除了读写寄存器，还需要**解码指令** 、**控制指令执行** 和**计算** 。\n\n#### CPU Cache（短期记忆&长期记忆）\n\nCPU Cache使用的是**SRAM** （Static Random-Access Memory，静态随机存储器）\n\nSRAM「静态」的原因是因为，数据只能在**有电** 的情况下保存，断电数据就会丢失\n\nSRAM的**访问速度非常快** ，这取决于其电路的简单\n\nCPU的高速缓存通常可以分为L1，L2，L3这样的**三层高速缓存**\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710075126536/990A2826DE8D91E1454B586583124A51)\n\n每块CPU核心都有属于自己的L1 Cache，L1高速缓存通常分成**指令缓存** 和**数据缓存**\n\n从L1到L3，位置相距于CPU越来越**远** ，容量越来越**大** ，访问速度越来越**慢** （再慢也比访问内存快的），成本价格越来越**低**\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710075163676/E8135281BCE5EC0C867E636FB16C72FD)\n\n##### 内存\n\n内存使用的是DRAM（Dynamic Random Access Memory）芯片\n\nDRAM「动态」的原因是因为电容会漏电，所以需要**定时刷新电容** ，才能保存数据\n\n##### SSD/HDD硬盘\n\n固态硬盘和机械硬盘\n\n##### 总结\n\n存储空间越大的存储器设备，其访问速度越慢，所需成本越低\n\n存储器每一层的设备只会跟**相邻的设备** 联系\n\n比如，CPU Cache 的数据是从内存加载过来的，写回数据的时候也只写回到内存，CPU Cache\n不会直接把数据写到硬盘，也不会直接从硬盘加载数据，而是先加载到内存，再从内存加载到 CPU Cache 中。\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710075241531/1D967FA83D6FDA816EE20E184CBFF175)\n\n### CPU的多级缓存机制\n\n当CPU需要访问内存中的某个数据，需要经过**寄存器** ，**L1 Cache** ，**L2 Cache** ，**L3 Cache** ，**内存**\n这几个存储器。根据顺序搜索如果在其中的某一层找到了数据，就直接返回数据给CPU\n\n其中，L1，L2是**每一个CPU核心独有的** ，而L3是**多个CPU核心共享的**\n\n### CPU缓存一致性\n\nCPU在什么时机才会把Cache中的数据写回到内存呢？\n\n#### 写直达\n\n将数据**直接同时写入内存和Cache中** ，被叫做写直达（Write Through）\n\n缺点：因为每次写操作都会把数据写入内存中，会消耗大量的时间，对性能会造成很大的影响\n\n#### 写回\n\n当发生写操作时，新的数据只会被写回Cache Block中，只有当发现Cache Block中的数据为脏的（Dirty）才会把数据写回内存\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710075323484/CDCFB3E10859C267EA25EC7AB1861A2D)\n\n意思就是，当这个数据A不在Cache，并发现Cache\nBlock发现这个数据被「其他数据B」占用了（该数据被标记为脏），我们就把数据B写回内存，并从内存把数据A更新到Cache\nBlock，同时也标记为脏（?这里有点不太懂）\n\n这样**减少了写入内存的次数** （我让别的数据帮我把新的数据放入内存，反正查询的时候命中缓存返回的也是新数据）\n\n#### 缓存一致性问题\n\n我们上述讲的写入内存的机制都是在单核的情况下考虑的，但如果是多核，因为写回不直接写入内存的特性，可能另外的核心读到的就是没有更新的情况下的。这种情况下要怎么解决呢？\n\n**写传播**\n\n当某个CPU核心里的Cache数据更新，必须传播到其他核心Cache\n\n**事务的串行化**\n\n某个CPU核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的\n\n  * CPU核心对于Cache中的数据，必须同步到其他CPU核心\n  * 要引入「锁」的概念，如果两个CPU核心里有相同的数据Cache，那么对于这个Cache数据更新，只有拿到了「锁」才能对对应数据进行更新\n\n#### 总线嗅探\n\n比如核心A修改了L1 Cache中变量`i`的值，然后我们通过总线将这个事件**广播**\n给其他所有的核心，其他核心会监听总线上的广播事件，并检查是否有相同的数据在自己的L1 Cache中，如果其他核心有这个数据，就会更新数据\n\n缺点：每次更新数据都要进行广播，会加重总线的负载\n\n#### MESI协议\n\n  * **Modified** ，已修改\n  * **Exclusive** ，独占\n  * **Shared** ，共享\n  * **Invalidated** ，已失效\n\n我们利用这四个状态来标记Cache Line四个不同的状态\n\n**「已修改」**状态就是所谓的脏标记，表示这个Cache Block上的数据已经被修改过，但是还没写到内存（同「脏」的定义，内存和Cache数据不一致）\n\n**「已失效」**表示这个Cache Block里的数据已经失效，不可再读取该状态的数据\n\n**「独占」**和** 「共享」**都表示Cache Block里的数据是干净的。\n\n  * **「独占」** ：数据只存储在一个CPU核心的Cache当中，其他核心没有这个数据。此时就不会存在缓存一致性的问题\n  * **「共享」** ：这个数据在多个CPU的Cache中都存在，此时我们利用**「总线嗅探」**的原理，在修改数据的时候，会通过总线向其他核心广播修改的请求，要求先把其他核心的Cache里面对应的数据修改成「无效」状态，然后再更新当前Cache里面的数据\n\n实例：以两个核心AB先后存储相同的数据`i`，然后修改A中的数据为例\n\n  1. 当CPU A从内存读取`i`，数据被缓存在CPU A的Cache当中，此时其他CPU核心没有存储这个数据，于是标记Cache Line为「独占」Exclusive，且此时内存和缓存数据一致\n  2. CPU B也从内存读取`i`，此时会广播其他的核心，由于A已经缓存这个数据，会把数据返回给B核心。此时，A和B对应的Cache Line存储了相同的数据，Cache Line状态变成「共享」，此时，内存和Cache缓存数据一致\n  3. A开始修改`i`的值，因为此时Cache Line为「共享」状态，所以A核心会先广播其他核心修改数据的请求，并将B核心中对应数据的Cache Line的数据置为「无效」，然后A才更改数据，此时，Cache Line的状态为「已修改」\n  4. 如果，此时A继续修改`i`的值，此时Cache Line为「已修改」状态，不需要向其他核心广播即可修改数据\n  5. 如果A中的`i`对应的Cache Line要被替换，发现此时状态为「已修改」，此时数据为脏，会在替换之前把数据同步到内存（这里就体现了写回机制，当写入新的不在缓存中的数据，且此时对应的Cache Block内的数据为脏，就先把脏数据写入内存，再把新数据进行替换）\n\n## 缓存淘汰策略\n\n  * LRU算法是啥样的？（说了最近最少使用，然后不知道说啥了说了具体实现hashmap+双向链表）\n  * 其他的缓存淘汰策略？（FIFO，轮询）\n  * Redis支持哪两种淘汰策略（LRU，LFU）\n\n### LFU\n\n**Least Frequently Used：最近最不常用算法** ，根据数据的**历史访问频率** 来淘汰数据\n\n做法：将使用频率最小的数据置换出去。\n\n实现方法：对整个缓存维护一个「程序计数器」，当一个数据被访问的时候，其访问计数器就累加1。当需要淘汰数据的时候，淘汰数据**最小** 的那一个\n\n### LRU\n\n**Least Recently Used：最近最少使用算法** ，根据数据的**历史访问记录** 来淘汰数据\n\n实现方法：Hashmap +\n双向链表。`put`数据的时候插入链表尾端，并利用hashMap实现![](https://www.nowcoder.com/equation?tex=O\\(1\\)&preview=true)的时间复杂度来访问链表中的节点。当重复数据被访问的时候将其提至链表头部。当缓存满了就淘汰链表尾端的数据\n\n### FIFO\n\n**First In First Out：先进先出算法** ，先进的数据最先被淘汰\n\n类似队列\n\n### 死锁\n\n  * 死锁？如何避免？（啊操作系统的东西全忘了，直接红豆泥私密马赛）\n  * 平时会用到锁吗？（饿汉式单例）\n\n#### **要点：**\n\n什么是死锁？死锁发生的条件？如何避免死锁？\n\n#### 死锁发生必须满足四个条件\n\n线程A拿了资源S的锁，线程B拿了资源T的锁，此时A想要拿资源T的数据，B想要拿S的数据，但是B拿着T的锁，A在等B释放；A拿着S的锁，B也在等A释放。\n\n如果没有外力介入，那么这两个线程就会**相互等待** ，程序无法继续运行，陷入了**死锁**\n\n死锁发生四个条件必须同时满足：\n\n  * **互斥**\n\n**多个线程不能同时使用同一个资源**\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710075444573/7BB5C9C487D753A15C6584771DAE4B4A)\n\n任意时刻一个资源只能给一个进程使用，如果其他资源想要使用该资源必须得等到**资源被释放** 才能获取\n\n  * **拥有并相互等待**\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710075482984/9E7DDF2988E5EB6A850F0F3C446B9DB3)\n\n**线程A在拥有资源1的同时请求资源2** ，且此时不会释放资源1但是线程B又在等待获取资源1。A请求资源2但是资源2被C拥有（吃完碗里的还看着锅里的）\n\n  * **不可剥夺**\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710075521708/8A59E693990E5BEE11283DBB0BB23EC4)\n\n当线程在使用资源时只能等资源使用完毕才会释放\n\n  * **环路等待**\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710075565365/2391149D26A4DD1E540A8B0AE12E9F22)\n\n死锁发生的时候，两个线程获取资源的顺序构成了**环形链**\n\n#### 避免死锁？\n\n产生死锁的四个条件为：互斥，拥有并互相等待，不可剥夺，环路等待\n\n那么避免死锁只要破坏其中的一个条件即可，比较常用的是**资源有序分配法**\n\n资源有序分配法：让两个线程用**相同的顺序** 来申请自己想要的资源\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710075586357/98915512C7481AF87DE271002DF6892D)\n\n## 栈和队列\n\n### 要点\n\n  * 数据结构的栈和队列啥区别？\n  * 一般用在啥场景？举些例子？（栈不记得了，队列说了消息队列）\n  * 栈和队列经常用的操作？\n\n### 应用场景\n\n**栈：**语义分析。例如我们进行括号匹配的时候，就可以使用栈来进行匹配\n\n相关题目：\n\n  * 括号匹配：左括号入栈，右括号看是否与栈顶括号匹配，匹配就栈顶括号出栈\n  * **[最长有效括号](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fleetcode.cn%2Fproblems%2Flongest-valid-parentheses%2Fdescription%2F%3FenvType%3Dfeatured-list%26envId%3D2cktkvj%3FenvType%3Dfeatured-list%26envId%3D2cktkvj)**\n\n**队列：**广泛使用在** 广度优先搜索**中，例如层次遍历一个二叉树的节点值\n\n    \n    \n    /**\n     * 树相关工具类\n     */\n    public class TreeUtils {\n        /**\n         * 将数组转化成树\n         * @param tree 树的数组\n         * @return 一棵树\n         */\n        public static TreeNode buildTree(int[] tree) {\n            TreeNode root = new TreeNode(tree[0]);\n            //同样也是利用queue来构建\n            Deque<TreeNode> queue = new ArrayDeque<>();\n            queue.add(root);\n    \n            //利用一个下标来维护树的长度\n            int index = 1;\n            while (!queue.isEmpty() && index < tree.length) {\n                TreeNode node = queue.poll();\n    \n                if (index < tree.length && tree[index] != -1) {\n                    node.left = new TreeNode(tree[index]);\n                    queue.add(node.left);\n                }\n                index++;\n                if (index < tree.length && tree[index] != -1) {\n                    node.right = new TreeNode(tree[index]);\n                    queue.add(node.right);\n                }\n                index++;\n            }\n            return root;\n        }\n    \n        /**\n         * 层次遍历树并将其输出\n         * @return\n         */\n        public static List<Integer> printTree(TreeNode root) {\n            //利用队列\n            Deque<TreeNode> queue = new ArrayDeque<>();\n            List<Integer> list = new ArrayList<>();\n    \n            queue.add(root);\n    \n    \n    \n            while (!queue.isEmpty()) {\n                TreeNode node = queue.poll();\n    \n                list.add(node.val);\n                //用一个boolean值判断是不是叶子节点，如果叶子节点我们就不进行new\n                boolean isLeaf = node.left == null && node.right == null;\n    \n                if (node.left != null) {\n                    queue.add(node.left);\n                } else if (!isLeaf){\n                    queue.add(new TreeNode(-1));\n                }\n    \n                if (node.right != null) {\n                    queue.add(node.right);\n                } else if (!isLeaf){\n                    queue.add(new TreeNode(-1));\n                }\n    \n            }\n            System.out.println(list);\n            return list;\n        }\n    \n        public static void main(String[] args) {\n            printTree(buildTree(new int[]{1, 2, 3, 4, -1, -1, 5}));\n        }\n    }\n    \n\n## 计网\n\n### :star:要点\n\nHTTP和HTTPS区别？HTTP为什么不安全？（明文传输的特点\n![](https://www.nowcoder.com/equation?tex=%5Cto&preview=true) ）\n\n  * Http和Https区别？\n  * Http没那么安全的例子？（啊？不知道了？随便乱答了个dDos攻击😵‍💫）\n  * 创建Https的过程有哪些步骤？（八股还没看到这，答不上来）\n\n### HTTP和HTTPS区别\n\n  * HTTP是超文本传输协议，信息是**明文传输** ，存在安全风险；HTTPS则解决了HTTP不安全的缺陷，在TCP和HTTP网络层之间加入了SSL/TLS安全协议，使得报文能够加密传输\n  * HTTP连接建立相对简单，TCP三次握手之后就可以进行HTTP报文传输。HTTPS在TCP三次握手之后，还需要进行SSL/TLS的握手过程，才可以加密报文传输\n  * 默认端口不一样，HTTPS是443，HTTP是80\n  * HTTPS需要向CA申请数字证书，来保证服务器的身份是可信的\n\n### HTTPS解决了HTTP什么问题\n\nHTTP明文传输的特点，所以在安全上会存在以下三个风险\n\n  * **窃听风险** ，比如通信链路上可以获取通信内容\n  * **篡改风险** ，比如强制植入垃圾广告\n  * **冒充风险** ，比如冒充淘宝网站\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710075653235/571B27097D443E3C30D8262908D0BF22)\n\nHTTPS在HTTP层和TCP层加入了`SSL/TLS`协议，可以很好的解决上述的风险：\n\n  * **信息加密：**交互的信息无法被窃取\n\nHTTPS通过**混合加密**的方式来确保信息的** 机密性**\n\n  * **校验机制：**无法篡改通信内容\n\n利用**[摘要算法](#摘要算法 + 数字签名)**来实现完整性\n\n  * **身份证书：**向CA发送数字证书来证明服务器的身份真实可信\n\n将服务器的公钥放入**数字证书**当中，解决了冒充的风险\n\n#### 混合加密\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710075680567/C916CB52FC7789EA12365CB5F9697920)\n\nHTTPS采用的是**对称加密** 和**非对称加密** 结合的「混合加密」方式\n\n  * 在**通信建立** 前采用**非对称加密** 的方式交换「会话秘钥」，后续就不再使用非对称加密（不是说「会话秘钥」是使用非对称加密，只是**交换过程** 使用非对称加密）\n  * 在**通信过程** 中全部使用**对称加密** 的「会话秘钥」的方式加密明文数据\n\n使用「混合加密」的原因：\n\n  * 通信过程使用**对称加密** ，因为只使用一个秘钥，运算速度快，这样就导致秘钥必须**保密** ，**无法做到安全的秘钥交换**\n\n  * 建立连接使用**非对称加密**，其含有两个秘钥：公钥和私钥，公钥可以随意分发，而私钥保密，**解决了秘钥交换问题但是速度慢** 。通过公钥加密的东西只能通过私钥解开，而通过私钥加密的，可以使用公钥解开。\n\n    * 公钥和私钥的用法：\n\n      1. 公钥加密，私钥解密（用于**数据加解密** ）\n      2. 私钥签名，公钥验签（用于**身份证明** ，私钥来证明我的身份）\n    * 为什么非对称加密闭对称加密慢？\n\n      * 对称加密主要的运算是**位运算** ，使用机器运算速度会很快\n\n      * 非对称加密运算涉及到**大数乘法、大数取模** 等运算（↩️回忆：Java的HashMap为什么容量是2的幂次 ![](https://www.nowcoder.com/equation?tex=%5Cto&preview=true) 计算桶位置`hash % n == hash & (n - 1)`）\n\n##### 摘要算法 + 数字签名\n\n我们会根据发送的内容生成一份「指纹」，只有当发送端和接收端收到的「指纹」是一致才能说明内容没有被篡改\n\n计算机通常会使用**摘要算法（哈希函数）**来计算内容的哈希值，也就是我们所说的「指纹」，这个** 哈希值是唯一的，且无法通过哈希值推算回原来的内容**\n\n![alt](https://uploadfiles.nowcoder.com/images/20240310/665508540_1710075736196/5E880DAB1E3E2718F6382ADD310F6D59)\n\n虽然哈希算法可以确保内容不会被篡改，**但是不能保证「内容 + 哈希值」不会被中间人替换** （可能我有个新的内容但是能保证内容 + 哈希值是一致的）\n\n所以我们这里使用**非对称加密算法**来对**内容的hash值** 来进行加密，这就是我们所说的**数字签名**\n\n  * **「私钥签名，公钥验签」** ：这样就保证了内容的哈希值不会被其他人替换了\n\n##### 数字证书\n\n上面我们已经解决了发送消息的**可靠性** （数字签名来确认消息是由持有私钥的一方来发送的）和**完整性** （对内容利用 _摘要算法/哈希算法_\n加密），而这些可以归纳为利用了**「混合加密」**的方式\n\n但是我们如何保证这一整套加密方式的可靠性呢？如果公钥和私钥都被伪造了那不就寄了？\n\n这就引入了**「数字证书」**的概念\n\n我们让第三方CA（Certificate Authority）介入\n\n我们将「个人信息 + 公钥 + 数字签名」打包成一个**数字证书** ，由CA来核验这个证书是否是可信的\n\n这个数字签名是由CA来签名确认的\n\n待续...\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596430052535877632?sourceSSR=users",
        "title": "03.10 【阿里云】提前批一面凉经 Java",
        "content": "第一次面试，记录一下，面试官人很好，项目和八股常规，手撕没写出来，gg\n\n全程1h10分钟，电话面，项目+八股+算法，算法自己卡了半小时\n\n【项目 + 八股】一些具体小问题就懒得记录了，写个大致问题的方向\n\n  * 用户登录校验的流程，5min\n  * 三级缓存怎么解决循环依赖，5min\n  * threadLocal底层，问得很细，10min\n  * CAS底层，ABA问题，5min\n  * 前后端分离的理解，5min\n  * 项目中哪里用了MQ，为什么要这样选，10 min\n\n【算法】\n\n  * ACM模式，三个线程打印”01020304...“，力扣1116\n\n没做过多线程的题，一下子懵了，到后面越来越紧张，思路都不清晰了，但面试官人很好，一直提醒我，虽然我还是没写出来，太菜了，感谢他给我第一次面试很好的体验[牛泪]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596411519127117824?sourceSSR=users",
        "title": "滴滴 秋招 提前批 面经/时间线",
        "content": "7.28-8.25开放\n\n7.31第三方平台投网约车\n\n#####  一面 8.29\n\n赛码 40min\n\n网约车 go\n\n  * 自我介绍\n  * 项目介绍\n  * Jvm\n  * 限流\n  * tcp可靠性\n  * 手撕 ：三数之和\n  * 反问 出行技术部，具体部门二面才能定\n\n#####  二面 8.29\n\n赛码 1h\n\n  * 实习（背景、需求、难点）\n  * http1.1 2.0\n  * 慢查询\n  * 死锁发生条件 预防\n  * redis的数据同步的机制 如何权衡高性能和一致性\n  * redis集群 怎么保证稳定性\n  * redis多个领导选举怎么决定\n  * 算法题：（多线程）模拟银行叫号，给定银行有5个窗口，每个窗口没5秒处理一个请求：银行大厅有25个座位，坐满之后不再放号：假设每秒中有一个用户进来，请你模拟以上的过程（写完了一直编译不过，又换了一道）\n  * 算法题：lru\n\n反问\n\n  * 增长技术部-用户运营中台（c端相关工具）\n  * 在线服务用go，后台用php\n  * 节奏偏快，简单项目一两天\n\n##### 三面 8.30\n\n本来一天三面 间隔十分钟 但三面冲突推迟了\n\n牛客 50min\n\n  * 秒杀系统考虑哪些点\n  * cnn项目（每一层的作用、cnn相比其他模型有什么优势）\n  * 实习\n  * 算法题：顺时针写入数组（写的不好）\n  * 智力题：100层楼测试两个鸡蛋（不会）\n\n反问\n\n  * 增长技术部，裂变营销、推荐、广告、新业务\n  * 主要go\n  * 1095\n\n挂了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596406957632663552?sourceSSR=users",
        "title": "腾讯 QQ 前端实习面经（二面）",
        "content": "发面经，攒人品！！！\n\n部门：QQ\n\n时间线：\n\n  * 2024-03-01 一年前的简历被捞，遂约面\n  * 2024-03-07 一面\n  * 2024-03-08 二面\n\n**二面**\n\n  1. 实习业务介绍\n  2. React18 有哪些新特性（直接用的就是 18 版本，遂回答刷视频看到过的 React 19 的新特性）\n  3. 常用的 hooks 有哪些\n  4. React Fiber 架构了解吗\n  5. Vue 组件通信方式 props 与 emitprovide 与 injectexpose 与 ref全局状态管理\n  6. Vuex 实现原理\n  7. 输入 URL 到页面展示的过程\n  8. 解析 HTML 时遇见 script 标签如何处理，script 的 defer 与 async 的区别\n  9. 了解过哪些性能优化方案\n  10. Vue-router 的实现原理\n  11. http1.0 / 1.1 / 2.0 的区别\n  12. cookie 的作用与常见属性\n  13. 开发中如何查看网络请求\n  14. 项目开发中用过哪些 ts 特性\n  15. 状态码 301/302/403 含义\n  16. package.json 作用与常见字段含义\n  17. package-lock.json 作用\n  18. node 模块解析机制\n  19. FPS 帧率的概念 ❌\n  20. Vue 中如何定义一个组件（没搞懂这个问题的意思，只回答了 SFC\n  21. 常用 Vue 指令\n  22. Vue3 中的 setup 函数具有什么作用？\n  23. 算法：大数减法\n  24. Github 仓库中的 qq 机器人项目做了什么\n  25. get 与 post 请求的区别\n  26. https 的加密过程（TLS 四次握手）\n  27. TSL 加密过程是比较消耗性能的，对于 QQ 这样的大型应用，有没有什么好的方案可以优化\n  28. Web 安全：XSS 攻击与 SQL 注入\n  29. Vue2 与 Vue3 响应式原理的区别\n\n今天最为酣畅淋漓的一场面试，几乎打穿了我的知识储备😭\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596387431524458496?sourceSSR=users",
        "title": "美团SaaS技术部-前端开发-一面（60min-已过）",
        "content": "一、八股：\n\n1.路由的 hash 模式和 history 模式的区别？\n\n2.vue2的生命周期？\n\n3.diff 算法？\n\n4.Vue2 和 Vue3 的区别？\n\n5.Vue 中 key 的作用\n\n6.Vuex?\n\n7.组件通信?\n\n8.Event Loop 的执行顺序\n\n9.如何使用 rem 或 viewport 进行移动端适配?\n\n10.实现元素水平垂直居中\n\n11.写代码：发布订阅（js）\n\n12.vue3当中响应的不一样的地方？\n\n13.vue2怎么设计的响应式\n\n14.vue3的优势？\n\n15.用flex实现居中分布\n\n16.Cookie、sessionStorage、localStorage 的区别?\n\n17.闭包?\n\n18.实现深拷贝的思路？\n\n19.async？\n\n20.script 标签放在 header 里和放在 body 底部里有什么区别？\n\n二、其他问题：\n\n1.多久开始学习前端？\n\n2.项目当中遇到了什么困难，如何解决？\n\n3.了解现在的主流框架有哪些？\n\n4.怎么学习前端？\n\n三、反问面试官\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596302571266912256?sourceSSR=users",
        "title": "美团3.9笔试题目",
        "content": "Q1：MT\n是美团的缩写，因此小美很喜欢这两个字母。现在小美拿到了一个仅由大写字母组成字符串，她可以最多操作k次，每次可以修改任意一个字符。小美想知道，操作结束后最多共有多少个'M'\n和'T' 字符? 输入 输入两个正整数n和k，代表字符串长度和操作次数第二行输入一个长度为n的、仅由大写字母组成的字符串。\n\n约束条件\n\n1≤k≤n≤10^5\n\n输出描述\n\n输出操作结束后最多共有多少个'M' 和'T'字符\n\nA1: 送分\n\n    \n    \n    import sys\n    \n    n,k = map(int,sys.stdin.readline().split())\n    s = str(sys.stdin.readline())\n    \n    count = 0\n    for c in s:\n        if c=='M' or c=='T':\n            count += 1\n    \n    print(min(count+k,n))\n    \n\nQ2:\n小美拿到了一个由正整数组成的数组，但其中有一些元素是未知的(用0来表示)。现在小美想知道，如果那些未知的元素在区间[l,r]范围内随机取值的话，数组所有元素之和的最小值和最大值分别是多少?共有q次询问。\n\n输入描述 第一行输入两个正整数n和 q，代表数组大小和询问次数。 第二行输入 n个整数 ai，其中如果输入的ai为0，那么说明ai是未知的。 接下来的\nq行，每行输入两个正整数 l 和r，代表一次询问。\n\n约束条件 1≤n,q≤10^5 0≤a_i≤10^9 1≤l≤r≤10^9\n\n输出描述 输出 q行，每行输出两个正整数，代表所有元素之和的最小值和最大值。\n\nA2:送分\n\n    \n    \n    import sys\n    \n    n,q = map(int,sys.stdin.readline().split())\n    array = list(map(int,sys.stdin.readline().split()))\n    count = 0\n    for a in array:\n        if not a:\n            count += 1\n    s = sum(array)\n    for i in range(q):\n        l,r = map(int,sys.stdin.readline().split())\n        print(s+count*l,s+count*r)\n    \n\nQ3:小美拿到了一个 nxn\n的矩阵，其中每个元素是0或者1。小美认为一个矩形区域是完美的，当且仅当该区域内0的数量恰好等于1的数量。现在，小美希望你回答有多少个ixi的完美矩形区域。你需要回答1≤i≤n的所有答案。\n输入描述 第一行输入一个正整数 n，代表矩阵大小。 接下来的 n行，每行输入一个长度为n的 01串，用来表示矩阵 约束条件 1≤n≤200 输出描述\n输出n行，第i行输出 ixi的完美矩形区域的数量。\n\nA3:完美矩阵：二维前缀和\n\n    \n    \n    import sys\n    \n    n = int(sys.stdin.readline())\n    \n    dp = [[0]*(n+1) for _ in range(n+1)]\n    \n    for i in range(1,n+1):\n        s = list(map(int,list(sys.stdin.readline().strip())))\n        su = 0\n        for j in range(1,n+1):\n            su += s[j-1]\n            dp[i][j] = dp[i-1][j]+su\n    \n    for i in range(1,n+1):\n        res = 0\n        if i%2:\n            print(0)\n        else:\n            for j in range(1,n+1):\n                for k in range(1,n+1):\n                    num = dp[j][k]-dp[j][k-i]-dp[j-i][k]+dp[j-i][k-i]\n                    if num == i*i//2:\n                        res += 1\n            print(res)\n    \n\nQ4: 小美拿到了一个大小为n的数组，她希望删除一个区间后，使得剩余所有元素的乘积未尾至少有k个0。小美想知道，一共有多少种不同的删除方案?\n\n输入描述 第一行输入两个正整数n和 k。 第二行输入n个正整数 ai，代表小美拿到的数组。\n\n约束条件 1≤n,k≤10^5 1≤ai≤10^9\n\n输出描述 一个整数，代表删除的方案数。\n\nA4:去除子区间的个数：前缀和+滑动窗口\n\n    \n    \n    import sys\n    \n    n,k = map(int,sys.stdin.readline().split())\n    array = list(map(int,sys.stdin.readline().split()))\n    \n    num_2,num_5 = [0]*(n+1),[0]*(n+1)\n    for i,a in enumerate(array):\n        num_2[i+1],num_5[i+1]=num_2[i],num_5[i]\n        while a%2==0:\n            num_2[i+1]+=1\n            a//=2\n        while a%5==0:\n            num_5[i+1]+=1\n            a//=5\n    \n    left,res = 0,0\n    for right in range(n):\n        while left<right and (num_2[n]-(num_2[right]-num_2[left])<k or num_5[n]-(num_5[right]-num_5[left])<k):\n            left+=1\n        res+=right-left\n    print(res)\n    \n\nQ5:\n小美认为，在人际交往中，随着时间的流逝，朋友的关系也会慢慢变淡，最终朋友关系就会淡忘。现在初始有一些朋友关系，存在一些事件会导致两个人淡忘了他们的朋友关系。小美想知道某一时刻中，某两人是否可以通过朋友介绍互相认识。\n事件共有 2 种: 1.1uv:代表编号u的人和编号v的人淡忘了他们的朋友关系 2.2uv:代表小美查询编号u的人和编号v的人是否能通过朋友介绍互相认识。\n注:介绍可以有多层，比如2号把1号介绍给3号，然后3号再把1号介绍给4号，这样1号和4号就认识了。\n\n输入描述 第一行输入三个正整数 n,m,q，代表总人数，初始的朋友关系数量，发生的事件数量。 接下来的 m 行，每行输入两个正整数\nu,v，代表初始编号u的人和编号v的人是朋友关系。 接下来的 q行，每行输入三个正整数 op,u,v，含义如题目描述所述。\n\n约束条件 1≤n≤10^9 1≤m,q≤10^5 1≤u,v≤n 1≤op≤2 保证至少存在一次查询操作。\n\n输出描述 对于每次2号操作，输出一行字符串代表查询的答案。如果编号u的人和编号心的人器涵过朋友介绍互治认识,则输出\"Yes\"。否则输出\"No\"。\n\nA5: 判断关系并且删除关系（不是online的）：逆序并查\n\n    \n    \n    import sys\n    \n    n,m,q = map(int,sys.stdin.readline().split())\n    \n    s = set()\n    for i in range(m):\n        u,v = map(int,sys.stdin.readline().split())\n        s.add((u,v))\n    \n    s_construct = s.copy()\n    query = []\n    for i in range(q):\n        op,u,v = map(int,sys.stdin.readline().split())\n        query.append((op,u,v))\n        if op == 1:\n            if (u,v) in s_construct:\n                s_construct.remove((u,v))\n            if (v,u) in s_construct:\n                s_construct.remove((v,u))\n                \n    fa = [-1]*(n+1)\n    csize = [1]*(n+1)\n    \n    def find(x):\n        if fa[x] == -1:\n            return x\n        fa[x] = find(fa[x])\n        return fa[x]\n    \n    def union(x,y):\n        x = find(x)\n        y = find(y)\n        if x == y:\n            return\n        if csize[x] < csize[y]:\n            x,y = y,x\n        fa[y] = x\n        csize[x] += csize[y]\n        \n    for u,v in s_construct:\n        union(u,v)\n    \n    res = []\n    for op,u,v in query[::-1]:\n        if op == 1:\n            if (u,v) in s or (v,u) in s:\n                union(u,v)\n        else:\n            res.append('YES' if find(u) == find(v) else 'NO')\n    print('\\n'.join(res[::-1]))\n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596399462059204608?sourceSSR=users",
        "title": "腾讯 QQ 前端实习面经（一面）",
        "content": "发面经，攒人品！！！！\n\n部门：QQ\n\n时间线：\n\n  * 2024-03-01 一年前的简历被捞，遂约面\n  * 2024-03-07 一面\n\n**一面**\n\n  1. 实习经历与难点介绍\n  2. 实习过程中的依赖升级是如何做的\n  3. （上一问延伸）npm 扁平安装机制如何处理版本冲突\n  4. package-lock.json 的作用\n  5. 类型体操：泛型函数\n  6. 算法：LRU 缓存（感谢牛友面经，刚好复习到了）\n  7. content-type 有哪些值, 分别代表什么?\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596193434319204352?sourceSSR=users",
        "title": "腾讯上海分部，优图实验室，测开日常实习面经（一面）",
        "content": "上来问了本科阶段学的课程，然后让介绍项目。\n\n可能是因为我的项目比较简单，只有Java SE控制台小游戏和Shell自动化脚本，所以他没有深入问八股文。只是问了我一些项目的细节，和遇到的困难。\n\n然后发了一个在线文档，让我共享屏幕并答题。第一题是**python打印数组后的控制台输出结果**\n，数组中有一个元素也是数组，形成了嵌套。要求是写出运行后控制台里的显示结果。然后有.copy.copy()，当时没做出来。后来经过研究，是python里的浅拷贝，属于入门内容。看来准备不够充分。。\n\n还有一题**简单类型leetcode**\n，设计一个方法，输入参数是一个数组，然后要求返回数组里重复两次的元素，只要求找到第一次出现的重复元素。数组已经排好序，类似[1,2,2,3,4,5,5,5,......]，最后只要输出2。当时用双层循环，暴力解出。然后面试官看我做得很吃力，所以不想再为难我，所以没有强制我优化。\n\n还有**写python/shell自动化脚本** ，统计一篇文章里每个单词重复出现的次数。分隔符为空格。比如说with with with kill\nfeel.\n\n最后就要输出\n\nwith 3\n\nkill 1\n\nfeel 1\n\n当时也没写出，确实不太应该。没复习到。网上都有，比如说[https://blog.csdn.net/cnds123321/article/details/125813205](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fcnds123321%2Farticle%2Fdetails%2F125813205)\n\n考了**Linux命令top** ，第三行所有参数的含义(这一行开头是%CPU(s))。load average是什么意思？\n\n![](https://uploadfiles.nowcoder.com/images/20240310/399225902_1710014565062/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n当时面试前复习过top命令，但只是黑马程序员免费教程的pdf，我只知道top命令会这样显示，kill\n-9命令可以终止PID对应的进程，还有top命令大概会在终端窗口显示一个模拟的任务管理器。所以最后没回答出。\n\nload average是系统平均负载。当时只要求知道概念，不要求深入了解原理。如果感兴趣，可以查看别人的博客\n[https://blog.csdn.net/mengwuyoulin/article/details/127996163](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fmengwuyoulin%2Farticle%2Fdetails%2F127996163)\n\nCPU行的参数含义，正确答案可以参考以下链接\n[https://blog.csdn.net/studyvcmfc/article/details/119842659](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fstudyvcmfc%2Farticle%2Fdetails%2F119842659)\n\n最后考了**智力题** ，甲和乙分别从AB两地出发，相向而行。具体可以参考百度知道的回答\n\n[https://zhidao.baidu.com/question/281200888.html?fr=wwwt&word=%E7%94%B2%E4%B9%99%E4%BA%8C%E4%BA%BA%E4%BB%A5%E5%9D%87%E5%8C%80%E9%80%9F%E5%BA%A6%E5%88%86%E5%88%AB%E4%BB%8Eab%E4%B8%A4%E5%9C%B0%E5%90%8C%E6%97%B6%E5%87%BA%E5%8F%91%2C%E7%9B%B8%E5%90%91%E8%80%8C%E8%A1%8C%2C%E4%BB%96%E4%BB%AC%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%9B%B8%E9%81%87%E5%9C%B0%E7%82%B9%E7%A6%BBa%E5%9C%B0&dyTabStr=MCwyLDEsMyw0LDUsNiw3LDgsOQ==](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhidao.baidu.com%2Fquestion%2F281200888.html%3Ffr%3Dwwwt%26word%3D%25E7%2594%25B2%25E4%25B9%2599%25E4%25BA%258C%25E4%25BA%25BA%25E4%25BB%25A5%25E5%259D%2587%25E5%258C%2580%25E9%2580%259F%25E5%25BA%25A6%25E5%2588%2586%25E5%2588%25AB%25E4%25BB%258Eab%25E4%25B8%25A4%25E5%259C%25B0%25E5%2590%258C%25E6%2597%25B6%25E5%2587%25BA%25E5%258F%2591%252C%25E7%259B%25B8%25E5%2590%2591%25E8%2580%258C%25E8%25A1%258C%252C%25E4%25BB%2596%25E4%25BB%25AC%25E7%25AC%25AC%25E4%25B8%2580%25E6%25AC%25A1%25E7%259B%25B8%25E9%2581%2587%25E5%259C%25B0%25E7%2582%25B9%25E7%25A6%25BBa%25E5%259C%25B0%26dyTabStr%3DMCwyLDEsMyw0LDUsNiw3LDgsOQ%3D%3D)\n\n其他记不得了，腾讯远程面试，也不允许录屏和拍照。做题的时候要求共享屏幕。\n\n总体觉得不太理想，可能已经挂了。所以要继续背八股文，做软件测试项目，刷leetcode和剑指offer。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596130637933830144?sourceSSR=users",
        "title": "【腾讯云】后端一面，OMG|0309",
        "content": "![](https://git.acwing.com/Hasity/interview_hunter/-/raw/master/2024/image/%E9%9D%A2%E7%BB%8F11%E8%85%BE%E8%AE%AF1.png)\n\n![](https://git.acwing.com/Hasity/interview_hunter/-/raw/master/2024/image/%E9%9D%A2%E7%BB%8F11%E8%85%BE%E8%AE%AF2.png)\n\n## 1\\. session里存啥，session和cookie区别\n\n**解析：**\n\n计算机网络基础题，必备题。\n\n**参考答案：**\n\n> 在Web开发中，Session和Cookie是两种常用的机制，用于在服务器和客户端之间存储和传递数据。\n>\n> Session是服务器端存储用户信息的一种机制。当用户第一次访问服务器时，服务器会为该用户创建一个唯一的Session\n> ID，并将该ID存储在Cookie中发送给客户端。客户端在后续的请求中会携带该Cookie，服务器通过Session\n> ID可以找到对应的Session数据。服务器可以在Session中存储用户的登录状态、购物车信息等数据，以便在用户不同请求之间保持状态的一致性。Session数据存储在服务器端，相对来说更安全，但会占用服务器的内存资源。\n>\n> Cookie是存储在客户端的一小段文本信息。服务器在响应中通过Set-\n> Cookie头部将Cookie信息发送给客户端，客户端会将Cookie保存起来，并在后续的请求中携带该Cookie发送给服务器。Cookie可以存储一些用户偏好设置、登录凭证等信息。由于Cookie存储在客户端，所以可以在不同的浏览器和设备之间共享，但也存在一定的安全风险，比如可能被恶意篡改或窃取。\n>\n>\n> Session和Cookie的区别主要在于存储位置和安全性。Session数据存储在服务器端，相对安全但占用服务器资源；Cookie存储在客户端，方便共享但存在一定的安全风险。\n\n**学习指导：**\n[Cookie和Session的区别](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fchen13333336677%2Farticle%2Fdetails%2F100939030)\n\n>\n> **[面经专栏直通车](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fcreation%2Fmanager%2FcolumnDetail%2F0xKkDM)**\n\n>\n> **[面经专栏下载](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgit.acwing.com%2Flicw%2F24_job_hunter)**\n\n## 2\\. redis和mysql双写一致性为什么删缓存而不是更新缓存\n\n**解析：**\n\n考察Redis作为缓存相关知识，属于常考题，必备题，难度中等。\n\n**参考答案**\n\n> 主要有以下几个原因：\n>\n>   1.\n> 数据一致性：当数据发生更新时，为了保证数据的一致性，需要先更新数据库，再更新缓存。如果先更新缓存，再更新数据库，可能会导致数据库更新失败或发生异常，导致数据库和缓存之间的数据不一致。而如果选择删除缓存，下次请求时会重新从数据库中读取最新数据并更新缓存，确保了数据的一致性。\n>   2.\n> 并发写入：在高并发的场景下，多个请求同时写入数据库可能会导致并发冲突和数据不一致的问题。如果先更新缓存，再更新数据库，可能会导致多个请求同时读取到旧的缓存数据并同时写入数据库，造成数据冲突。而删除缓存后，下次请求会重新从数据库读取最新数据并更新缓存，避免了并发写入的问题。\n>   3.\n> 缓存更新成本：更新缓存需要进行网络通信和缓存的写入操作，相对于删除缓存来说，更新缓存的成本更高。而删除缓存后，下次请求会重新从数据库读取最新数据并更新缓存，可以减少缓存更新的成本。\n>\n\n>\n>\n> 删除缓存后，下次请求会重新从数据库读取最新数据并更新缓存，可能会对系统的性能产生一定的影响，因为需要进行数据库查询和缓存写入的操作。因此，在实际应用中，需要根据具体的业务场景和性能需求来选择适合的缓存策略。\n\n**学习指导：**[Redis与MySQL双写一致性如何保证？](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjuejin.cn%2Fpost%2F6964531365643550751)\n\n## 3\\. 布隆过滤器会不会比较耗内存，添加数据怎么办，删除数据怎么办\n\n**解析：**\n\n数据结构的基本应用，数据近今年新出的题，一般与Redis易通考察。、\n\n**参考答案**\n\n> 布隆过滤器是一种用于快速判断一个元素是否存在于集合中的数据结构，它的优点是查询效率高且占用内存较少。然而，布隆过滤器也存在一些限制和操作上的考虑。\n>\n>   1.\n> 内存消耗：布隆过滤器的内存消耗主要取决于预期的误判率和要存储的元素数量。误判率越低，所需的内存空间就越大。一般情况下，布隆过滤器的内存消耗相对较小，但随着元素数量的增加，内存占用也会逐渐增加。\n>   2.\n> 添加数据：向布隆过滤器添加数据时，需要对元素进行哈希计算，并将对应的位标记为1。如果哈希冲突较多，可能会导致位的重复标记，进而影响误判率。在添加数据时，可以适当调整布隆过滤器的容量和哈希函数的数量，以平衡误判率和内存消耗。\n>   3.\n> 删除数据：布隆过滤器本身不支持直接删除已添加的元素，因为删除一个元素可能会影响其他元素的判断结果。如果需要删除元素，一种常见的做法是使用计数器或其他数据结构辅助记录元素的添加次数，然后在判断元素是否存在时，根据计数器的值进行判断。当计数器为0时，可以认为元素不存在。\n>\n\n>\n> 需要注意的是，布隆过滤器在判断元素是否存在时，可能存在一定的误判率。因此，在使用布隆过滤器时，需要根据具体的应用场景和需求来选择合适的误判率和内存消耗。\n\n**学习指导：**[布隆过滤器优化内存占用过大问题](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2FseasonLai%2Farticle%2Fdetails%2F120083299)\n\n## 4\\. 解决缓存穿透其他方法\n\n**解析：**\n\nRedis 相关知识，属于必考题。\n\n**参考答案：**\n\n> 访问一个缓存和数据库都不存在的\n> key，此时会直接打到数据库上，并且查不到数据，没法写缓存，所以下一次同样会打到数据库上。此时，缓存起不到作用，请求每次都会走到数据库，流量大时数据库可能会被打挂。此时缓存就好像被“穿透”了一样，起不到任何作用。\n>\n> **解决方案：**\n>\n> 1、**接口校验。**在正常业务流程中可能会存在少量访问不存在 key\n> 的情况，但是一般不会出现大量的情况，所以这种场景最大的可能性是遭受了非法攻击。可以在最外层先做一层校验：用户鉴权、数据合法性校验等，例如商品查询中，商品的ID是正整数，则可以直接对非正整数直接过滤等等。\n>\n> 2、**缓存空值** 。当访问缓存和DB都没有查询到值时，可以将空值写进缓存，但是设置较短的过期时间，该时间需要根据产品业务特性来设置。\n>\n> 3、**布隆过滤器** 。使用布隆过滤器存储所有可能访问的 key，不存在的 key 直接被过滤，存在的 key 则再进一步查询缓存和数据库。\n\n**学习指导：**[缓存穿透问题，线上解决方案](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F96093916)\n\n## 5\\. 缓存击穿解决方案，抛开分布式的话如何解决\n\n**解析：**\n\nRedis 相关知识，属于必考题。\n\n> 缓存击穿：某一个热点\n> key，在缓存过期的一瞬间，同时有大量的请求打进来，由于此时缓存过期了，所以请求最终都会走到数据库，造成瞬时数据库请求量大、压力骤增，甚至可能打垮数据库。\n>\n>   1.\n> 设置热点数据永不过期：对于一些热点数据，可以将其缓存设置为永不过期，确保即使缓存失效，也能够从缓存中获取到数据。这样可以避免热点数据失效后，大量请求直接访问数据库。\n>   2.\n> 加锁机制：在缓存失效的瞬间，可以使用互斥锁（如分布式锁）来保证只有一个请求能够访问数据库，其他请求等待结果。当第一个请求从数据库中获取到数据后，更新缓存并释放锁，其他请求再从缓存中获取数据。\n>   3.\n> 缓存预热：在系统启动或者定时任务中，将热点数据预先加载到缓存中。这样可以避免在热点数据失效时，大量请求直接访问数据库，而是直接从缓存中获取数据。\n>   4. 异步更新缓存：在数据更新时，先更新数据库，然后异步更新缓存。这样可以保证数据的一致性，同时减少对数据库的访问延迟。\n>   5. 限流和熔断：对请求进行限流和熔断处理，当请求量过大时，可以直接拒绝请求或者返回默认结果，避免对数据库造成过大的压力。\n>\n\n**学习指导：**[缓存穿透、缓存击穿、缓存雪崩解决方案](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F359118610)\n\n## 6\\. 给消息队列发消息失败了怎么办\n\n**解析：**\n\n消息队列相关知识，难度中等，常考题\n\n**参考答案：**\n\n> 当给消息队列发送消息失败时，可以采取以下几种处理方式：\n>\n>   1.\n> 重试发送：首先，可以尝试重新发送消息。消息队列通常提供了重试机制，可以设置重试次数和重试间隔。在发送失败后，可以根据重试策略进行自动或手动的重试操作，直到消息发送成功或达到最大重试次数。\n>   2.\n> 消息持久化：如果消息发送失败，可以将消息持久化到本地或者其他存储介质中，以便稍后进行重试。在持久化时，需要注意保证消息的唯一性和顺序性，避免重复发送或乱序发送。\n>   3.\n> 错误日志记录：记录发送失败的消息和相关错误信息到日志中，以便后续进行排查和处理。错误日志可以包含发送失败的消息内容、发送时间、错误码等信息，有助于定位问题和进行故障排除。\n>   4. 监控和报警：建立监控系统，实时监控消息队列的发送状态和错误情况。当发现消息发送失败时，及时触发报警机制，通知相关人员进行处理和修复。\n>   5.\n> 容错处理：在设计系统时，可以考虑引入容错机制，例如使用备份队列或者消息重放机制。当主队列发送失败时，可以将消息发送到备份队列，或者通过消息重放机制重新发送消息，以确保消息的可靠性。\n>\n\n>\n> 需要根据具体的业务场景和消息队列的特性选择合适的处理方式。同时，也要注意监控和及时处理发送失败的消息，以保证系统的稳定性和可靠性。\n\n**学习指导：**[RabbitMq消息丢失原因及其解决方案](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F418193165)\n\n## 7\\. 限流是针对什么进行限流\n\n**解析：**\n\n后端技术的常考提，难度简单。\n\n**参考答案：**\n\n> 限流是一种流量控制的手段，用于限制系统或服务的请求流量，以保护系统免受过载或恶意攻击的影响。限流可以针对以下几个方面进行限制：\n>\n>   1.\n> 请求频率限流：限制单位时间内的请求次数或请求速率。例如，限制每秒钟的请求次数不超过某个阈值，或者限制每分钟的请求速率不超过某个阈值。这种限流方式可以防止系统被过多的请求压垮，保证系统的稳定性和可用性。\n>   2.\n> 并发连接限流：限制同时连接到系统的请求数量。通过设置最大并发连接数，可以防止系统因为过多的并发请求而资源耗尽或崩溃。这种限流方式适用于需要控制系统负载和资源消耗的场景。\n>   3.\n> API接口限流：对特定的API接口进行限流。可以根据接口的重要性、资源消耗情况、用户权限等因素，设置不同的限流策略。这种限流方式可以保护重要接口免受滥用或恶意攻击，确保接口的可用性和稳定性。\n>   4.\n> IP限流：对特定IP地址进行限流。可以根据IP地址的访问频率、访问行为等进行限制，防止某个IP地址对系统进行恶意攻击、爬虫行为或者过多的请求。这种限流方式可以保护系统免受恶意访问的影响。\n>\n\n>\n> 限流的目的是为了保护系统的稳定性、可用性和安全性，防止系统被过载或恶意攻击。具体的限流策略和方式需要根据系统的实际情况和需求进行选择和配置。\n\n**学习指导：**[什么是限流？](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fqq_32727095%2Farticle%2Fdetails%2F129485376)\n\n## 8\\. docker实现原理\n\n**解析：**\n\n简历提到了docker，一般会问。\n\n**参考答案：**\n\n> Docker 是一种开源的容器化平台，它的实现原理主要包括以下几个方面：\n>\n>   1. 命名空间（Namespaces）：Docker 使用 Linux 的命名空间技术，包括 PID\n> 命名空间、网络命名空间、挂载命名空间等，通过隔离进程、网络、文件系统等资源，使得每个容器拥有独立的运行环境。\n>   2. 控制组（Cgroups）：Docker 使用 Linux 的控制组技术，通过限制和管理资源的使用，如\n> CPU、内存、磁盘、网络带宽等，实现对容器资源的控制和隔离。\n>   3. 联合文件系统（UnionFS）：Docker\n> 使用联合文件系统来构建容器的文件系统。联合文件系统允许将多个文件系统挂载到同一个目录下，形成一个统一的文件系统视图。Docker\n> 默认使用的联合文件系统是 OverlayFS。\n>   4. 容器镜像（Container Image）：Docker\n> 使用容器镜像来打包和分发应用程序及其依赖。容器镜像是一个只读的模板，包含了运行应用程序所需的文件系统、库、环境变量等。Docker\n> 镜像采用分层存储的方式，每一层都是一个只读的文件系统，多个镜像可以共享相同的基础层，节省存储空间。\n>   5. 容器运行时（Container Runtime）：Docker 使用容器运行时来创建和管理容器。常用的容器运行时包括 Docker 自带的\n> Docker Engine、Containerd、CRI-O 等。容器运行时负责加载容器镜像、创建容器的命名空间和控制组、启动容器进程等。\n>   6. Docker 守护进程（Docker Daemon）：Docker 守护进程是 Docker\n> 的核心组件，负责接收和处理用户的命令，管理容器的生命周期，与容器运行时进行交互，监控容器的状态等。\n>\n\n>\n> 通过以上的技术和组件，Docker 实现了轻量级、快速启动、隔离性好的容器化环境。用户可以使用 Docker 命令和 API\n> 来创建、启动、停止、删除容器，以及构建、推送、拉取和管理容器镜像。\n\n**学习指导：**[一文弄懂Docker核心技术与实现原理](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F257954941)\n\n## 9\\. docker的虚拟网络如何实现\n\n**解析：**\n\n简历提到了docker，一般会问。\n\n**参考答案：**\n\n> Docker的虚拟网络实现主要依赖于Linux内核提供的Network\n> Namespace功能，该功能可以创建多个隔离的网络空间，每个网络空间都有独自的网络栈信息。当Docker创建一个容器时，会执行一系列操作来设置和配置容器的虚拟网络。\n>\n> 以下是Docker创建一个容器时执行的主要操作：\n>\n>   1. 创建一对虚拟接口：Docker会在本地主机（Docker宿主机）和新创建的容器中各创建一个虚拟接口。\n>   2.\n> 连接虚拟接口到网桥：本地主机一端的虚拟接口会连接到默认的docker0网桥或指定的网桥上，并会获得一个以“veth”开头的唯一名字，如veth1234。\n>   3. 放置并重命名容器端虚拟接口：容器一端的虚拟接口会被放置到新创建的容器中，并修改其名字，通常是“eth0”。这个接口只在容器的命名空间内可见。\n>   4.\n> 分配IP地址：Docker会从网桥可用地址段中获取一个空闲地址，例如172.17.0.2/16，并将其分配给容器的eth0接口。同时，还会配置默认路由网关为docker0网卡的内部接口IP地址。\n>\n\n>\n> 完成上述操作后，容器就可以使用其eth0虚拟网卡来连接其他容器和访问外部网络。这种机制允许容器仿佛自己都在独立的网络中运行，而不同Network\n> Namespace的资源相互不可见，彼此之间无法通信。\n>\n>\n> 此外，Docker还提供了多种网络模式供用户选择，包括bridge模式（默认值，连接到默认的网桥）、host模式（容器使用本地主机的网络，拥有完全的本地主机接口访问权限）等。用户可以通过docker\n> network命令来手动管理网络，定制适合自身需求的网络配置。\n\n**学习指导：**[Docker\n网络模式详解及容器间网络通信](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F212772001)\n\n## 10\\. xss攻击\n\n**解析：**\n\n常见的安全相关的问题，如果问安全相关的题，属于常考题。\n\n**参考答案：**\n\n> XSS（Cross-Site\n> Scripting）攻击是一种常见的网络安全漏洞，攻击者通过注入恶意脚本代码到受信任的网页中，使得用户在浏览器中执行这些恶意脚本，从而达到攻击的目的。XSS\n> 攻击可以分为以下几种类型：\n>\n>   1. 存储型 XSS：攻击者将恶意脚本代码存储到目标网站的数据库中，当其他用户访问包含恶意代码的页面时，恶意代码会从服务器返回并在用户浏览器中执行。\n>   2. 反射型 XSS：攻击者将恶意脚本代码作为参数附加在 URL 中，当用户点击包含恶意代码的链接时，服务器将恶意代码返回给用户浏览器并执行。\n>   3. DOM 型 XSS：攻击者通过修改网页的 DOM 结构，使得恶意脚本代码被执行。这种攻击方式不涉及服务器的参与，而是直接在用户浏览器中执行。\n>\n\n>\n> XSS 攻击可能导致以下危害：\n>\n>   * 盗取用户敏感信息，如登录凭证、个人信息等。\n>   * 劫持用户会话，进行恶意操作。\n>   * 在受攻击网站上注入恶意广告或重定向到恶意网站。\n>   * 篡改网页内容，欺骗用户或破坏网站的可信度。\n>\n\n>\n> 为了防止 XSS 攻击，可以采取以下措施：\n>\n>   * 输入验证和过滤：对用户输入的数据进行验证和过滤，确保只接受合法的数据。\n>   * 输出编码：在将用户输入的数据输出到网页时，进行适当的编码，防止恶意代码被执行。\n>   * 使用 HTTP 头部中的 Content Security Policy（CSP）来限制页面中可执行的脚本。\n>   * 设置 HttpOnly 属性，防止恶意脚本通过 JavaScript 访问敏感的 Cookie 数据。\n>   * 对于存储型 XSS，对用户输入的数据进行严格的过滤和转义，确保恶意代码无法存储到数据库中。\n>\n\n**学习指导：**[web攻防之XSS攻击详解——XSS简介与类型](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F342603075)\n\n## 11\\. sql注入\n\n**解析：**\n\n常见的安全相关的问题，如果问安全相关的题，属于常考题。\n\n>\n> SQL注入是一种常见的网络安全漏洞，攻击者通过在应用程序的输入字段中注入恶意的SQL代码，从而绕过应用程序的输入验证，执行恶意的SQL查询或命令。这可能导致数据库被攻击者非法访问、数据泄露、数据篡改或系统瘫痪等问题。\n>\n> SQL注入攻击可以分为以下几种类型：\n>\n>   1. 基于错误的注入：攻击者通过构造恶意的SQL语句，利用应用程序返回的错误信息来获取数据库的信息。\n>   2. 基于布尔的盲注入：攻击者通过构造恶意的SQL语句，利用应用程序的不同响应来判断SQL语句的执行结果，从而逐步获取数据库的信息。\n>   3. 基于时间的盲注入：攻击者通过构造恶意的SQL语句，利用应用程序的延迟响应来判断SQL语句的执行结果，从而逐步获取数据库的信息。\n>\n\n**学习指导：**[入坑解读 | 什么是SQL注入？](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F151653049)\n\n## 15\\. 如何防止sql注入\n\n**解析：**\n\n常见的安全相关的问题，如果问安全相关的题，属于常考题。\n\n**参考答案：**\n\n> 要防止SQL注入攻击，可以采取以下几个关键措施：\n>\n>   1.\n> 输入验证和过滤：对用户输入的数据进行验证和过滤，确保只接受合法的数据。可以使用白名单或正则表达式来验证输入数据的格式和内容，并拒绝包含特殊字符或恶意代码的输入。\n>   2.\n> 使用参数化查询或预编译语句：使用参数化查询或预编译语句可以将用户输入的数据作为参数传递给SQL查询，而不是将其直接拼接到SQL语句中。这样可以防止攻击者通过注入恶意代码来改变SQL查询的逻辑。\n>   3.\n> 避免动态拼接SQL语句：尽量避免在应用程序中动态拼接SQL语句，特别是使用用户输入的数据拼接SQL语句。如果必须拼接SQL语句，确保对用户输入的数据进行适当的转义或编码，以防止恶意代码的注入。\n>   4.\n> 最小权限原则：数据库用户应该具有最小的权限，只能访问必要的数据和执行必要的操作。限制数据库用户的权限可以减少攻击者的影响范围，即使发生SQL注入攻击，也能最大程度地减少损失。\n>   5.\n> 使用安全的开发框架和库：使用经过安全审计和验证的开发框架和库，这些框架和库通常会提供内置的防御机制来防止SQL注入攻击。例如，ORM（对象关系映射）框架可以自动处理参数化查询，从而减少了手动编写SQL语句的风险。\n>   6.\n> 日志记录和监控：记录应用程序的日志，并监控异常的SQL查询，及时发现和阻止潜在的注入攻击。定期审查日志，以便及时发现异常行为并采取相应的应对措施。\n>   7.\n> 定期更新和维护：及时更新和维护应用程序和数据库的软件版本，以修复已知的安全漏洞。同时，定期进行安全审计和漏洞扫描，以发现和修复潜在的SQL注入漏洞。\n>\n\n>\n> 通过综合应用上述措施，可以大大降低SQL注入攻击的风险，并保护应用程序和数据库的安全。\n\n**学习指导：**[sql注入攻击的原理以及防范措施](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F617688640)\n\n## 16\\. mysql的prepare\n\n**解析：**\n\nMySQL 比较冷门的题，适当了解即可。\n\n**参考答案：**\n\n> MySQL的PREPARE语句是一种用于执行动态SQL的机制。它允许在执行之前预先准备SQL语句，并在需要时执行该语句。PREPARE语句的语法如下：\n>  \n>  \n>     复制PREPARE statement_name FROM 'sql_statement';\n>  \n>\n> 其中，`statement_name`是自定义的准备语句的名称，`sql_statement`是要准备的SQL语句。\n>\n>\n> 使用PREPARE语句的好处是可以将SQL语句与参数分离，从而提高查询的效率和安全性。通过将参数作为占位符（如`?`）放入SQL语句中，然后在执行时将具体的参数值传递给准备语句，可以避免SQL注入攻击，并且可以重复使用准备语句以提高性能。\n>\n> 下面是一个使用PREPARE语句的示例：\n>  \n>  \n>     复制PREPARE stmt FROM 'SELECT * FROM users WHERE id = ?';\n>     SET @id = 1;\n>     EXECUTE stmt USING @id;\n>  \n>\n> 在上述示例中，首先使用PREPARE语句准备了一个查询语句，然后使用EXECUTE语句执行该准备语句，并通过USING子句将参数值传递给准备语句。\n>\n> 执行PREPARE语句后，可以使用DEALLOCATE PREPARE语句来释放准备语句的资源，例如：\n>  \n>  \n>     复制DEALLOCATE PREPARE stmt;\n>  \n>\n>\n> 通过PREPARE语句，可以动态构建和执行SQL语句，提高查询的效率和安全性。但需要注意的是，PREPARE语句在使用时需要谨慎处理参数，确保参数的合法性和正确性，以避免潜在的安全风险。\n\n**学习指导：**[mysql 存储过程中的\nprepare语句](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Flqx_sunhan%2Farticle%2Fdetails%2F79852063)\n\n## 17\\. mysql唯一索引和主键索引区别 唯一索引可以空吗 主键索引可以空吗\n\n**解析：**\n\nMySQL 常考题，必会题。\n\n**参考答案：**\n\n> 唯一索引和主键索引在MySQL中有一些区别，包括是否允许为空和是否可以有重复值。\n>\n>   1. 唯一索引（Unique Index）：\n>      * 唯一索引允许为空值，即可以在索引列中存储NULL值。\n>      * 唯一索引可以用来保证数据表中某列的值是唯一的。\n>   2. 主键索引（Primary Key Index）：\n>      * 主键索引不允许为空值，即主键列不能为空。\n>      * 主键索引要求每个索引值都是唯一的。\n>      * 主键索引用于唯一标识数据表中的每一行数据，每个数据表只能有一个主键。\n>\n\n**学习指导：**[sql：主键和唯一索引区别](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fweixin_38750084%2Farticle%2Fdetails%2F84885565)\n\n## 18\\. redis的pipeline\n\n**解析：**\n\nRedis 的中等难度题，常考题。\n\n**参考答案：**\n\n>\n> Redis的pipeline是一种在客户端与服务器之间进行批量命令传输和响应的技术。它允许客户端一次性发送多个命令给服务器，而不需要等待每个命令的响应。服务器收到这些命令后，会将它们按顺序执行，并将所有命令的响应一次性返回给客户端，从而减少了通信的往返次数，提高了性能和吞吐量。Pipeline对于需要批量处理的场景非常有用，例如批量写入、批量读取等。\n\n**学习指导：**[Redis\nPipeline这一篇就够了](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjuejin.cn%2Fpost%2F6904433426560974856)\n\n## 19\\. 读接口并发量高怎么优化（限流，缓存，数据库查询优化）\n\n**解析：**\n\n一般是和项目关联，结合项目回答即可。\n\n**参考答案：**\n\n> 当接口的并发量高时，确实需要通过多种策略来优化性能。以下是一些针对限流、缓存和数据库查询优化的建议：\n>\n> **限流**\n>\n> 限流是控制接口请求速率的一种手段，目的是防止因过多的请求而导致的系统崩溃或资源耗尽。\n>\n>   1. **令牌桶算法或漏桶算法** ：使用这两种算法来限制接口的请求速率。令牌桶算法允许突发流量，而漏桶算法则更加平滑。\n>   2. **分布式限流** ：对于微服务架构，可以使用Redis等分布式系统来实现全局限流。\n>   3. **API网关限流** ：在API网关层进行限流，可以保护后端服务不受过量请求的冲击。\n>\n\n>\n> **缓存**\n>\n> 缓存可以显著提高接口的响应速度，减少对数据库的访问次数。\n>\n>   1. **本地缓存** ：使用如Guava Cache、Ehcache等本地缓存库，存储热点数据。\n>   2. **分布式缓存** ：对于需要共享缓存的场景，可以使用Redis、Memcached等分布式缓存系统。\n>   3. **缓存击穿与雪崩**\n> ：注意处理缓存击穿（当缓存中没有数据，大量请求直接打到数据库）和缓存雪崩（大量缓存同时失效，导致请求全部打到数据库）的问题。\n>\n\n>\n> **数据库查询优化**\n>\n> 数据库查询优化是提升接口性能的关键环节。\n>\n>   1. **索引优化** ：确保经常查询的字段都有合适的索引，同时避免全表扫描。\n>   2. **SQL语句优化** ：简化复杂的SQL语句，避免在SQL中使用子查询和复杂的连接操作。\n>   3. **读写分离读写** ：使用主从复制等技术，将读操作和写操作分离到不同的数据库服务器上，提高并发性能。\n>   4. **批量操作** ：尽量减少数据库的操作次数，可以将多次操作合并为一次批量操作。\n>   5. **数据库连接池** ：使用数据库连接池可以减少数据库连接的创建和销毁开销。\n>\n\n>\n> **其他优化策略**\n>\n> 除了上述提到的限流、缓存和数据库查询优化外，还可以考虑以下策略：\n>\n>   1. **异步处理** ：对于非实时性要求较高的请求，可以使用异步处理的方式，减少主线程的阻塞时间。\n>   2. **负载均衡** ：通过负载均衡技术，将请求分发到多个服务器上，提高系统的处理能力。\n>   3. **服务拆分** ：对于复杂的业务逻辑，可以将其拆分为多个微服务，降低单个服务的复杂度。\n>   4. **监控与告警** ：建立完善的监控与告警系统，及时发现并解决性能瓶颈。\n>\n\n**学习指导：**[高并发读写优化方案](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F1266930)\n\n## 20\\. 写接口并发量高怎么优化（异步+批量）\n\n**解析：**\n\n一般是和项目关联，结合项目回答即可。\n\n**参考答案：**\n\n> 写接口并发量高时，可以采取以下优化措施：\n>\n>   1. **异步处理：**\n> 将写接口的处理逻辑进行异步化，使用消息队列等技术将请求放入队列中，然后异步处理队列中的请求。这样可以减少请求的排队等待时间，提高接口的并发处理能力。\n>   2. **单线程变多线程** 写、批量写操作\n>   3. **批量处理,合并写请求：**\n> 将多个写操作合并成批量操作，减少单个写操作的次数，从而减少对数据库的频繁访问。通过批量操作可以提高数据库的吞吐量，减少写入操作的响应时间。\n>\n\n**学习指导：**[高并发读写优化方案](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F1266930)\n\n>\n> [更多面经直通车](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fusers%2F630265916)\n\n>\n> [原贴连接](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fusers%2F548238257)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596397054415462400?sourceSSR=users",
        "title": "base北京 百度 前端实习面经",
        "content": "部门：质量效能\n\n投递渠道： BOSS 直聘\n\n时间线\n\n  * 2024-02-27 一面\n  * 2024-02-27 二面\n  * 2024-03-06 三面\n\n**一面**\n\n  1. 实习经历业务介绍\n  2. Vue 响应式原理, 开始吟唱 😎\n  3. Vue 常见的指令\n  4. V-if 与 V-show 的区别\n  5. 输入 URL 到页面展示的过程\n  6. 定义 CSS 的三种方式\n  7. CSS 选择器与优先级\n  8. get 请求与 post 请求的区别, 传参格式与传参位置有什么区别\n  9. 跨域问题与解决方案\n  10. 设计实现七天免密登录\n  11. 算法：括号合法性判断\n\n**二面 15 min**\n\n  1. 为什么离职\n  2. 输入 URL 到页面展示的过程（怎么又问一遍\n  3. 手写代码，原生实现输入框输入时, p 标签中同步显示输入内容\n  4. 用过哪些 Linux 命令\n  5. 看代码说结果:\n\n    \n    \n    var i = 0;\n    for (i = 1; i <= 3; i++)\n      setTimeout(function () {\n        console.log(i);\n      }, 0);\n    // 4 4 4\n    // 解释: 先执行完 for 循环, i 的值变为 4, 然后再执行宏任务\n    \n    \n\n  1. 什么是 XSS 攻击\n  2. 如何理解 Promise, 有哪些常见的方法\n\n**三面 30min**\n\n  1. 实习难点\n  2. React 与 Vue 的区别\n  3. 新项目技术选型, 可以从哪些维度考虑使用 React 或者 Vue\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596124837462978560?sourceSSR=users",
        "title": "美团3.9 笔试",
        "content": "T1 T2 T3水题不说了\n\n### T4\n\n> 题目描述: 小美拿到了一个大小为n的数组，她希望删除一个区间后，使得剩余所有元素的乘积末尾至少有k个 0。小美想知道，一共有多少种不同的删除方案？\n>\n> 输入: 第一行输入两个正整数n，k。第二行输入n个正整数ai，代表小美拿到的数组。\n>\n> 1<=n,k<=10^5\n>\n> 1<=ai<=10^9\n>\n> 输出: 一个整数，代表删除的方案数。\n>\n> 示例 1\n>\n> 输入\n>\n> 5 2\n>\n> 2 5 3 4 20\n>\n> 输出\n>\n> 4\n>\n> 说明\n>\n> 第一个方案，删除[3]。\n>\n> 第二个方案，删除[4]。\n>\n> 第三个方案，删除[3,4]。\n>\n> 第四个方案，删除[2]。\n\n思路:\n\n计算构成0的个数，其实就是计算2和5的个数最小值。假设数组中2的个数为x，5的个数为y，构成0的个数就是min(x,\ny)。假设某区间2和5的个数分别为x1和y1，那么如果删除该区间，剩余2的个数为x-x1，剩余5的个数为y-y1，如果min(x-x1, y-y1) >=\nk，那么该区间可以删除。先计算2和5的前缀和，然后枚举可以删除的区间\n\n    \n    \n    import java.io.*;\n    public class T4 {\n        static final int N = 100010;\n        static int[] a = new int[N], pre2 = new int[N], pre5 = new int[N];\n        static int n, k, total2, total5;\n        public static void main(String[] args) throws IOException{\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String[] str = br.readLine().split(\" \");\n            n = Integer.parseInt(str[0]);\n            k = Integer.parseInt(str[1]);\n    \n            str = br.readLine().split(\" \");\n            for (int i = 0; i < n; i++) {\n                a[i] = Integer.parseInt(str[i]);\n                int cnt2 = cal(a[i], 2), cnt5 = cal(a[i], 5);\n                total2 += cnt2;\n                total5 += cnt5;\n                pre2[i + 1] = pre2[i] + cnt2;\n                pre5[i + 1] = pre5[i] + cnt5;\n            }\n    \n            int res = 0;\n            for (int i = 0, j = 0; i < n; i++) {\n                while (j < n) {\n                    int cnt2 = pre2[j + 1] - pre2[i];\n                    int cnt5 = pre5[j + 1] - pre5[i];\n                    int remain2 = total2 - cnt2, remain5 = total5 - cnt5;\n                    if (Math.min(remain2, remain5) >= k)\n                        j++;\n                    else\n                        break;\n                }\n                res += Math.max((j - i), 0);\n            }\n            System.out.println(res);\n        }\n    \n        public static int cal(int num, int mod) {\n            int cnt = 0;\n            while (num != 0) {\n                if (num % mod == 0)\n                    cnt++;\n                else\n                    break;\n                num /= mod;\n            }\n            return cnt;\n        }\n    }\n    \n\n### T5\n\n> 题目描述: 小美认为，在人际交往中，但是随着时间的流逝，朋友的关系也是会慢慢变淡的，最终朋友关系就淡忘了。\n>\n> 现在初始有一些朋友关系，存在一些事件会导致两个人淡忘了他们的朋友关系。小美想知道某一时刻中，某两人是否可以通过朋友介绍互相认识？\n>\n> 事件共有 2 种：\n>\n> 1 u v：代表编号 u 的人和编号 v 的人淡忘了他们的朋友关系。\n>\n> 2 u v：代表小美查询编号 u 的人和编号 v 的人是否能通过朋友介绍互相认识。\n>\n> 注：介绍可以有多层，比如 2 号把 1 号介绍给 3 号，然后 3 号再把 1 号介绍给 4 号，这样 1 号和 4 号就认识了。\n>\n> 输入描述:\n> 第一行输入三个正整数n,m,q，代表总人数，初始的朋友关系数量，发生的事件数量。接下来的m行，每行输入两个正整数u,v，代表初始编号u的人和编号v的人是朋友关系。接下来的q行，每行输入三个正整数op,u,v，含义如题目描述所述。\n>\n> 1 <= n <= 10^9\n>\n> 1 <= m,q <= 10^5\n>\n> 1 <= u,v <= n\n>\n> 1 <= op <= 2\n>\n> 保证至少存在一次查询操作。\n>\n> 输出描述: 对于每次 2 号操作，输出一行字符串代表查询的答案。如果编号 u 的人和编号 v\n> 的人能通过朋友介绍互相认识，则输出\"Yes\"。否则输出\"No\"。\n>\n> 示例 1\n>\n> 输入\n>\n> 5 3 5\n>\n> 1 2\n>\n> 2 3\n>\n> 4 5\n>\n> 1 1 5\n>\n> 2 1 3\n>\n> 2 1 4\n>\n> 1 1 2\n>\n> 2 1 3\n>\n> 输出\n>\n> Yes\n>\n> No\n>\n> No\n>\n> 说明:\n>\n> 第一次事件，1 号和 5 号本来就不是朋友，所以无事发生。\n>\n> 第二次事件是询问，1 号和 3 号可以通过 2 号的介绍认识。\n>\n> 第三次事件是询问，显然 1 号和 4 号无法互相认识。\n>\n> 第四次事件，1 号和 2 号淡忘了。\n>\n> 第五次事件，此时 1 号无法再经过 2 号和 3 号互相认识了。\n\n思路: 逆向并查集.\n正向使用并查集因为涉及到删除操作，所以无法使用。但是我们可以逆向使用，先构建所有的边，然后将所有需要删除的边全部删除，从后往前遍历q个操作。\n如果是查询操作，直接使用并查集即可，如果是删除操作，我们就进行加边的操作\n\n> 还需要做离散化，因为n的范围为1e9，太麻烦，懒得处理了\n    \n    \n    import java.io.*;\n    import java.util.*;\n    public class T5 {\n        static final int N = 100010;\n        static int[] fa = new int[N];\n        static List<String> res = new ArrayList<>();\n        static int n, m, q;\n        public static void main(String[] args) throws IOException{\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String[] str = br.readLine().split(\" \");\n            n = Integer.parseInt(str[0]);\n            m = Integer.parseInt(str[1]);\n            q = Integer.parseInt(str[2]);\n    \n            for (int i = 0; i < N; i++)\n                fa[i] = i;\n    \n            Set<int[]> edge = new HashSet<>();\n            Set<int[]> del_edge = new HashSet<>();\n            List<int[]> ops = new ArrayList<>();\n            for (int i = 0; i < m; i++) {\n                str = br.readLine().split(\" \");\n                int u = Integer.parseInt(str[0]), v = Integer.parseInt(str[1]);\n                edge.add(new int[]{u, v});\n            }\n    \n            for (int i = 0; i < q; i++) {\n                str = br.readLine().split(\" \");\n                int op = Integer.parseInt(str[0]), u = Integer.parseInt(str[1]), v = Integer.parseInt(str[2]);\n                if (op == 1) {\n                    del_edge.add(new int[]{u, v});\n                    del_edge.add(new int[]{v, u});\n                }\n                ops.add(new int[]{op, u, v});\n            }\n    \n            // 并查集建边\n            for (int[] t : edge) {\n                boolean flag = false;\n                for (int[] x : del_edge) {\n                    if (t[0] == x[0] && t[1] == x[1]) {\n                        flag = true;\n                        break;\n                    }\n                }\n                if (flag)\n                    continue;\n                merge(t[0], t[1]);\n            }\n    \n            for (int i = q - 1; i >= 0; i--) {\n                int[] t = ops.get(i);\n                int u = t[1], v = t[2];\n                if (t[0] == 1) {\n                    merge(u, v);\n                } else {\n                    int a = find(u), b = find(v);\n                    if (a == b)\n                        res.add(\"Yes\");\n                    else\n                        res.add(\"No\");\n                }\n            }\n            for (int i = res.size() - 1; i >= 0; i--) {\n                System.out.println(res.get(i));\n            }\n        }\n    \n        public static int find(int x) {\n            if (x != fa[x])\n                fa[x] = find(fa[x]);\n            return fa[x];\n        }\n    \n        public static void merge(int a, int b) {\n            int ta = find(a), tb = find(b);\n            fa[ta] = tb;\n        }\n    }\n    \n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596108253239455744?sourceSSR=users",
        "title": "校招面试—如何正确和理性的看待",
        "content": "最近看到一些帖子，还有之前我写的文章里大家的评论，**会有一些人对面试的心态有些不太稳定，也有被面试官搞心态的情况**\n。因为我对于面试者和面试官都有不少的经历，所以结合自身的经验，来相对客观的说明一下，如何正确和理性的看待校招的面试。\n\n#### 目标始终如一\n\n无论怎么样，我们都需要始终牢牢把握住面试的方向：**求职+积累经验** 。仅仅是这两个方向而已，**其他的都是次要的**\n。把握好了主方向，对于一些不重要的事情和可能的情况，便可以比较淡然的处理和看待了。\n\n#### 接受不同面试官的差异性\n\n其实和去饭店吃饭也是类似的，有服务态度好的，就有服务态度差的，是非常正常的事。再加上公司的水平参差不齐、\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596103991776292864?sourceSSR=users",
        "title": "东宝软件 （二次开发工程师） 一面",
        "content": "时间：2024.3.5\n\n时长：40分钟\n\n1、自我介绍\n\n2、mysql数据库修改连接池要怎么操作\n\n3、实现项目中做的业务主要有哪些，为什么不留在实习公司\n\n4、职业规划，为了自己的职业规划会做什么样的努力呢\n\n5、做项目什么时候会用到事务，事务可以解决哪些问题\n\n6、数据库分页用什么关键词，分组用什么关键词，group by 加条件用什么关键词\n\n7、手写sql语句\n\n订单表（id，店铺id，订单金额，订单生成时间，支付状态）\n\n店铺表（店铺id，店铺名称，店铺图片、店铺描述）\n\n查询上个月销售额最高三个店铺的信息\n\n写完了面试官问如果发现查询比较慢你会怎么优化sql语句\n\n8、servlet1和servlet2的区别\n\n9、springMVC的工作原理\n\n10、期望薪资，实习的期望薪资\n\n11、是二开，且要出差可以接受吗？\n\n总结：当天就收到结果说面试通过了，二面是要求写一个小项目但是要求在第二天中午前完成，我拒了，因为第二天早上我有一个比较中意的公司的面试，想多花一些时间去准备。虽然没参加东宝软件的二面有些遗憾，但我不后悔，我中意的那家面试在这星期顺利通过了一二面，希望会有一个好的结果。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596091495497641984?sourceSSR=users",
        "title": "Java双非大二找实习记录",
        "content": "先说结论：2.22→3.6线上+线下面了七家，最后oc两家小公司，接了其中一个。\n\n### 本人bg：\n\n真·名不经传双非一本，无绩点无竞赛无奖项无实习，23年12月开始学java。若非要说一点相关的经历，就是有java基础，韩顺平的课用了一年断断续续看了400集（总共910）。以下仅为个人经历和感悟分享，运气成分较大。\n\n### 路线\n\n黑马的路线，具体为：javase（黑马20天版）→黑马最新javaweb→苍穹外卖→mybatisplus→黑马点评\n\n这一套下来java基础技术栈已经入门了，我就开始搓简历找工作。其实也并不是特别顺利，boss上面海投也多是已读不回，但是还是约到一些面试机会作为练手。\n\n### 第一阶段：boss海投，时间：2月22号\n\n编辑好在线简历，说什么都答应，实习时间问就是六个月以上，全国海投一直到boss投满了。约到了我第一个线上面，具体记录如下图，真的非常紧张，可以说是“裸面”了。这个面试不出意外的挂了，其实我也没抱指望，所以没让我灰心。\n\n###\n![](https://uploadfiles.nowcoder.com/images/20240309/39850392_1709985881269/A461A99C2E33B3D5345E1571A563CDBE)第二阶段：线下双选会，时间：2月26号。\n\n首先，最后接到offer的两家公司都是在这投来的。其次，我个人认为这个场合是个锻炼面试能力的好地方。如果各位的学校也有类似的活动，或许可以像我一样去凑凑热闹，或许有惊喜呢？\n\n作为大二，我本来只是以一种逛街的方式去看看的，当时的我并没有指望在这里找到实习，因为毕竟面向春招嘛。但是我这不是刚好搓了简历吗，随手打印了二十份，投着玩玩。一开始就吃了闭门羹，不过后面就顺溜起来了。什么行业我都去聊一聊，反正来逛街嘛，了解下各行各业的状况。从互联网安全汽车游戏聊到销售，我感兴趣的或者我完全看不懂的岗位我都问问，你们这个是招什么呀，需要什么前置技能呀？还有一些公司有java开发的，我就直接问问他们招不招实习生，然后把我的简历给他们，阐述我的基本信息。我不太记得我聊了多少，但是越到后面，我越能感觉到我的紧张消失，表达也变得更加流利。我认为，这也是对我影响很大的一次“面试训练“。\n\n### 第三阶段：真正的面试，时间 2月27-3月6\n\n前面的网上海投还有些别的收获，我成功约到了一些小公司、较知名企业和知名企业的面试。\n\n其中有交通两小时，面试六分钟，薪资一百块，后续沉大海的小公司。还有“我们希望招一个开发助理”，“我认为根据文档编写代码没有自己思考”，“招一个长期实习和公司共进退”的画饼公司，什么莫名其妙的面试我都接（这里接出一个感触，非要你线下面的公司极大程度上不靠谱，但是可以练练表达）。\n\n技术面试对我的帮助非常大，特别是遇见好的面试官的时候。\n\n我有最大提升的一次，是某披萨公司的技术面。面试官老师根据我的学习情况一点点问，耐心的跟我讲，几乎有点在授课的意思了。我没有背过八股，面试官老师就全问我应用层面的事情，问我的项目，最后给我提了很多建议，还对我说大二这样很不错了，并透露如果我要过来他那边没问题（可能因为招的是技术支持，要求较低）。我开心得飞天了！！！！面试完我去教室上课一路上嘴都咧到耳朵上了。因为这次面试的反馈，我下去又熟悉了项目，学习了下不懂的知识点，并意识到我对这个项目理解得太浅。\n\n再一次就是，某知名企业的面试邀约，让我从头到脚慌了，这段时间吃不下饭睡不着觉，三四天的时间，背八股，看项目，熟悉简历知识点。虽然还是挂了，但是这个准备的过程又让我收获很多。在面试的阶段，面试官直接把我做的项目落地了，问我，这样你怎么解决，那样你怎么解决，这个怎么设计的，那个怎么设计的。我真正意识到，我做的东西是玩具，这个项目有很多地方需要完善，而我没做。\n\n面完我其实已经意识到自己欠缺的东西非常非常多了，我已经不打算去实习了。下一步的计划是继续深耕项目八股算法，但是还是打算把之前约的最后两家面完。\n\n就是这两家出现了一些转机，或许是因为我已经不在意了，表现得更加好，或许也是有了前面的积淀，让我能更好的应对了。还有一些运气因素，比如，刚背的知识点刚好被考到了！再比如，算法怎么挑我会的出！总之，最后这两家过了，我也决定入职其中一家。一是考虑到学校不占优势，或许有实习经历可以写简历上我之后的简历会更好过筛，二是进公司有人push我，还能接触真开发，或许比我闭门造车好。\n\n到这，我的找实习之旅就告一段落，下周一，我就是现役打工人了。\n\n### 有非常多感受想分享：\n\n一个是，大二找实习真是自带光环，所有面试官都会因为你是大二放低对你的要求，八股问简单的，算法出简单的，甚至需要问你，学过吗，开始背八股了吗，写过算法题吗？所有的面试都是正反馈，每次面试完我都很开心。\n\n二是，在大城市上学的优势在找实习的时候完全体会到了，好处就有，岗位多，而且小公司更愿意要本来就在本地的学生（个人分析了下，可能本地学生不需要支付房租，工资给低也能cover生活，从而稳定性高），那无形之中就有了更多练手机会。二就是，无交通成本，无租房成本，入职完全无负担。不想干了感觉撂挑子直接就走了，完全不需要考虑什么押一付三的房租，回学校的机票。甚至学校有突发状况还能直接请假回去，或者期末考试，请个假考完无缝又可以上班了，所有事情都非常方便。（以上仅针对学校无优势的菜鸟找第一份实习例如我，公司肯定更愿意要9爷呜呜，大公司也没有这些顾虑）。\n\n三是，找实习的时间节点很重要，我是在春节假期过后第一周开始找的，可能这会儿实习生过春节再加开学离职多，能约到面试也有这个原因。\n\n四是，不要等准备好了再投，两个项目写完，搓一个简历，投起来，走入下一个阶段的你，更能明白现在这个阶段的自己有什么不足。而如果你一直停留在”准备阶段“，其实是有局限性的，一方面看不清前路，一方面，要准备到什么时候才算准备好呢？\n\n五是，这些准备完全无法面过大公司，还需要回头恶补基础知识，猛刷算法，狂背八股。\n\n最后就是，前期一定要海，被拒不要沮丧。分析原因，重整旗鼓，下次就是更厉害的自己了！![](https://uploadfiles.nowcoder.com/message_images/20240321/39850392_1710994518573/discuss_1710994518062.jpeg)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596064413442949120?sourceSSR=users",
        "title": "2024U3D游戏客户端，社招面经(一)",
        "content": "#### 前言：记录下自己面试的经验，因为自己从其他同学的面经中受益良多，现在也想记录一下\n\n已经面试完了。最终选择了网易，想想这一个月的社招还是很艰辛。\n\n挂了或者拒绝了：完美世界手游。盛趣。MetaApp。吉比特。途游。友塔(二面什么都没问，然后评估了一个星期，给挂了，服)。网易外包(因为职业规划不合面试官心意，服)。大梦龙途。完美世界诛仙1。飞鱼科技。冰川网络。小牛互联。域起网络。微派手游。凉屋游戏(让做一个Gamefeel的游戏demo，实在没时间做了)。\n\n最终offer：网易\n\n#### 面试问题：（不敢标注具体公司，狗头保命）\n\n### 一：\n\n  1. C#和C++的类的区别\n  2. C# List添加100个Obj和100 int内存是怎么变化的（一个一个添加），我答错了，可能觉得我不太熟悉C#开始问C++，（刚刚查了下原来C#的List居然是个数组。。虽然也不奇怪C#没有指针）\n  3. 重载和重写的区别，重载是怎么实现的\n  4. 重写是怎么实现的？（当时没听懂面试官说的是什么问题，然后我就往我懂的方向去引导了。我答的是子类继承父类虚函数的实现过程虚函数表和指针的实现，）\n  5. 虚函数表是类的还是对象的\n  6. 用过哪些C++的STL\n  7. Vector底层是怎么实现的\n  8. Vector添加一百次数据内存是怎么变化（一个个添加）\n  9. Map的底层，红黑树的查询和插入的时间复杂程度，Unordermap的底层实现是什么\n  10. List的底层是怎么实现的（发现自己对List完全不了解下来一定好好看看），队列是怎么实现的（我只记得用两个栈可以实现）\n  11. 给了游戏场景，场景里面有6个玩家扮演贪吃蛇进行3v3，场景里面有水果吃了可以边长，蛇碰到队友没有问题，碰到自己的尾巴也没有问题，碰到对手的尾巴的时候会死掉。问怎么把游戏抽象用代码实现（感觉自己答的贼好不知道为什么答的都很对，可能以前做过MMO的全栈开发思想比较符合）\n  12. 我简历上面说我平常做了游戏UI的优化，问我怎么优化的UI\n  13. 为什么要用图集，规定图集的大小，超出了图集大小怎么办\n  14. 了解drawcall吗，什么情况下drawcall会被打断\n  15. 了解渲染吗\n  16. 你在上个RPGMMO项目里面的服务器代码是怎么实现的，你们服务器有多少个进程和线程，进程之间是怎么通信的(我说我不知道，是我我只会用tcp/udp连接通信)\n  17. tcp/udp在哪一层，socket呢\n  18. C++和lua是怎么通信的\n  19. C++和C#的异同（我没总结过，我凭感觉答的，我说最大是GC，C#不用操作和管理指针）\n  20. 了解九宫格吗，原理是怎么样的呢，怎么让一张很小的图变大\n  21. 说下面对对象设计\n  22. 你在项目里面做了哪些UI系统，讲一下\n  23. 你们UI的消息是怎么交互的，讲下你们项目的UI框架\n  24. 了解过资源的更新吗，如果一个很大的图集更新，但是里面只更新了一小张图，更好的更新方式是什么，难道是直接更新一个图集吗，（最后引导下来是先更新一个小图过去维护功能，不打进图集，下个版本的时候再重新打图集）\n  25. 你了解python的GC吗，不了解只了解过Lua的，然后说了一下lua的。\n  26. C#中Ref和out的区别\n  27. 手写快排\n  28. 怎么优化的UI，图集过大怎么办，怎么优化的spine和特效和animition\n  29. 有没有接触过渲染\n  30. 讲下Tcp的过程几次挥手几次握手\n\n### 二：\n\n1，3D的模型怎么显示到2DUI上面\n\n2，C#的ArryList和List的区别\n\n3，接口和抽象类的区别，你一般什么时候用接口\n\n4，UGUI怎么渲染的UI，UGUI的层级管理（怎么不打断合批），合批流程\n\n5，平常用到了设计模式，观察者模式是什么\n\n6，上个项目的UI框架，怎么管理的UI的切换，和场景的切换\n\n7，Unity和android怎么交互的\n\n8，Unity编辑器的扩展学过吗，学过哪些，新增一个窗口是继承哪个类\n\n9，Lua的类型有哪些，pair和ipair的区别，lua怎么实现的面对对象，__newindex是什么，一般用来干嘛，\n\n10，对象池用过吗，好处和坏处\n\n11，Uinty携程用过吗，和线程的区别，之前项目组哪些地方用携程\n\n12，Unity里面判断两个物体的碰撞条件(我回答的需要挂在哪些组件)，碰撞器和触发器的区别\n\n13，用过什么算法，A*怎么实现，最重要的是哪些数据结构，A*是宽还是深搜索，搜索路径是最短还是最优\n\n14，你们项目的动画都是用什么做的，你参与过开发吗\n\n15，用过什么lua交互，xlua\n\n16，问了很多上个项目的内容不具体说明了。\n\n### 三：\n\n  1. 你们项目设置系统是怎么做的\n  2. 讲下你做了哪些UI系统\n  3. (我讲了一个我做的UI系统用了很多携程)你用携程做UI系统的时候不会出现同步不及时的问题吗(肯定有，不过没关系，策划能接受)\n  4. 用的UGUI吗？讲下你们的UI框架\n  5. 有对UGUI的源码改动吗，你了解哪些改动。\n  6. 滑动窗口定向滑到一个位置你们是怎么做的\n  7. 你们ui上面会用粒子特效吗（没有）\n  8. 你们的窗口会有窗口动效吗。是怎么做的呢（animition）\n  9. 你们UGUI是怎么优化的吗（开始背书）\n  10. 你们UI这块除了图集本身的材质还会用到其他的材质吗（没有，有我也不知道，我没写过shader）\n  11. UGUI的Mask的原理，为什么Mask会打断合批，怎么实现个不打断合批的Mask\n  12. Lua的metatable你们项目哪些地方用到了\n  13. Lua面向对象继承有遇到过问题吗，是怎么实现的\n  14. Lua里面的全局变量用的多吗，有什么常量会定义到全局的东西里面吗\n  15. 你们C#和lua是怎么交互的\n  16. Lua的内存优化有了解过吗（我说的UI框架会控制GC时机，我只了解对象池和Lua的GC流程）\n  17. 你用UnityProfile检查出过什么问题\n  18. 你们游戏有哪些公共组件\n  19. 讲下你接触到的战斗相关的\n  20. 战斗对技能模型，动效之类的有更深入的了解吗\n  21. 接入过哪些SDK，打包是怎么打的\n  22. 职业规划\n\n### 四：狠狠吐槽某些外包面试官，上来问我技术的职业规划方向，然后说我的方向没用。讲了一小时道理，转手给你挂了。浪费时间\n\n### 五：\n\n  1. C++，释放内存的时候 关键字delete和free有什么区别\n  2. 堆和栈内存有什么区别\n  3. 指针跟引用的区别\n  4. C++多态是怎么是实现的\n  5. 怎么创建一个不能继承的类\n  6. Socket实现的过程是怎么样的\n  7. UDP和TCP的区别是什么\n  8. 多线程怎么通信，竞争资源怎么办，怎么避免产生死锁\n  9. Lua跟C++的绑定知道怎么写吗\n  10. 计算机的图像学\n  11. 有些过什么开发工具之类的吗\n\n### 六：\n\n  1. 数据持久化是怎么实现的\n  2. 对象池是怎么实现的\n  3. 图片的淡出怎么实现\n  4. 图片某些情况显示灰色是怎么实现，写shader怎么写\n  5. 说一个你遇到的技术上的问题\n  6. 接入过哪些SDK\n  7. 了解协程吗，看过源码吗，知道延时器怎么写吗\n\n### 七：\n\n  1. 问了很多项目组的东西\n  2. C++基础，stl用过哪些，list,vector,map,unodermap\n  3. Map,unodermap的区别\n  4. 删除map的一个元素用什么方法，erase返回的迭代器是指向哪\n  5. Vector扩容的过程\n  6. Map,和unordermap 对有序性没有要求，插入和删除频率很高一般选哪个\n  7. 跟着上面。如果是插入会引起容器大小的剧烈变化一般用哪个\n\n### 八：\n\n  1. Lua怎么实现的面对对象\n  2. _newIndex是干嘛的\n  3. 方法调用的点和冒号有什么区别\n  4. Lua的异常捕获是用的什么，堆栈信息是怎么打印\n  5. 闭包的概念，举个例子\n  6. C#中ArryList和List的区别，dictionary是怎么实现的，栈和队列的特点\n  7. 数据结构中链表和数组的插入和删除和访问的复杂度\n  8. 二叉树，平衡二叉树的概念\n  9. Dijstla和A*算法\n  10. 常用的排序算法说下，快排和堆排\n  11. 用过协程和线程吗，(task,thread没用过线程，后来了解到项目要用ECS，下来学下下这方面)\n  12. 你们项目组是怎么管理的资源包，和加载的资源包\n  13. TCP三次握手和四次挥手过程\n  14. TCP的拆包和粘包的问题是什么，怎么解决(听都没听过..)\n  15. 什么是drawcall,什么是合批\n  16. 3d模型勾选的静态合批太多了会有什么问题\n  17. Xlua和C#交互的原理\n  18. C#代码在unity里面编译跑起来的流程\n  19. Mono内存有什么特点因为没听懂，换成问C#创建一个对象是问谁要内存（我回答的堆内存），堆内存是谁管理的（我说是mono虚拟机）。释放一个对象的内存mono会还给操作系统吗（我说不会应该会做压缩操作吧），mono是解释性运行C#的中间代码吗（我猜的是，因为可以做C#热更新）。乱答的不知道对不对\n  20. Unity的GC流程\n\n### 九：\n\n  1. 游戏设计个排行榜，100W个玩家，想知道排行榜前一百的玩家是谁。怎么设计我说的用数组加堆排\n  2. 建堆的算法复杂度\n  3. 玩家发生变更怎么办(我说拿出来 然后二分查找到合适的位置)\n  4. 二分查找的算法复杂度\n  5. C#的DIctionary是怎么实现的\n  6. Hash表查询和插入的时间复杂度\n  7. 解决的hash冲突有哪些方法\n  8. 用开放定址法的线性探测法删除一个元素的过程是怎么样的(我说找到之后直接删除，问我直接删除元素至于不会有什么问题吗，一番争执之下我发现自己错了，直接打脸)，时间复杂度是怎么样的。\n  9. 图集有尝试做工具检查多引用吗\n  10. Unity怎么会产生GC(我回答的是创建引用过多和协程会产生)，创建对象少一点会有GC吗(也会，不过GC频率会少一点吧)，创建协程会有GC吗，具体在哪一步，怎么避免(瞎猜的)\n  11. 设计模式了解的多吗(我说我会单例，工厂，代理，观察者，其他也看过，他直接问其他的是哪些说一下，我直接回答不上来，6)\n  12. UGUI看过哪些源码，对UGUI的布局组件看过吗(layout)，用的多吗，layoutelement这个组件知道吗\n\n###\n太长了接：[https://www.nowcoder.com/share/jump/1711364601771](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fshare%2Fjump%2F1711364601771)\n\n总结和建议：希望各位同学能呆满三年最好呆满三年。多学一些核心技术，不然面试没有优势，社招面试的时候大家其实差不多，经验和优势点(会一些别人不会的技能会成为竞争的强有力优势)。基础很重要，对以前项目的自己设计的框架或者系统建议画图讲解不然真的很乱，加油！\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596062318623055872?sourceSSR=users",
        "title": "网易雷火 面经/时间线",
        "content": "7.12提前批开\n\n7.13投 web后端\n\n##### 8.20笔试\n\n牛客 2h\n\n编程x2（岛屿 dfs 83%、dfs 83%）、问答x3（lru编码、前者并发的改进）\n\n##### 9.5 一面\n\n牛客 40min\n\n  * 实习项目（用到的设计模式、难点、grpc特点、怎么确定重试次数、linux日志用法）\n  * 反射、反射类、实际的应用\n  * springboot常用注解\n  * 如何自定义注解handler处理异常\n  * 事务隔离级别\n  * 怎么处理cookies的过期时间和他在redis里的过期时间，cookies过期了redis里还有怎么办\n  * rabbitmq重复下单怎么解决\n  * 项目重构的流程、按照什么顺序重构、新旧代码并行怎么调度、git版本控制、冲突怎么解决\n  * 手撕：有序链表转换为二叉搜索树（应该用递归，没写完）\n\n反问\n\n  * 效能平台部 面向内部\n  * java、python\n\n答的不好 后续没消息 估计挂了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596058445275508736?sourceSSR=users",
        "title": "24届OPPO安卓客户端笔试-春招",
        "content": "**投递岗位：** OPPO，安卓客户端开发\n\n**投递时间：** OPPO的春招早在1月份就已经开了，我是2月21号投递的，3月8号发邮件，3月9号，也就是今天，要求笔试。\n\n**笔试题目（单选）：**\n\n**单选1-5：**\n1，动态分区的作用。2，时间复杂度求解（单层循环）。3，URL和URI的概念（谁的范围更大）。4，Java抽象类和接口的区别。5，块设备和字符设备有哪些。\n\n**单选6-10：**\n6，安卓布局（居中布局）。7，反射机制的作用。8，Activity的概念（Activity不能够长期的在后台工作）。9，单链表的删除流程。10，DNS是什么。\n\n**单选11-15：**\n11，404返回码的概念。12，SQL排序语句。13，Kotlin声明一个常量。14，Kotlin的权限修饰符。15，Java的流（字符流和字节流）。\n\n**单选16-20：**\n16，Kotlin的类对象（一定要构造函数吗）。17，前缀表达式转中缀表达式。18，SQL插入一条数据。19，service的作用（是否附于Activity）。20，二分查找的次序。\n\n**编程题（3题，15分，20分，25分）**\n\n1，给你一个只会有a和b组成的字符串。这个字符串的前缀可能由连续的a组成，同时后缀可能由连续的b组成，交换这两个字符子串并且输出。\n\n2，给你N个开闭区间，求这些开闭区间有多少组是相交的。（如下图）\n\n![](https://uploadfiles.nowcoder.com/images/20240309/238658153_1709982519195/072774B6B658B3603E1AA7198722775C)\n\n3，给你一个图，（本质上是一个二维数组），这个图里面仅仅含有三种标识（+代表客户，*代表障碍，a代表通路），你需要在标识为通路的地方修建邮局，邮局和所有的客户之间的距离是最短的。你可以在这个图里面找到多少合适的地点来修建邮局？（输出可以为0）\n\n**总结：**\n\n1，OPPO的这个笔试，编程题应该具有泛用性，也就是前端，后端，算法，可能都会是类似的题库。\n\n2，编程题的第二题挺意难平的，因为题目并不难，按照示例的介绍，应该认为区间内部非连续。换言之，认为[3,5)和(4,6]是没有交集的，这两个区间分别只含有数字3，4以及数字5，6。通过这种方式可以得出示例的答案，也就是4。然而实际的算法没有通过一个样例。遂更改算法，认为上面的区间是可以重合的，但也仍然没有通过的样例。\n\n3，所以说，可能本人真的和OPPO没啥缘分吧。OPPO这边想要进入面试，至少要求完成两道算法题才有进面的资格。所以我这种情况是肯定是走不了后续的。现在投递OPPO是肯定还有机会的，所以也就把经验发上来，有缘人自取便是。\n\n===================\n\n3月27号更新，OPPO这边突然把我捞起来了，可以参加后续的面试。有具体的进展再分享吧。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596053408885288960?sourceSSR=users",
        "title": "上海某数字科技公司 Java 面经",
        "content": "# 上海某数字科技公司 Java 面经\n\n1）\n\n面试官：先自我介绍一下\n\n我：大家先写个文档记录一下，然后按流程进行背诵就好了，如果有新的获奖和实习，直接按时间顺序进行增加即可，面的多了基本就麻木了...\n\n2）\n\n面试官：你的项目是为了什么而做的？\n\n我：反复介绍\nAPI，自圆其说即可，我主要做了拓展，最近考虑加点东西和参数优化，别说自己的项目是跟做的就行，当然外卖这种无所谓，主打一个能拓展就行，项目有五个级别。\n\n第一种级别，开源项目，获得很多收藏和一定的使用，第二种级别，项目已经上线了，这个项目是自己独立做的，并且有过功能难点的拓展和思考\n第三种级别，项目是跟做的，但是自己有过功能拓展，可以完整讲述业务，第四种级别，项目是跟做的，没有拓展，可以完整讲述业务和功能，第五种级别，直接 down\n了项目，甚至没上线，业务和功能也讲不出来\n\n3）\n\n面试官：讲一下你的项目的技术难点？\n\n我：讲一下项目搭建过程中可能使用 Dubbo 的问题、字符编码问题、缓存优化问题、SQL\n优化、虚拟机等，都可以讲，建议先准备好，然后去阐述，其实自己做项目中肯定会遇到一些问题的，平时要记录下来，后续做一个汇总。\n\n4）\n\n面试官：你的项目是怎么使用 Redis 的？\n\n我：还是那句话，Redis + 定时任务做缓存预热是最简单的，其他像 Redis + Lua 做限流（但这是分布式，你项目是分布式的？），单体限流直接\nGoogle 的 Guava 就可以了，像其他可能用到 Redission\n分布式锁使用，自己需要了解一些八股文，会的越多，可以拓展的点就越多，虽然你可能项目没用，但还是可以讲一讲。\n\n5）\n\n面试官：Redis 基本数据类型介绍一下，你的项目怎么使用的，底层原理介绍一下？\n\n我：首先介绍一下基础数据类型五种，然后主要介绍一下 String 和 Zset 的底层原理就可以了，结合你的项目具体去使用，现在不使用 Redis\n的项目很少了，基本都会用到，于是后面就是经典八股文。\n\n6）\n\n面试官：介绍一下缓存穿透、缓存击穿、缓存雪崩的问题和解决方案\n\n我：经典的八股文，但是结合项目去讲，你这边选择了什么方案，如果是用分布式锁 Redission 的可以讲 Redission ，有用到 Caffeine\n也可以讲一下多级缓存使用。\n\n7）\n\n面试官：有没有进行多人团队合作过？\n\n我：我自己是全栈开发，一个人做项目，主要采用 Git 版本控制，有开发实习的经历的一般是多人团队。\n\n8）\n\n面试官：你项目技术方案有分歧的话怎么做？\n\n我：主要按照软件工程的xxxx进行分析，然后看看新技术是否有大牛能够 cover，以稳定性为保障，追求性能。\n\n9）\n\n面试官：你是怎么用的新技术，在哪里看的？\n\n我：结合一些前沿的网站，公众号、利用科学上网工具等等，然后去尝试跑 Demo，试一试新技术还是挺有趣的\n\n10）\n\n面试官：你未来的职业规划是怎么样的？\n\n我：阿巴阿巴，各位阐述自己的一个方向就行了，也不用很清楚，但还是要说点的。\n\n11）\n\n反问技术栈，业务....基本其实就是缺人，主要看我。\n\n开源项目 Gitee 地址：[https://gitee.com/falle22222n-leaves/vue_-book-manage-\nsystem，](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgitee.com%2Ffalle22222n-leaves%2Fvue_-\nbook-manage-system%25EF%25BC%258C) 已有前后端总计 800+ Star，1.5W 访问。\n\n欢迎老铁们 Star 下！⭐⭐⭐\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596025056698871808?sourceSSR=users",
        "title": "#简单递归#骨牌铺地板#复旦大学机试",
        "content": "\n    /*描述\n    用 1×2和2×1的骨牌铺满大小为 2×n的地板，请问共有多少种不同铺法。\n    输入格式:一个整数 n。\n    输出格式:一个整数，表示铺法数量对 999983取模后的结果。\n    数据范围\n    1≤n≤10000\n    输入样例：6\n    输出样例：13*/\n    #include <iostream>\n    #include <cstdio>\n    #include <vector>\n    #include <string>\n    \n    using namespace std;\n    \n    int main(){\n        int n;\n        scanf(\"%d\",&n);\n        int a[10001];\n        a[1]=1;\n        a[2]=2;\n        for(int m=3;m<=n;m++){\n            a[m]=a[m-1]+a[m-2];\n        }\n        printf(\"%d\",a[n]%999983);\n        return 0;\n    }\n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596016042460065792?sourceSSR=users",
        "title": "360笔试 3.9 技术卷a",
        "content": "选择题有点难，乱七八糟啥都考\n\n编程题：\n\n1.项目派遣\n\n2.超长序列\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596004990804602880?sourceSSR=users",
        "title": "滴滴前端日常实习一面（3.8）",
        "content": "3.6号投的简历，3.8号就给我约面了（没想到这么快...我八股还没怎么背，算法题也没刷。。\n\n### 项目一\n\n  * 说一下思维导图的节点形状的逻辑处理\n  * 如何做到关闭页面，再打开时自动渲染上一次的内容？\n  * 自定义拉伸节点尺寸的功能怎么做的？\n  * 怎么处理节点位置的？缩放、平移\n\n### 网络\n\n  * 302 和 304 的区别？\n  * 206有遇见过吗？416呢？\n  * 拉取服务器的音视频这种大文件时是怎么样的流程？\n\n### 手撕\n\n打开共享屏幕，在自己的编译器上写\n\n  * 二分查找\n  * 深拷贝\n  * 判断值类型的方法？\n\n### 看代码输出\n\n一共9道题，考察一些比较细致的js特性\n\n  * 涉及原始值类型、类型转换、装箱类型、拆箱类型\n  * 考察对象的属性类型，及隐式类型转换，Symbol有使用场景吗？说几个\n  * 考察闭包、作用域链\n\n有两题讲错了，面试官还给我补充了一些知识\n\n### 一些八股\n\n  * 怎么做的自适应布局？讲一下flex？发来一张效果图，用flex实现，讲一下思路？用过媒体查询吗？\n  * 用的css单位有哪些？rem的原理？给width设置100vh行不行？\n  * 图片瀑布流中有大量图片，怎么给每个图片添加事件？讲了事件代理，冒泡，捕获等等，又问addEventListner对老ie浏览器的兼容方法？\n\n### Git\n\n给了我三个场景，问我怎么做？前两个都不会。。汗流浃背了[牛泪]早知道技术栈里不写Git了\n\n### 场景题\n\n  * 讲一下你对Vue路由的理解？原理？（为后面的业务场景题做铺垫）\n  * 给我讲了一个业务场景，原生ios app+H5，点击首页的营销按钮，弹出一个H5的页面，然后监听用户离开页面的操作，弹出一个模态框，问是否确定离开。让我做我会怎么做？讲不出来，一直引导，问我了解过jsbrige吗？然后提示我往路由上想一想。。。还是讲不出来，面试官直接给我讲了，用双层路由。。讨论了十几分钟，最后还是模棱两可的，尴尬\n  * 问我了解过数据埋点相关的吗？\n  * 除了我简历上写的这些性能优化方法，还有其他的吗？（我把我知道的都写上去了。。。硬想了两个简单答了了下\n\n### 反问\n\n面试官：我这边没什么问题了，大概率会给通过，约个二面。说他自身偏向业务方面，二面主要是考察技术深度，\n\n我：\n\n  * 对我的评价？人生第一次面试就面大厂，都紧张到语无伦次了。。。\n  * 技术栈相关\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/596007904621223936?sourceSSR=users",
        "title": "#递归分治#2的幂次#acwing#上交机试题",
        "content": "acwing链接[https://www.acwing.com/problem/content/3486/](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.acwing.com%2Fproblem%2Fcontent%2F3486%2F)\n\n思路：读取m后，将m在实际内存中存储的01串为1的位数压入动态数组exp中，同时维护一个字符串res用来保存输出结果。想要得到最终正确的字符串，需要返回类型为string的函数处理：\n\n1.加号+在每次用于遍历的i不为0的时候拼接到res后（可以避免算式结束之后多余+）\n\n2.若exp[i]等于1，则直接拼接2即可，没有其他项（类似于递归起始的数据）\n\n3.若exp[i]不等于1；则先拼接（2，再调用函数获取子串，再拼接），保持格式正确\n\n4.0的问题：若传入的整形参数为0，则直接打印一个0；\n\n完成后，用while！=EOF处理多个输入并换行依次输出res内容即可\n\n    \n    \n    /*每个正数都可以用指数形式表示。\n    例如，137=27+23+20。让我们用 a(b)来表示 ab。那么 137可以表示为 2(7)+2(3)+2(0)。\n    因为 7=22+2+20，3=2+20，所以 137最终可以表示为 2(2(2)+2+2(0))+2(2+2(0))+2(0)。\n    给定一个正数 ，请你将 n表示为只包含 0和 2的指数形式。\n    输入格式\n    输入包含多组数据。每组数据占一行，一个正数 n。\n    输出格式\n    每组数据输出一行，一个指数形式表示。\n    数据范围\n    1≤n≤20000,每个输入最多包含 100组数据。\n    输入样例：\n    1315\n    输出样例：\n    2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)*/\n    \n    #include <iostream>\n    #include <cstdio>\n    #include <vector>\n    #include <string>\n    \n    using namespace std;\n    string Gets2sExponet(int n){\n        if(n==0){\n            return \"0\";\n        }\n        vector<int> exp;\n        for(int i=15;i>=0;i--){\n            if((n&(1<<i)) != 0){\n                exp.push_back(i);\n            }\n        }\n        string res=\"\";\n        for(int i=0;i<exp.size();i++){\n            if(i!=0){\n                res+=\"+\";\n            }\n            if(exp[i]==1){\n                res+=\"2\";\n            }\n            else{\n                res+=\"2(\"+ Gets2sExponet(exp[i])+\")\";\n            }\n        }return res;\n    }\n    int main(){\n        int m;\n        while(scanf(\"%d\",&m)!=EOF){\n            printf(\"%s\\n\", Gets2sExponet(m).c_str());\n        }\n        return 0;\n    }\n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595986699264503808?sourceSSR=users",
        "title": "腾讯csig 运营开发 一面（凉）",
        "content": "时间：2024.03.08\n\n# **流程1：自我介绍**\n\n随便介绍了下基本信息+学校+项目经历\n\n# **流程2：项目八股**\n\n1\\. 讲一下实习项目&实习期间有没有感觉有什么比较难的点\n\n2\\. 讲一下项目2，springcloudoauth2是怎么去实现单点登陆的\n\n3\\. oauth2具体是怎么回事\n\n4\\. jwt是怎么传递的，谁来传递的\n\n5\\. jwt结构原理\n\n6\\. jwt能不能被反解析\n\n7\\. 怎么设计的退出登陆，准备怎么做\n\n8\\. jwt和redis配合的退出登陆你觉得好不好\n\n9\\. 如果现在有一个需求是，管理员改了某个用户的密码，然后就要马上把他给下线，或者我就是要马上下线某个人，怎么处理\n\n10\\. 拿jwt放redis你怎么去存储呢，管理员怎么能找到具体那个jwt是现在这个用户的呢\n\n11\\. 那你说这样载荷里面还有存储id的必要吗\n\n12\\. 你数据库用户密码怎么加密的\n\n13\\. 那你知道BcryptPasswordEncode的原理吗\n\n14\\. 你知道有那些加密方式\n\n15\\. 怎么加密才能防止密码被破解\n\n16\\. mysql的innodb用的那种数据结构，为什么\n\n17\\. 你mysql用的哪个版本\n\n18\\. 你觉得什么样才算微服务，什么是微服务，说说你的理解\n\n19\\. 我看你写了Vue，你谈谈你对他的理解，其中响应式怎么回事，知道哪些底层\n\n20\\. 你微服务项目都是怎么部署的，部署到哪的\n_（如实回答，我说我宝塔linux部署的，不太熟悉原生linux部署方式。以及说了拆分部署到了多个云服务器上）_\n\n# **流程3：算法**\n\nlc300 最长递增子序列\n\n****\n\n# **自我总结**\n\n**个人还是太菜，回答磕磕碰碰，很多只浮于表面没有深入，算法也拉胯。**\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595985435126411264?sourceSSR=users",
        "title": "孝庸基金 提前批 面经/时间线",
        "content": "8.14开\n\n8.15投 软开cpp岗\n\n##### 8.23笔试\n\n18天内完成\n\n【问答题】2023孝庸基金笔试(152)\n\n牛客 60min\n\n问答x4\n\n  1. 一列数的规则如下：1、1、2、3、5、8、13、21、34..求第30位数是多少，用递归算法实现任何编程语言都可以，请写出具体的代码\n  2. int xy num1int xy num2不使用额外的空间，不使用基本的加减乘除运算交换整数xy_num1和y_num2的值，可以写出具体执行代码，也可以写伪代码说明你的思路\n  3. 实现下面的函数，判断一个整数是不是2的整数次方\n  4. 设计并实现一个优先队列\n\n【客观题】2023孝庸基金笔试(152)\n\n牛客 60min\n\n单选x1填空x12（linux、算法、数据结构、操作系统）\n\n##### 9.1hr面\n\n腾讯会议 25min\n\n  * 实习情况、能不能留用\n  * 为什么不读研\n  * 手里有什么offer、为什么不满意\n  * 有没有偏向cpp的项目\n  * 城市\n  * 兴趣爱好\n  * 金融了解多少\n  * 反问：做金融私募二级市场、交易系统都是自研的、正常855、忙时加班11点、还有一轮技术面\n\n语言和上下班时间偏好不符合 结束流程\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595986844605493248?sourceSSR=users",
        "title": "#不连续1的子串#递归与分治#acwing#中山大学机试",
        "content": "[https://www.acwing.com/problem/content/3709/](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.acwing.com%2Fproblem%2Fcontent%2F3709%2F)\n\n    \n    \n    /*请计算长度为 N且不含连续 1的 01串的个数。\n    例如，当 N=3时，答案为 5，因为长度为 3且不含连续 1的 01串一共 5个：000,001,010,100,101。\n    输入格式\n    一个整数 N。\n    输出格式\n    一个整数，表示结果。\n    数据范围\n    1≤N≤20*/\n    \n    #include <iostream>\n    #include <cstdio>\n    #include <stack>\n    #include <string>\n    \n    using namespace std;\n    int fun0(int i);\n    int fun1(int i);\n    int fun0(int i){\n        if(i==1){\n            return 1;\n        }\n        else {\n            return fun0(i-1)+fun1(i-1);\n        }\n    }\n    int fun1(int i){\n        if(i==1){\n            return 1;\n        }\n        else{\n            return fun0(i-1)\n        }\n    }\n    int main(){\n        int n;\n        scanf(\"%d\",&n);\n        printf(\"%d\",fun0(n)+fun1(n));\n        return 0;\n    }\n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595968008091086848?sourceSSR=users",
        "title": "Mobvista汇量科技-大数据开发实习生-日常实习",
        "content": "个人bg：双非+0实习经历+两个相关项目\n\n面试时间：2023年国庆后 已oc但没去，目前找到一个比较满意的实习就把之前的面经都发发\n\n一面\n\n自我介绍\n\n* 介绍实时项目\n* 你们项目的数据量是多大\n* 你们项目中有遇到什么性能问题嘛\n* 两道算法题\n* 两数之和\n* 数组的小和\n* spark如果要读取两份相同的数据怎样做\n* spark参数调优这个得重点了解一下\n* scala有什么算子可以去重我答了distinct，面试官追问如果是对几个列进行去重呢，寄，忘记了\n* 对数据清洗有什么了解\n* 对数仓分层有什么了解\n* 数据倾斜怎么处理\n* hive掌握程度\n* spark掌握程度\n\n二面\n\n有点记不太清了，主要是针对spark进行提问，如果有意向的话记得提前复习spark相关知识\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595984635318808576?sourceSSR=users",
        "title": "西门子 ai面试 8.20",
        "content": "3天内完成\n\n45s准备 120s答题\n\n  1. 在您负责的任务或项目中有没有出现过重大的突发状况？您当时面临的状况是什么？您的行动和结果如何？请用具体案例阐述。\n  2. 您是如何保持对最新技术的跟进？在过去的一年中，有哪些技术发展让您印象深？为什么您对它印象深刻？\n  3. 请举例说明，在工作中您是如何把学到的知识应用到实践中的。\n  4. 请举例说明一个您在过往的学习或项目中不断进行迭代优化的例子。在其中您的优化方案是什么？结果如何？\n  5. 请回忆一段您与他人合作过程中，克服分歧并实现重要目标的经历。具体描述您是如何处理分歧的？结果如何？\n  6. 请分享一个您在执行团队任务中主动帮助别人解决问题或推动项目更好的进行下去的案例。当时的情况是怎么样的？您是怎么做的？结果如何？\n  7. 请说一说为了获得更好的工作机会，您曾刻意培养过哪些能力或技能？未来您还计划培养哪些能力或技能？为什么？\n  8. What made you choose Siemens as a potential employer?\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595965439675514880?sourceSSR=users",
        "title": "3.9 美团笔试",
        "content": "> 24年第一次笔试...\n\n## T1, 模拟\n\n    \n    \n    #include <bits/stdc++.h>\n    using namespace std;\n    \n    int main() {\n        int n, k; cin >> n >> k;\n        string s; cin >> s;\n        int current = 0;\n        for (auto c : s) {\n            if (c == 'M' || c == 'T') current++;\n        }\n        int res = min(int(s.length()), current+k);\n        cout << res << endl;\n        return 0;\n    }\n    \n\n## T2，模拟\n\n> **注意数据范围，使用long**\n    \n    \n    #include<bits/stdc++.h>\n    \n    using namespace std;\n    \n    int main() {\n        int n, q; cin >> n >> q;\n        long tmp, zeroCnt = 0, nonZeroSum = 0;\n        for (int i = 0; i < n; i++) {\n            cin >> tmp;\n            if (tmp == 0) {\n                zeroCnt++;\n            } else {\n                nonZeroSum += tmp;\n            }\n        }\n        while (q--) {\n            long l, r;\n            cin >> l >> r;\n            cout << nonZeroSum + zeroCnt*l << ' ' << nonZeroSum+zeroCnt*r << endl;\n        }\n        return 0;\n    }\n    \n\n## T3，**二维前缀和**\n\n    \n    \n    #include<bits/stdc++.h>\n    \n    using namespace std;\n    \n    int main() {\n        int n; cin >> n;\n        vector<string> mat(n);\n        for (int i = 0; i < n; i++) cin >> mat[i];\n        int pre[205][205]{};\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                pre[i+1][j+1] =  pre[i+1][j] + pre[i][j+1] - pre[i][j] + (mat[i][j]=='1');\n            }\n        }\n        for (int len = 1; len <= n; len++) {\n            if (len % 2 == 1) {\n                cout << 0 << endl;\n                continue;\n            }\n            int current = 0, target = len*len/2;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    int endI = i+len-1,  endJ =j+len-1;\n                    if (endI > n-1 || endJ > n-1) continue;\n                    int val = pre[endI+1][endJ+1] - pre[endI+1][j] - pre[i][endJ+1] + pre[i][j];\n                    if (val == target) current++;\n                }\n            }\n            cout << current << endl;\n        }\n        return 0;\n    }\n    \n\n## T4，前缀和 + 滑动窗口\n\n![](https://uploadfiles.nowcoder.com/images/20240311/321389395_1710166638169/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n> (注意数据范围, 使用long)\n\n思路：\n\n  * 给出的数字都是不为0的，最终乘积的0 一定是由素因子 2, 5构成的， 因此主要关心区间内2、5的数量\n  * 要求删除区间后0的数量应该大于等于k，即删除区间后剩下的数中 素因子2、5的数量必须同时大于等于k\n\n> 滑动窗口： 枚举以i开始的可以删除的子串数量，for循环内部while结束后, i-j对应的子串是不符合条件的，但i到 [i+1、i+2、 ...\n> j-1]都是满足条件的。\n\n复杂度 `O(n)`\n\n    \n    \n    #include<bits/stdc++.h>\n    \n    using namespace std;\n    \n    const int MaxN = 1e5+5;\n    int main() {\n        int n, k; cin >> n >> k;\n        int arr[n];\n        long pre2[MaxN]{}, pre5[MaxN]{};\n        for (int i = 0; i < n; i++) {\n            cin >> arr[i];\n            int cntFactor2 = 0, cntFactor5 = 0;\n            for (int x = arr[i]; x % 2 == 0; x /= 2) cntFactor2++;\n            for (int x = arr[i]; x % 5 == 0; x /= 5) cntFactor5++;\n            pre2[i+1] += pre2[i] + cntFactor2;\n            pre5[i+1] += pre5[i] + cntFactor5;\n        }\n    \n        long res = 0, zeroCnt = min(pre2[n], pre5[n]);\n        for (int i = 0, j = 0; i < n; i++) {\n            while (j < n) {\n                int range2 = pre2[j+1] - pre2[i];\n                int range5 = pre5[j+1] - pre5[i];\n                int remain2 = pre2[n] - range2;\n                int remain5 = pre5[n] - range5;\n                if (min(remain2, remain5) < k) break;\n                j++;\n            }\n            res += max(j-i, 0);\n        }\n        cout << res << endl;\n        return 0;\n    }\n    \n\n## T5, 并查集、离散化、逆向思维\n\n![](https://uploadfiles.nowcoder.com/images/20240310/321389395_1710048880140/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n> 笔试时想到了并查集，但没写出来，写了个dfs，超时～\n\n> 笔试后参考@Y丶bs(679742139)大佬的思路使用并查集实现了下。 ref:\n> [https://www.nowcoder.com/discuss/596124837462978560](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F596124837462978560)\n\n### 并查集写法\n\n    \n    \n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    const int MaxN = 4e5+5;\n    int fa[MaxN];\n    \n    int find(int x) {\n        return fa[x] == x ? x : fa[x] = find(fa[x]);\n    }\n    \n    void merge(int x, int y) {\n        int faX = find(x);\n        int faY = find(y);\n        if (faX != faY) {\n            fa[faX] = faY;\n        }\n    }\n    \n    int main() {\n        iota(fa, fa+MaxN, 0);   // 初始化fa数组\n        unordered_set<int> points;  // 记录所有点, 离散化使用\n        int n, m, q; cin >> n >> m >> q;\n        vector<vector<int>> edges;\n        for (int i = 0; i < m; i++) {\n            int a, b;  cin >> a >> b;\n    \n            points.insert(a);\n            points.insert(b);\n            edges.push_back({a, b});\n        }\n    \n        unordered_map<int, unordered_set<int>> delEdgeMap;\n        vector<vector<int>> ops; \n        while (q--) {\n            int op, u, v; cin >> op >> u >> v;\n    \n            points.insert(u);\n            points.insert(v);\n            ops.push_back({op, u, v});\n            if (op == 1) {\n                delEdgeMap[u].insert(v);\n                delEdgeMap[v].insert(u);\n            } \n        }\n    \n        int idx = 0;    // 离散化初始idx\n        unordered_map<int, int> val2Idx;\n        for (auto u : points) val2Idx[u] = idx++;\n    \n        // 建立并查集、不使用删除的边\n        for (auto &e : edges) {\n            int u = e[0], v = e[1]; \n            if (delEdgeMap.count(u) && delEdgeMap[u].count(v)) {\n                continue;\n            }\n    \n            merge(val2Idx[u], val2Idx[v]);\n        }\n    \n        vector<bool> result;\n        reverse(ops.begin(), ops.end());  // 反向遍历\n        for (auto &item : ops) {\n            int op = item[0], u = item[1], v = item[2];\n            int idxU = val2Idx[u], idxV = val2Idx[v];\n            if (op == 1) {  // 加边操作\n                merge(idxU, idxV);\n                continue;\n            }\n    \n            if (find(idxU) == find(idxV)) {\n                result.push_back(true);\n            } else {\n                result.push_back(false);\n            }\n        }\n        for (int i = result.size()-1; i >= 0; i--) {\n            if (result[i]) {\n                printf(\"Yes\\n\");\n            } else {\n                printf(\"No\\n\");\n            }\n        }\n    \n        return 0;\n    }\n    \n\n### 暴力dfs解法(超时...)\n\n    \n    \n    #include <bits/stdc++.h>\n    \n    using namespace std;\n    int n, m, q;\n    unordered_map<int, unordered_map<int, bool>> g;\n    \n    bool dfs(int u, int parent, int target) {\n        if (u == target) {\n            return true;\n        }\n        for (auto &[v, ok] : g[u]) {\n            if (v != parent && ok && dfs(v, u, target)){\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    int main() {\n        cin >> n >> m >> q;\n        for (int i = 0; i < m; i++) {\n            int a, b; cin >> a >> b;\n            g[a][b] = true;\n            g[b][a] = true;\n        }\n        while (q--) {\n            int op, u, v;\n            cin >> op >> u >> v;\n            if (op == 1) {\n                g[u][v] = false;\n                g[v][u] = false;\n                continue;\n            } \n            if (dfs(u, -1, v)) {\n                cout << \"Yes\" << endl;\n            } else {\n                cout << \"No\" << endl;\n            }\n        }\n        return 0;\n    }\n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595957452655308800?sourceSSR=users",
        "title": "悄悄话 - 华为OD统一考试（C卷）",
        "content": "> OD统一考试（C卷）\n>\n> 分值： 100分\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n给定一个二叉树，每个节点上站一个人，节点数字表示父节点到该节点传递悄悄话需要花费的时间。\n\n初始时，根节点所在位置的人有一个悄悄话想要传递给其他人，求二叉树所有节点上的人都接收到悄悄话花费的时间。\n\n## 输入描述\n\n给定二叉树\n\n    \n    \n    0 9 20 -1 -1 15 7 -1 -1 -1 -1 3 2\n    \n\n注： -1 表示空节点\n\n![image-20240131101708298](https://smqk.oss-cn-\nbeijing.aliyuncs.com/images/image-20240131101708298.png)\n\n## 输出描述\n\n返回所有节点都接收到悄悄话花费的时间\n\n    \n    \n    38\n    \n\n## 示例1\n\n    \n    \n    输入：\n    0 9 20 -1 -1 15 15 7 -1 -1 -1 -1 3 2\n    \n    输出：\n    38\n    \n\n## 题解\n\n> 这个题目是一个树的遍历问题，采用**深度优先搜索（DFS）**的方式解决。\n>\n> 遍历时叶子节点最晚到达时间即为答案。\n\n### Java\n\n    \n    \n    import java.util.Arrays;\n    import java.util.Scanner;\n    \n    /**\n     * @author code5bug\n     */\n    public class Main {\n    \n        static int[] arr;\n    \n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            arr = Arrays.stream(scanner.nextLine().split(\" \"))\n                    .mapToInt(Integer::parseInt).toArray();\n    \n            System.out.println(dfs(0));\n        }\n    \n        // 从 idx 节点到叶子节点最大耗时\n        static int dfs(int idx) {\n            int maxCostTime = 0;\n    \n            // 左右节点\n            int leftIdx = 2 * idx + 1, rightIdx = 2 * idx + 2;\n            if (leftIdx < arr.length && arr[leftIdx] != -1) {\n                max\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595952078518792192?sourceSSR=users",
        "title": "数据分析面试题｜如何提升app的用户参与度",
        "content": "**_*******************_**\n\n**_春招保驾护航！_**\n\n参考回答：\n\n  \n\n-       第一步：定义指标。几乎所有的产品案例研究都从一个模糊的目标开始，第一步是将此目标转化为可以优化的指标。 比如。 \"我将小红书上用户的参与度定义为每天至少采取一项行动的用户比例，其中行动意味着与网站互动，即发布、喜欢、上传图片等\" 。\n\n  \n\n-       在指标确定之后，选择我们认为对该指标起到影响的变量特征。比如用户特征（性别、年龄、城市、关注数量、粉丝数量等）以及与他们的浏览/在线行为（最近一天发布内容数量、最近一天点赞数量等）。\n\n  \n\n-       选择一个模型来使用第 2 点的变量来预测第 1 点确定的指标。我们可以选择决策树等模型，这里可以讲一讲选择这个模型的优势是什么。比如，我选择随机森林 (RF) 是因为我想要高准确率。RF 在具有分类变量和异常值的高维度数据上运行良好，并且随机森林能够告诉我每个变量的重要性。\n\n  \n\n-       提出几个模型预测结果可能出现的场景。 比如。在检查了我的模型后，我发现来自低端机型的用户参与度并不高。另一方面，30 岁以下的女性用户非常投入，但相应地，我们没有很多这样的用户。利用自己对他们产品的了解，尝试提出可能真实存在的问题（分维度，新老用户，不同年龄用户，不同区域用户等等，某一类用户可能投入很好或者很不好）\n\n  \n\n-       定义下一步如何解决。 比如，我会检查低端机型用户的性能问题，比如直播/视频等的加载延迟问题，是不是由于低端机性能差。出现很卡的情况，从而导致用户的使用体验很不好，我们可以尝试对性能进行优化。另一方面，年轻的女性用户的参与度很高，我会告诉运营团队通过广告或特定营销策略来吸引更多年轻的女性用户。最终我们的案例研究答案应始终以可能的后续步骤来改进和提升原始指标。\n\n⚠️提醒：\n\n  \n\n只要有意义，指标如何准确定义并不重要，例如你选择时间长度为每周，也可以每日，或可以选择用户的平均操作次数而不是超过一定阈值的用户百分比。请不要选择一些很难测量的指标。例如，知乎上问题的回复率不是一个具体的指标。无法评价，太模糊了。但是一天内至少得到一个回复​​的问题的百分比是一个指标。大家可以尝试选择与公司使命相关的指标。就像小红书关心用户之间的交互一样，这就是为什么我们在上面选择了激励用户的操作。或者比如app的使用时长，这些指标都可以反应用户对你app的使用体验。\n\n  \n\n再比如知乎关心高级内容（内容生态），因此你可以选择一些包含质量衡量标准的指标，例如：第一天内至少获得 3 个点赞的回复)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595946971605549056?sourceSSR=users",
        "title": "2024-03-09 美团笔试 430/500",
        "content": "  * 第一题 100%（签到）\n  * 1e5长度的字符串，k次修改次数，最多可以让字符串有多少'M'，'T'字符\n  * 不是'M'或'T'的话改就行，直到k用完\n  * 第二题 100% （签到）\n  * 1e5长度的正整数数组，其中有部分元素为0，1e5次询问，每次给L和R，问0元素全部改成该区间范围内某元素后，数组的和最大、最小为多少\n  * 记一下0的数量，显然把0全变成L最小，变成R最大\n  * 第三题 100% （二维前缀和）\n  * 大小为200的01方阵，从1到n输出答案，答案为大小为i的方阵中01数量相等的方阵有多少\n  * 直接暴力会T，用二维前缀和记一下\n  * 第四题 30% （看评论区老哥解法学会了）\n  * 大小为1e5的正整数数组，有多少种删除区间的方案，使得剩下元素的乘积末尾0至少为k个\n  * 直接枚举区间范围暴力，能过30%\n  * 第五题 100% （离线 + 反向并查集）\n  * 编号为1e9的人，有1e5对朋友关系，朋友关系能够间接传递；1e5次询问，询问包含：1、删除一对直接朋友关系 2、询问两个人是否能通过朋友关系认识，对于2的询问输出Yes或No\n  * 并查集支持合并与栈形式的撤销合并操作，对于本题无序的删边，需要用到离线\n  * 最开始只合并操作中没有删除的边，然后从询问反着依次查询以及合并\n  * 一些边界条件：\n  * 可能会重复删除，记得只保存第一次删除的，同时，非直接关系需要忽略\n  * 保存边的时候要保存无向图，如{u, v}，应该保存{u, v}和{v, u}\n  * 点的大小为1e9，并查集数组需要用哈希表来存，预先把所有点存下来再初始化\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595949079851556864?sourceSSR=users",
        "title": "T1 小美的数组询问(15分) - 美团编程题 & 题解",
        "content": "> 考试平台： 牛客网\n>\n> 题目类型： 30道单选题（60分）+ 2 道编程题 （15分 + 25分）\n>\n> 考试时间： 2024-03-09 （两小时）\n\n![image-20230904091037592](https://smqk.oss-cn-\nbeijing.aliyuncs.com/images/image-20230904091037592.png)\n\n### 题目描述\n\n小美拿到了一个由正整数组成的数组，但其中有一些元素是未知的（用 0 来表示）。\n现在小美想知道，如果那些未知的元素在区间![\\[l,r\\]](https://www.nowcoder.com/equation?tex=%5Bl%2Cr%5D)范围内随机取值的话，数组所有元素之和的最小值和最大值分别是多少？\n共有![q](https://www.nowcoder.com/equation?tex=q)次询问。\n\n### 输入描述：\n\n第一行输入两个正整数 `n`,`q`，代表数组大小和询问次数。\n第二行输入![n](https://hr.nowcoder.com/equation?tex=n)个整数![a_i](https://hr.nowcoder.com/equation?tex=a_i)，其中如果输入的![a_i](https://hr.nowcoder.com/equation?tex=a_i)为\n0，那么说明![a_i](https://hr.nowcoder.com/equation?tex=a_i)是未知的。 接下来的`q`行，每行输入两个正整数\n![l,r](https://hr.nowcoder.com/equation?tex=l%2Cr)，代表一次询问。\n![](https://www.nowcoder.com/equation?tex=1%5Cleq%20n%2Cq%20%5Cleq%2010%5E5&preview=true)\n![](https://www.nowcoder.com/equation?tex=0%20%5Cleq%20a_i%20%5Cleq%2010%5E9&preview=true)\n![](https://www.nowcoder.com/equation?tex=1%5Cleq%20l%20%5Cleq%20r%20%5Cleq%2010%5E9&preview=true)\n\n### 输出描述：\n\n输出`q`行，每行输出两个正整数，代表所有元素之和的最小值和最大值。\n\n### 示例：\n\n    \n    \n    输入：\n    3 \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595917456867110912?sourceSSR=users",
        "title": "#超级简单#经典跳台阶#acwing#复旦大学机试",
        "content": "思路：倒推，对于任何一个台阶来说，都可以从上一个节点跳一次或者两次达到，故考虑使用递归\n\n    \n    \n    #include <iostream>\n    #include <cstdio>\n    \n    using namespace std;\n    int main(){\n        int n,m,a[20];\n        a[1]=1;\n        a[2]=2;\n        scanf(\"%d\",&n);\n        for(m=3;m<=n;m++){\n            a[m]=a[m-1]+a[m-2];\n        }\n        printf(\"%d\",a[n]);\n        return 0;\n    }\n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595948717690109952?sourceSSR=users",
        "title": "T2 小美的平衡矩阵(25分) - 美团编程题 & 题解",
        "content": "> 考试平台： 牛客网\n>\n> 题目类型： 30道单选题（60分）+ 2 道编程题 （15分 + 25分）\n>\n> 考试时间： 2024-03-09 （两小时）\n\n### 题目描述\n\n小美拿到了一个`n*n`的矩阵，其中每个元素是 0 或者 1。 小美认为一个矩形区域是完美的，当且仅当该区域内 0 的数量恰好等于 1 的数量。\n现在，小美希望你回答有多少个`i*i`的完美矩形区域。你需要回答![](https://www.nowcoder.com/equation?tex=1%5Cleq%20i%20%5Cleq%20n&preview=true)的所有答案。\n\n### 输入描述\n\n第一行输入一个正整数`n` ，代表矩阵大小。 接下来的`n`行，每行输入一个长度为`n`的 01 串，用来表示矩阵。\n![](https://www.nowcoder.com/equation?tex=1%5Cleq%20n%20%5Cleq%20200&preview=true)\n\n### 输出描述\n\n输出`n`行，第`i`行输出 `i*i`的完美矩形区域的数量。\n\n### 示例\n\n    \n    \n    输入：\n    4\n    1010\n    0101\n    1100\n    0011\n    \n    输出：\n    0\n    7\n    0\n    1\n    \n\n### 题解\n\n> 暴力枚举所有情况， 在暴力枚举的情况下使用前缀和优化检验 \"是否是完美矩形区域\" 的方法。\n    \n    \n    from collections import defaultdict\n    \n    n = int(input())\n    \n    grid = [input() for _ in range(n)]\n    \n    # 前缀和 psum[r][i] 表示 grid[r][0:i] 中 “1” 的个数\n    psum = [[0] * (n+1) for _ in range(n)]\n    for r in ra\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595762627133882368?sourceSSR=users",
        "title": "Go后端日常实习面经（边无际、momenta）",
        "content": "## 边无际\n\n### 3.1一面\n\n三部分\n\n第一部分(5min)：自我介绍，简历介绍\n\n第二部分(40min)：写代码，实现消息队列\n\n第三部分(10min)：简单问问英语水平\n\n### 3.4笔试\n\n在Kubernetes中运行Shifu(边无际的开源项目)并编写一个应用\n\n## momenta\n\n### 3.7一面30min\n\n两个代码题讲思路（和网上别人面经一样的原题）\n\nGin优点 中间件使用\n\ngo并发下载10个数据，怎么写\n\n### 3.8二面30min\n\n深挖实习做的项目，扩展场景提问\n\nGin的中间件如何处理，Gin的路由原理\n\nslice底层原理\n\n如何实习单例模式\n\n红黑树的读写复杂度\n\n快排稳定吗\n\n孤儿进程和僵尸进程\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595750586285395968?sourceSSR=users",
        "title": "柠檬微趣笔试 柠檬微趣笔试题 0303",
        "content": "笔试时间：2024年03月03日 春招\n\n历史笔试传送门：[2023秋招笔试合集](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fcreation%2Fmanager%2FcolumnDetail%2F0ODrNm)\n\n# 第一题\n\n### 题目：求和方式\n\n给定一个正整数 s 和 n 个正整数 , 求有多少种组合的和为 s ？数值相同的两个数视为不同的两个数。\n\n### 输入描述\n\n第一行两个整数 n，s，含义如题所述；\n\n第二行 n 个整数。\n\n1<=n<=30, 1<=s<=900, 1<=wi<=s\n\n### 输出描述\n\n输出一个整数表示答案。特别地，如果没有合法方案，输出0。\n\n### 样例输入\n\n> 10 5\n>\n> 1 1 1 1 1 1 1 1 1 1\n\n### 样例输出\n\n> 252\n\n### 说明\n\nC(10, 5) = 252\n\n### 参考题解\n\n采用动态规划的方式，对于n个整数，每一个可能被选上，也可能不被选上，状态定义：f[i] [j]\n考虑前i个元素，凑出和为j的元素有多少种组合。状态转移方程：f[i] [j] = f[i-1] [j] + f[i-1] [j-a[i]]。\n\nPython：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    memo = {}\n    \n    def count_subsets(index, current_sum):\n        key = (index, current_sum)\n        if key in memo:\n            return memo[key]\n    \n        if index >= num_elements or current_sum > target_sum:\n            return 1 if current_sum == target_sum else 0\n    \n        result = count_subsets(index + 1, current_sum) + count_subsets(index + 1, current_sum + elements[index])\n        memo[key] = result\n        return result\n    \n    num_elements, target_sum = map(int, input().split())\n    elements = list(map(int, input().split()))\n    \n    print(count_subsets(0, 0))\n    \n    \n\nC++：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    #include <iostream>\n    #include <vector>\n    #include <map>\n    using namespace std;\n    \n    int num_elements, target_sum;\n    vector<int> elements;\n    map<pair<int, int>, int> memo;\n    \n    int countSubsets(int index, int current_sum) {\n        // 检查结果是否已经存在于备忘录中\n        map<pair<int, int>, int>::iterator it = memo.find(make_pair(index, current_sum));\n        if (it != memo.end()) {\n            return it->second;\n        }\n        \n        if (index >= num_elements || current_sum > target_sum) {\n            return (current_sum == target_sum) ? 1 : 0; // 如果 current_sum 等于 target_sum，则返回 1，否则返回 0\n        }\n        \n        // 递归调用：排除当前元素或包含它\n        int result = countSubsets(index + 1, current_sum) + countSubsets(index + 1, current_sum + elements[index]);\n        memo[make_pair(index, current_sum)] = result; // 在返回前将结果保存到备忘录中\n        return result;\n    }\n    \n    int main() {\n        cin >> num_elements >> target_sum;\n        elements.resize(num_elements);\n        for (int i = 0; i < num_elements; ++i) {\n            cin >> elements[i];\n        }\n        \n        cout << countSubsets(0, 0) << endl;\n        return 0;\n    }\n    \n    \n\nJava：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    import java.util.HashMap;\n    import java.util.Map;\n    import java.util.Scanner;\n    \n    public class Main {\n        static int numElements, targetSum;\n        static int[] elements;\n        static Map<String, Integer> memo;\n    \n        static int countSubsets(int index, int currentSum) {\n            String key = index + \",\" + currentSum;\n            if (memo.containsKey(key)) {\n                return memo.get(key);\n            }\n    \n            if (index >= numElements || currentSum > targetSum) {\n                return (currentSum == targetSum) ? 1 : 0;\n            }\n    \n            int result = countSubsets(index + 1, currentSum) + countSubsets(index + 1, currentSum + elements[index]);\n            memo.put(key, result);\n            return result;\n        }\n    \n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            numElements = scanner.nextInt();\n            targetSum = scanner.nextInt();\n            elements = new int[numElements];\n            memo = new HashMap<>();\n    \n            for (int i = 0; i < numElements; ++i) {\n                elements[i] = scanner.nextInt();\n            }\n    \n            System.out.println(countSubsets(0, 0));\n        }\n    }\n    \n    \n\n# 第二题\n\n### 题目：Regular Expresssion\n\n实现简单的正则表达式匹配，本题中模式字符串所包含的字符的范围为字母、“.”、“*”、“?\"、其中：\n\n  * “.” 匹配任何单个字符；\n  * “*” 与模式字符串前一个字符组成一组，匹配零个或多个前面的字符；\n  * “?” 与模式字符串前一个字符组成一组，匹配一个或多个前面的字符；\n\n匹配应该覆盖到整个输入的字符串（而不是局部的），测试用例中不会出现超出匹配字符范围之外的字符，也不会出现非法的模式字符串。**使用语言提供的正则表达式库将算作无效答案。**\n\n### 输入描述\n\n输入的第一行为需要检测匹配的用例数，接下来的每一行包括两个字符串，前一个字符串为待匹配的字符串，后一个字符串为模式字符串，\n\n待匹配字符串的长度不超过10。\n\n### 输出描述\n\n对于每一个测试用例，如果匹配则输出一行true，如果不匹配则输出一行false。\n\n### 样例输入一\n\n> 3\n>\n> aa a\n>\n> aa aa\n>\n> aaa aa\n\n### 样例输出一\n\n> false\n>\n> true\n>\n> false\n\n### 样例输入二\n\n> 5\n>\n> a a.\n>\n> a a.*\n>\n> ab .*\n>\n> ab .?\n>\n> b a?\n\n### 样例输出二\n\n> false\n>\n> true\n>\n> true\n>\n> true\n>\n> false\n\n### 参考题解\n\n需要注意不同符号的功能，然后逐个比较字符串就行。\n\nPython：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    def match_core(text, text_index, pattern, pattern_index):\n        if text_index == len(text) and pattern_index == len(pattern):\n            return True  # 完全匹配\n        if text_index != len(text) and pattern_index == len(pattern):\n            return False  # 模式串用完但字符串没有用完，不匹配\n    \n        # 检查下一个字符是不是'*'或'?'\n        next_is_star = pattern_index + 1 < len(pattern) and pattern[pattern_index + 1] == '*'\n        next_is_question = pattern_index + 1 < len(pattern) and pattern[pattern_index + 1] == '?'\n    \n        if next_is_star:\n            if (text_index != len(text) and (pattern[pattern_index] == text[text_index] or pattern[pattern_index] == '.')) or \\\n                    (text_index == len(text) and pattern_index + 2 == len(pattern)):\n                # 移动字符串或模式串，或者两者都移动\n                return match_core(text, text_index + 1, pattern, pattern_index) or \\\n                       match_core(text, text_index, pattern, pattern_index + 2) or \\\n                       match_core(text, text_index + 1, pattern, pattern_index + 2)\n            else:\n                return match_core(text, text_index, pattern, pattern_index + 2)\n        elif next_is_question:\n            if text_index != len(text) and (pattern[pattern_index] == text[text_index] or pattern[pattern_index] == '.'):\n                # 匹配一个字符，然后移动模式串和字符串\n                return match_core(text, text_index + 1,\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595711192291618816?sourceSSR=users",
        "title": "项目排期 - 华为OD统一考试（C卷）",
        "content": "> OD统一考试（C卷）\n>\n> 分值： 200分\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n项目组共有N个开发人员，项目经理接到了M个独立的需求，每个需求的工作量不同，且每个需求只能由一个开发人员独立完成，不能多人合作。\n\n假定各个需求直接无任何先后依赖关系，请设计算法帮助项目经理进行工作安排，使整个项目能用最少的时间交付。\n\n## 输入描述\n\n第一行输入为M个需求的工作量，单位为天，用逗号隔开。 例如：X1 X2 X3 .... Xm\n表示共有M个需求，每个需求的工作量分别为X1天，X2天......Xm天。其中0<M<30；0<Xm<200 第二行输入为项目组人员数量N 例如： 5\n表示共有5名员工，其中0<N<10\n\n## 输出描述\n\n最快完成所有工作的天数 例如： 25 表示最短需要25天能完成所有工作\n\n## 示例1\n\n    \n    \n    输入：\n    6 2 7 7 9 3 2 1 3 11 4\n    2\n    \n    输出：\n    28\n    \n    说明：\n    共有两位员工，其中一位分配需求6 2 7 7 3 2 1共需要28天完成，另一位分配需求9 3 11 4共需要27天完成，故完成所有工作至少需要28天。\n    \n\n## 题解\n\n> 这道题可以使用**二分查找 + 回溯** 来解决，二分的范围为需求工作量的最大值到总工作量的和。具体步骤如下：\n>\n>   1. 定义一个二分查找范围，最小值为需求工作量的最大值 - 1，最大值为总工作量的和。\n>   2. 利用二分查找，查找最小的 MAX_SUM，使得每个人的工作量不超过 MAX_SUM。为了判断是否能满足条件，使用递归函数 `ok`\n> （回溯法），在函数中模拟分配工作的过程，尝试将每个需求分配给不同的人员，看是否满足总工作量不超过 MAX_SUM。\n>   3. 如果能满足条件，则缩小二分查找范围为左半部分；否则，缩小二分查找范围为右半部分。\n>   4. 最终找到的二分查找范围左边界就是答案。\n>\n\n### Java\n\n    \n    \n    import java.util.Arrays;\n    import java.util.Scanner;\n    \n    /**\n     * @author code5bug\n     */\n    public class Main {\n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n    \n            // 读取每个工作的工作量\n            int[] works = Arrays.stream(scanner.nextLine().split(\" \"))\n                    .mapToInt(Integer::parseInt).toArray();\n    \n            // 读取开发人员的数量\n            int N = scanner.nextInt();\n    \n            Solution solution = new Solution(works, N);\n            System.out.println(solution.solve());\n        }\n    }\n    \n    \n    class Solution {\n        int N;\n        int[] works;\n    \n        public Solution(int[] works, int N) {\n            this.N = N;\n            this.works = works;\n        }\n    \n        public int solve() {\n            // 二分查找，找到最小的 MAX_SUM，使得每个人的工作量 <= MAX_SUM\n            int l = Arrays.stream(works).max().getAsInt() - 1;\n            int r = Arrays.stream(works).sum();\n    \n            while (l + 1 < r) {\n                int mid = (l + r) >> 1;\n                if (ok(0, mid, new int[N])) {\n                    r = mid;\n                } else {\n                    l = mid;\n                }\n            \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595685640251912192?sourceSSR=users",
        "title": "腾讯实习基地 wxg后台开发 一二三面 面经",
        "content": "  * 2024-03-06 一面（50min）\n  * raft算法如何保证一致性，除了raft还了解过其他分布式算法吗\n  * raft存储部分是用什么实现的，有没有测过性能，还做过哪些存储的项目\n  * https的加密过程\n  * Mysql存储引擎有哪些，说下对innoDB框架的理解\n  * 如何实现一个定时器\n  * 怎么理解C++移动语义\n  * I/O多路复用的原理，epoll的实现，ET和LT\n  * 算法题两道：顺序矩阵找元素，怎么优化；合法IP地址\n  * 反问：找实习还需要学啥（开源项目）；多久出结果（不清楚）\n  * 2024-03-08 二面（75min）\n  * 简单问了实验室的一个项目\n  * 介绍一下各种语言的特点和区别；介绍下C++RAII、override、移动语义、内存泄漏的场景、怎么解决，用过哪些调试方法\n  * raft的作用是什么，性能如何，怎么持久化的；脑裂发生后，集群怎么恢复的；最多多少个结点崩溃后仍然可以保持集群运转；还了解过什么分布式算法\n  * TCP和UDP区别，TCP的time_wait状态是什么；udp如何保证可靠，怎么实现，和TCP比性能如何\n  * 你对HTTP了解多少，各个版本的区别，了解QUIC吗\n  * 文件读写过程中发生了哪些事，进程A写100个数据和进程B写100个数据，文件会是什么样；文件open的时候，另一个进程删除它会怎么样\n  * 了解过哪些数据库引擎，他们的区别有哪些，多线程B+树的底层如何实现；常见的隔离级别，可能存在的问题，怎样通过加锁释放锁来实现隔离级别；MVCC说一下；redis如何持久化，MySQL呢；有没有比较高效的日志恢复方法；了解过levelDB吗\n  * 设计一个单进程或多进程的服务器，需要考虑哪些内容\n  * 两道算法题：最大连续子序列和以及区间下标；AC自动机模板题（时间复杂度），面试官说一般用RK算法；你还对哪些算法比较熟悉\n  * 系统设计：对QQ号以及相关的kv信息进行存储，怎么设计，性能如何\n  * 反问：两次面试都问了很多存储，是不是做存储比较多（是）；找实习还需要学啥（OS底层，数据库底层）\n  * 2024-03-13 三面（1h 50min）\n  * 第一小时做三道题：直播系统的功能设计，概率题，完全二叉树三个点的LCA\n  * 唠了会三道题的做法还有优化\n  * 你打算法比赛最好的成绩是什么，一般负责哪些内容\n  * 讲一下Raft日志选举，怎么判断其他结点日志是否更新，什么是MapReduce里的倾斜\n  * 快排的复杂度，什么时候会O（N * N）\n  * 反问：找存储的实习还需要学啥（开源项目），后面还有面试吗（可能还有一到两轮）\n  * 2024-03-18 三面挂，不算休息日第三天挂，应该是被排序了吧，下次加油\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595685381102682112?sourceSSR=users",
        "title": "展心展力 Android 二面 3.5",
        "content": "实习工作  \n自定义view 过程中要注意的点（触摸事件，组合，onMeasure处理， padding处理， 自绘控件，canvas，paint，path）  \n实习中的成就点  \n对mvvm和mvp的认识  \n项目中 kotlin flow 的用处  \n冷流与热流的概念  \nhashmap  \n为什么学 flutter 而不是 compose  \n反问  \n  \n3月7号hr面，暂无消息\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595677450378424320?sourceSSR=users",
        "title": "Java软件开发面试题1（睿联科技）",
        "content": "1.mysql如何存储金额？\n\n用Decimal，这是为专门为财务相关问题设计的数据类型。\n\n语法格式：DECIMAL(最大整数位数M, 最大小数位数D) //其中，D≤M\n\n2.mysql的Date类型介绍一下，并举出使用示例，最后再举出如何配合Java使用。\n\n【概念介绍】MySQL 的 DATE 类型用于存储日期值，格式为 'YYYY-MM-DD'。它只包含年、月、日信息，不包含时间信息\n\n【使用示例】INSERT INTO example_table (event_date) VALUES ('2023-10-23');\n\n【日期函数】CURDATE() 函数获取当前日期。使用示例：INSERT INTO example_table (event_date) VALUES\n(CURDATE());\n\n【增加函数】DATE_ADD() 函数给日期加上一定的日期。使用示例：UPDATE example_table SET event_date =\nDATE_ADD(event_date, INTERVAL 5 DAY) WHERE id = 1;\n//可选项：MICROSECOND、SECOND、MINUTE、HOUR、DAY、WEEK、MONTH、QUARTER、YEAR\n\nTips：如果想处理时间，那么应该使用DATETIME类型：\n\n这种类型用于存储日期和时间信息，格式通常为'YYYY-MM-DD HH:mm:ss'\n\nTips2：Java中也有Date和DateTime类，从而实现了对于MySQL该种类型的操作\n\n3.linux线程池和进程池工作的区别\n\n**线程池（Thread Pool）：**\n\n线程池是用来管理线程的集合，可以重复使用已创建的线程来执行多个任务。\n\n在Linux中，线程池通常是通过Java中的ExecutorService接口实现的。\n\n线程池适用于处理短时间、轻量级的任务，因为线程的创建和销毁开销较小。\n\n线程池中的线程共享同一个进程的资源，因此需要注意线程之间的同步和资源竞争问题。\n\n**进程池（Process Pool）：**\n\n进程池是用来管理进程的集合，每个进程都有自己独立的内存空间和资源。\n\n在Linux中，进程池通常需要通过操作系统级别的API来实现。\n\n进程池适用于处理长时间、重量级的任务，因为每个进程都有独立的资源空间。\n\n进程之间相互隔离，不会出现线程之间的资源竞争问题，但进程间通信开销较大。\n\n**总体而言，线程池适合处理轻量级任务并且能够更高效地利用系统资源，而进程池适合处理重量级任务并且能够提供更好的隔离性。在选择使用哪种池时，需要根据具体任务需求和系统资源情况进行权衡。**\n\n4.设计模式 工厂和建造者的区别\n\n**工厂方法模式（Factory Method Pattern）**\n用于创建一些简单对象，而且通常只需要一步就可以创建完成。通过定义一个工厂接口和多个实现类，每个工厂实现类负责创建自己所对应的产品类型。\n\n**建造者模式（Builder Pattern）**\n则更适用于创建复杂对象，例如需要一步步构建或者配置许多不同的组成部分才能完成的对象。它通过将对象构造和表示分离来实现目标，并提供灵活的方式使得同样的构建过程可以创建不同的表现形式。\n\n**例如：当我们要考虑生产一个超人；**\n\n  * 若使用工厂方法，模式，一般将生产超人和生产机器人放在一起比较，我们提供生产超人的工厂就可以将超人生产出来了。\n  * 若使用建造者模式考虑，就是将超人分成头、手、脚等等部分生产好，然后进行组装好。最后穿上内裤就可以了，在这个过程中就需要一个指挥者了，用于指定生产顺序。\n\n5.抽象类和接口的区别\n\n**抽象类**\n\n  * 不能被实例化，只能被用作子类的超类。\n  * 可以包含抽象和非抽象方法。\n  * 子类使用extends关键字来继承抽象类。\n  * 可以有构造函数。\n  * 类可以继承一个抽象类。\n\n**接口**\n\n  * 是抽象方法的集合，所有方法都隐含是抽象的。\n  * 类实现接口时使用implements关键字。\n  * 接口中的成员函数默认是public，不能包含方法体。\n  * 类可以实现多个接口，但只能继承一个抽象类。\n\n总体来说，**抽象类更适合捕捉通用特性和提供默认实现、** 是**对类的抽象**\n\n而**接口更适合定义行为规范和强制实现者遵循规范、** 是**对行为的抽象**\n\n6.简述一下linux的权限操作\n\n在Linux中，权限操作是通过文件权限来控制对文件和目录的访问权限。每个文件和目录都有一个所有者、一个所属组和其他用户的权限设置。以下是简要的解释：\n\n  * 文件类型：Linux中的文件类型包括普通文件、目录、链接文件、设备文件、数据接口文件等，每种类型有不同的属性标识。\n  * 权限属性：文件权限属性包括**读（r, 4）、写（w, 2）、执行（x, 1）** 权限，分别对应于**所有者、所属组和其他用户** 。权限属性可以通过数字表示（如764）或符号表示（如rwxr-xr--）。\n  * 系统保护：**文件权限提供系统保护** ，确保非权限用户无法操作具有某些权限的功能和数据，适合团队开发和数据共享。\n  * 常用命令：在Linux中，常用命令包括ls查看文件列表，cat查看文本文件内容，**chmod修改文件权限，chown修改文件所有者** 等。\n\n总体而言，Linux的权限操作通过设置不同的读、写、执行权限来控制对文件和目录的访问。这种机制确保了系统安全性，并允许管理员灵活地管理用户对不同资源的访问权限。\n\n7.redis的队列如何实现？存储、获取的命令如何？\n\n可以使用List实现。\n\nLPUSH key val // 将值val插入到列表key的表头\n\nLPOP key // 弹出列表key表头的元素\n\nRPUSH key val // 将值val插入到列表key的表尾\n\nRPOP key // 弹出列表key表尾的元素\n\n8.相比于前端而言，你觉得后端最大的难点在哪儿？\n\n并发请求、性能优化、系统稳定性、技术选型\n\n  * **并发请求处理：** 处理大量并发请求可能导致系统性能下降，需要采取多线程、缓存、队列等技术来提高系统的并发处理能力。\n  * **性能优化：** 优化系统性能是一个持续的挑战，需要通过GC优化、压测分析、性能监控等手段来提升系统效率。\n  * **系统稳定性：** 保证系统长时间稳定运行是关键，遇到假死情况或异常情况时，需要分析问题根源并采取相应措施解决。\n  * **技术选型：** 选择合适的技术栈和架构设计对项目成功至关重要，需要考虑业务需求、团队实力和未来扩展性等因素。\n\n9.https和http的区别，如何加密的？\n\nHTTP和HTTPS之间的主要区别在于安全性和加密方式：\n\n  * **HTTP是超文本传输协议** ，数据传输是明文的，不加密。它运行在TCP之上，客户端与服务器端无法验证对方的身份，容易被窃听、篡改和伪装请求。\n  * HTTPS是在HTTP基础上加入了加密和认证机制的安全HTTP协议。**HTTPS使用SSL/TLS协议进行加密传输，通过公钥加密、私钥解密的方式保证通信安全。** HTTPS通信需要**证书** ，一般需要向认证机构购买。\n\nSSL/TLS协议通过以下步骤实现安全通信：\n\n  * **握手阶段：** 在握手阶段，客户端和服务器之间进行身份认证、协商加密算法、交换加密密钥等初始化协商功能。\n  * **记录协议层：** 建立在可靠传输层协议（如TCP）之上，提供数据封装、压缩、加密等基本功能。\n  * **握手协议层：** 用于在实际数据传输开始前，进行身份认证、协商加密算法、交换加密密钥等操作。\n\n10.http如何知道报文片是最后一个的？\n\n在HTTP中，报文片段如何知道是否是最后一个取决于报文头部的**Content-Length** 字段或Transfer-Encoding字段。\n\n  * Content-Length字段：当服务器发送HTTP响应时，如果在**响应头部包含了Content-Length字段，它指定了整个消息体的长度。** 客户端通过检查已接收数据的长度是否等于Content-Length字段的值来确定是否接收到了完整的消息。\n  * Transfer-Encoding字段：另一种方式是使用**Transfer-Encoding: chunked字段，它表示消息体被分成多个块传输。** 每个块前面会有一个十六进制数表示块的长度，**最后一个块长度为0。当客户端接收到一个长度为0的块时，就知道这是最后一个块，即消息传输完成。**\n\n11.腾讯会议是什么连接？mac地址是什么？\n\n  * 腾讯会议使用的是TCP/IP协议进行通信。具体来说，腾讯会议客户端和服务端的通信都使用TCP/IP、HTTP、RTP/RTCP协议\n  * MAC地址（Media Access Control Address）是网络设备的物理地址，是一个唯一的标识符，通常由48位二进制数表示。MAC地址用于在局域网中唯一标识网络设备，类似于设备的身份证号码。MAC地址通常以十六进制表示，由6组两位十六进制数（00-FF）组成，中间用冒号或短横线分隔。MAC地址是数据链路层的概念，在网络通信中起着重要作用。\n\n12.linux的系统调用函数有哪些？\n\n  1. open()：打开文件或创建文件。\n  2. read()：从文件描述符中读取数据。\n  3. write()：向文件描述符中写入数据。\n  4. close()：关闭文件描述符。\n  5. fork()：创建子进程。\n  6. exec()：执行程序。\n  7. wait()：等待子进程结束。\n  8. exit()：退出进程。\n  9. pipe()：创建管道。\n  10. socket()：创建套接字。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595685059798077440?sourceSSR=users",
        "title": "展心展力 Android一面 3.5",
        "content": "为什么要离开实习公司  \n谈谈学过的数据结构  \n介绍下链表与数组  \n链表与数组的特点  \n数组查找（二分）  \n寻找链表的中点  \n寻找链表的环节点  \n谈谈你学过的排序算法  \n冒泡排序的时间复杂度  \n快速排序时间复杂度  \n快排思想（没答上来）  \njava内部类的区别  \n内存泄漏都有哪几种情况  \njava的引用类型  \njava引用如何实现（直接答不了解jvm）  \nhandler怎样持有activity引用  \n内存泄漏如何治理  \n内存泄漏工具（不知道）  \n如何获取两个线程都运行完的结果  \n学习过哪些编程语言（c,c++,kotlin,go,asm,java）  \n用一句话描述出每种语言适合做些什么  \n对compose有了解吗  \n反问\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595648285843402752?sourceSSR=users",
        "title": "计算面积 - 华为OD统一考试（C卷）",
        "content": "> OD统一考试（C卷）\n>\n> 分值： 100分\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n绘图机器的绘图笔初始位置在原点（0, 0），机器启动后其绘图笔按下面规则绘制直线：\n\n1）尝试沿着横向坐标轴正向绘制直线，直到给定的终点值E。\n\n2）期间可通过指令在纵坐标轴方向进行偏移，并同时绘制直线，偏移后按规则1 绘制直线；指令的格式为X offsetY，表示在横坐标X\n沿纵坐标方向偏移，offsetY为正数表示正向偏移，为负数表示负向偏移。\n\n给定了横坐标终点值E、以及若干条绘制指令，请计算绘制的直线和横坐标轴、以及 X=E 的直线组成图形的面积。\n\n## 输入描述\n\n首行为两个整数N E，表示有N条指令，机器运行的横坐标终点值E；\n\n接下来N行，每行两个整数表示一条绘制指令X offsetY，用例保证横坐标X以递增排席方式出现，目不会出现相同横坐标X；\n\n取值范围: 0<N<=10000，0<= X<=E<=20000,-10000 <= offsetY <= 10000。\n\n## 输出描述\n\n一个整数，表示计算得到的面积，用例保证，结果范围在0~4294967295内\n\n## 示例1\n\n    \n    \n    输入：\n    4 10\n    1 1\n    2 1\n    3 1\n    4 -2\n    \n    输出：\n    12\n    \n\n![alt](https://uploadfiles.nowcoder.com/images/20240308/644248237_1709885551947/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n## 示例2\n\n    \n    \n    输入：\n    2 4\n    0 1\n    2 -2\n    \n    输出：\n    4\n    \n\n![alt](https://uploadfiles.nowcoder.com/images/20240308/644248237_1709885539241/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n## 题解\n\n> 这是一个简单的几何题，通过读取指令和横坐标值，计算出图形的总面积。以下是对该问题的解法总结：\n>\n>   1. **解题思路：** 按要求读取每个指令，根据指令更新绘图笔位置并计算相应的面积。\n>   2. **代码描述：**\n>      * 初始化图形总面积 `totalArea` 和绘图笔位置 `(x, y)`。\n>      * 读取每个指令，计算当前边和前一条边组成的面积，并更新绘图笔位置。\n>      * 最后计算最后一条边组成的面积。\n>      * 输出结果。\n>\n\n### Java\n\n    \n    \n    import java.util.Scanner;\n    \n    /**\n     * @author code5bug\n     */\n    \n    public class Main {\n        public static void main(String[] args) {\n            Scanner in = new Scanner(System.in);\n    \n            // 读取输入的 N 和 E\n            int N = in.nextInt(), E = in.nextInt();\n    \n            // 初始化图形总面积\n            long totalArea = 0;\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595645463160770560?sourceSSR=users",
        "title": "小鹅通-后端开发实习面经",
        "content": "时间是2023年10月份，已offer已入职\n\n## 2023.10.9 一面\n\n  1. 自我介绍\n  2. mini项目的职责？负责什么？遇到的难点或者有趣的点？\n  3. 如何无侵入地接入的otel-sdk？\n  4. 如何利用go的特性通用地给redis/orm层来无侵入接入？\n  5. 输入网址的过程？\n  6. tcp四次挥手的原因？\n  7. udp如何像tcp一样可靠传输？\n  8. go的数据结构map是否并发安全？\n  9. 如何并发访问map？如何提高加锁的性能？\n  10. 访问关闭的go的channel会怎么样？为什么会panic？怎么知道channel关闭了？\n  11. go内存泄漏应该如何排查，哪个方向？\n  12. 最近或者看过什么专业书？\n  13. 反问：\n  14. 公司的技术栈？技术要求？\n  15. 公司业务？\n\n## 2023.10.10 二面\n\n  1. 自我介绍\n  2. 大三？全职实习？\n  3. 腾讯相关项目的信息？\n  4. mini项目负责什么？项目背景？收获了什么？\n  5. 遇到什么困难？（管理上的具体）\n  6. 老方案与新方案的差异在哪（具体），优缺点？答：一条一条/批处理；es/ck\n  7. ck为什么优秀？\n  8. ck怎么追加写？怎么merge（压缩空间）？磁盘IO？碎片？\n  9. Linux的文件系统？\n  10. Linux的命令知道哪些？\n  11. Linux的软连接、硬链接？\n  12. 项目用kafka来做什么？\n  13. kafka的基础概念？broker、分区、副本等等\n  14. 是什么时候用副本？集群保证高可用性\n  15. 从什么时候接触编程？\n  16. 反问：\n  17. 公司、部门的团队或人员组成分布？\n  18. 新项目/任务的流程是怎么样的？\n  19. 实习/入职的工作建议or规划？\n\n## 2023.10.11 hr面\n\n  1. 通过前面几轮面试你对公司或者部门的了解？\n  2. 投递简历看重什么？\n  3. 通过什么途径来学习go这些技术的？\n  4. 通过什么途径来参加简历中的项目的？\n  5. 项目都作为leader遇到了什么困难？\n  6. 导师对你打分多少（10分制）？评价如何？\n  7. 你提到的前期导向不清晰，你会怎么去解决？\n  8. 你的职业规划是什么？\n  9. 三个关键字形容自己的性格？\n  10. 哪里人？\n  11. 学校在哪里？实习交通怎么处理？\n  12. 实习时间的安排？\n  13. 有没有投递其他公司？\n  14. 有什么坚持比较久的兴趣爱好？\n  15. 为什么喜欢打篮球？\n  16. 反问：\n  17. 胜任工作的最看重的素质或者能力？\n  18. 最喜欢公司哪一方面？\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595588094691164160?sourceSSR=users",
        "title": "24提前批 抖音 推荐架构 C++",
        "content": "23 年 8 月面的\n\n  * 自我介绍\n  * 列式存储的优势 被问烂了\n  * 主流列式数据库，主流使用场景\n  * 列式存储压缩算法（lz4、snappy、zstd区别） [https://bbs.huaweicloud.com/blogs/detail/278702](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fbbs.huaweicloud.com%2Fblogs%2Fdetail%2F278702)\n  * RAII怎么使用的\n  * 你的性能提升来自于哪里\n  * c++类型转换static_cast和dynamic_cast \n  * dynamic_cast可以把子类指针转父类吗 [https://blog.csdn.net/qq_42301196/article/details/128839038](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fqq_42301196%2Farticle%2Fdetails%2F128839038)\n  * 主流json库，json设计上的有什么区别\n  * json函数选型考虑\n  * 一百个位置用到该json库，如何最快方式测试出来该库是否可用\n  * vector::size() 性能\n  * 析构函数中可以调用虚函数吗：不能确定析构到哪一步，调用父类还是子类的对象\n  * A中有虚函数和int类型，B继承A并实现了虚函数，B的大小是多少：16byte=虚函数指针8byte+int8byte\n  * A中有int和char类型成员变量，A的大小 [https://www.cnblogs.com/fengyaoyao/p/10262312.html](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.cnblogs.com%2Ffengyaoyao%2Fp%2F10262312.html)\n  * 堆插入的时间复杂度O（logn），快排时间复杂度O(n log n)，二分查找时间复杂度(log2n)\n  * 初始化列表的优势 [https://blog.csdn.net/lws123253/article/details/80368047](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Flws123253%2Farticle%2Fdetails%2F80368047)\n  * c++堆和栈的区别\n  * 常见的锁类型\n  * 乐观锁，悲观锁\n  * 在线文档，用什么锁\n  * map和unordered_map有什么区别 [https://zhuanlan.zhihu.com/p/210458185](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F210458185)\n  * 插入hash表冲突是多少，最坏是多少，什么时候扩容，扩容因子由什么决定\n  * 清空一个vector，使得capacity和size均为0：\n\n    \n    \n    vector<int> nums{1,2,3,4,5}\n    vector<int>().swap(nums);\n    \n\n  * 手撕：两个有序数组中第k大的数\n\n非常想去，但是当时没咋准备八股，被问麻了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595578761140064256?sourceSSR=users",
        "title": "面经 超星",
        "content": "  1. 自我介绍\n  2. 你为什么想来做产品岗\n  3. b端产品的特性\n  4. 使用线上教育类产品有无什么感触\n  5. 线上监管的功能好处及改进点\n  6. 工作中的推进困难部分及方法\n  7. 阅读方式及平台\n  8. 自己的关键词\n\n海投投的，屡次卡壳（\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595574221514821632?sourceSSR=users",
        "title": "字节跳动数据科学面经",
        "content": "一面：\n\n  1. 自我介绍\n  2. 机器学习中常见的回归和分类算法\n  3. AB实验：全流程、两类错误、p值、样本量、中心极限定理、Z检验&t检验、卡方检验，绝对值指标以及比值指标各自适用的检验\n  4. 线性回归共线性、过拟合、正则化\n  5. 针对实习经历问了常用的时序模型以及评价标准\n  6. 对DS和DA的理解\n\n二面：\n\n  1. 自我介绍\n  2. 逻辑回归的损失函数\n  3. 随机森林和XGBoost的区别\n  4. 主成分分析的原理\n  5. sql窗口函数以及区别\n  6. 中心极限定理和大数定律\n\n三面：\n\n  1. 自我介绍\n  2. 介绍一个实习中的项目I\n  3. 客户留存率下降怎么分析？\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595587051412533248?sourceSSR=users",
        "title": "24届校招 高德 导航规划 C++",
        "content": "23 年 9 月面的。面试体验很好，我愿称之为 C++ 之光\n\n  * 怼项目1，限流方案是你自己设计的吗\n  * 怼项目2，内核升级是做什么\n  * 怼项目3，批量注册是什么\n  * 项目对你提升最大的地方\n  * 你觉得MariaDB内置的JSON和主流JSON库有什么区别吗\n  * 主流JSON库了解吗\n  * 有什么性能优化的思路吗\n  * 内存泄漏的问题如何排查\n  * GDB常用的命令\n  * g++ -g会保留较多的调试信息，有可能会影响程序的运行效率，那么影响的是哪部分的运行时间？\n  * 内存池了解吗，为了解决什么问题\n  * c++新标准\n  * 移动语义说一下\n  * vector的扩容策略，扩容1.5倍或2倍是由什么决定的\n  * new了1w个对象没释放，有没有占用到物理内存\n  * 不占用物理内存的话，实际上它消耗了什么别的资源\n  * 常用排序算法，快速排序原理，最好最坏情况\n  * Dijkstra算法\n  * linux有一个文件不断被写入，如何查找写入这个文件的进程（lsof）\n  * 查看端口占用\n  * 进程与线程的区别，协程\n  * thread_local了解吗 [https://zhuanlan.zhihu.com/p/77585472](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F77585472)\n  * golang的协程如何调度\n  * 协程可以跨线程调度吗 [https://zhuanlan.zhihu.com/p/323271088](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F323271088)\n  * 进程通信方式\n  * 共享内存可以跨进程吗？可以\n  * 进程A申请了共享内存与进程B通信，进程A崩溃，共享内存还存在吗\n  * TLS了解吗\n  * brpc的线程相对c++线程有什么优势\n  * brpc底层基于什么协议\n  * brpc服务端如何做服务发现的\n  * docker有用过吗\n  * 手撕：二叉树最小高度（递归非递归都要）\n  * 平时怎么学习新技术\n  * 说一下印象最深的技术点\n\n##\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595573720614260736?sourceSSR=users",
        "title": "安踏AI面筋",
        "content": "安踏ai测评属于秒发类型，当天中午投递下午左右就收到ai面的邮件。\n\n面完觉得寄了，因为前半程胡说八道后半程答题乱七八糟[发火]\n\n分享下面经吧[摸鱼中]\n\n# 大致流程：\n\n行为测试——个人特性——计算题\n\n## 行为测试：\n\n最好是准备个手机支架，该过程会录制回答视频。验证你不同个性能力的题目会先让你在【学习经历】【社团经历】【工作经历】里面选，之后再设定场景回答，大概是有20几秒的读题时间。答题时限是5、6分钟，具体忘记了。觉得嘴瓢可以有一次重录机会，但是不会再多给时间。\n\n由于本人零工作经验题目全是学习、社团里选。\n\n根据回忆大概是有以下几题：\n\n  1. 描述你是如何在社团活动中推进项目的，结果如何\n  2. 说说跨部门合作的经历\n  3. 遇到过什么困难的事情，最后是怎么解决的\n  4. 举例和别人产生争执的情况，你是怎么做的，结果怎样\n\n## 个人特性：\n\n四项描述里分别拖一项到“最像我”和“最不像我”的框里，大概有十几题\n\n## 计算题：\n\n材料分析加计算，我的重灾区[牛泪]12min做9题，一定要上下划拉划拉题目看看有没有别的信息没看全！！！我做汇率的时候搁那看半天后面才发现下面还有一截题[笑cry]\n\n有时限来做题很考验沉着冷静的能力，而且只有本题做完才能往下做\n\n# 最后：\n\n祝大家面试顺利！offer多多！\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595572156893769728?sourceSSR=users",
        "title": "华为OD-Python测试面经（22届考研）",
        "content": "**背景**\n\n22届某211目标院校，考研二战失利，计算机相关专业，因为全力投入考研而无实习经验，有跟随导师做过一些项目，项目涉及数据分析所以主学Python。在了解到华为od之前也投过一些简历，有些是因为非23届应届生而不接受简历，有些则是能够给面试机会但是待遇不高。在此期间了解到华为od项目，正好自己有Python基础，所以选择Python机考。\n\n首先我通过牛客网咨询内推HR，例如岗位要求、面试流程、经验资料等，在细致了解后决定抓住机会试一试，这是一次进入大厂的好机会。\n\n**准备阶段**\n\n首先从网络上搜集相关考试资料，也咨询了内推人相关考试经验与题型。机考分为三个题目，对于Leetcode上难度为两个简单一个中等。如果有一定的编程基础，比如自己写过小程序或者本科、研究生论文项目等，这个难度只需要将牛客网上华为机考中简单和中等难度题目全部过一遍即可，熟悉题目如何输入输出，也算是热身练手；如果完全没有编程基础也没有关系，目标院校只需要150分即可通过考试，三个题目的分数分别是100，100和200，也就是说只需要前面两个题目AC即可轻松通过，简单题同样是在牛客网华为机考里选择优秀题目刷，不会的题目可以看评论区解答，从依葫芦画瓢开始到闭门造车，一周内足以提升自己的水平。\n\n我自己有项目经验，Python编程自然是不在话下。找了一家奶茶店，在一个安静的角落开始逐个攻克题目，栈、队、二分查找、贪心算法、动态规划、BFS、DFS……很快一周就把所有可能涉及的题型通过，Python做算法题还是很有优势的。\n\n**机考**\n\n机考前还是非常紧张的，前一天一定要保持好睡眠，考试前检查好环境，一切准备就绪。\n\n1、任务执行时长\n\n2、考勤信息\n\n3、日志上报积分\n\n考试题目运气相对较好，不算很难，部分题目难以理解，需要多读几次，过程中前两个题目很快AC，第三个题目一直卡住不能AC，最后获得350+分进入下一轮面试。\n\n**情绪测试**\n\n情绪测试可能会挂人，一定不能松懈，同样保持好睡眠。我在考试之前去公园逛了一会，放松大脑也呼吸新鲜空气，保持愉快的心情开始考试。情绪测试多选正面、积极、能吃苦、善于合作、理解他人、不随意发情绪等作为首选即可，例如有主见、有领导能力、有创新能力等在其他选项拿不准时可以作为最后选。\n\n**技术一面**\n\n过程很顺利，来到了技术一面。准备技术面可以看看八股文，参考一下最基本的问题应该怎么回答，同时也需要了解一下自己面试的部门或者岗位面试经常会遇到的问题或者知识点，机会总是留给有准备的人。例如我是面试的测试岗位，所以通过各种途径搜索测试岗位需要做什么，有什么面试常见问题，记下来并且能够对着镜子流畅的回答即可。\n\n技术一面的面试官相对比较和蔼，谈吐清晰，逻辑严谨。首先给了我一道题目做，题目是分糖果，应该是Leetcode的原题，题目有一些印象。在自己思考下很快解了出来，面试官也对代码提了一些意见。随后面试官问了我一些问题，包括\n\n1、 Python八股文\n\n2、 项目经历\n\n3、 项目中有没有遇到难的问题，如何解决\n\n4、 对测试的理解\n\n5、 自己所做项目中是否进行测试。如何理解这个过程中的测试\n\n6、 遇到意见不一致如何与团队沟通\n\n面试官非常注重对业务的考虑以及实际项目中团队的作用，当然技术能力不可或缺。总的来说准备好八股文，面试会轻松很多。\n\n**技术二面**\n\n技术二面面试官相对来说非常严肃，全程没有笑容，说话非常严谨认真，一看就是一个大佬，这着实让我担心不少。果然，一开始出了一个非常难的代码题目，写的我满头大汗，但是答案一直不正确。面试官看我迟迟答不上来，稍微提示了一下算法，我恍然大悟，在面试官的指导下还是顺利写出来了。\n\n随后，面试官问我有关简历的项目经历，提前准备好了当然轻松回答，但面试官说应该在参与项目中加入更多自己的思考，这个建议确实印象很深刻，很中的。然后围绕简历，面试官大致问了如下问题：\n\n1、 为什么选择面测试岗（本质在问什么是测试）？\n\n2、 测试项目的一般流程是什么？\n\n3、 有哪些常用的测试方法？\n\n4、 为什么要做自动化测试？\n\n5、 你认为一名优秀的测试应该有的品质是什么？\n\n这些都是测试常见问题，这些问题都很好的答上来了，面试官也表现出对答案的满意。最后，面试官问了有关Python测试的技术问题，我由于没有使用过相关框架，只能简要作答，好在面试官并没有在此处刁难深挖。\n\n**主管面**\n\n主管们首先自我介绍，主管围绕我项目进行展开，但是相对来说技术方面的问题少了很多，更多的是对我本人综合能力的考察，相关问题如下：\n\n1、 为什么选择测试岗（梅开二度，这次回答的更完整了，包含了心路历程）\n\n2、 考研二战，怎么做的决定？对二战失败的总结？\n\n3、 项目经历\n\n4、 项目中如何分工？\n\n5、 团队合作项目中印象最深刻的一件事\n\n6、 对od和华为文化的看法\n\n7、 学校中的兴趣爱好以及最成功的一件事情\n\n8、 对未来的规划以及想法\n\n9、 反问\n\n总的来说，问题更多围绕项目展开，对我所说项目内容进行延申来反映我的性格以及能力，在这个方面进行追加提问以及反思。准备的话可以围绕自己的能力以及价值展开，更多表现自己闪光点，围绕自己熟悉的地方进行展开发散。\n\n最后，非常推荐帮助我的靠谱HR，在此过程中帮助我很多，非常专业热情，会给予很多指导，整不停催进度使得整个流程很快完成，几乎没有停滞。HR非常上心，也很感谢他的指导。已经顺利上岸，目前工作非常顺利，与团队成员相处很好，氛围非常优秀！期待大家的加入！\n\n**最后打个广告，招录Java，python，C/C++，Js等主流软件开发，也招软件测试，可以私聊投递简历**\n\n## 主要地点： 东莞、深圳、杭州、 西安，长沙，上海，武汉，成都、南京、北京！\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595557098189049856?sourceSSR=users",
        "title": "螺旋数字矩阵 - 华为OD统一考试（C卷）",
        "content": "> OD统一考试（C卷）\n>\n> 分值： 100分\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n疫情期间，小明隔离在家，百无聊赖，在纸上写数字玩。他发明了一种写法:\n\n给出数字**个数n** 和**行数m** (0 < n <= 999，0 < m <= 999)，从左上角的1开始，按照**顺时针螺旋向内写**\n方式，依次写出2,3...n，最终形成一个m行矩阵。\n\n小明对这个矩阵有些要求:\n\n  1. 每行数字的个数一样多\n  2. 列的数量尽可能少\n  3. 填充数字时优先填充外部\n  4. 数字不够时，使用单个*号占位\n\n## 输入描述\n\n两个整数，空格隔开，依次表示n、m\n\n## 输出描述\n\n符合要求的唯一矩阵\n\n## 示例1\n\n    \n    \n    输入：\n    9 4\n    \n    输出：\n    1 2 3\n    * * 4\n    9 * 5\n    8 7 6\n    \n    说明：\n    9个数字写成4行，最少需要3列\n    \n\n## 示例2\n\n    \n    \n    输入：\n    3 5\n    \n    输出：\n    1\n    2\n    3\n    *\n    *\n    \n    说明：\n    3个数字写5行，只有一列，数字不够用*号填充\n    \n\n## 题解\n\n> 这是一个**模拟题** ，主要考察对矩阵的遍历和填充的能力。\n>\n>   1. 首先，通过输入获取数字个数n和行数m。\n>   2. 计算矩阵的列数cols，根据题意，最少需要的列数是(n-1) / m + 1。\n>   3. 初始化一个大小为m行cols列的矩阵，所有元素初始值为\"*\"。\n>   4. 使用四个变量top、bottom、left、right来表示当前矩阵的上下左右边界。\n>   5. 使用cur变量表示当前要填充的数字，从1开始。\n>   6. 进入循环，按照顺时针螺旋的方式依次填充矩阵的数字。\n>      * 从左到右：遍历当前行的左右范围，依次填充数字。\n>      * 从上到下：遍历当前列的上下范围，依次填充数字。\n>      * 从右到左：遍历当前行的右左范围，依次填充数字。\n>      * 从下到上：遍历当前列的下上范围，依次填充数字。\n>   7. 在每次填充后，更新相应的边界。\n>   8. 循环直到所有数字都填充完毕。\n>   9. 最后，输出填充好的矩阵。\n>\n\n>\n> 这样，通过模拟顺时针螺旋填充的过程，就能得到符合要求的矩阵。\n\n### Java\n\n    \n    \n    import java.util.Arrays;\n    import java.util.Scanner;\n    import java.util.stream.Collectors;\n    /**\n     * @author code5bug\n     */\n    public class Main {\n        public static void main(String[] args) {\n            Scanner in = new Scanner(System.in);\n            int n = in.nextInt(), m = in.nextInt();\n            int rows = m, cols = (n - 1) / m + 1;\n    \n            // grid[i][j] == 0 则认为数字不够为 *\n            int[][] grid = new int[rows][cols];\n    \n            // 上下左右，四侧的边界\n            int top = 0, bottom = rows - 1, left = 0, right = cols - 1;\n            int cur = 1;\n            while (cur <= n) {\n                // 从左到右\n                for (int i = left; i <= right && cur <= n; i++) {\n                    grid[top][i] = cur++;\n                }\n                if (++top > bottom) break; // 收缩范围\n    \n                // 从上到下\n                for (int i = top; i <= bottom && cur <= n; i++) {\n                    grid[i][right] = cur++;\n                }\n                if (--right < left) break; // 收缩范围\n    \n                // 从右到左\n                for (int i = right; i >= left && cur <= n; i--) {\n                    grid[bottom][i] = cur++;\n                }\n                if (--bottom < top) break; // 收缩范围\n    \n                // 从下到上\n                for (int i = bottom; i >= top && cur <= n; i--) {\n      \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595548894105276416?sourceSSR=users",
        "title": "越疆 | 测开 | 二面 | 0302",
        "content": "> ## 发面经 攒好运\n\n已拒\n\n主管面+hr面\n\n主管\n\n  1. 自我介绍\n  2. qt项目具体负责的模块\n  3. 在项目中遇到的问题\n  4. 如何进行开发？确定需求\n  5. 如何判断界面是符合需求的\n  6. 项目中通信协议是如何实现的\n  7. 如何判断接口设置的没问题\n  8. 有没有了解过其他机械臂厂家\n  9. 项目有没有值得改进的？\n  10. 为什么考雅思\n\nHR\n\n  1. 老师、同学对你的评价\n  2. 自己的优缺点\n  3. 为什么没有参加秋招\n  4. 未来还会考虑读博吗？\n  5. 高考多少分，最好的是哪一门？\n  6. 为什么选这个专业\n  7. 哪些经历是你觉得不满意的？重来一次你会怎么做？\n\n反问\n\n  1. 部门结构？技术栈？一个项目几个测试负责？\n  2. 试用期多长？如何考核？。。。6个月，说是每个月都有考核任务\n\n周六上午面的，应该是要996\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595548021081817088?sourceSSR=users",
        "title": "京东 | 测开 | 二面 | 0304",
        "content": "> 发面经 攒好运\n\n已挂\n\n  1. 自我介绍\n  2. 聊项目\n  3. 面试官自我介绍\n  4. linux命令：如何查看服务器上的log.txt文件中的user_id字段？\n  5. Linux：文件夹中如何查看最近被修改的文件。。head tail\n  6. 常用的STL容器？\n  7. 为什么要用容器中的数组？\n  8. vector和list的区别？\n  9. vector如何动态扩容？扩容机制\n  10. 如果vector元素非常多怎么办？\n  11. 测试问题：秒杀茅台如何测试？\n  12. 手撕：均分数组反问\n  13. 反问：技术栈和技能要求？\n\n"
    }
]