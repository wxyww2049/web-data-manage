[
    {
        "url": "https://www.nowcoder.com/discuss/599913580456079360?sourceSSR=users",
        "title": "一嗨租车 java一面 57min",
        "content": "一嗨租车一面 57min\n\n技术面一上来问期望薪资，我直接说\"15k就行了\"（乌鱼子）\n\n1.开源项目\n\n2.ribbon源码改了吗，更新ribbon缓存的方法\n\n3.nacos热更新配置实现方式\n\n4.RabbitMQ话题模式，如果队列要扩展怎么处理\n\n5.RabbitMQ容错方案\n\n6.jvm内存模型，常规八股（奏乐~）\n\n7.jvm相关问题，stop the world的触发场景，从垃圾收集器角度\n\n8.jvm调优经历，调堆（对nacos做jvm调优）\n\n9.Java程序里会调c++方法，当jvm打印堆栈异常信息时的局限性问题怎么处理（我真懵逼了）\n\n10.线程池“一键推送”缴费信息，线程池推这么多缴费信息怎么保证任务准确完成（实习里的业务场景，想问线程池做任务对其结果准确性的监测机制）\n\n11.有没有取代线程池的方案（太多了说不过来）\n\n12.docker、k8s水平（我说我电脑跑不起来k8s就没问k8s了）\n\n13.想要在docker容器和宿主机之间操作文件方式（我就说了个数据卷挂载，之后反正一直是他在装逼）\n\n14.docker常用指令（看似非常简单实则非常反应水平）\n\n15.为什么数组下标从0开始\n\n16.兴趣爱好，线下开发者活动\n\n17.反问\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599885673654476800?sourceSSR=users",
        "title": "字节商业化产品与技术一面",
        "content": "后端开发岗位，1h到点结束\n\n  1. 自我介绍\n  2. 讲一下简历上的写的项目\n  3. 遇到了哪些困难，怎么解决的\n  4. 为什么你会用到epoll\n  5. 讲一下IO多路复用\n  6. 和select、poll的区别\n  7. 上一段实习经历\n  8. 主要是负责什么\n  9. 遇到了哪些问题\n  10. 详细讲讲（博主把一个debug问题详细地讲了些）\n  11. 简历上一个Github作品链接\n  12. 做了些什么\n  13. 提到了b树，所以问数据库相关\n  14. Mysql的存储引擎\n  15. B+树和B树的区别\n  16. 为什么要用B+树\n  17. 最小堆/最大堆\n  18. 建堆过程\n  19. 调整和删除\n  20. 时间复杂度\n  21. 平衡二叉树和红黑树\n  22. 相比于普通二叉树为什么要用平衡二叉树\n  23. 相比于平衡二叉树为什么用红黑树\n  24. 讲讲红黑树？\n  25. 算法题\n  26. hot100中的二叉树右视图\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599874114614026240?sourceSSR=users",
        "title": "阿里云3.18最新实习后端面经解析：top 1的云难名不虚传",
        "content": "####\n嗨～我是可拟雀，一个后端开发工程师，毕业于某985大学，目前供职于bat某大厂核心部门后端。每天分享最新面经答案，希望在大环境不好的当下能帮到你，让你多积累面试经验。需要内推或者面经合集请评论哦。\n\n#### 讲一下map，讲一下HashMap吧\n\n答：Map是一种专门用来搜索的数据结构，它经常用来存放键值对。Map允许我们在查找的时候进行插入和删除操作，这使得它在处理这类任务时非常高效。Map的使用与其实例的子类有关，因此不同的Map实现可能会有不同的搜索效率。\n\nHashMap是Map接口的一个实现类，它主要适用于插入、删除和定位元素的操作。HashMap基于哈希表实现，它利用哈希函数（如hashCode()）将键（key）转化为数组的索引（index），然后根据这个索引来存储和查找键值对。这种机制使得HashMap在插入、删除和定位元素时具有非常高的效率。\n\n然而，HashMap并不保证键的顺序，也就是说，遍历HashMap可能会得到不同的顺序结果，除非在特定的构造器中进行排序。如果需要有序的遍历，那么可能会选择其他类型的Map，比如TreeMap。\n\n当不同的键通过哈希函数运算得到相同的索引时，就会发生哈希碰撞（或哈希冲突）。HashMap通过链表或红黑树（在Java\n8及以后的版本中，当链表长度超过一定阈值时，链表会转化为红黑树）来解决这种冲突，这种策略被称为拉链法。\n\n#### 你说到了链表长度为8的时候会转换为红黑树，为什么是8呢？\n\n答：当HashMap中的某个桶（bucket）的链表长度达到8时，会触发树化（treeifyBin）操作，将链表转换为红黑树。这是为了优化性能，因为红黑树的查找、插入和删除操作的时间复杂度都是O(log\nn)，而链表在长度较长时的这些操作的时间复杂度为O(n)。当桶中的元素数量较少时，链表操作已经足够高效，因此没有必要转换为红黑树。\n\n另外，链表长度超过8并不是唯一触发树化的条件。还有一个条件是桶的总数超过64。也就是说，如果HashMap中的桶的总数超过64，并且某个桶的链表长度达到8，那么链表就会转换为红黑树。这是为了避免过多的树化操作，因为红黑树的空间占用相对于链表来说要大一些。\n\n至于为什么选择8和64这两个数字，它们是通过实验和性能测试得出的经验值。这些值在大多数情况下都能提供较好的性能和空间使用效果。当然，具体的实现可能会因Java版本的不同而有所差异，但背后的设计思想和权衡是相似的。\n\n#### HashMap为什么线程不安全？\n\n答：扩容：当HashMap中的元素数量超过其容量时，会触发扩容操作。这个操作涉及到生成新的数组、重新计算原有键值对的位置，并写入新的数组。如果在多线程环境下，多个线程同时检测到需要扩容并尝试执行resize操作，这可能导致数据不一致、死循环或死锁。例如，某些线程可能已经完成赋值，而其他线程刚开始赋值，这样就可能用已经被赋值的table作为原始数组，从而导致问题。\n\nput和get操作的非原子性：在HashMap中，put和get操作并不是原子性的。这意味着在多线程环境下，一个线程可能正在执行put操作（包括计算哈希值、确定索引和存储键值对等步骤），而另一个线程可能同时执行get操作，这可能导致get到的值并不是最新的或者预期的值。\n\n删除操作的问题：当在HashMap中删除某个键值对时，实际上是删除了该键值对在内部数组中的对应位置。如果有多个线程同时尝试删除不同的键值对，它们可能会相互干扰，导致数据不一致。\n\n#### 线程池参数有哪些？\n\n答：线程池的参数主要包括以下几个方面：\n\ncorePoolSize：线程池中的常驻核心线程数。这些线程在创建线程池后就会立即启动，即使它们当前并没有任务执行。\n\nmaximumPoolSize：线程池能够容纳同时执行的最大线程数。当工作队列已满，并且正在执行的线程数达到这个值时，线程池就不会再创建新的线程。这个值必须大于等于1。\n\nkeepAliveTime：多余的空闲线程的存活时间。当线程池中的线程数超过corePoolSize，并且这些多余的线程在keepAliveTime这段时间内没有执行任务，那么它们就会被销毁，直到线程池中的线程数减少到corePoolSize为止。\n\nunit：keepAliveTime的单位，比如可以是TimeUnit.SECONDS、TimeUnit.MILLISECONDS等。\n\nworkQueue：任务队列。当线程池中的线程都在忙时，新提交的任务会存放在这个队列中等待执行。\n\nthreadFactory：线程工厂，用于创建新的线程。一般情况下，我们可以使用默认的线程工厂，但如果需要自定义线程的创建方式，比如设置线程名、设置线程优先级等，就需要使用自定义的线程工厂。\n\nhandler：拒绝策略。当队列已满，并且线程池中的线程数已达到maximumPoolSize时，如果还有新的任务提交，就需要根据这个策略来处理这个新任务。常见的拒绝策略有：直接抛出异常、使用调用者的线程来运行任务、丢弃这个任务、丢弃队列中最老的任务然后尝试提交新任务等。\n\n#### 怎么关闭线程池？\n\n答：在Java中，关闭线程池通常使用`ExecutorService`接口的`shutdown()`或`shutdownNow()`方法。`ExecutorService`是Java并发包（`java.util.concurrent`）中的一个关键接口，它定义了一系列用于管理线程池的方法。\n\n  1. shutdown() 方法：这个方法会启动线程池的关闭序列。线程池不再接受新的任务，但是会等待所有已提交的任务执行完毕。这是优雅地关闭线程池的方式，因为它确保所有任务都能得到执行。\n  2. shutdownNow() 方法：这个方法尝试立即停止所有正在执行的任务，停止处理正在等待的任务，并返回等待执行的任务列表。这个方法并不保证能立即停止所有任务，因为有些任务可能正在执行关键操作，不能被立即中断。使用shutdownNow()可能会导致一些任务未能正常完成。\n\n在调用`shutdown()`或`shutdownNow()`后，通常还会调用`awaitTermination()`方法来等待线程池中的所有任务都执行完毕或者超时。这可以确保在程序退出前线程池被正确关闭。\n\n一旦线程池被关闭，就不能再向其提交新任务。如果尝试在关闭后提交任务，将会抛出`RejectedExecutionException`异常。\n\n如果你使用的是`ScheduledThreadPoolExecutor`，它提供了`scheduleAtFixedRate`和`scheduleWithFixedDelay`等方法来执行定时任务。对于这类线程池，在关闭时也应该考虑正在等待执行的定时任务，并确保它们得到妥善处理。\n\n#### shutdownNow()为什么有些任务无法取消？\n\n答：`ExecutorService` 的 `shutdownNow()`\n方法尝试取消当前正在执行的任务和未开始执行的任务。它会返回一个包含尚未开始执行的任务列表，并尝试通过调用每个工作线程的\n`Thread.interrupt()` 方法来中断所有正在运行的任务。\n\n然而，任务是否能够被成功取消取决于任务自身对于中断机制的支持。在Java中，线程中断是一个协作机制，而不是强制终止。这意味着当一个线程接收到中断请求时（其\n`isInterrupted()` 方法返回\n`true`），线程本身需要检查这个中断标志并根据该标志来决定如何响应，通常是在适当的清理后退出循环或提前结束任务。\n\n如果一个正在运行的任务没有实现对中断的响应，或者任务中的某个阻塞操作（如 `Thread.sleep()`, `BlockingQueue.take()`\n等）不响应中断（有些阻塞方法可以响应中断并抛出InterruptedException），那么即使调用了\n`shutdownNow()`，该任务也可能无法立即停止执行。\n\n#### TreadLocal是干嘛的？原理是什么？\n\n答：`ThreadLocal` 是 Java\n中一个类，用于在多线程环境下为每个线程提供独立的变量副本。它主要用于解决多线程中的数据同步问题，确保每个线程都能访问到独立的数据，从而避免数据竞争和不一致的问题。\n\n`ThreadLocal` 的原理是基于线程本地存储（Thread Local Storage，简称 TLS）。每个线程都有一个独立的 TLS\n存储，用于存储该线程的局部变量。当一个线程访问 `ThreadLocal` 变量时，它会在自己的 TLS 存储中查找或创建该变量的副本。这样，不同线程之间的\n`ThreadLocal` 变量互不干扰，实现了线程隔离。\n\n`ThreadLocal` 的主要方法有：\n\n1\\. `set(T value)`：将指定值与当前线程的 `ThreadLocal` 变量关联。\n\n2\\. `get()`：返回当前线程的 `ThreadLocal` 变量的值。如果当前线程尚未设置值，则返回 `null`。\n\n3\\. `remove()`：移除当前线程的 `ThreadLocal` 变量的值。这可以防止内存泄漏，因为 `ThreadLocal`\n变量在线程结束后仍然存在。\n\n`ThreadLocal` 的使用场景包括：\n\n1\\. 数据库连接：在多线程环境下，每个线程都需要独立的数据库连接，以避免资源竞争。\n\n2\\. 用户会话管理：在 Web 应用中，每个用户请求都会创建一个新的线程，使用 `ThreadLocal` 可以为每个线程存储用户会话信息。\n\n3\\. 日志记录：在多线程环境下，可以使用 `ThreadLocal` 存储每个线程的日志记录器，以便在日志中记录线程相关的信息。\n\n#### ThreadLocal会导致什么问题？\n\n答：虽然 `ThreadLocal` 在多线程环境下为每个线程提供独立的变量副本，从而解决了数据同步问题，但在某些情况下，它也可能导致一些问题：\n\n1\\. 内存泄漏：`ThreadLocal` 变量在线程结束后仍然存在，如果没有正确地移除对应的值，可能会导致内存泄漏。在使用 `ThreadLocal`\n时，需要确保在不再需要变量时调用 `remove()` 方法，以释放资源。\n\n2\\. 线程池问题：在使用线程池的环境下，线程是被重用的。当一个线程从线程池中取出并执行任务时，可能会包含之前任务的 `ThreadLocal`\n变量值。这可能导致数据污染和不一致。为了避免这个问题，可以在任务执行完成后调用 `remove()` 方法清除 `ThreadLocal` 变量的值。\n\n3\\. 可读性和维护性：`ThreadLocal` 变量的作用域仅限于当前线程，这可能导致代码的可读性和维护性降低。在使用 `ThreadLocal`\n时，需要确保变量的作用域和使用方式清晰明了，以便于理解和维护。\n\n4\\. 性能问题：`ThreadLocal` 变量的访问速度可能比普通变量慢，因为它需要在线程的 TLS\n存储中查找和创建变量副本。在性能敏感的场景下，需要权衡 `ThreadLocal` 带来的便利性和性能影响。\n\n总之，虽然 `ThreadLocal`\n在多线程环境下提供了线程隔离的解决方案，但在使用过程中也需要注意潜在的问题，如内存泄漏、线程池问题、可读性和维护性以及性能问题。在适当的场景下使用\n`ThreadLocal`，可以提高代码的健壮性和可维护性。\n\nsynchronized 和 ReentrantLock 有什么区别？\n\n答：synchronized和ReentrantLock在Java中都是用于控制多线程访问同步资源的机制，但它们之间存在一些重要的区别。\n\n  1. **实现方式** ：synchronized是Java的关键字，是JVM级别的锁，其实现依赖于JVM。而ReentrantLock是Java提供的API，是Lock接口下的一个实现类，因此它位于API层面。\n  2. **锁的公平性** ：synchronized只能是非公平锁，而ReentrantLock可以指定为公平锁或非公平锁。公平锁会按照线程请求的顺序来获取锁，而非公平锁则允许插队现象。\n  3. **锁的灵活性** ：ReentrantLock提供了更多的功能，比如可以中断等待锁的线程，获取等待锁的线程列表，还可以尝试获取锁（通过tryLock方法）。相比之下，synchronized的灵活性较低。\n  4. **异常处理** ：synchronized在发生异常时会自动释放占有的锁，因此不会出现死锁。而ReentrantLock在发生异常时不会主动释放占有的锁，必须手动调用unlock方法来释放锁，否则可能引起死锁的发生。\n  5. **性能** ：在JDK1.6之后，synchronized的性能得到了很大优化，和ReentrantLock比较接近。然而，由于ReentrantLock提供了更多的功能和灵活性，因此在某些情况下，它可能提供更高的性能。\n  6. **锁的细粒度控制** ：ReentrantLock可以更精确的控制锁，提供了更丰富的锁操作方法，如可重入概念（一个线程可以多次获取同一个锁）等。\n\n#### ReentrantLock是怎么实现的？AQS？讲一下AQS？他是怎样获取锁的？\n\n答：`ReentrantLock` 是 Java 中一个可重入的互斥锁，它提供了与 `synchronized`\n关键字类似的功能，但具有更高的灵活性和扩展性。`ReentrantLock` 的底层实现是基于 Java 并发包中的\n`AbstractQueuedSynchronizer`（简称 AQS）框架。\n\nAQS 是 Java 并发包中的一个核心框架，它为实现基于 FIFO 队列的阻塞锁和相关同步器（如信号量、读写锁等）提供了一个框架。AQS\n的主要目标是简化同步器的实现，提供一种通用的基于 FIFO 队列的阻塞锁实现。\n\nAQS 的核心思想是将锁的获取和释放操作抽象为一个整数状态（state），通过维护一个 FIFO\n队列来管理等待获取锁的线程。当一个线程尝试获取锁时，如果锁已被其他线程持有，那么该线程会被加入到等待队列的尾部，并进入阻塞状态。当锁被释放时，等待队列的头部线程会被唤醒并尝试获取锁。\n\nAQS 提供了一些模板方法，如 `tryAcquire()`、`tryRelease()`、`tryAcquireShared()` 和\n`tryReleaseShared()`，这些方法需要子类根据具体的锁实现来实现。`ReentrantLock` 就是 AQS\n的一个子类，它实现了这些模板方法，以支持可重入的互斥锁功能。\n\n`ReentrantLock` 的获取锁的过程大致如下：\n\n1\\. 调用 `lock()` 方法尝试获取锁。\n\n2\\. 如果锁当前未被持有，那么调用 AQS 的 `tryAcquire()` 方法尝试获取锁。在 `ReentrantLock`\n的实现中，`tryAcquire()` 方法会检查当前线程是否已经持有锁，如果是，则增加锁的计数器；如果不是，则尝试获取锁。\n\n3\\. 如果 `tryAcquire()` 方法返回 `true`，表示成功获取锁，执行同步代码。\n\n4\\. 如果 `tryAcquire()` 方法返回 `false`，表示锁已被其他线程持有，那么当前线程会被加入到等待队列的尾部，并进入阻塞状态。\n\n5\\. 当锁被释放时，等待队列的头部线程会被唤醒并尝试获取锁。\n\n#### Semaphore和CountDownLatch有了解过吗？\n\n答：是的，我了解 `Semaphore` 和 `CountDownLatch`。它们都是 Java 并发包中的同步工具类，用于控制多个线程之间的协作和同步。\n\n  1. Semaphore：Semaphore 是一个计数信号量，用于控制同时访问特定资源的线程数量。它维护了一个许可集，线程可以通过调用 acquire() 方法来获取许可，如果许可已用完，线程将阻塞等待。线程可以通过调用 release() 方法来释放许可。Semaphore 可以用于限制资源的并发访问，例如限制数据库连接的数量。\n  2. CountDownLatch：CountDownLatch 是一个同步辅助类，用于在多个线程之间实现协作。它维护了一个计数器，当计数器减少到 0 时，所有等待的线程将被唤醒。CountDownLatch 提供了 countDown() 方法来减少计数器，提供了 await() 方法来等待计数器减少到 0。CountDownLatch 可以用于等待多个线程完成任务，然后执行后续操作。\n\n#### 讲一下Java有哪些IO模型\n\n答：Java 中涉及的IO模型主要指的是在处理输入输出操作时，Java API 提供的不同机制。以下是Java中常见的四种IO模型：\n\n  1. 阻塞式I/O（Blocking I/O, BIO）在传统的Java IO（java.io包）中，默认采用的是阻塞式I/O模型。当调用诸如InputStream.read()或OutputStream.write()等方法时，如果数据没有准备好或者缓冲区已满，则线程会一直阻塞，直到有数据可读或空间可写。\n  2. 非阻塞式I/O（Non-blocking I/O, NIO）Java NIO（java.nio包）提供了非阻塞式的通道和缓冲器进行数据传输。使用非阻塞模式时，调用read或write方法不会阻塞当前线程，而是立即返回一个状态值，例如“尚未准备好”或“已经完成”。NIO还引入了选择器（Selector），可以实现单个线程管理多个通道，并监控这些通道是否有就绪事件发生（如读就绪、写就绪等），从而实现I/O多路复用。\n  3. I/O多路复用（Multiplexing I/O）这是NIO中的一个特性，通过Selector组件能够同时监听多个Channel上的事件，当任何一个Channel准备好了进行读写操作时，Selector就会通知相应的应用程序。该模型特别适用于高并发场景下，一个线程可以同时管理大量连接，而不是为每个连接分配单独的线程。\n  4. 异步I/O（Asynchronous I/O, AIO）也称为Java New I/O 2 (NIO.2)，自Java 7开始提供，在java.nio.channels包下增加了新的异步通道类，如AsynchronousSocketChannel和AsynchronousServerSocketChannel。异步I/O允许应用程序发起一个I/O操作后立刻返回，不等待操作结果，而是在I/O操作完成后由操作系统回调通知Java应用完成状态。异步I/O不需要使用Selector来轮询就绪的通道，而是基于事件驱动和回调机制，从而更高效地利用系统资源。\n\n#### 你知道select和epoll有什么区别吗？\n\n答：select和epoll都是Linux下用于处理I/O操作的多路复用机制，但它们在多个方面存在显著的差异。\n\n首先，从I/O模型的角度来看，select使用轮询模型。这意味着，无论文件描述符是否活跃，select都会遍历所有的文件描述符集合。这种方式在处理大量文件描述符时效率较低，因为每次都需要检查所有的文件描述符。相比之下，epoll采用基于事件驱动的模型。它只会对活跃的文件描述符进行操作，通过回调函数进行处理，从而大大提高了效率。\n\n其次，两者的文件描述符数量限制也不同。对于select，其文件描述符数量被限制在1024左右。这在处理大量并发连接时可能会成为问题，需要使用fd_set多次扩展或者使用其他的多路复用技术。然而，epoll则没有这样的限制，它可以支持数万个文件描述符，因此非常适合处理高并发场景。\n\n此外，两者在触发方式上也存在差异。select和epoll对可读事件和可写事件的触发方式并不相同，具体细节会根据具体的使用场景和编程需求有所不同。\n\n#### 零拷贝有哪些实现方式？\n\n答：零拷贝是一种高效的数据传输技术，它可以将数据从内核空间直接传输到应用程序的内存空间中，从而减少数据传输过程中的额外拷贝。以下是一些常见的零拷贝实现方式：\n\n  1. sendfile：这是一种在网络传输中实现零拷贝的方式。sendfile() 是一种特殊的系统调用，它允许在内核空间和用户空间之间直接传输数据，避免了数据在内核和用户空间之间的额外拷贝。这在高性能的网络传输中非常有效。\n  2. mmap：mmap() 是另一种在文件传输中实现零拷贝的方式。它通过将文件映射到进程的地址空间，使得进程可以直接访问文件内容，而不需要经过中间缓冲区的拷贝。这样在文件读写时，数据可以直接在内核缓冲区和用户空间之间传输，从而实现零拷贝。\n  3. Direct I/O：Direct I/O 是一种在文件传输中实现零拷贝的方式，也称为直接IO或裸IO。它允许数据在磁盘和用户空间之间直接传输，避免了数据在内核和用户空间之间的额外拷贝，从而实现零拷贝。\n  4. splice：splice() 是一种在管道传输中实现零拷贝的方式。它允许将一个文件描述符的数据直接传输到另一个文件描述符，避免了数据在用户空间和内核空间之间的额外拷贝。\n  5. Netty：Netty是一个高性能的网络通信框架，它通过使用堆外内存（直接内存）和组合Buffer对象来实现零拷贝。此外，Netty还采用了sendfile机制进行文件传输，从而避免了传统通过循环write方式导致的内存拷贝问题。\n\n#### 用过Java哪些框架？springboot是用来解决什么问题的？spring呢？\n\n答：Java 的框架有很多种，其中一些比较流行的包括 Spring、Spring Boot、Hibernate、MyBatis、Struts、Spring\nMVC、Spring Security、Quartz、Apache Camel 等。这些框架各有不同的功能和用途，可以满足不同开发需求。\n\n  * Spring 是一个开源的 Java 应用开发框架，它提供了一整套的编程模型和工具，用于简化企业级应用的开发过程。Spring 框架的核心理念是依赖注入（Dependency Injection，简称 DI）和面向切面编程（Aspect-Oriented Programming，简称 AOP），它们有助于消除耦合，提高代码的可重用性和可维护性。\n  * Spring Boot 是 Spring 的一种优化和扩展，它简化了 Spring 应用的配置和部署过程，大大加速了开发周期。Spring Boot 提供了许多预设的默认配置，使得开发者能够更加快速地构建和运行应用程序。同时，Spring Boot 还支持微服务架构，易于扩展和维护。\n\nSpring Boot 主要用来解决以下问题：\n\n  1. 简化 Spring 应用的配置和部署过程，提高开发效率。\n  2. 提供预设的默认配置，使得开发者能够更加快速地构建和运行应用程序。\n  3. 支持微服务架构，易于扩展和维护。\n\n总的来说，Spring Boot 使得开发者能够更加专注于业务逻辑的实现，而无需过多关注底层的配置和管理。\n\n至于 Spring，它是一个开源的 Java 应用开发框架，提供了一整套的编程模型和工具，用于简化企业级应用的开发过程。Spring\n框架的核心理念是依赖注入（Dependency Injection，简称 DI）和面向切面编程（Aspect-Oriented Programming，简称\nAOP），它们有助于消除耦合，提高代码的可重用性和可维护性。Spring 框架广泛应用于各种企业级应用开发中，包括 Web\n开发、数据访问、事务管理、安全性、消息传递等。\n\n#### 说一下jvm内存区域划分\n\n答：Java 虚拟机（JVM）内存区域主要分为以下几个部分：\n\n  1. 堆（Heap）：堆是 JVM 内存中最大的一块区域，主要用于存放对象实例和数组。堆被所有线程共享，垃圾回收器（Garbage Collector）会定期回收堆中不再使用的对象，以释放内存空间。\n  2. 方法区（Method Area）：方法区用于存储已加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区也被所有线程共享。\n  3. 栈（Stack）：栈是一个线程私有的内存区域，用于存储局部变量、方法调用和基本类型数据。每个线程都有一个独立的栈，栈中的数据只能在当前线程中访问。栈的大小是有限的，当栈空间不足时，会抛出 StackOverflowError 异常。\n  4. 本地方法栈（Native Method Stack）：本地方法栈与栈类似，但用于存储 Java 本地方法（通过 JNI 调用的方法）的调用信息。本地方法栈也是线程私有的。\n  5. 程序计数器（Program Counter Register）：程序计数器是一个很小的内存区域，用于存储当前线程正在执行的字节码指令的地址。每个线程都有一个独立的程序计数器。\n\n#### 说一下本地方法栈和java虚拟机栈的关系\n\n答：Java虚拟机栈是线程私有的，其生命周期与线程相同。它主要描述的是Java方法执行的线程内存模型，每次方法调用的数据都是通过栈传递的。Java虚拟机栈中存储了被调用方法的局部变量和操作数栈。局部变量是方法内部定义的变量，只有该方法内部可以访问。而操作数栈则用于存储方法执行过程中的操作数。\n\n本地方法栈与虚拟机栈所发挥的作用非常相似，但有一些关键的区别。虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的本地（Native）方法服务。本地方法是用其他语言（如C/C++）编写的方法，在Java程序中通过JNI（Java\nNative\nInterface）来调用。本地方法栈由多个栈帧组成，每个栈帧保存了一个Native方法的执行状态，包括方法的局部变量、操作数栈、返回值等信息。\n\n本地方法栈也是线程私有的，并且在栈深度溢出或者拓展失败时，会抛出StackOverFlowError和OutOfMemoryError异常。值得注意的是，不是所有的JVM都支持本地方法，因为Java虚拟机规范并没有明确要求本地方法栈使用的语言、具体实现方式或数据结构等。\n\n#### 垃圾回收算法有哪些？\n\n答：垃圾回收（Garbage Collection，简称 GC）是 Java\n虚拟机（JVM）自动管理内存的一种机制，它会定期回收不再使用的对象，以释放内存空间。以下是一些常见的垃圾回收算法：\n\n  1. 标记-清除（Mark-Sweep）：标记-清除算法分为两个阶段。首先，垃圾回收器会遍历所有可达对象，将它们标记为“存活”。然后，垃圾回收器会遍历堆中的所有对象，将未被标记为“存活”的对象清除。这种算法的缺点是会产生内存碎片，导致内存利用率降低。\n  2. 复制（Copying）：复制算法将堆分为两个相等的区域，每次只使用其中一个区域。当这个区域的内存空间不足时，垃圾回收器会将存活的对象复制到另一个区域，然后清除当前区域的所有对象。这种算法的优点是不会产生内存碎片，但缺点是需要额外的内存空间来存储复制的对象。\n  3. 标记-整理（Mark-Compact）：标记-整理算法是标记-清除算法的改进版本。在标记阶段，垃圾回收器会遍历所有可达对象，将它们标记为“存活”。然后，垃圾回收器会将存活的对象向一端移动，从而减少内存碎片。最后，垃圾回收器会清除剩余的未被标记的对象。这种算法的优点是不会产生内存碎片，但缺点是需要额外的时间来移动存活的对象。\n  4. 分代收集（Generational Collection）：分代收集算法将堆划分为不同的代（Generation），如新生代（Young Generation）和老年代（Old Generation）。新生代中的对象存活时间较短，因此可以频繁地进行垃圾回收。老年代中的对象存活时间较长，因此垃圾回收的频率较低。分代收集算法通常结合了复制算法和标记-清除（或标记-整理）算法，以实现高效的垃圾回收。\n  5. 并行收集（Parallel Collection）：并行收集算法在多核处理器上进行垃圾回收，可以显著提高垃圾回收的速度。在并行收集过程中，多个线程会同时进行垃圾回收，从而减少垃圾回收的暂停时间。\n  6. 并发收集（Concurrent Collection）：并发收集算法允许垃圾回收和应用程序线程同时运行，从而减少垃圾回收对应用程序性能的影响。在并发收集过程中，垃圾回收器会在应用程序线程运行的同时进行垃圾回收，从而减少垃圾回收的暂停时间。\n\n#### 了解哪些最新的垃圾回收器？\n\n答：垃圾回收器是Java虚拟机（JVM）中用于自动管理内存的重要组件。随着JVM的不断发展和升级，垃圾回收器也在不断演进和创新。以下是一些较新的垃圾回收器及其特点：\n\n  1. G1（Garbage First）回收器：G1回收器是Java 7中引入的，旨在提供一种低暂停时间且高吞吐量的垃圾回收解决方案。G1回收器采用分代收集的思想，将堆划分为多个大小相等的区域，并根据对象的存活时间和分布情况动态调整回收策略。G1回收器通过并发标记-整理算法实现，能够在减少暂停时间的同时保持较高的吞吐量。\n  2. ZGC（Z Garbage Collector）：ZGC是Java 11中引入的一种实验性质的垃圾回收器，它的设计目标是实现极低的暂停时间，特别是在处理大型堆时。ZGC采用了全新的内存管理和回收算法，包括着色指针、读屏障和并发压缩等关键技术。ZGC目前仍在不断优化和改进中，未来有望成为主流的垃圾回收器之一。\n  3. Shenandoah GC：Shenandoah GC是另一款在Java 12中引入的实验性质的垃圾回收器，它的目标也是实现低延迟和高吞吐量的垃圾回收。Shenandoah GC采用了并发标记-清除算法，并通过多种优化手段减少了暂停时间和内存占用。Shenandoah GC还支持增量回收和并发压缩等功能，进一步提升了垃圾回收的性能和效率。\n\n#### MySQL有哪些锁？\n\n答：\n\n  1. **共享锁（Shared Locks，S锁）** ：允许事务读取一行数据。当一个事务为数据加上读锁后，其他事务只能对该数据加读锁，不能加写锁。直到所有读锁释放后，其他事务才能对数据加持写锁。\n  2. **排他锁（Exclusive Locks，X锁）** ：又称为写锁。当一个事务为数据加上写锁时，其他事务不能对其加上任何锁。\n  3. **记录锁（Record Locks）** ：锁定单个行记录。InnoDB存储引擎支持记录锁。\n  4. **间隙锁（Gap Locks）** ：锁定一个范围，但不包括记录本身。主要用于防止幻读（Phantom Reads）。\n  5. **临键锁（Next-Key Locks）** ：是记录锁和间隙锁的组合，它锁定一个记录以及该记录前的间隙。InnoDB存储引擎的默认锁定算法。\n  6. **表锁（Table Locks）** ：开销小，加锁快，但可能出现死锁。对整个表进行上锁，当下一个事务访问该表时，必须等待上一个事务释放了表锁才能访问。主要由MySQL Server实现，例如在DDL（数据定义语言）操作如ALTER时使用。\n  7. **页锁（Page Locks）** ：开销大于表锁但小于行锁，可能出现死锁。某些存储引擎如BDB可能使用页锁。\n  8. **意向锁（Intention Locks）** ：是一种表级别的锁，表示事务想要在行上或表上设置某种类型的锁。有两种意向锁：意向共享锁（IS）和意向排他锁（IX）。\n  9. **自增锁（AUTO-INC Locks）** ：当插入记录时，如果表中有自增字段，则可能需要自增锁来确保自增值的唯一性。\n\n#### 事务有哪些隔离级别\n\n答：\n\n  1. 读未提交（Read Uncommitted）：在这个隔离级别下，一个事务可以读取另一个事务尚未提交的数据。这种隔离级别可能导致脏读、不可重复读和幻读等问题。读未提交隔离级别的并发性能较高，但数据一致性较差。\n  2. 读已提交（Read Committed）：在这个隔离级别下，一个事务只能读取另一个事务已经提交的数据。这种隔离级别可以避免脏读问题，但仍然可能出现不可重复读和幻读等问题。读已提交隔离级别的并发性能较高，数据一致性相对较好。\n  3. 可重复读（Repeatable Read）：在这个隔离级别下，一个事务在执行过程中多次读取同一数据时，始终返回相同的结果。这种隔离级别可以避免脏读和不可重复读问题，但仍然可能出现幻读等问题。可重复读隔离级别的并发性能较低，数据一致性较好。\n  4. 串行化（Serializable）：在这个隔离级别下，事务之间会进行串行化处理，即一个事务在执行过程中，其他事务必须等待当前事务完成后才能执行。这种隔离级别可以避免脏读、不可重复读和幻读等问题，但并发性能较差，数据一致性最好。\n\n#### readview是干嘛的？\n\n答：`ReadView` 是一个在数据库管理系统（DBMS）中用于实现多版本并发控制（MVCC，Multi-Version Concurrency\nControl）的概念。MVCC 是一种用于解决事务并发问题的技术，它允许多个事务同时访问和操作数据，而不会互相干扰。在 MVCC\n中，每个事务都会看到一个特定版本的数据，这个版本是基于事务开始时的数据状态创建的。\n\n`ReadView` 在 MVCC 中起到了关键作用，它表示了一个事务在执行过程中看到的数据版本。`ReadView` 包含了以下信息：\n\n  1. **事务ID** ：当前事务的唯一标识符。\n  2. **快照时间** ：事务开始时的时间戳，用于确定事务开始时的数据状态。\n  3. **活跃事务列表** ：当前正在执行的事务列表，这些事务可能会对数据进行修改，因此需要在读取数据时考虑这些事务的影响。\n\n在 MVCC 中，当一个事务需要读取数据时，它会根据 `ReadView`\n中的信息来确定应该读取哪个版本的数据。这样，每个事务都可以在自己的事务上下文中看到一致的数据，而不会受到其他事务的影响。这种机制可以有效地解决脏读、不可重复读和幻读等并发问题，同时提高了数据库的并发性能。\n\n#### 除了可重复读就没别的地方使用readview了吗？\n\n答：\n\n  1. MVCC（多版本并发控制）：MySQL的InnoDB存储引擎使用了MVCC来实现事务的并发控制，Read View就是MVCC中的核心组件之一，无论在哪个事务隔离级别下，只要涉及到并发事务间的读写冲突处理，都可能会用到Read View。\n  2. Snapshot读取：在一些特定情况下，即使不是在“可重复读”的事务隔离级别下，也可能需要创建一个Read View来获取某个时间点的数据快照，以满足特定的一致性读取需求。\n  3. 数据库系统设计：在其他数据库系统或者分布式数据库的设计中，为了实现类似MVCC的功能，可能会借鉴并使用Read View这种机制来管理不同事务版本的数据可见性问题。\n\n#### ReadView的结构。这三个问题他都想引导我说undolog，没反应过来。\n\n答：ReadView在数据库管理系统中，特别是在MVCC（多版本并发控制）的上下文中，扮演着非常重要的角色。它主要用于在事务执行快照读操作时生成一个“读视图”，以确定哪些数据版本对当前事务是可见的。\n\nReadView的结构主要包括以下几个关键部分：\n\n  1. **活跃事务列表 (TRX_IDS)** : 这个列表记录了生成ReadView时刻系统中所有活跃的事务ID。每个事务在开启时都会被分配一个唯一的ID，这个ID在事务的整个生命周期内保持不变。这个列表是ReadView进行可见性判断的重要依据。\n  2. **最小活跃事务ID (TRX_ID_MIN)** : 这个值是活跃事务列表中的最小事务ID。它用于快速判断一个数据行版本是否在当前所有活跃事务之前被修改过。\n  3. **最大可能事务ID (TRX_ID_MAX)** : 这个值通常表示ReadView生成时刻系统尚未分配的下一个事务ID。它用于判断一个数据行版本是否在ReadView生成之后被修改过。\n  4. **其他可能的属性或信息** : 根据具体的实现和需要，ReadView可能还包含其他信息，比如创建时间、关联的数据库对象等。\n\n当进行select操作时，ReadView会根据数据行版本的事务ID与上述属性之间的关系来判断该数据行版本是否对当前事务可见：\n\n  * 如果数据行版本的事务ID小于TRX_ID_MIN，说明这个数据行版本在当前所有活跃事务之前就已经被修改，因此对当前事务是可见的。\n  * 如果数据行版本的事务ID大于或等于TRX_ID_MAX，说明这个数据行版本在ReadView生成之后才被修改，因此对当前事务是不可见的。\n  * 如果数据行版本的事务ID在TRX_ID_MIN和TRX_ID_MAX之间，那么还需要根据具体的事务隔离级别来进行进一步的判断。\n\n#### 宕机了，redolog是怎么保证持久性的？\n\n答：当数据库宕机时，redolog（redo log）是一种用于保证数据持久性的技术。Redolog\n是数据库管理系统（DBMS）在内存中维护的一个日志文件，用于记录对数据的修改操作。当数据库发生故障时，可以使用 redolog 来恢复丢失的数据。\n\nRedolog 的工作原理如下：\n\n  1. 当一个事务需要对数据进行修改时，DBMS 首先会将这个修改操作记录到 redolog 中。这个过程称为“写前日志”（Write-Ahead Logging，WAL）。\n  2. 然后，DBMS 会将修改操作应用到实际的数据文件中。这个过程称为“脏页刷新”（Dirty Page Flush）。\n  3. 当事务提交时，DBMS 会将 redolog 中的修改操作永久地保存到磁盘上的 redolog 文件中。这个过程称为“提交日志”（Commit Log）。\n  4. 如果数据库发生故障，DBMS 可以使用 redolog 文件中的信息来恢复丢失的数据。恢复过程包括以下几个步骤：a. 重做（Redo）：DBMS 会读取 redolog 文件中的修改操作，并将这些操作应用到数据文件上。这样可以恢复在故障发生时尚未完成的数据修改。b. 回滚（Undo）：如果有未提交的事务，DBMS 会根据 redolog 文件中的信息回滚这些事务的修改操作，以确保数据的一致性。\n\n通过这种方式，redolog 可以保证数据库在宕机后能够恢复到故障发生前的状态，从而实现了数据的持久性。此外，redolog\n还可以提高数据库的并发性能，因为它允许事务在不等待数据文件写入的情况下继续执行。\n\n#### binlog和redolog的区别？\n\n答：binlog（binary log）和 redolog（redo\nlog）都是数据库管理系统（DBMS）中用于实现数据持久性和事务处理的技术，但它们在功能和用途上有一些区别：\n\n  1. binlog：binlog 是 MySQL 数据库中的一种日志文件，用于记录对数据的修改操作。它主要用于数据库的复制和备份。binlog 记录了所有的数据修改操作，包括 INSERT、UPDATE、DELETE 等。binlog 的内容是以二进制格式存储的，因此称为“binary log”。binlog 的主要特点如下：它是逻辑日志，记录的是 SQL 语句的执行结果，而不是物理数据页的变化。它是在主服务器（Master）上生成的，用于实现数据库的主从复制。它可以用于数据库的备份和恢复。\n  2. redolog：redolog 是数据库管理系统（如 Oracle、SQL Server 等）中的一种日志文件，用于记录对数据的修改操作。它主要用于实现事务处理和数据持久性。redolog 记录了所有的数据修改操作，包括 INSERT、UPDATE、DELETE 等。redolog 的内容是以物理日志记录（Physical Log Record，PLR）的形式存储的，因此称为“redo log”。redolog 的主要特点如下：它是物理日志，记录的是物理数据页的变化，而不是 SQL 语句的执行结果。它是在数据库服务器上生成的，用于实现事务处理和数据持久性。它可以用于数据库的故障恢复。\n\n#### 如何实现binlog和redolog的同步？\n\n答：在数据库管理系统（DBMS）中，binlog 和 redolog 的同步是通过主从复制（Master-Slave\nReplication）来实现的。主从复制是一种将主服务器（Master）上的数据更新操作同步到从服务器（Slave）的技术。在 MySQL\n中，binlog 是实现主从复制的关键组件，而在其他数据库系统（如 Oracle、SQL Server 等）中，redolog 可能会扮演类似的角色。\n\n以下是实现 binlog 和 redolog 同步的基本步骤：\n\n  1. 配置主服务器：在主服务器上启用 binlog，并配置相关参数，如 binlog 文件的存储路径、文件名、日志格式等。\n  2. 配置从服务器：在从服务器上配置主服务器的信息，如主服务器的 IP 地址、端口、用户名和密码等。\n  3. 启动主从复制：在从服务器上启动主从复制进程，通常称为“I/O 线程”和“SQL 线程”。I/O 线程负责从主服务器获取 binlog 数据，而 SQL 线程负责将获取到的 binlog 数据应用到从服务器上。\n  4. 同步 binlog：当主服务器上有数据更新操作时，binlog 会记录这些操作。I/O 线程会将这些操作从主服务器获取到从服务器。\n  5. 应用 redolog：在从服务器上，SQL 线程会将获取到的 binlog 数据应用到从服务器的数据文件上。这个过程可能涉及到 redolog 的使用，具体取决于从服务器所使用的数据库系统。\n  6. 监控和管理：在主从复制过程中，可以使用一些监控和管理工具来监控复制状态、延迟等信息，并在需要时进行故障切换和其他操作。\n\n#### 讲一下zookeeper的底层原理\n\n答：Zookeeper的底层原理主要涉及数据状态管理、集群扩展性、可靠性以及分布式算法的应用。\n\nZookeeper的数据状态不是保存在内存中，而是使用磁盘来保存日志。这种设计有助于确保数据的持久性和可恢复性。\n\nZookeeper的集群扩展性是通过设计不同的节点角色来实现的。其中，Observer节点主要是为了放大查询能力而设计的，它并不参与写操作。这种设计可以使得查询操作在多个节点上并行进行，从而提高系统的查询能力。\n\n在可靠性方面，Zookeeper具有快速恢复leader的能力。当一个leader节点挂掉，且没有新的leader节点确定时，Zookeeper集群会暂停对外提供服务，以防止错误的数据被提供给客户端。这种设计保证了系统的高可用性。此外，Zookeeper底层使用了Paxos算法和Zab广播算法，这两种算法都是分布式系统中常用的算法，它们保证了在分布式环境下数据的正确性和可靠性。\n\nZookeeper的底层原理还包括其独特的数据结构。Zookeeper采用树形结构，每个子目录项如NameService都被称作为znode（目录节点）。与文件系统类似，用户可以自由地增加、删除znode，以及在一个znode下增加、删除子znode。但与文件系统不同的是，znode是可以存储数据的，并且会传递节点的数据变化。\n\n#### 除了ZAB，还知道哪些分布式一致性协议？\n\n答：\n\n  1. Paxos：由Leslie Lamport在1990年提出的一种分布式一致性算法，用于解决分布式系统中的一致性问题，包括选举、数据复制等。\n  2. Raft：由Diego Ongaro和John Ousterhout在2013年提出的一种更易理解和实现的分布式一致性算法，与Paxos类似，但提供了更清晰的领导者选举机制和日志复制算法。\n  3. Viewstamped Replication：一种由Barbara Liskov和Brian Oki于1998年提出的一致性算法，用于实现分布式系统中的状态机复制。\n  4. Multi-Paxos：基于Paxos算法的扩展，用于在分布式系统中执行多个命令序列。\n  5. EPaxos：一种高效的基于Paxos的分布式一致性算法，用于支持分布式数据库系统等高性能应用。\n\n这些算法在不同的分布式系统中发挥着重要作用，用于确保数据的一致性、可靠性和可用性。\n\n#### 说一下你对最终一致性和强一致性的理解\n\n答：最终一致性和强一致性是分布式系统中两种不同的一致性模型。它们在数据一致性、性能和可用性等方面有不同的权衡。\n\n  1. 最终一致性：最终一致性是一种弱一致性模型，它允许在一段时间内系统中的数据存在不一致的状态，但最终所有节点上的数据都会达到一致的状态。最终一致性的优点是它可以提供较高的性能和可用性，因为它允许在不同节点上进行并发读写操作，而不需要等待所有节点达成一致。最终一致性的缺点是它可能导致数据的不一致，因此在某些场景下可能不适用。\n  2. 强一致性：强一致性是一种强一致性模型，它要求在任何时刻，所有节点上的数据都必须保持一致。强一致性的优点是它可以确保数据的一致性，避免数据不一致的问题。强一致性的缺点是它可能导致性能和可用性的降低，因为在进行数据更新操作时，所有节点都需要等待其他节点达成一致，从而增加了系统的延迟。\n\n#### 手撕 lc287 寻找重复数\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599898197149970432?sourceSSR=users",
        "title": "慧策（掌上先机）java一面 1h17min",
        "content": "1.自我介绍\n\n2.开源项目\n\n3.MQ消息保证不丢失\n\n4.分布式全局唯一id生成，并发场景，长度问题\n\n5.防止用户重复下单机制\n\n6.反射，破坏单例怎么预防\n\n7.反射耗性能，Spring怎么处理的\n\n8.SpringBean三级缓存加载流程\n\n9.Jvm双亲委派模型，如何打破双亲委派\n\n10.Jvm上面遇到过的问题\n\n11.mysql事务以及事务实现\n\n12.mysql索引结构，索引类型\n\n13.abcdef字段分别选取部分字段建联合索引，写SQL走索引\n\n14.SQL优化经历\n\n15.mysql事务，事务失效的场景\n\n16.Redis数据双写一致性\n\n17.Redis数据过期策略\n\n18.多线程通信方式\n\n19.synchronized锁升级\n\n20.写SQL\n\n21.写算法\n\n22.反问环节\n\nso easy 约了二面\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599749573984219136?sourceSSR=users",
        "title": "小米嵌入式软件实习笔试编程题",
        "content": "**《嵌入式软件开发笔试与面试手册》**\n：[https://blog.nowcoder.net/zhuanlan/jvN8gj](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgw-c.nowcoder.com%2Fapi%2Fsparta%2Fjump%2Flink%3Flink%3Dhttps%253A%252F%252Fgw-c.nowcoder.com%252Fapi%252Fsparta%252Fjump%252Flink%253Flink%253Dhttps%25253A%25252F%25252Fgw-c.nowcoder.com%25252Fapi%25252Fsparta%25252Fjump%25252Flink%25253Flink%25253Dhttps%2525253A%2525252F%2525252Fgw-c.nowcoder.com%2525252Fapi%2525252Fsparta%2525252Fjump%2525252Flink%2525253Flink%2525253Dhttps%252525253A%252525252F%252525252Fgw-c.nowcoder.com%252525252Fapi%252525252Fsparta%252525252Fjump%252525252Flink%252525253Flink%252525253Dhttps%25252525253A%25252525252F%25252525252Fgw-c.nowcoder.com%25252525252Fapi%25252525252Fsparta%25252525252Fjump%25252525252Flink%25252525253Flink%25252525253Dhttps%2525252525253A%2525252525252F%2525252525252Fgw-c.nowcoder.com%2525252525252Fapi%2525252525252Fsparta%2525252525252Fjump%2525252525252Flink%2525252525253Flink%2525252525253Dhttps%252525252525253A%252525252525252F%252525252525252Fgw-c.nowcoder.com%252525252525252Fapi%252525252525252Fsparta%252525252525252Fjump%252525252525252Flink%252525252525253Flink%252525252525253Dhttps%25252525252525253A%25252525252525252F%25252525252525252Fgw-c.nowcoder.com%25252525252525252Fapi%25252525252525252Fsparta%25252525252525252Fjump%25252525252525252Flink%25252525252525253Flink%25252525252525253Dhttps%2525252525252525253A%2525252525252525252F%2525252525252525252Fgw-c.nowcoder.com%2525252525252525252Fapi%2525252525252525252Fsparta%2525252525252525252Fjump%2525252525252525252Flink%2525252525252525253Flink%2525252525252525253Dhttps%252525252525252525253A%252525252525252525252F%252525252525252525252Fgw-c.nowcoder.com%252525252525252525252Fapi%252525252525252525252Fsparta%252525252525252525252Fjump%252525252525252525252Flink%252525252525252525253Flink%252525252525252525253Dhttps%25252525252525252525253A%25252525252525252525252F%25252525252525252525252Fgw-c.nowcoder.com%25252525252525252525252Fapi%25252525252525252525252Fsparta%25252525252525252525252Fjump%25252525252525252525252Flink%25252525252525252525253Flink%25252525252525252525253Dhttps%2525252525252525252525253A%2525252525252525252525252F%2525252525252525252525252Fgw-c.nowcoder.com%2525252525252525252525252Fapi%2525252525252525252525252Fsparta%2525252525252525252525252Fjump%2525252525252525252525252Flink%2525252525252525252525253Flink%2525252525252525252525253Dhttps%252525252525252525252525253A%252525252525252525252525252F%252525252525252525252525252Fgw-c.nowcoder.com%252525252525252525252525252Fapi%252525252525252525252525252Fsparta%252525252525252525252525252Fjump%252525252525252525252525252Flink%252525252525252525252525253Flink%252525252525252525252525253Dhttps%25252525252525252525252525253A%25252525252525252525252525252F%25252525252525252525252525252Fgw-c.nowcoder.com%25252525252525252525252525252Fapi%25252525252525252525252525252Fsparta%25252525252525252525252525252Fjump%25252525252525252525252525252Flink%25252525252525252525252525253Flink%25252525252525252525252525253Dhttps%2525252525252525252525252525253A%2525252525252525252525252525252F%2525252525252525252525252525252Fgw-c.nowcoder.com%2525252525252525252525252525252Fapi%2525252525252525252525252525252Fsparta%2525252525252525252525252525252Fjump%2525252525252525252525252525252Flink%2525252525252525252525252525253Flink%2525252525252525252525252525253Dhttps%252525252525252525252525252525253A%252525252525252525252525252525252F%252525252525252525252525252525252Fgw-c.nowcoder.com%252525252525252525252525252525252Fapi%252525252525252525252525252525252Fsparta%252525252525252525252525252525252Fjump%252525252525252525252525252525252Flink%252525252525252525252525252525253Flink%252525252525252525252525252525253Dhttps%25252525252525252525252525252525253A%25252525252525252525252525252525252F%25252525252525252525252525252525252Fgw-c.nowcoder.com%25252525252525252525252525252525252Fapi%25252525252525252525252525252525252Fsparta%25252525252525252525252525252525252Fjump%25252525252525252525252525252525252Flink%25252525252525252525252525252525253Flink%25252525252525252525252525252525253Dhttps%2525252525252525252525252525252525253A%2525252525252525252525252525252525252F%2525252525252525252525252525252525252Fblog.nowcoder.net%2525252525252525252525252525252525252Fzhuanlan%2525252525252525252525252525252525252FjvN8gj)\n\n**《软件开发笔试汇总》**\n：[https://blog.nowcoder.net/zhuanlan/0oDWVm](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.nowcoder.net%2Fzhuanlan%2F0oDWVm)\n\n偏爱的字符\n\n题目描述：\n\n小李天生偏爱一些字符，对于一个字符串，他总是想把字符串中的字符变成他偏爱的那些字符。如果字符串中某个字符不是他所偏爱的字符，称为非偏爱字符，那么他会将该非偏爱字符替换为字符串中距离该字符最近的一个偏爱的字符。这里的距离定义即为字符在字符串中的对应下标之差的绝对值。如果有不止一个偏爱的字符距离非偏爱字符最近，那么小李会选择最左边的那个偏爱字符来替换该非偏爱字符，这样就保证了替换后的字符串是唯一的。小李的所有替换操作是同时进行的。\n\n假定小李有m个偏爱的字符，依次为c1,c2...cm，当小李看到一个长度为n的字符串s时，请你输出小李在进行全部替换操作后形成的字符串。\n\n输入描述\n\n第一行输入两个正整数n，m。\n\n接下来一行输入m个字符c1,c2...cm，每两个字符之间用空格隔开，表示小李偏爱的字符。\n\n接下来一行输入一个字符串s。\n\n1≤n≤100000，1≤m≤26，保证题目中所有的字符均为大写字符，小李偏爱的字符互不相同，且偏爱字符至少出现一次。\n\n输出描述\n\n输出一行字符串，表示小李将给定的字符串s替换后形成的字符串。\n\n样例输入\n\n12 4\n\nZ G B A\n\nZQWEGRTBYAAI\n\n样例输出\n\nZZZGGGBBBAAA\n\n提示\n\n字符Q为非偏爱字符，且偏爱字符Z距离它最近，所以替换成Z；同理E距离G最近，替换成G；\n\n对于字符W，偏爱字符Z和G与其距离相同，所以替换为左边的Z；\n\n.......\n\n对于字符 I ，右边没有偏爱字符，左边第一个偏爱字符是A，所以替换成字符A。\n\n同一个偏爱字符可能会在字符串中出现多次。\n\n    \n    \n    #include <iostream>\n    #include <vector>\n    #include <unordered_set>\n    #include <algorithm>\n    #include <limits>\n    #include <string>\n    \n    using namespace std;\n    \n    int main() {\n        int n, m;\n        cin >> n >> m;\n        \n        string loves;\n        cin.ignore();\n        getline(cin, loves);\n        unordered_set<char> loves_set(loves.begin(), loves.end());\n        \n        string inputs;\n        getline(cin, inputs);\n        \n        vector<int> loves_indexes;\n        for (int i = 0; i < inputs.length(); ++i) {\n            if (loves_set.find(inputs[i]) != loves_set.end()) {\n                loves_indexes.push_back(i);\n            }\n        }\n        \n        for (int i = 0; i < inputs.length(); ++i) {\n            if (loves_set.find(inputs[i]) == loves_set.end()) {\n                auto lower = lower_bound(loves_indexes.begin(), loves_indexes.end(), i);\n                int l_index = (lower != loves_indexes.begin()) ? *(--lower) : numeric_limits<int>::min();\n                auto upper = upper_bound(loves_indexes.begin(), loves_indexes.end(), i);\n                int r_index = (upper != loves_indexes.end()) ? *upper : numeric_limits<int>::max();\n                \n                if (i - l_index <= r_index - i) {\n                    inputs[i] = inputs[l_index];\n                } else {\n                    inputs[i] = inputs[r_index];\n                }\n            }\n        }\n        \n        cout << inputs << endl;\n        \n        return 0;\n    }\n    \n    \n\n小明打砖块\n\n题目描述：\n\n小明在玩一个消除游戏。这个消除游戏有点特别。游戏中，你会得到n个一维排列的有各自颜色的砖块。\n\n消除的时候，你有三种消除方案。你可以单消一个砖块，这样你可以得到a的得分；如果两个颜色一样的砖块在一起，你可以将这两个砖块一起消除获得b的得分；如果三个颜色一样的砖块在一期，你可以将这三个砖块一起消除获得c的得分。\n\n消除后，被消除的砖块自动消失，被消除砖块的左右两端的砖块将在消除之后挨在一起。\n\n小明想知道在最优策略下他能得到多少得分。\n\n输入描述\n\n第一行4个整数n，a，b，c，表示砖块数量，和一消/二消/三消的得分。\n\n接下来一行n个整数，第i个整数si表示第i个砖块的颜色。\n\n输出描述\n\n输出最高得分\n\n样例输入\n\n8 1 3 7\n\n3 1 3 1 3 2 2 3\n\n样例输出\n\n14\n\n提示\n\n1≤si≤n≤300，0≤a,b,c≤10000\n\n    \n    \n    #include <iostream>\n    #include <vector>\n    #include <map>\n    #include <tuple>\n    #include <algorithm>\n    \n    using namespace std;\n    \n    int a, b, c;\n    vector<int> blocks;\n    map<pair<int, int>, int> memo;\n    \n    int dfs(int i, int j) {\n        if (i >= j)\n            return i > j ? 0 : a;\n    \n        auto key = make_pair(i, j);\n        if (memo.find(key) != memo.end())\n            return memo[key];\n    \n        int ans = max(dfs(i+1, j), dfs(i, j-1)) + a;\n        if (blocks[i] == blocks[j])\n            ans = max(ans, b + dfs(i+1, j-1));\n    \n        for (int k = i+1; k < j; ++k) {\n            if (blocks[i] == blocks[k] && blocks[k] == blocks[j])\n                ans = max(ans, dfs(i+1, k-1) + dfs(k+1, j-1) + c);\n        }\n    \n        memo[key] = ans;\n        return ans;\n    }\n    \n    int main() {\n        int n;\n        cin >> n >> a >> b >> c;\n        blocks.resize(n);\n        for (int i = 0; i < n; ++i)\n            cin >> blocks[i];\n    \n        cout << dfs(0, n-1) << endl;\n        return 0;\n    }\n    \n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599746145140699136?sourceSSR=users",
        "title": "美团 前端&客户端一面",
        "content": "总共 45min\n\n  1. 自我介绍\n  2. 项目介绍\n  3. 问项目——问的挺深，有一些不会被挖出来，比如 (1) SDK 调用，bugly 的原理等等 (2) 使用 xxx 框架的原因 (3) JNI 层调用的原理（这里不会\n  4. Hashmap 的原理（基本必问\n  5. 有没有用到过多线程？进程是什么？\n  6. TCP/IP 网络架构，和七层的区别\n  7. Tcp、UDP、HTTP 的区别和应用场景\n  8. https、http1.0、1.1、2.0、3.0（问到 3.0 和 2.0 的区别） 算法：二分排序 反问：业务主要做什么、实习生工作和正式员工的区别、对实习生的期待\n\n除了几个很底层的基本都很简单。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599741606958231552?sourceSSR=users",
        "title": "美团笔试 美团实习 0415",
        "content": "**笔试时间：2023年04月15日**\n\n# 第一题\n\n### 题目：字符串的前缀\n\n现在有两个字符串S和T，你需要对S进行若干次操作，使得S是T的一个前缀（空串也是一个前缀）。每次操作可以修改S的一个字符，或者删除一个S末尾的字符。小团需要写一段程序，输出最少需要操作的次数。\n\n### 输入描述\n\n第一行一个正整数C，表示数据组数；\n\n对于每一组数据输入两行仅包含小写字母的字符串S和T。\n\n### 输出描述\n\n对于每一组数据，输出一个整数，表示最少需要操作的次数。\n\n### 样例输入\n\n> 2\n>\n> aba\n>\n> abb\n>\n> abcd\n>\n> efg\n\n### 样例输出\n\n> 1\n>\n> 4\n\n**提示：**\n\n第一组数据，可以修改最后一个字母，使得S=abb，是T的一个前缀；第二组数据，需要将S整个串删除，操作次数为4。\n\n### 参考题解\n\nC++：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    #include <iostream>\n    #include <string>\n    using namespace std;\n    \n    int main() {\n        int C;\n        cin >> C;\n        cin.ignore(); // Ignore the newline after reading C\n    \n        for (int i = 0; i < C; ++i) {\n            string S, T;\n            getline(cin, S);\n            getline(cin, T);\n    \n            int res = 0;\n            int pos = 0;\n    \n            if (S.length() > T.length()) {\n                res = S.length() - T.length();\n                pos = T.length() - 1;\n            } else {\n                pos = S.length() - 1;\n            }\n    \n            bool flag = false;\n    \n            while (pos >= 0) {\n                if (!flag) {\n                    if (S[pos] == T[pos]) {\n                        flag = true;\n                    } else {\n                        res++;\n                    }\n                } else {\n                    if (S[pos] != T[pos]) {\n                        res++;\n                    }\n                }\n    \n                pos--;\n            }\n    \n            cout << res << endl;\n        }\n    \n        return 0;\n    }\n    \n\nJava：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    import java.util.Scanner;\n    \n    public class Main {\n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            int C = scanner.nextInt();\n            scanner.nextLine(); // Consume newline\n    \n            for (int i = 0; i < C; ++i) {\n                String S = scanner.nextLine();\n                String T = scanner.nextLine();\n    \n                int res = 0;\n                int pos = 0;\n    \n                if (S.length() > T.length()) {\n                    res = S.length() - T.length();\n                    pos = T.length() - 1;\n                } else {\n                    pos = S.length() - 1;\n                }\n    \n                boolean flag = false;\n    \n                while (pos >= 0) {\n                    if (!flag) {\n                        if (S.charAt(pos) == T.charAt(pos)) {\n                            flag = true;\n                        } else {\n                            res++;\n                        }\n                    } else {\n                        if (S.charAt(pos) != T.charAt(pos)) {\n                            res++;\n                        }\n                    }\n    \n                    pos--;\n                }\n    \n                System.out.println(res);\n            }\n        }\n    }\n    \n\nPython：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    C = int(input())\n    for _ in range(C):\n        S = input()\n        T = input()\n        res, pos = 0, 0\n        if len(S) > len(T):\n            res = len(S) - len(T)\n            pos = len(T) - 1\n        else:\n            pos = len(S) - 1 \n        flag = False\n        while pos >= 0:\n            if not flag:\n                if S[pos] == T[pos]:\n                    flag = True\n                else:\n                    res += 1\n            else:\n                if S[pos] != T[pos]: res += 1\n            pos -= 1\n        print(res)\n    \n\n# 第二题\n\n### 题目：小美分糖\n\n某一天，小美从商店买了两种糖果，分别买了a个和b个，要分给班上n个小朋友。为了不浪费，每块糖果都得恰好分到一个小朋友。另外，两种糖果一起吃的话味道其实并不好，所以每一个小朋友都只能得到其中一种糖果。小美希望分得最少糖果的那个小朋友能得到尽量多的糖果。小美的任务是求得这个数量是多少。\n\n### 输入描述\n\n第一行一个正整数T，表示有T组数据。\n\n对于每一组数据，输入一行n,a,b，中间用空格隔开。\n\n1≤a,b≤10000,  2≤n≤a+b, 1≤T≤100\n\n### 输出描述\n\n对于每一组数据，输出仅一行一个整数，表示答案。\n\n### 样例输入\n\n> 2\n>\n> 5 2 3\n>\n> 4 7 10\n\n### 样例输出\n\n> 1\n>\n> 3\n\n**提示：**\n\n第一组数据，每个小朋友都恰好分得一个糖果；第二组数据，可以分成：（3个第一种，4个第一种，5个第二种，5个第二种），这样第一个小朋友分得最少，没有其他方案使得分得最少的那个小朋友的糖果数量更大。\n\n### 参考题解\n\n二分答案。\n\nC++：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    #include <iostream>\n    using namespace std;\n    \n    bool check(long long x, long long n, long long a, long long b) {\n        long long r1 = min(a, b);\n        long long r2 = max(a, b);\n        long long cnt = 1;\n        r2 -= x;\n        cnt += (r2 / x) + (r1 / x);\n        return cnt >= n;\n    }\n    \n    int main() {\n        int T;\n        cin >> T;\n    \n        for (int t = 0; t < T; ++t) {\n            long long n, a, b;\n            cin >> n >> a >> b;\n    \n            long long l = 0;\n            long long r = max(a, b);\n    \n            while (l < r) {\n                long long mid = (l + r + 1) >> 1;\n                if (check(mid, n, a, b)) {\n                    l = mid;\n                } else {\n                    r = mid - 1;\n                }\n            }\n    \n            cout << r << endl;\n        }\n    \n        return 0;\n    }\n    \n    \n\nJava：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    import java.util.Scanner;\n    \n    public class Main {\n        public static boolean check(long x, long n, long a, long b) {\n            long r1 = Math.min(a, b);\n            long r2 = Math.max(a, b);\n            long cnt = 1;\n            r2 -= x;\n            cnt += (r2 / x) + (r1 / x);\n            return cnt >= n;\n        }\n    \n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            int T = scanner.nextInt();\n    \n            for (int t = 0; t < T; ++t) {\n                long n = scanner.nextLong();\n                long a = scanner.nextLong();\n                long b = scanner.nextLong();\n    \n                long l = 0;\n                long r = Math.max(a, b);\n    \n                while (l < r) {\n                    long mid = (l + r + 1) >> 1;\n                    if (check(mid, n, a, b)) {\n                        l = mid;\n                    } else {\n                        r = mid - 1;\n                    }\n                }\n    \n                System.out.println(r);\n            }\n        }\n    }\n    \n\nPython：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    T = int(input())\n    \n    for _ in range(T):\n        n, a, b = map(int, input().strip().split(\" \"))\n        def check(x):\n            r1, r2 = min(a,b), max(a,b)\n            cnt = 1\n            r2 -= x\n            cnt += (r2 //x) + (r1 //x) \n            '''一个人分x  其他人x+1， 如果可以就ok'''\n            return cnt >= n\n            \n                \n        l, r = 0, max(a,b)\n        while l < r:\n            mid = (l + r + 1) >> 1\n            if check(mid):l = mid\n            else:  r = mid - 1\n        print(r)\n    \n\n# 第三题\n\n### 题目：交通规则\n\nA国有n个城市，这n个城市排成一列，依次编号为1,2,3,...,n。一开始，这n座城市之间都没有任何交通路线，于是政府打算修建一些铁路来进行交通规划。接下来T天，每一天会进行如下操作的其中一种：-\n“L x”：表示编号为 x 的城市与其左边的城市之间修建一条铁路。如果 x 左边没有城市或者已经修建了铁路，则无视该操作；- “R x”：表示编号为\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599747600354390016?sourceSSR=users",
        "title": "美团嵌入式软件实习笔试编程题",
        "content": "**《嵌入式软件开发笔试与面试手册》**\n：[https://blog.nowcoder.net/zhuanlan/jvN8gj](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgw-c.nowcoder.com%2Fapi%2Fsparta%2Fjump%2Flink%3Flink%3Dhttps%253A%252F%252Fgw-c.nowcoder.com%252Fapi%252Fsparta%252Fjump%252Flink%253Flink%253Dhttps%25253A%25252F%25252Fgw-c.nowcoder.com%25252Fapi%25252Fsparta%25252Fjump%25252Flink%25253Flink%25253Dhttps%2525253A%2525252F%2525252Fgw-c.nowcoder.com%2525252Fapi%2525252Fsparta%2525252Fjump%2525252Flink%2525253Flink%2525253Dhttps%252525253A%252525252F%252525252Fgw-c.nowcoder.com%252525252Fapi%252525252Fsparta%252525252Fjump%252525252Flink%252525253Flink%252525253Dhttps%25252525253A%25252525252F%25252525252Fgw-c.nowcoder.com%25252525252Fapi%25252525252Fsparta%25252525252Fjump%25252525252Flink%25252525253Flink%25252525253Dhttps%2525252525253A%2525252525252F%2525252525252Fgw-c.nowcoder.com%2525252525252Fapi%2525252525252Fsparta%2525252525252Fjump%2525252525252Flink%2525252525253Flink%2525252525253Dhttps%252525252525253A%252525252525252F%252525252525252Fgw-c.nowcoder.com%252525252525252Fapi%252525252525252Fsparta%252525252525252Fjump%252525252525252Flink%252525252525253Flink%252525252525253Dhttps%25252525252525253A%25252525252525252F%25252525252525252Fgw-c.nowcoder.com%25252525252525252Fapi%25252525252525252Fsparta%25252525252525252Fjump%25252525252525252Flink%25252525252525253Flink%25252525252525253Dhttps%2525252525252525253A%2525252525252525252F%2525252525252525252Fgw-c.nowcoder.com%2525252525252525252Fapi%2525252525252525252Fsparta%2525252525252525252Fjump%2525252525252525252Flink%2525252525252525253Flink%2525252525252525253Dhttps%252525252525252525253A%252525252525252525252F%252525252525252525252Fgw-c.nowcoder.com%252525252525252525252Fapi%252525252525252525252Fsparta%252525252525252525252Fjump%252525252525252525252Flink%252525252525252525253Flink%252525252525252525253Dhttps%25252525252525252525253A%25252525252525252525252F%25252525252525252525252Fgw-c.nowcoder.com%25252525252525252525252Fapi%25252525252525252525252Fsparta%25252525252525252525252Fjump%25252525252525252525252Flink%25252525252525252525253Flink%25252525252525252525253Dhttps%2525252525252525252525253A%2525252525252525252525252F%2525252525252525252525252Fgw-c.nowcoder.com%2525252525252525252525252Fapi%2525252525252525252525252Fsparta%2525252525252525252525252Fjump%2525252525252525252525252Flink%2525252525252525252525253Flink%2525252525252525252525253Dhttps%252525252525252525252525253A%252525252525252525252525252F%252525252525252525252525252Fgw-c.nowcoder.com%252525252525252525252525252Fapi%252525252525252525252525252Fsparta%252525252525252525252525252Fjump%252525252525252525252525252Flink%252525252525252525252525253Flink%252525252525252525252525253Dhttps%25252525252525252525252525253A%25252525252525252525252525252F%25252525252525252525252525252Fgw-c.nowcoder.com%25252525252525252525252525252Fapi%25252525252525252525252525252Fsparta%25252525252525252525252525252Fjump%25252525252525252525252525252Flink%25252525252525252525252525253Flink%25252525252525252525252525253Dhttps%2525252525252525252525252525253A%2525252525252525252525252525252F%2525252525252525252525252525252Fgw-c.nowcoder.com%2525252525252525252525252525252Fapi%2525252525252525252525252525252Fsparta%2525252525252525252525252525252Fjump%2525252525252525252525252525252Flink%2525252525252525252525252525253Flink%2525252525252525252525252525253Dhttps%252525252525252525252525252525253A%252525252525252525252525252525252F%252525252525252525252525252525252Fgw-c.nowcoder.com%252525252525252525252525252525252Fapi%252525252525252525252525252525252Fsparta%252525252525252525252525252525252Fjump%252525252525252525252525252525252Flink%252525252525252525252525252525253Flink%252525252525252525252525252525253Dhttps%25252525252525252525252525252525253A%25252525252525252525252525252525252F%25252525252525252525252525252525252Fgw-c.nowcoder.com%25252525252525252525252525252525252Fapi%25252525252525252525252525252525252Fsparta%25252525252525252525252525252525252Fjump%25252525252525252525252525252525252Flink%25252525252525252525252525252525253Flink%25252525252525252525252525252525253Dhttps%2525252525252525252525252525252525253A%2525252525252525252525252525252525252F%2525252525252525252525252525252525252Fblog.nowcoder.net%2525252525252525252525252525252525252Fzhuanlan%2525252525252525252525252525252525252FjvN8gj)\n\n**《软件开发笔试汇总》**\n：[https://blog.nowcoder.net/zhuanlan/0oDWVm](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgw-c.nowcoder.com%2Fapi%2Fsparta%2Fjump%2Flink%3Flink%3Dhttps%253A%252F%252Fgw-c.nowcoder.com%252Fapi%252Fsparta%252Fjump%252Flink%253Flink%253Dhttps%25253A%25252F%25252Fgw-c.nowcoder.com%25252Fapi%25252Fsparta%25252Fjump%25252Flink%25253Flink%25253Dhttps%2525253A%2525252F%2525252Fgw-c.nowcoder.com%2525252Fapi%2525252Fsparta%2525252Fjump%2525252Flink%2525253Flink%2525253Dhttps%252525253A%252525252F%252525252Fgw-c.nowcoder.com%252525252Fapi%252525252Fsparta%252525252Fjump%252525252Flink%252525253Flink%252525253Dhttps%25252525253A%25252525252F%25252525252Fgw-c.nowcoder.com%25252525252Fapi%25252525252Fsparta%25252525252Fjump%25252525252Flink%25252525253Flink%25252525253Dhttps%2525252525253A%2525252525252F%2525252525252Fgw-c.nowcoder.com%2525252525252Fapi%2525252525252Fsparta%2525252525252Fjump%2525252525252Flink%2525252525253Flink%2525252525253Dhttps%252525252525253A%252525252525252F%252525252525252Fgw-c.nowcoder.com%252525252525252Fapi%252525252525252Fsparta%252525252525252Fjump%252525252525252Flink%252525252525253Flink%252525252525253Dhttps%25252525252525253A%25252525252525252F%25252525252525252Fgw-c.nowcoder.com%25252525252525252Fapi%25252525252525252Fsparta%25252525252525252Fjump%25252525252525252Flink%25252525252525253Flink%25252525252525253Dhttps%2525252525252525253A%2525252525252525252F%2525252525252525252Fgw-c.nowcoder.com%2525252525252525252Fapi%2525252525252525252Fsparta%2525252525252525252Fjump%2525252525252525252Flink%2525252525252525253Flink%2525252525252525253Dhttps%252525252525252525253A%252525252525252525252F%252525252525252525252Fgw-c.nowcoder.com%252525252525252525252Fapi%252525252525252525252Fsparta%252525252525252525252Fjump%252525252525252525252Flink%252525252525252525253Flink%252525252525252525253Dhttps%25252525252525252525253A%25252525252525252525252F%25252525252525252525252Fgw-c.nowcoder.com%25252525252525252525252Fapi%25252525252525252525252Fsparta%25252525252525252525252Fjump%25252525252525252525252Flink%25252525252525252525253Flink%25252525252525252525253Dhttps%2525252525252525252525253A%2525252525252525252525252F%2525252525252525252525252Fgw-c.nowcoder.com%2525252525252525252525252Fapi%2525252525252525252525252Fsparta%2525252525252525252525252Fjump%2525252525252525252525252Flink%2525252525252525252525253Flink%2525252525252525252525253Dhttps%252525252525252525252525253A%252525252525252525252525252F%252525252525252525252525252Fgw-c.nowcoder.com%252525252525252525252525252Fapi%252525252525252525252525252Fsparta%252525252525252525252525252Fjump%252525252525252525252525252Flink%252525252525252525252525253Flink%252525252525252525252525253Dhttps%25252525252525252525252525253A%25252525252525252525252525252F%25252525252525252525252525252Fgw-c.nowcoder.com%25252525252525252525252525252Fapi%25252525252525252525252525252Fsparta%25252525252525252525252525252Fjump%25252525252525252525252525252Flink%25252525252525252525252525253Flink%25252525252525252525252525253Dhttps%2525252525252525252525252525253A%2525252525252525252525252525252F%2525252525252525252525252525252Fgw-c.nowcoder.com%2525252525252525252525252525252Fapi%2525252525252525252525252525252Fsparta%2525252525252525252525252525252Fjump%2525252525252525252525252525252Flink%2525252525252525252525252525253Flink%2525252525252525252525252525253Dhttps%252525252525252525252525252525253A%252525252525252525252525252525252F%252525252525252525252525252525252Fgw-c.nowcoder.com%252525252525252525252525252525252Fapi%252525252525252525252525252525252Fsparta%252525252525252525252525252525252Fjump%252525252525252525252525252525252Flink%252525252525252525252525252525253Flink%252525252525252525252525252525253Dhttps%25252525252525252525252525252525253A%25252525252525252525252525252525252F%25252525252525252525252525252525252Fgw-c.nowcoder.com%25252525252525252525252525252525252Fapi%25252525252525252525252525252525252Fsparta%25252525252525252525252525252525252Fjump%25252525252525252525252525252525252Flink%25252525252525252525252525252525253Flink%25252525252525252525252525252525253Dhttps%2525252525252525252525252525252525253A%2525252525252525252525252525252525252F%2525252525252525252525252525252525252Fwww.nowcoder.com%2525252525252525252525252525252525252Fcreation%2525252525252525252525252525252525252Fmanager%2525252525252525252525252525252525252FcolumnDetail%2525252525252525252525252525252525252F0oDWVm)\n\n1.小美点外卖\n\n小美是美团外卖的忠实用户，她经常去美团外卖 app 上面点外卖，因为会员红包的性价比太高啦！\n\n现在小美点了若干道菜，她希望你计算一个订单的总价。你能帮帮她吗？\n\n输入描述\n\n第一行输入一个正整数，代表菜品总数。\n\n第二行输入个正整数，代表每道菜的价格。\n\n第三行输入两个正整数x和y，x代表满减的价格，y代表红包的价格。\n\n1<=n<=10^5\n\n1<=x,y,ai<=10^9\n\n保证所有的和大于，保证会用到满减\n\n输出描述\n\n一个正整数，代表小美最终应付的钱数。\n\n示例 1\n\n输入\n\n4\n\n10 20 10 20\n\n25 10\n\n输出\n\n25\n\n说明\n\n四个菜一共 60 元，满减减掉了 25 元，再用一个 10 元的红包，因此需要付 25 元。\n\n    \n    \n    #include <iostream>\n    using namespace std;\n    \n    int main() {\n        int num;\n        long long sum = 0;\n        cin >> num;\n        for (int i = 0; i < num; i++) {\n            long long temp;\n            cin >> temp;\n            sum += temp;\n        }\n        long long l1, l2;\n        cin >> l1 >> l2;\n        sum = sum - l1 - l2;\n        cout << sum << endl;\n        return 0;\n    }\n    \n\n2.小美的合法单词\n\n小美定义以下三种单词是合法的：\n\n  1. 所有字母都是小写。例如：good\n  2. 所有字母都是大写。例如：APP\n  3. 第一个字母大写，后面所有字母都是小写。例如：Alice\n\n现在小美拿到了一个单词，她每次操作可以修改任意一个字符的大小写。小美想知道最少操作几次可以使得单词变成合法的？\n\n输入描述\n\n一个仅由大写字母和小写字母组成的字符串，长度不超过10^5。\n\n输出描述\n\n一个整数，代表操作的最小次数。\n\n示例 1\n\n输入\n\nAbC\n\n输出\n\n1\n\n说明\n\n变成 ABC 或者 Abc 均可。只需要一次操作。\n\n    \n    \n    #include <iostream>\n    #include <string>\n    #include <algorithm>\n    \n    using namespace std;\n    \n    int main() {\n        string s;\n        getline(cin, s);\n        int small = 0, big = 0;\n        int res = s.length();\n        for (size_t i = 0; i < s.length(); ++i) {\n            if(s[i] >= 'a' && s[i] <= 'z') small++;\n            else if(s[i] >= 'A' && s[i] <= 'Z') big++;\n        }\n        int temp = s.length();\n        if(s[0] >= 'A' && s[0] <= 'Z') temp = s.length() - 1 - small;\n        res = min({small, big, temp}); // 使用min函数计算三个数中的最小值\n        cout << res << endl;\n        return 0;\n    }\n    \n    \n\n3、翻倍元素\n\n小美拿到了一个数组，她每次操作会将除了第x个元素的其余元素翻倍，一共操作了q次。请你帮小美计算操作结束后所有元素之和。\n\n由于答案过大，请对10^9+7取模。\n\n输入描述\n\n第一行输入两个正整数n,q，代表数组的大小和操作次数。 第二行输入n个正整数ai，代表数组的元素。 第三行输入一个正整数q，代表操作的次数。\n接下来的q行，每行输入一个正整数xi，代表第i次操作未被翻倍的元素。 1<=n,q<=10^5 1<=xi<=n 1<=ai<=10^9\n\n输出描述\n\n一个整数，代表操作结束后所有元素之和模10^9+7的值。\n\n示例\n\n输入\n\n4 2 1 2 3 4 1 2\n\n输出\n\n34\n\n说明\n\n第一次操作后，数组变成[1,4,6,8] 第二次操作后，数组变成[2,4,12,16] 所有元素之和为 34。\n\n    \n    \n    #include <iostream>\n    #include <vector>\n    using namespace std;\n    \n    const int MOD = 1000000007;\n    \n    long powMod(long x, int n, int MOD) {\n        long result = 1;\n        x = x % MOD;\n        while (n > 0) {\n            if (n & 1) {\n                result = (result * x) % MOD;\n            }\n            x = (x * x) % MOD;\n            n >>= 1;\n        }\n        return result;\n    }\n    \n    int main() {\n        int n, q;\n        cin >> n >> q;\n        vector<int> nums(n), times(n, q);\n    \n        for (int i = 0; i < n; i++) {\n            cin >> nums[i];\n        }\n    \n        for (int i = 0; i < q; i++) {\n            int x;\n            cin >> x;\n            times[x - 1]--;\n        }\n    \n        long sum = 0;\n        for (int i = 0; i < n; i++) {\n            long val = static_cast<long>(nums[i]) * powMod(2, times[i], MOD) % MOD;\n            sum = (sum + val) % MOD;\n        }\n    \n        cout << sum << endl;\n        return 0;\n    }\n    \n    \n\n4.小美的众数\n\n小美拿到了一个数组。她希望你求出所有区间众数之和。你能帮帮她吗？\n\n定义区间的众数为出现次数最多的那个数。如果有多个数出现次数最多，那么众数是其中最小的那个数。\n\n输入描述\n\n第一行输入一个正整数n，代表数组的大小。\n\n第二行输入n个正整ai，代表数组的元素。\n\n1<=n<=200000\n\n1<=ai<=2\n\n输出描述\n\n一个正整数，代表所有区间的众数之和。\n\n示例 1\n\n输入\n\n3\n\n2 1 2\n\n输出\n\n9\n\n说明\n\n[2],[2,1,2],[2]的众数是 2。[2,1],[1],[1,2]的众数是 1。因此答案是 9。\n\n    \n    \n    #include <cstdio>\n    #include <iostream>\n    #include <algorithm>\n    \n    typedef long long LL;\n    \n    const int N = 200010;\n    \n    int n;\n    int a[N], tr[N * 2];\n    int sum[N];\n    \n    int lowbit(int x) {\n        return x & -x;\n    }\n    \n    void modify(int x, int k) {\n        for (int i = x; i <= 2 * n + 5; i += lowbit(i)) tr[i] += k;\n    }\n    \n    int query(int x) {\n        int res = 0;\n        for (int i = x; i; i -= lowbit(i)) res += tr[i];\n        return res;\n    }\n    \n    int main() {\n        scanf(\"%d\", &n);\n        for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n        LL ans = 0;\n        modify(0 + n + 1, 1);\n        for (int i = 1; i <= n; i++) {\n            sum[i] = sum[i - 1];\n            if (a[i] == 1) sum[i] += 1;\n            else sum[i] -= 1;\n            ans += query(sum[i] + n + 1) + (i - query(sum[i] + n + 1)) * 2;\n            modify(sum[i] + n + 1, 1);\n        }\n        printf(\"%lld\", ans);\n        return 0;\n    }\n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599735227145089024?sourceSSR=users",
        "title": "3月19日腾讯云一面凉经",
        "content": "3月19日晚上面试，本来约的晚上7点30，面试官临时有事改成了8点30\n\n1、介绍项目，简单问了问项目，10分钟\n\n2、算法题，粉刷房子，给了十分钟时间没写出来，就问了下思路\n\n3、快排，前两天看了下怎么实现的，但是被问了最好最坏情况，就记得个平均时间复杂度O(nlogn)，按照记忆惯性最好情况说成了复杂度是O(n)，最坏O(n2)，然后最好情况和最坏情况的例子也举错了。。\n\n4、怎么分析进程占用的cpu、内存？回答了可以使用top\n\n5、如何查看究竟是哪个函数最占用时间？回答了可以使用perf，绘制火焰图\n\n6、面试官直接截了一张top的结果，是那种带缩写的，问这些参数代表什么。。胡扯了几句，也不咋懂\n\n7、反问，base在哪，主要在成都，北京上海好像也有\n\n8、业务是什么，腾讯云做数据库管控的\n\n面完秒挂，面试前几天准备了计网、操作系统、mysql、redis的八股文，完美绕开了自己准备的八股文，算法实在太薄弱。。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599740289527410688?sourceSSR=users",
        "title": "美团笔试 美团实习 0401",
        "content": "**笔试时间：2023年04月01日**\n\n# 第一题\n\n### 题目：算数\n\n小美在数学课上学会了加减乘除，现在她想多进行一些算数训练来加强自己的计算能力。为了不重复出题，她想出一个好方法。她先写下了一排n个数(n≥2)，依次用加号连接。举例来说，小美可能写下了如下的式子1+4+7+4+2+3+1共7个数以及6个加号。接着小美以一种全新的方式进行出题：她每次选择一个加号，将它改变成加减乘除中的一个（虽然很奇怪，但小美认为加号也可以被改成加号，尽管不会产生任何影响），然后计算整个式子的结果。值得注意的是，小美认为每次操作不对后续操作产生影响，详见样例解释。小美认真做了很多次算数训练，现在她想让作为她好朋友的你帮她用程序计算一次，方便她核对答案。\n\n### 输入描述\n\n第一行一个整数n，含义见题面。\n\n接下来一行n个整数a1,a2,..,an，依次表示小美初始写下的连加算式中的每一个数。\n\n接下来一个整数m，表示小美做了m次算数训练\n\n接下来2m个以空格分开数字或符号 t1,o1, t2,o2, ...\ntm,om，其中ti为数字，oi是'+','-','*','/'(即加减乘除符号，不含引号)中的一个符号，表示第 i\n次操作选定了第ti个加号，将其改变为了oi。\n\n对于所有的的数据,2≤N≤50000，1≤M≤50000,1≤ai≤500,1≤ti<N,oi∈{+,-,*,/}\n\n### 输出描述\n\n输出一行m个整数，分别表示每次操作的答案，结果四舍五入到一位小数。\n\n### 样例输入\n\n> 5\n>\n> 1 2 4 2 5\n>\n> 3\n>\n> 1 - 2 * 4 /\n\n### 样例输出\n\n> 10.0 16.0 7.4\n\n**解释：**\n\n第一次操作后算数式为1-2+4+2+5 = 10.0\n\n第二次操作后算数式为1+2*4+2+5 = 16.0\n\n第三次操作后算数式为1+2+4+2/5 = 7.4\n\n值得注意的是，每次操作都认为对初始的全加号式子(此处为1+2+4+2+5)进行操作，操作之间互不影响。\n\n### 参考题解\n\n按照题意模拟。\n\nC++：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    #include <iostream>\n    #include <vector>\n    #include <iomanip>\n    \n    using namespace std;\n    \n    double perform_operation(int a, int b, char op) {\n        switch (op) {\n            case '+':\n                return a + b;\n            case '-':\n                return a - b;\n            case '*':\n                return a * b;\n            case '/':\n                return static_cast<double>(a) / b;\n            default:\n                return 0;\n        }\n    }\n    \n    int main() {\n        int n;\n        cin >> n;\n        vector<int> nums(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> nums[i];\n        }\n    \n        // 计算原始算式的结果\n        int original_sum = 0;\n        for (int i = 0; i < n; ++i) {\n            original_sum += nums[i];\n        }\n    \n        int m;\n        cin >> m;\n        vector<int> t(m);\n        vector<char> op(m);\n        for (int i = 0; i < m; ++i) {\n            cin >> t[i] >> op[i];\n        }\n    \n        cout << fixed << setprecision(1);\n        for (int i = 0; i < m; ++i) {\n            int index = t[i] - 1;\n            char operation = op[i];\n            double result = original_sum - nums[index] - nums[index + 1];\n            result += perform_operation(nums[index], nums[index + 1], operation);\n            cout << result << \" \";\n        }\n    \n        return 0;\n    }\n    \n\nJava：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    import java.util.Scanner;\n    \n    public class Main {\n        public static double performOperation(int a, int b, char op) {\n            switch (op) {\n                case '+':\n                    return a + b;\n                case '-':\n                    return a - b;\n                case '*':\n                    return a * b;\n                case '/':\n                    return (double) a / b;\n                default:\n                    return 0.0;\n            }\n        }\n    \n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            int n = scanner.nextInt();\n            int[] nums = new int[n];\n            for (int i = 0; i < n; ++i) {\n                nums[i] = scanner.nextInt();\n            }\n    \n            // 计算原始算式的结果\n            int originalSum = 0;\n            for (int i = 0; i < n; ++i) {\n                originalSum += nums[i];\n            }\n    \n            int m = scanner.nextInt();\n            int[] t = new int[m];\n            char[] op = new char[m];\n            for (int i = 0; i < m; ++i) {\n                t[i] = scanner.nextInt();\n                op[i] = scanner.next().charAt(0);\n            }\n    \n            for (int i = 0; i < m; ++i) {\n                int index = t[i] - 1;\n                char operation = op[i];\n                double result = originalSum - nums[index] - nums[index + 1];\n                result += performOperation(nums[index], nums[index + 1], operation);\n                System.out.printf(\"%.1f \", result);\n            }\n        }\n    }\n    \n\nPython：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    def perform_operation(a, b, op):\n        if op == '+':\n            return a + b\n        elif op == '-':\n            return a - b\n        elif op == '*':\n            return a * b\n        elif op == '/':\n            return float(a) / b\n        else:\n            return 0.0\n    \n    def main():\n        n = int(input())\n        nums = list(map(int, input().split()))\n    \n        # 计算原始算式的结果\n        original_sum = sum(nums)\n    \n        m = int(input())\n        t = []\n        op = []\n        for _ in range(m):\n            ti, opi = input().split()\n            t.append(int(ti))\n            op.append(opi)\n    \n        for i in range(m):\n            index = t[i] - 1\n            operation = op[i]\n            result = original_sum - nums[index] - nums[index + 1]\n            result += perform_operation(nums[index], nums[index + 1], operation)\n            print(\"{:.1f}\".format(result), end=\" \")\n    \n    if __name__ == \"__main__\":\n        main()\n    \n\n# 第二题\n\n### 题目：整理\n\n小美正在整理桌子上的一排装饰品。小美对待装饰品摆放方式的审美角度很奇特，她认为高度相差比较大的装饰品放在相邻位置会很难看，她想对这一排装饰品进行整理，可以交换任意两个装饰品的位置任意多次。假设当前从左到右n个装饰品的高度分别为h1,h2,...,hn，那么当前一排装饰品的丑陋值为![\\\\sum_{i=1}^{n-1}{\\\\left|\nh_{i} - h_{i+1}\n\\\\right|}](https://hr.nowcoder.com/equation?tex=%5Csum_%7Bi%3D1%7D%5E%7Bn-1%7D%7B%5Cleft%7C%20h_%7Bi%7D%20-%20h_%7Bi%2B1%7D%20%5Cright%7C%7D&preview=true)，其中|x|为x的绝对值。小美想最小化她的装饰品的丑陋值，请你帮她排一下顺序。形式化地来讲，有一长为n的序列a1,a2,...,an，你可以任意次数地进行交换，每次交换都可以选择任意两个不同的数i,j,交换ai,aj的位置。经过若干次交换后，序列变为h1,h2,...,hn，其丑陋值为![\\\\sum_{i=1}^{n-1}{\\\\left|\nh_{i} - h_{i+1}\n\\\\right|}](https://hr.nowcoder.com/equation?tex=%5Csum_%7Bi%3D1%7D%5E%7Bn-1%7D%7B%5Cleft%7C%20h_%7Bi%7D%20-%20h_%7Bi%2B1%7D%20%5Cright%7C%7D&preview=true)，你需要找出一种交换方式，使得最终序列{hn}的丑陋值最小化。你不需要输出具体交换方式，只需要输出最终的{hn}序列的丑陋值即可。\n\n### 输入描述\n\n第一行一个整数n，表示小美的装饰品数量。\n\n接下来一行n个整数a1,a2,...,an，依次表示从左到右n个装饰品的高度。\n\n对于所有的数据:2≤N≤50000，0≤ai≤10^9。\n\n### 输出描述\n\n输出第一行一个数，为最优方案的最小丑陋值。\n\n### 样例输入\n\n> 3 3 1 2\n\n### 样例输出\n\n> 2\n\n**提示：**\n\n我们可以将3和1交换，得到1 3 2然后再将2和3交换，得到1 2 3可以证明，此时有最小丑陋值|1-2|+|2-3|=2\n\n### 参考题解\n\nC++：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    #include <iostream>\n    #include <vector>\n    #include <algorithm>\n    using namespace std;\n    \n    int main() {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n    \n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n    \n        sort(a.begin(), a.end());\n    \n        int res = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            res += a[i + 1] - a[i];\n        }\n    \n        cout << res << endl;\n    \n        return 0;\n    }\n    \n\nJava：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    import java.util.Arrays;\n    import java.util.Scanner;\n    \n    public class Main {\n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            int n = scanner.nextInt();\n            int[] a = new int[n];\n    \n            for (int i = 0; i < n; ++i) {\n                a[i] = scanner.nextInt();\n            }\n    \n            Arrays.sort(a);\n    \n            int res = 0;\n      \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599732110227763200?sourceSSR=users",
        "title": "腾讯前端-WXG-暑期实习-1面",
        "content": "今天面试感觉还可以，自己发挥不错，题目都答对了，八股也还可以。难受的是上一轮腾讯健康面试转到微信支付部门，我又要多一轮面试，感觉好折磨，难受🤣。\n\n## 八股\n\n八股文主要是结合项目中技术进行延伸回答，部分场景还会结合业务场景，问题比较多，尽力回忆。\n\n  1. 结合项目经历进行一个学习历程的介绍，介绍自己项目遇到的问题和解决办法\n  2. accessToken的作用，如何设置\n  3. CSRF是什么，如何进行处理，CSRF token 有用到吗？\n  4. 你使用Echarts，d3，Antv等进行可视化，你是如何选择的，为什么要用不同可视化库\n  5. 如何开启浏览器GPU加速\n  6. D3有2中渲染模式，SVG和Canvas，你是选择那种模式，为什么要选择这个\n  7. 你们可视化使用的是实时数据处理吗？如果要实现实时数据处理要如何完成\n  8. 浏览器获取HTML后如何进行一个页面处理\n  9. 常用的异步和同步实现方法有什么\n  10. 如何实现跨页面通信\n  11. 浏览器事件循环\n  12. HTTP1.0和HTTP1.1，HTTP2.0的区别\n  13. Electron中主进程和渲染进程之间的关系\n  14. Vue的响应式实现原理\n  15. Vue和React都用了虚拟DOM，他的实现原理是什么\n  16. 虚拟DOM一定能得到更好的性能吗\n  17. 如果有10000个球要在页面进行渲染，你使用虚拟DOM还是原生DOM\n  18. 用户给你反馈浏览器出现白屏，你该如何解决\n  19. 用户反馈在使用应用时，手机出现严重发热，如何解决。\n\n## 手写输出\n\n  1. 经典判断this指向\n  2. JavaScript中作用域，var的输出\n\n## 代码题\n\n  1. 实现一个repeat函数，接受参数为（func，times，delay),调用这个函数会执行func函数times次，每次间隔为delay。如const repeatFunc=repeat(alert,4,2);repaet('111')输出111，共4次，间隔2ms。\n  2. 给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。leetcode:54\n  3. 字符串解码：给定一个经过编码的字符串，返回它解码后的字符串leet：394\n\n## 反问\n\n  1. 多久出结果？得到了这是1面，上一面不同部门没有什么用\n  2. 前端工程化和规范化\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599723127639207936?sourceSSR=users",
        "title": "3.19 腾讯CSIG面试",
        "content": "这个部门复活赛以为打赢了，结果感觉是kpi面[牛泪] 基本根据简历来问~\n\n  1. 自我介绍\n  2. 项目经历：你这个项目是学校内部的项目吗？有部署到云端之类的吗？有没有人用呢？（点评加外卖，懂得都懂吧...）\n\n（一点思考：为什么会这样问？可能是觉得见的太多了，都已经知根知底，显然不会太受欢迎；部署的问题，可能是微服务架构部分，希望可以看到一些关注的架构处理方面的逻辑；有没有人用？说明服务项目的欢迎程度，如果可以上线进行部署会好很多。）\n\n  1. 实习期间做了什么项目东西？有没有遇到过什么比较难的问题？自己参与的比较深，可以解决工作中的问题？\n  2. 缓存用到的是什么数据结构？有序集合的底层原理实现？\n  3. Java中的锁有哪几种？分别是什么实现方式？\n  4. Java IO中的阻塞式IO和非阻塞式IO的区别和联系？\n  5. 聊聊Java中的反射机制？并且在Spring中是如何进行反射相关操作的？\n  6. Java集合ArrayList和LinkedList的区别联系？哪个查找元素的速度快一点？\n  7. **JMM，java内存模型 （问得很深，回答不全）**\n  8. MySQL索引失效问题以及解决方案？\n  9. MySQL索引用的是什么数据结构？\n  10. MySQL数据库服务器飙升，会是什么原因造成的？\n  11. 缓存中的生产问题（缓存击穿、穿透、雪崩问题，原因、解决方式）\n  12. 3道手撕题目ACM模式：反转链表、最长有序子序列、岛屿问题（上回对输入输出额外练习后，这三题也完全可以秒了[尴尬]）\n\n总结：\n\n  1. 全程没问项目，都是基础八股和之前小公司实习经历询问。\n  2. 面试官人蛮好的，循序渐进，可以提供不同的思考方式，也为我后续的学习提点中肯建议。（八股还得深入理解，最好结合具体实现案例进行回答）\n  3. 体验挺好，八股都回答得可以，没有秒挂，可惜感觉是kpi，唉[牛泪]~\n\n另外：面完就接到电话，以为过了...结果是美团的约面，呃呃呃...\n\n继续加油吧，后续再看看tx流程会不会更新[牛泪]\n\n​\n\n\\----3.21更新----\n\n官网显示流程结束，和鹅缘分已尽[叹息]\n\n继续海投面试，希望下周团子面试顺利！！\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599738882497736704?sourceSSR=users",
        "title": "美团笔试 美团实习 0325",
        "content": "**笔试时间：2023年3月25日**\n\n# 第一题\n\n### 题目：火车迷\n\n小美是一个火车迷。最近她在观察家附近火车站的火车驶入和驶出情况，发现火车驶入和驶出的顺序并不一致。经过小美调查发现，原来这个火车站里面有一个类似于栈的结构，如下图所示：\n\n![](https://uploadfiles.nowcoder.com/images/20240319/646661816_1710860652219/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n例如可能1号火车驶入了火车站中的休息区s，在驶出之前2号火车驶入了。那么在这种情况下，1号火车需要等待2号火车倒车出去后才能出去（显然被后面驶入的2号火车挡住了，这个休息区s只有一个出入口）。出于好奇，小美统计了近些天的火车驶入驶出情况，开始统计和结束统计时休息区s中均是空的。由于中途疏忽，小美觉得自己好像弄错了几个驶入驶出顺序，想请你帮她验证一下。值得注意的是，小美虽然可能弄错了顺序，但对火车的记录是不重不漏的。形式化地来形容休息区s，我们视其为一个容量无限大的空间，假设两列火车\ni 和 j 同时处于休息区s中，驶入时刻Tin满足Tin(i)<Tin(j)，则驶出时间Tout必定满足Tout(i)>Tout(j)，即，先进后出。\n\n### 输入描述\n\n第一行一个整数T表示数据组数。\n\n对每组测试而言：\n\n第一行一个整数n，表示观察到的火车数量。\n\n第二行n个整数x1,x2,...,xn，表示小美记录的火车驶入休息区s的顺序。\n\n第三行n个整数y1,y2,...,yn，表示小美记录的火车驶出休息区s的顺序。\n\n1≤T≤10,1≤n≤50000,1≤xi,yi≤n, 且{xn} 、{yn}\n均为{1,2,3,...,n}的一个排列，即1~n这n个数在其中不重不漏恰好出现一次。\n\n### 输出描述\n\n对每组数据输出一行：如果小美记录的驶入和驶出顺序无法被满足则输出No，否则输出Yes。\n\n### 示例输入\n\n> 3\n>\n> 3\n>\n> 1 2 3\n>\n> 1 2 3\n>\n> 3\n>\n> 1 2 3\n>\n> 3 2 1\n>\n> 3\n>\n> 1 2 3\n>\n> 3 1 2\n\n### 示例输出\n\n> Yes\n>\n> Yes\n>\n> No\n\n**提示**\n\n对第一组数据：每辆火车刚驶入便立刻驶出即可满足此记录。\n\n对第二组数据：\n\n[ <\\- 休息区出口 （空 初始状态）\n\n[1 <\\- 休息区出口 （1号驶入）\n\n[1 2 <\\- 休息区出口 （2号驶入）\n\n[1 2 3 <\\- 休息区出口 （3号驶入）\n\n[1 2 <\\- 休息区出口 （3号驶出）\n\n[1 <\\- 休息区出口 （2号驶出）\n\n[ <\\- 休息区出口 （1号驶出）\n\n记录可以被此种方案满足。\n\n对第三组数据：\n\n[ <\\- 休息区出口 （空 初始状态）\n\n[1 <\\- 休息区出口 （1号驶入）\n\n[1 2 <\\- 休息区出口 （2号驶入）\n\n[1 2 3 <\\- 休息区出口 （3号驶入）\n\n[1 2 <\\- 休息区出口 （3号驶出）\n\n发现1号被2号堵住，无法先于2号驶出。可以证明，亦不存在其他驶入驶出方案使得第三组数据满足要求。\n\n### 参考题解\n\n我们可以使用栈这个数据结构来模拟火车驶入驶出的过程\n\nC++：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    #include <iostream>\n    #include <vector>\n    #include <stack>\n    using namespace std;\n    \n    bool isValidTrainSequence(vector<int>& in_sequence, vector<int>& out_sequence) {\n        stack<int> stk;\n        int in_index = 0, out_index = 0;\n    \n        while (out_index < out_sequence.size()) {\n            while (stk.empty() || (stk.top() != out_sequence[out_index])) {\n                if (in_index < in_sequence.size()) {\n                    stk.push(in_sequence[in_index]);\n                    in_index++;\n                } else {\n                    return false;\n                }\n            }\n            stk.pop();\n            out_index++;\n        }\n    \n        return true;\n    }\n    \n    int main() {\n        int T;\n        cin >> T;\n    \n        for (int _ = 0; _ < T; ++_) {\n            int n;\n            cin >> n;\n            vector<int> in_sequence(n), out_sequence(n);\n    \n            for (int i = 0; i < n; ++i) {\n                cin >> in_sequence[i];\n            }\n    \n            for (int i = 0; i < n; ++i) {\n                cin >> out_sequence[i];\n            }\n    \n            if (isValidTrainSequence(in_sequence, out_sequence)) {\n                cout << \"Yes\" << endl;\n            } else {\n                cout << \"No\" << endl;\n            }\n        }\n    \n        return 0;\n    }\n    \n\nJava：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    import java.util.Scanner;\n    import java.util.Stack;\n    \n    public class Main {\n        public static boolean isValidTrainSequence(int[] inSequence, int[] outSequence) {\n            Stack<Integer> stack = new Stack<>();\n            int inIndex = 0, outIndex = 0;\n    \n            while (outIndex < outSequence.length) {\n                while (stack.empty() || (stack.peek() != outSequence[outIndex])) {\n                    if (inIndex < inSequence.length) {\n                        stack.push(inSequence[inIndex]);\n                        inIndex++;\n                    } else {\n                        return false;\n                    }\n                }\n                stack.pop();\n                outIndex++;\n            }\n    \n            return true;\n        }\n    \n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            int T = scanner.nextInt();\n    \n            for (int _ = 0; _ < T; ++_) {\n                int n = scanner.nextInt();\n                int[] inSequence = new int[n];\n                int[] outSequence = new int[n];\n    \n                for (int i = 0; i < n; ++i) {\n                    inSequence[i] = scanner.nextInt();\n                }\n    \n                for (int i = 0; i < n; ++i) {\n                    outSequence[i] = scanner.nextInt();\n                }\n    \n                if (isValidTrainSequence(inSequence, outSequence)) {\n                    System.out.println(\"Yes\");\n                } else {\n                    System.out.println(\"No\");\n                }\n            }\n        }\n    }\n    \n\n# 第二题\n\n### 题目：分糖\n\n小美因乐于助人的突出表现获得了老师的嘉奖。老师允许小美从一堆n个编号分别为1,2,...,n的糖果中选择任意多个糖果作为奖励（每种编号的糖果各一个），但为了防止小美一次吃太多糖果有害身体健康，老师设定了一个限制：如果选择了编号为\ni 的糖果，那么就不能选择编号为 i-1, i-2, i+1,\ni+2的四个糖果了。在小美看来，每个糖果都有一个对应的美味值，小美想让她选出的糖果的美味值之和最大！作为小美的好朋友，请你帮帮她！\n\n### 输入描述\n\n第一行一个整数n，表示糖果数量。\n\n第二行n个整数a1,a2,...,an，其中ai表示编号为 i 的糖果的美味值。\n\n1≤n≤50000 , 1≤ai≤10000\n\n### 输出描述\n\n输出一行一个数，表示小美能获得的糖果美味值之和最大值。\n\n### 示例输入\n\n> 7\n>\n> 3 1 2 7 10 2 4\n\n### 示例输出\n\n> 14\n\n### 参考题解\n\n动态规划，类似打家劫舍\n\nC++：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    #include <iostream>\n    #include <vector>\n    #include <algorithm>\n    \n    const int mxn = 50001;\n    std::vector<int> a(mxn);\n    std::vector<int> dp(mxn, -1);\n    \n    int dfs(int i, int n) {\n        if (i > n) {\n            return 0;\n        }\n        if (dp[i] != -1) {\n            return dp[i];\n        }\n        dp[i] =\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599714824850857984?sourceSSR=users",
        "title": "停车场车辆统计 - 华为OD统一考试 (C卷)",
        "content": "> OD统一考试 (C卷)\n>\n> 分值： 100分\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n特定大小的停车场，数组cars[]表示，其中1表示有车，0表示没车。\n\n车辆大小不一，小车占一个车位（长度1），货车占两个车位（长度2），卡车占三个车位（长度3），统计停车场最少可以停多少辆车，返回具体的数目。\n\n## 输入描述\n\n整型字符串数组cars[]，其中1表示有车，0表示没车，数组长度小于1000。\n\n## 输出描述\n\n整型数字字符串，表示最少停车数目。\n\n## 示例1\n\n    \n    \n    输入：\n    1,0,1\n    \n    输出：\n    2\n    \n    说明：\n    1个小车占1个车位\n    第二个车位空\n    1个小车占3个车位最少有两辆车\n    \n\n## 示例2\n\n    \n    \n    输入：\n    1,1,0,0,1,1,1,0,1\n    \n    输出：\n    3\n    \n    说明：\n    1个货车占第1、2个车位\n    第3、4个车位空\n    1个卡车占第5、6、7个车位\n    第8个车位空\n    1个小车占第9个车位\n    最少3辆车\n    \n\n## 题解\n\n> 停车场的规则是：小车占一个车位（长度1），货车占两个车位（长度2），卡车占三个车位（长度3）。\n>\n> 我们可以通过遍历输入的车辆状态数组 `cars[]`，同时记录当前连续的占用车位数 `d`。\n>\n>   * 当遇到有车（`1`）时 d + 1；\n>   * 当遇到空位时，计算可以停放多少辆车（**贪心** 的选择： 卡车 》 货车 》 小车），并将 `d` 置零。\n>   * 最后，再次检查一下是否还有剩余的车位数未计算，进行补充计算。最终得到停车场最少可以停多少辆车。\n>\n\n>\n> ### 复杂度分析\n>\n> 时间复杂度：O(n)，其中 n 为输入数组 `cars[]` 的长度。\n>\n> 空间复杂度：O(1)，只使用了常数个变量。\n\n### Java\n\n    \n    \n    import java.util.Scanner;\n    \n    /**\n     * @author code5bug\n     */\n    public class Main {\n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            String[] carsStr =\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599712908305588224?sourceSSR=users",
        "title": "测试开发 - 面经 - 字节跳动（国际化商业产品与技术）",
        "content": "自我介绍\n\n在介绍中说了解广告是，具体讲讲\n\n是在抖音或者头条上有推送过广告么\n\n讲讲实习，有什么问题，如何解决的，有什么样的效果\n\n当时对于日志和脚本的监控是怎么做的\n\n日志信息一般用什么命令看呢\n\ngit相关，基本操作，拉分支推分支当时是如何操作的\n\nget请求和post请求有什么区别\n\nPython装饰器\n\n算法：ACM模式\n\n最长字符子串的长度，力扣原题\n\n思路是什么样的\n\n目前大三可以出来实习是吗\n\n反问环节\n\n需要尽快到岗\n\n唉😔\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599737396829122560?sourceSSR=users",
        "title": "美团笔试 美团实习 0311",
        "content": "**笔试时间：2023年3月11日**\n\n# 第一题\n\n### 题目：小美的字符串\n\n小美有一个由数字字符组成的字符串。现在她想对这个字符串进行一些修改。具体地，她可以将这个字符串中任意位置字符修改为任意的数字字符。她想知道至少进行多少次修改，可以使修改后的字符串不包含两个连续相同的字符？例如，对于字符串”111222333”，她可以进行3次修改将其变为”121212313\"。\n\n### 输入描述\n\n一行， 一个字符串s，保证s只包含数字字符。(1 <= |s| <= 100000)\n\n### 输出描述\n\n一行，一个整数，表示修改的最少次数。\n\n### 示例输入\n\n> 示例一：111222333\n>\n> 示例二：11551111\n\n### 示例输出\n\n> 示例一：3\n>\n> 示例二：4\n\n### 参考题解\n\nC++：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    #include <iostream>\n    #include <vector>\n    using namespace std;\n    \n    int solution(vector<char>& s) {\n        int cnt = 0;\n        for (int i = 1; i < s.size(); i++) {\n            if (s[i] == s[i - 1]) {\n                cnt++;\n                if (i == s.size() - 1) {\n                    return cnt;\n                }\n    \n                for (int nx = 0; nx < 10; nx++) {\n                    if (static_cast<char>('0' + nx) != s[i - 1] && static_cast<char>('0' + nx) != s[i + 1]) {\n                        s[i] = static_cast<char>('0' + nx);\n                        break;\n                    }\n                }\n            }\n        }\n        return cnt;\n    }\n    \n    int main() {\n        string input;\n        cin >> input;\n        vector<char> s(input.begin(), input.end());\n        cout << solution(s) << endl;\n    \n        return 0;\n    }\n    \n\nJava：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    import java.util.Scanner;\n    \n    public class Main {\n        public static void main(String[] args) {\n            Scanner sc = new Scanner(System.in);\n            char[] s = sc.nextLine().toCharArray();\n            System.out.println(solution(s));\n        }\n    \n        static int solution(char[] s) {\n            int cnt = 0;\n            for (int i = 1; i < s.length; i++) {\n                if (s[i] == s[i - 1]) {\n                    cnt++;\n                    if (i == s.length - 1) {\n                        return cnt;\n                    }\n    \n                    for (int nx = 0; nx < 10; nx++) {\n                        if (Character.forDigit(nx, 10) != s[i - 1] && Character.forDigit(nx, 10) != s[i + 1]) {\n                            s[i] = Character.forDigit(nx, 10);\n                            break;\n                        }\n                    }\n                }\n            }\n            return cnt;\n        }\n    }\n    \n\nPython：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    def solution(s):\n        cnt = 0\n        for i in range(1, len(s)):\n            if s[i] == s[i - 1]:\n                cnt += 1\n                if i == len(s) - 1:\n                    return cnt\n    \n                for nx in range(10):\n                    if str(nx) != s[i - 1] and str(nx) != s[i + 1]:\n                        s[i] = str(nx)\n                        break\n        return cnt\n    \n    print(solution([c for c in input()]))\n    \n\n# 第二题\n\n### 题目：流星\n\n小美是一位天文爱好者，她收集了接下来一段时间中所有会划过她所在的观测地上空的流星信息。具体地,她收集了n个流星在她所在观测地上空的出现时刻和消失时刻。对于一个流星，若其的出现时刻为s,消失时刻为t,那么小美在时间段[s,t]都能够观测到它。对于一个时刻，观测地上空出现的流星数量越多，则小美认为该时刻越好。小美希望能够选择一个最佳的时刻进行观测和摄影，使她能观测到最多数量的流星。现在小美想知道，在这个最佳时刻，她最多能观测到多少个流星以及一共有多少个最佳时刻可供她选择。\n\n### 输入描述\n\n第一行是一个正整数n,表示流星的数量。\n\n第二行是n个用空格隔开的正整数,第i个数si表示第i个流星的出现时间。\n\n第三行是n个用空格隔开的正整数,第i个数ti表示第i个流星的消失时间。\n\n1<=n<=100000, 1<=si<=ti<=10^9\n\n### 输出描述\n\n输出一行用空格隔开的两个数x和y，其中x表示小美能观测到的最多的流行数，y表示可供她选择的最佳时刻数量。\n\n### 示例输入\n\n> 3\n>\n> 2 1 5\n>\n> 6 3 7\n\n### 示例输出\n\n> 2 4\n\n### 参考题解\n\nJava：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    import java.util.ArrayList;\n    import java.util.Collections;\n    import java.util.List;\n    import java.util.Scanner;\n    \n    public class Main {\n        public static void main(String[] args) {\n            Scanner sc = new Scanner(System.in);\n            int n = sc.nextInt();\n            int[][] intervals = new int[n][2];\n    \n            int[] starts = new int[n];\n            int[] ends = new int[n];\n            for (int i = 0; i < n; i++) {\n                starts[i] = sc.nextInt();\n            }\n            for (int i = 0; i < n; i++) {\n                ends[i] = sc.nextInt();\n            }\n            for (int i = 0; i < n; i++) {\n                intervals[i][0] = starts[i];\n                intervals[i][1] = ends[i];\n            }\n    \n            maxCoveredPoint(intervals);\n        }\n    \n        static void maxCoveredPoint(int[][] intervals) {\n            List<int[]> points = new ArrayList<>();\n            for (int[] interval : intervals) {\n                if (interval[0] == interval[1]) {\n                    points.add(new int[]{interval[0], 3});\n                }\n                points.add(new int[]{interval[0], 1});\n                points.add(new int[]{interval[1], 2});\n            }\n            Collections.sort(points, (a, b) -> a[0] - b[0]);\n    \n            int maxCoverage = 0;\n            int coveredPoint = 0;\n            int count = 0;\n            for (int[] point : points) {\n                if (point[1] == 1) coveredPoint += point[1];\n                if (coveredPoint > maxCoverage) {\n                    maxCoverage = coveredPoint;\n                    count = 1;\n                } else if (coveredPoint == maxCoverage) {\n                    count++;\n                }\n                if (point[1] == 2 || point[1] == 3) coveredPoint -= 1;\n            }\n    \n            System.out.print(maxCoverage + \" \");\n            System.out.println(count);\n        }\n    }\n    \n\nPython：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    def max_covered_point(intervals):\n        points = []\n        for interval in intervals:\n            if interval[0] == intervals[1]:\n                points.append(interval[0], 3)\n            points.append((interval[0], 1))\n            points.append((interval[1], 2))\n        points.sort()\n        max_ = 0\n        cov_point = 0\n        cnt = 0\n        for point in points:\n            if point[1] == 1: cov_point += point[1]\n            if cov_point > max_:\n                max_ = cov_point\n                cnt = 1\n            elif cov_point == max_:\n                cnt += 1\n            if point[1] == 2 or points[1] == 3: cov_point -= 1\n    \n    \n        print(max_, end=\" \")\n        print(cnt)\n    \n    n = int(input())\n    intevals = [[0, 0] for _ in range(n)]\n    \n    sts = [int(c) for c in input().split(\" \")]\n    ends = [int(c) for c in input().split(\" \")]\n    for i in range(n):\n        intevals[i][0] = sts[i]\n        intevals[i][1] = ends[i]\n    \n    max_covered_point(intevals)\n    \n\n# 第三题\n\n### 题目：最佳规划\n\n小团在一个n\n*m的网格地图上探索。网格地图上第i行第j列的格子用坐标(i,j)简记。初始时,小团的位置在地图的左上角。即坐标(1,1),地图上的每一个格子上都有一定的金币，特别地,小团位于的初始位置(1,1)上的金币为0。小团在进行探索移动时,可以选择向右移动一格(即从(x,y)到达(x,y+1))或向下移动一格(即从(x,y)到达(x+1,y))。地图上的每个格子都有一个颜色，红色或蓝色。如果小团一次移动前后的两个格子颜色不同，那么他需要支付k个金币才能够完成这一次移动;如果移动前后的两个格子颜色相同,则不需要支付金币。小团可以在任意格子选择结束探索。现在给你网格地图上每个格子的颜色与金币数量,假设小团初始时的金币数量为0，请你帮助小团计算出最优规划，使他能获得最多的金币,输出能获得的最多金币数量即可。\n\n注意:要求保证小团任意时刻金币数量不小于零。\n\n### 输入描述\n\n第一行是三个用空格隔开的整数n,m和k，表示网格地图的行数为n，列\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599709119464955904?sourceSSR=users",
        "title": "得物3-19笔试",
        "content": "1.字符串中找到长度为n的字串为回文串\n\n暴力跑\n\n2.leetcode40，但是只需要输出最少需要的数量\n\n刚开始做了剪枝，但还是tle\n\n暴力大剪枝对了64%。\n\n知道错在哪，但不知道怎么调整代码防tle了。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599706734675914752?sourceSSR=users",
        "title": "春招线上面试怎么准备?",
        "content": "本文首发自「林行学长」，欢迎来撩。\n\n了解校招、分享校招知识的学长来了！\n\n三月中旬，不少企业已经开始春招的面试了。\n\n学长注意到，不少企业还是选择了线上面试这一便捷的途径进行面试。\n\n线上面试有三个特点：\n\n**第一点，突破了空间和时间的限制，只要安排合理，网速靠谱，线上面试都能来者不拒；**\n\n**第二点，拉近了面试官与求职者之间的距离，高清镜头下，面试官更能捕捉到你的面部表情和肢体语言；**\n\n**第三点，线上面试更加直接，直奔主题，并且可以记录双方面试情况。**\n\n但是，线上面试的注意事项可能有点多。\n\n# 01 硬件准备\n\n**为了让自己的线上面试不掉线，最好在面试前确保自己的硬件环境良好。**\n\n不少企业在自己的招聘动态中就有提到这些注意事项，学长深以为然。\n\n1）摄像头：视频面试须全程开启摄像头功能，请提前准备好带有摄像功能的电脑参加面试；\n\n2）耳机：为保证交流过程音质清晰不受干扰，建议提前准备好耳机用于面试；\n\n3）电脑和网络要求：面试中请关闭其他应用，尽量选择网络状况良好的环境进行，网络速度达到100kb/s以上；\n\n4）下载好相应的线上面试软件，比如：腾讯会议、钉钉等，提前做好测试，知道哪里可以调亮度，调音量，桌面共享如何进行等等。\n\n**建议同学们在面试前检查摄像头以及麦克风是否运转正常，网速是否达标且稳定。**\n\n![](https://uploadfiles.nowcoder.com/files/20240319/218396548_1710849539694/.jpg)\n\n建议将手机热点作为备选方案，如遇到网速不佳的情况，及时切换。\n\n# 02 面试环境\n\n面试应该是一个专业的、私密的环境，所以一定要找个安静、背景简单的地方。\n\n学长曾看到过一个同学发帖，苦恼自己在寝室面试，室友会打扰自己的思维。\n\n线上面试，就要避免自己面试过程中出现干扰的情况。\n\n如果你是视频面试，那还要注意一下周围的光线不能过暗，能够看得清脸。\n\n**面试的时候要面向光源，不要背向光源。**\n\n![](https://uploadfiles.nowcoder.com/files/20240319/218396548_1710849539407/.jpg)\n\n这里有个小技巧教给大家，可以在面前放一盏台灯，能起到补光效果，人会看起来更精神。\n\n# 03 面试礼仪\n\n线下面试穿什么样子，线上也要穿得一样。\n\n尽量不要只打扮上半身，也就是上半身西装领带，下半身睡衣拖鞋。\n\n**一旦不小心起身暴露了自己，你和面试官，总有一个人会觉得尴尬。**\n\n![](https://uploadfiles.nowcoder.com/files/20240319/218396548_1710849539443/.jpg)\n\n此外，说话的时候要看着摄像头，当你看着摄像头的时候，面试官会觉得你跟他有眼神交流；\n\n**据调查，“视频面试有效的交流 55% 来自于面部和身体语言，38％ 来自于语音语调，7% 来自于说话内容。”**\n\n在视频面试中，忌无精打采，也不要“多动症”，比如频繁捋头发，摸鼻子下巴。\n\n**同时务必注意眼睛看镜头，而不是看屏幕。这样做的目的是跟面试官有眼神交流。**\n\n如果一直看着屏幕里的面试官，那么对方看到你一直是低着头的，缺少互动。\n\n# 04 主动！主动！\n\n1）主动选择面试时间\n\n有一些同学一打电话发现是面试官就很紧张，装作说我没空之类。\n\n就算你当下没有做好准备，也可以先告诉面试官\n“很抱歉现在不是很方便，是否可以约一个更适合的时间。比如今天下午2点，是否方便呢？”，主动去向面试官约时间，通常面试官都能表示理解。\n\n2）主动向面试官提出疑惑\n\n在面试过程中，如果对面试官的提问有疑惑，可以复述一遍提问，确保自己没有误解面试官的意思。\n\n另外在面试后，可以适当向面试官争取机会，表达自己强烈的意愿。\n\n# 05 复盘面试\n\n由于不受空间的限制，可能会存在一天多场面试的情况。\n\n那么问题来了，你记得清屏幕对面是哪家企业的hr吗？还记得自己投的什么岗位吗？\n\n所以，一份线上面试安排表十分重要。\n\n大家可以把自己接到的面试邀约，按照时间顺序依次记录，随时更新。\n\n记录表要包括几个内容：面试时间、面试平台/软件、应聘公司和岗位，以及岗位的基本职责要求。\n\n这也让自己便于复盘面试情况，查漏补缺。\n\n祝大家春招顺利！\n\n最后，欢迎来关注「林行学长」，聊聊职场，聊聊工作，聊聊生活，林行学长和你一起成长~\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599736205097394176?sourceSSR=users",
        "title": "美团笔试 美团实习 0304",
        "content": "笔试时间：2023年3月4日\n\n# 第一题\n\n### 题目：平滑值\n\n小红定义一个数组的平滑值为:任意两个相邻元素的差的绝对值的最大值。例如:数组[2,4,3,3]的平滑值为|2-4|=2。小红希望你构造一个长度为n的排列,满足排列的平滑值等于k。你能帮帮她吗?\n排列是指:长度为n的数组,1到n每个正整数都恰好出现1次。\n\n### 输入描述\n\n第一行输入两个正整数，分别表示n和k。其中，1≤k<n≤10^5\n\n### 输出描述\n\n输出n个数字，用空格隔开。输入 输出\n\n### 样例输入\n\n> 4 2\n\n### 样例输出\n\n> 1 3 2 4  \n\n### 参考题解\n\nC++：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    #include <iostream>\n    #include <vector>\n    using namespace std;\n    \n    int main() {\n        int n, k;\n        cin >> n >> k;\n    \n        vector<int> arr = {k + 1};\n        for (int i = 1; i <= k; i++) {\n            arr.push_back(i);\n        }\n        for (int j = k + 2; j <= n; j++) {\n            arr.push_back(j);\n        }\n    \n        for (int i : arr) {\n            cout << i << \" \";\n        }\n        \n        return 0;\n    }\n    \n\nJava：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    import java.util.Scanner;\n    import java.util.ArrayList;\n    \n    public class Main {\n        public static void main(String[] args) {\n            Scanner sc = new Scanner(System.in);\n            int n = sc.nextInt();\n            int k = sc.nextInt();\n    \n            ArrayList<Integer> arr = new ArrayList<>();\n            arr.add(k + 1);\n            for (int i = 1; i <= k; i++) {\n                arr.add(i);\n            }\n            for (int j = k + 2; j <= n; j++) {\n                arr.add(j);\n            }\n    \n            for (int i : arr) {\n                System.out.print(i + \" \");\n            }\n        }\n    }\n    \n\n# 第二题\n\n### 题目：p的倍数\n\n小红拿到了一个正整数n,她可以进行若干次操作，每次操作将选择一个数位,使其加1或者减1。不过有两条限制:\n\n1、每个数位最多只能操作一次。\n\n2、如果选择的是9，则无法进行加1操作。如果选择的是0,则无法进行减1操作。\n\n小红希望最终n成为p的倍数，你能帮小红输出操作结束后的整数n吗?\n\n### 输入描述\n\n两个正整数n和p。\n\n1≤n,p≤10^13\n\n### 输出描述\n\n如果误解，请输出-1。假设有多解的时候，输出任意解即可。（如果操作包含前导零，请将前导零一起输出）\n\n### 参考题解\n\nC++：[此代码未进行大量数据的测试，仅供参考]\n\n    \n    \n    #include <iostream>\n    #include <vector>\n    #include <string>\n    using namespace std;\n    \n    int n, p;\n    vector<int> arr;\n    int ans = -1;\n    \n    void dfs(int cur, int index) {\n        if \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599704748740083712?sourceSSR=users",
        "title": "腾讯视频-数据工程暑期实习一面",
        "content": "腾讯这次暑期实习没有笔试，做了测评之后，就发了面邀了，2024.03.19今天下午面试，时长一个半小时，面试官人很好，但是鼠鼠太菜了，G嘞，不过还是记录一下面试问题吧。\n\n1.聊了一下研究生的方向以及跟着导师做的项目，大概沟通了下。\n\n2.然后问了下实习经历，做了哪些事，遇到了哪些问题，怎么解决的。\n\n3.平时使用到哪些组件，然后问了一些八股：\n\n  * 有没有遇到数据量过大，导致代码运行时间慢的问题？做过哪些调优操作？我回答成数据倾斜方向的了，然后讲了数据倾斜怎么发生的，怎么解决，有点尬。。。\n  * kafka为什么可以实现高效传输数据，答：因为kafka零拷贝加页缓存。\n  * 页缓存是底层操作系统提供的PageCache功能，那他如果数据丢失了怎么办？答：我也不知道哇，数据定期持久化？\n  * 那为什么零拷贝呢，为什么不拷贝，不拷贝怎么知道传过来了哪些数据？答：因为应用层不关心数据，只要producer和consumer需要，他们自己去页缓存中读取。感觉也不太对~~~┭┮﹏┭┮\n  * Hbase了不了解，写入数据怎么写入到HDFS中的，既然是写入到Mem story，那在里边是以什么数据格式存储的？不会！！\n  * Hbase与ClickHouse和Redis各自的使用场景和功能介绍？\n  * Flink如何实现分布式快照？快照中保存的是什么？答：Flink实现分布式快照用的是CheckPoint检查点，通过发送barrier到各个算子，算子接收到barrier之后，保存自己的快照到HDFS中，最终所有的算子都保存完成之后，发送给checkpoint协调器，代表完成了，快照，包含了所有Task/Operator的状态。这样即使在应用出现异常挂掉时，也能通过恢复CheckPoint来\n  * 实现数据恢复。\n  * Flink怎么实现最少一次？如果快照完成之后，在传输的时候失败了会怎么办？Flink实现至少一次，跟传输失败是同样的，除了自身开启checkpoint，输入端像kafka也需要支持数据重放功能，像Flink保存消费数据的偏移量offset，这样就可以在故障重启后，提交offset来重新读取数据，这就是实现至少一次的保证。\n\nJava篇：\n\n  * Java的堆和栈有什么区别，各自的作用？\n  * Java的堆分为哪几种？新建一个实例化对象，会存储在什么位置，如果是一个特别大的呢？\u0013\n  * CAS什么意思？\n  * CAS与synchronized有什么区别？\n\n算法篇：\n\n写一个442. 数组中重复的数据\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599704604175073280?sourceSSR=users",
        "title": "网易云大前端实习",
        "content": "上来先做四道js题\n\nvar作用域\n\njs宏任务\n\npromise状态\n\npromise笔试题 看输出\n\nVue3和Vue2的区别\n\n响应式原理具体区别\n\nnexttick\n\n三栏布局flex实现\n\ncss3动画\n\n多个promise同时发送什么的 不记得了\n\nz relax （可能拼错了不知道是什么）\n\npromise和async await区别\n\n  \n\n  \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599699711045509120?sourceSSR=users",
        "title": "阿里云实习一面",
        "content": "1、介绍项目\n\n2、TCP三次握手，四次挥手\n\n3、客户端主动断开连接与服务端主动断开连接区别？\n\n4、TCP连接不能正常建立，发送什么样的报文关闭，reset？ reset会不会有ACK？\n\n5、TCP的拥塞控制\n\n6、滑动窗口会在发送端生效吗\n\n7、一个完整的http请求包含哪几部分？\n\n8、以什么方式确认HTTP请求已经结束了\n\n9、epoll与select区别\n\n10、同步/异步日志系统\n\n11、服务器并发问题\n\n12、Linux常见的锁\n\n13、UDP与TCP连接过程区别\n\n14、实现memcpy（）\n\n14、void几个字节\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599697195016757248?sourceSSR=users",
        "title": "实习面试经验分享",
        "content": "# 1、面试的语速\n\n可能大家面多了之后对于自我介绍和回答一些机械问题的时候，**语速会比较快，面试官可能听不清楚会导致沟通不畅** （腾讯面试官提醒的）\n\n# 2、常考知识点\n\n我这几天面了蚂蚁、腾讯、携程（虽然没有一个有消息的/(ㄒoㄒ)/~~），发现有几个每个人都会问的。并且最好对其中一到两个非常深入的了解\n\n## 2.1 concurrentHashmap\n\n扩容的操作、如何记录这个size的（腾讯问到了，我只说了用原子变量，但是好像可以分为多个cell）等\n\n## 2.2 JVM的垃圾回收\n\n需要注意的是最好深入**可达性算法、G1、以及跨代引用** 是怎么处理的\n\n## 2.3 三挥四握、流量控制、拥塞控制\n\n计算机网络最好都了解一下、特别是为什么三次挥手啊啥的。\n\n## 2.4 同步阻塞IO、同步非阻塞IO、异步IO\n\n了解每个的优点啥的（推荐非科班的补一下操作系统的相关知识、我目前还在学，但是记不住QAQ）\n\n# 3、如果说对某个知识点不会、还没写、或者哪一部分不熟悉、可以提问的时候直接说\n\n**比如腾讯面试官问我的时候、我直接说没看过Spring、SpringBoot的源码、他直接说不问了。最后反问的时候，我问面评、他说不会因为一两个知识点不会就pass啥的、他也希望他问的大家都能答出来、不会说不会什么就特意问什么。（面试官真好）。然后说，希望就是对一两个知识点有比较深入的了解，比如concurrenthashmap，或者G1垃圾回收器、或者某个部分。这样说明有一定的技术的专研精神。**\n\n# 4 祝大家都能拿到好的offer！！！\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599688566557503488?sourceSSR=users",
        "title": "阿里国际数字商业 校招笔试真题",
        "content": "9.15笔试\n\n阿里国际数字商业集团秋季2024届校园招聘在线笔试-工程-0918\n\n牛客 100min\n\n单选x8 多选x7（数据库、数据结构、计网、操作系统、linux、设计模式）、编程x3（20%、96.7%、3%）\n\n  * 小红拿到了一个01串，她有以下两种操作：1.选择一个字符取反，代价为x.2.选择两个相邻的字符同时取反，代价为y.小红想知道，自己将字符串变成全'0的最小代价是多少？字符取反，指的是1'变成0；'0变成1'。\n  * 小红有一个长度为几的数组，小红会进行q次操作，每次操作是以下三种操作之一：1.将下标为p的数置为x,即ap=x;2.将所有数加x,即a1=a1+x·,an=an+ti3.询问下标为p的数的值。\n  * 小红拿到了一棵树。所谓树，即m个节点、n-1条边的无向连通图。小红定义一张图的权值为：所有节点到1号节点的最短路长度之和。小红想知道，假设号节点和1号节点连一条边，生成的基环树的权值为多少？你需要回答从1到的答案。(i=1时可以视为不添加任何边)基环树定义：几个节点、几条边的图。基环树保证有且仅有一个环。本题中，所有的边均为无向边，且长度为1。\n\n多个部门简历评估挂\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599680392756465664?sourceSSR=users",
        "title": "3.19 京东测开实习一面 30min凉经",
        "content": "1.自我介绍（说自己是本硕都是计算机科班，基础扎实 [小丑][小丑]看后面面试流程感觉还不如不说这句话）\n\n2.Springboot IOC介绍一下\n\n3.bean的生命周期（不会，之前以为测开岗不太问Java框架的，就把时间都用背别的八股文了）\n\n3.JVM类加载过程说一下，如果是static变量呢？\n\n补充：说一下反射\n\n说一下sql查询语句执行慢如何排查？\n\n4.红黑树了解吗？（不太了解，知道的都说了）\n\n5.红黑树在Java中有什么应用（说了hashmap）\n\n6.中间件了解多少（说只了解redis）\n\n7.那你说一下redis（简历上没写redis，知道的都说了，也没说多少）\n\n8.redis底层数据结构知道吗（不知道，说可能类似Java的HashMap）\n\n9.说一下你了解的测试方法和流程\n\n10.场景：一个系统，如果它的某一模块做了改动，其他模块没变，而且测试时间比较紧张的话，如何去测？（不太会，说了自己的理解）\n\n11.自动化测试框架了解多少（没用过，说了点个人理解，他说你理解的主要还是UI测试，实际上还有接口自动化等等）\n\n12.一个bug 开发不认为是bug，怎么办\n\n13.对于测开岗将来的规划（我说是主要在业务方向发展，相对于技术，测试的业务能力更重要）\n\n14.闲聊\n\n听最后面试官介绍，这个测开好像是真测开，开发占比比较大，结果面试的时候我说自己想向业务测试方向发展 [小丑][小丑]不过我觉得问题应该不太大吧。。。\n\n计网、操作系统、Java基础、mysql一点没问，redis还没学，简历上也没写，结果一直问（因为看其他测试面经主要是问mysql）\n\n为什么感觉整体问的问题怪怪的，可能我太菜了。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599670168675020800?sourceSSR=users",
        "title": "海康威视前端实习面经（寄）",
        "content": "自我介绍\n\n项目，\n\n技术栈\n\nwebsocted的实现\n\n首先是websocket\n\nes6新特性\n\nlet const,箭头函数,解构赋值，map set，迭代器和生成器，类，默认参数，promise，模板字符串，symbol数据类型，模块化，\n\n解构赋值\n\narr = [1,2,3] arrmax = arr[2],arrmin = arr[0]\n\npromise\n\n三种状态padding，resolved，rejected。 实现异步，通过.then和.catch捕获异常。\n\npromise异步怎么实现同步\n\n用async和await。\n网络延时，下一个任务需要上一个异步任务的结果才能执行下一步操作，下一步必须要上一步的结果才能执行，网络请求有延时，为了保证下一步任务有数据，\n\n所以要阻塞。拿到异步\n\nwh 100px的垂直居中\n\ngrid flex ：justify-content：center。align-item\n\n组件间通信\n\nvuex,provide and inject,event bus\n\n跨域的方法以及优缺点\n\n同源策略：所谓同源就是url，主机号端口号相同。该策略是一种安全机制，确保限制一个网页文档如何来自于不同源的资源进行交互\n\n原因：域名和端口号不匹配\n\njsonp：操作简单，适合简单场景。只支持get请求\n\ncors：http请求都支持。需要服务端配合，不支持ie10以下\n\n代理服务器：解决复杂任务。增加服务器开销\n\nwebsocket：全双工，实时性，长链接。服务端和客户端都需要配置\n\n跨域资源共享：支持所有http，通过配置可以控制访问权限。需要服务端配合，不支持ie10以下\n\naxios常见配置项\n\nurl，method,params获取数据请求,data发送数据\n\nget，post区别：get没有post安全，因为url铭文。get的参数只能是ascii类型，get的参数包含在url中，post在request\nbody中。get会在浏览器有历史记录，\n\nget传递的参数长度在url有限制，只能进行url编码。但是其实本质都是tcp传输，只不过因为http规定，所以发送和请求。但是get其实发送一个包，data和http\nheader是一并发送，服务端返回200\n\npost发送两个包，先发http header 服务端返回100，再发data，返回200.firefox只发一个包\n\n深拷贝浅拷贝\n\n乾拷贝 clone，for，slice，运算符...，concat\n\n深拷贝：递归拷贝，clonedeep\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599687958135939072?sourceSSR=users",
        "title": "阿里控股-钉钉 校招面经",
        "content": "9.8投 爱橙、钉钉\n\n企业发展产品技术部简历评估挂\n\n9.28 钉钉一面\n\n1h\n\n  * 实习\n  * 操作系统的io介绍一下\n  * 红黑树\n  * 7层网络模型\n  * https的握手\n  * 负载均衡算法有哪些\n  * 数据库的三个范式\n  * 事务隔离级别\n  * 设计模式\n  * Spring aop的实现原理\n  * rabbitmq的组成结构\n  * redis有哪些数据结构 zset底层怎么实现 hash底层怎么实现\n  * jvm内存模型\n  * gc算法介绍一下\n  * 反问：钉钉智能人事，做人事saas系统和paas平台，挑战是流量比较大、流程复杂，tob的 需要抽象然后商业化\n\n挂了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599670034562150400?sourceSSR=users",
        "title": "海康威视前端实习面经",
        "content": "1自我介绍\n\n2项目介绍\n\nl3ocalstorage和senssionstorage(同时我也补充了sessionstorage)\n\n4css选择器都有哪些\n\n类，伪类，id，标签，通配符等等\n\n5这些选择器的权重\n\n肯定是行内权重最大，1k\n\n6盒子模型的理解\n\ncontent，margin，border，padding\n\n7手撕盒子垂直水平居中\n\n相对绝对定位，flex，grid都可以\n\n8手撕遍历数组\n\nfor，foreach，map，forin，forof，reduce等等\n\n反问\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599666493378379776?sourceSSR=users",
        "title": "度小满Java一面",
        "content": "  1. 项目\n  2. Java参数调优，MySQL调优，实习难点\n  3. 怎么解决幻读，MVCC\n  4. 意向锁（没打上，快速判断表里是否有记录被加锁）\n  5. For update加的什么锁\n  6. 缓存穿透，击穿，雪崩\n  7. 保证线程安全，synchronized，ReentrantLock公平吗，可重入吗\n  8. sleep和wait区别\n  9. volatile，OOM\n  10. 堆有哪些区域，划分规则，GC具体流程\n  11. 进入老年代条件，有没有例外\n  12. coding：最大正方形\n\n呱呱呱ggg，感觉打得还行啊，就是有点乱，很久没面试过了，但有这么差吗\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599664297735622656?sourceSSR=users",
        "title": "vivo 一面 面经 24春招 已凉",
        "content": "个人背景：本9海硕，一段本硕之间的一年工作经验，一段老外研究所实习\n\n岗位：算法架构工程师（AI方向）\n\nTL：3/12投递，3/12行测，3/13笔试，3/19一面，3/21进入人才库\n\n**一面：**\n\n时间：3/19，长度40分钟\n\n内容：\n\n  1. 自我介绍\n  2. 全程项目，简历上项目的每一条都被详细问到了\n  3. 结合项目问八股：\n  4. 数据库文件的底层实现\n  5. CAD软件文件的底层实现\n  6. 在工作中最常用的C++新特性，具体是怎么用的，回答了auto，for循环，智能指针，新的类型转换等。每一条都深入讲了好久。\n  7. 无手撕\n  8. 反问工作内容，一开始被这个岗的名字唬到了，实际这个岗并不是AI算法岗，是训练平台的开发岗\n\n感受：聊天氛围，面试官没有太咄咄逼人，整体算不上有难度，就是结合简历讲讲，面了这么多次简历都快背熟了。\n\n最后：3月21号上官网一看进人才库了，凉凉。这次春招vivo基本只招算法岗，看上去hc不超过100个，凉了也正常。看评论区有些牛友没怎么问八股技术反而进二面了，果然要不要某个人某种程度上看简历就决定了，高强度问技术或许只是没其他想问的凑时间罢了。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599669934897086464?sourceSSR=users",
        "title": "百度智慧云3.19一面前端面经（感觉得寄）",
        "content": "自我介绍\n\n项目介绍\n\nreact了解吗 没学过\n\nwebgl绘制 了解吗 不了解\n\najax的执行过程\n\najax的状态\n\najax如何取消请求，我回答响应拦截器\n\n又问具体怎么实现，说了个cancelToken\n\n事件循环说一下\n\n浏览器开启新的线程 不知道\n\necharts显示百万级别的数据用折线图显示，怎么优化处理\n\n页面崩溃的话怎么检查\n\n如果是后端问题呢？\n\n代码题多维数组，判断数组最大层深\n\n代码题给定正整数N，以及array数组，在数组中找出连续的元素求和的值>=给定的正整数\n\n问的太深了，很难\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599656502151999488?sourceSSR=users",
        "title": "阿里_银泰-java开发-暑期实习一面",
        "content": "  1. 自我介绍\n  2. 项目中mysql表分区讲一下\n  3. 分区后，范围查询是怎么个情况\n  4. 分区后，底层不是多个idb文件，那多个idb的事务怎么保证\n  5. MYSQL相关优化——答了建索引、避免回表查询\n  6. 回表查询讲一下\n  7. 加索引的原则\n  8. 联合索引的先后顺序\n  9. 索引下沉了解吗\n  10. Mysql怎么解决幻读——mvcc、间隙锁 https://blog.csdn.net/m0_71777195/article/details/128075397\n  11. Java jvm内存分区\n  12. 堆内部分为哪些区域（在垃圾回收维度\n  13. 永久代存放哪些东西\n  14. 多线程一般用在什么场景下——答了IO密集型还有CPU密集型\n  15. 操作系统在进行线程切换时会有哪些动作\n  16. 进程上下文包含哪些东西 https://easylearn.baidu.com/edu-page/tiangong/bgkdetail?id=b3eb82056c85ec3a87c2c5e6&fr=search\n  17. NIO、异步非阻塞io了解吗 https://blog.csdn.net/wsq_zqfl/article/details/114439613\n  18. 讲一下代码规范吧，平时你在写代码时的一些心得啊，可用性比较好的代码（高内聚低耦合\n  19. 编码规范中有个SOLID原则了解吗\n  20. 编程中遇到的比较困难的问题，将一下怎么解决的\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599662506709217280?sourceSSR=users",
        "title": "京东 一二面 面经 24春招 已凉",
        "content": "个人背景：本9海硕，一段本硕之间的一年工作经验，一段老外研究所实习\n\n岗位：数据开发\n（我投的后端开发，怎么给我转数据开发了，我还专门填了不接受职位调剂，还是被硬转了。转归转，但数据开发那些东西我是一点不会啊，看职位要求要熟悉java，但我是写C++的....希望二面能过吧）\n\nTL：3/6投递，3/7行测，3/16笔试，3/19一面，3/21二面\n\n**一面：**\n\n时间：3/19，长度50分钟\n\n内容：\n\n  1. 自我介绍\n  2. 拷打项目\n  3. C++的多态相比C的多态有什么优点\n  4. 模板编程的优缺点\n  5. 开发中遇到的最大难点\n  6. C++新特性\n  7. 手撕实现字典树，这玩意我之前从没做过，还好最后做出来了，写了几个用例一次就过\n\n感受：京东面试难度感觉中等偏难，尤其手撕我觉得有点不按套路，中间八股有一两个没答出来，可能要寄\n\n**二面：**\n\n时间：3/21，长度35分钟\n\n内容：\n\n  1. 自我介绍\n  2. 问项目，没有问的很深\n  3. 手撕时间字符串压缩存储\n  4. 口述算法，四则运算表达式怎么求值\n  5. 1000台服务器如何尽快同时打印hello world\n\n感受：面试不算难，但我算法刷的还不够熟，表达式求值只说了个大概思路。面完转头面试官就告诉我说京东有政策，本硕之间工作过不算校招生，我当时就绷不住了。又问是转社招了吗，说京东社招现在没hc，隐含意思是不能推进下去，挂了！说真的我当时是有点想骂人的，既然有这种政策，为啥一开始把我捞起来面试，一笔两面花了我多少时间去做去准备啊，我现在还在国外，二面是半夜四点爬起来面的，结果因为这种事挂了，无语。京东要是说面试本身没过还好，说因为应届生政策这种事挂了真挺窝火的，我寻思就是国企也只是要求最高学历后没有工作经历吧？\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599669825668911104?sourceSSR=users",
        "title": "字节商业部3.18前端实习面经(寄)",
        "content": "1自我介绍\n\n2项目介绍\n\n3前端存储\n\n4http缓存\n\n5ajax使用，其他传输方法\n\n6跨域怎么解决\n\n7盒模型\n\n8display：inline有margin吗\n\n9 原型链的题目\n\nwindow.name = \"ByteDance\";\n\nfunction A() {\n\nthis.name = -123;\n\n}\n\nA.prototype.getA = function() {\n\nconsole.log(this.name);\n\nreturn this.name+1;\n\n};\n\nlet a = new A();\n\nlet funcA = a.getA\n\nfuncA() 原型链的题目\n\nthis.name中的this指向什么\n\nfuncA() 输出什么\n\n10 手写一个数组展平，instanceof 和concat都可以实现\n\n没了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599653692412895232?sourceSSR=users",
        "title": "还剩5天！中行信息科技类笔试如何冲刺？",
        "content": "❗️重中之重❗️速去预约考点，3.19 10:00-3.21 10:00开放\n\n[冲]信息科技类笔试为行测➕英语➕计算机知识\n\n**一、行测**\n：推荐中公的《银行招聘考试一本通》，包含例题讲解和真题，时间紧的同学可以先做真题熟悉题型。学习一下各种类型题目的技巧。印象中还会有时政和中行特色题目，很多考场都会有阿姨在门口发资料，上面有时政和中行知识，大家可以早去一会看一看。\n\n秋招时政考了很多亚运会的知识。\n\n中行特色知识必会的包括成立时间，上市时间，简称。\n\n**二、英语** ：选词填空+完形+阅读，一本通中也有例题和真题，个人感觉不用花费太多时间准备，考试前一天练练手感就好。\n\n**三、计算机知识****：** 单选+多选，涉及面非常广，可参考考研408，包括数据结构，数据库，操作系统，编程填结果（java，c++），机器学习等等。\n\n**tips：**\n\n1\\. 注意时间分配，因为题量很大，所以每道题分值不高，不要在一道题上花费太多时间\n\n2\\. 注意题目是否可以回看，秋招时是可以回看的\n\n3\\. 带好准考证和身份证，缺一不可\n\n4\\. 计算机知识涉及面很广泛，如果来不及系统学习的同学，建议先做真题\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599652031372042240?sourceSSR=users",
        "title": "华为OD机考题，不定期更新！",
        "content": "3道算法题（2道100分+1道200分）刷leetcode hot100或者是csdn上的华为od题库都可以\n\n**常见考点**\n：字符串、树（例如5G网络建设）、贪心（例如停车位查找、座位调整）、二分查找（例如孙悟空吃蟠桃）、排列组合、递归、滑动窗口、双指南针、位运算、链表等\n\n**简单题型** ：\n\n字符串占比30%，分割匹配排序较多，数组运算题、排列组合、连续数列条件的匹配题型较多\n\n**困难题型** ：\n\n复杂的树、图、堆栈算法，考察最短路径、关键路径、图结果较多\n\n牛客上也有不少同学分享机考题目，可做参考，指路链接\n\n[https://www.nowcoder.com/users/314849604](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fusers%2F314849604)\n\n[https://www.nowcoder.com/users/644248237](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fusers%2F644248237)\n\n[https://www.nowcoder.com/users/63176848](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fusers%2F63176848)\n\n[https://www.nowcoder.com/users/323955696](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fusers%2F323955696)\n\n[https://www.nowcoder.com/discuss/599637628727705600?sourceSSR=search](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F599637628727705600%3FsourceSSR%3Dsearch)\n\n引流华为OD 面经\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599669608404074496?sourceSSR=users",
        "title": "得物3.16前端实习面经",
        "content": "自我介绍\n\n项目介绍\n\n为什么用的是vue2\n\n子组件怎么给父组件传递\n\n我顺便说了非父子的event bus(给自己埋坑)\n\nEventsBus的运行机制\n\nEventsBus的常用方法\n\n发布者订阅者模式\n\n为什么选择前端，我从实验室分工进行描述\n\n实验室的人数和分工情况(没想到问这个)\n\ncookie和localstorage区别(我补充了session storage)\n\n（cookie属于给自己挖坑）\n\ncookie使用场景\n\ncookie怎么传输给后端\n\n反问\n\n技术栈有什么 主要react，electron，node\n\n什么时候有消息 说不来\n\n全程不到15分钟就结束了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599650572370821120?sourceSSR=users",
        "title": "【暑期实习记录】腾讯oc",
        "content": "部门：实习基地 - 无意向 - csig腾讯云捞\n\nTimeLine\n\n**3.3 压线投递实习基地**\n\n**3.6 一面**\n\n主要深问项目，包括设计、困难点、亮点、迭代过程、对比、测试和部署等，然后问了一些相关的八股，一道简单sql和简单算法\n\n之后反问面试官他对应届生项目有什么看法，他说他就非常看重刚才问的那些点，主要体现思考（这是回答最好的一集\n\n**3.13 二面**\n\n嗯问MQ（因为我写了），然后好多场景题\n\n**3.14 云证 + HR面**\n\n主要问实习的收获、困难、和学校的对比，个人优势，项目挑战和收获\n\n**3.18 oc**\n\n**3.19 offer letter**\n\n总结：不知道为什么就两轮技术面，但是也挺好，感谢鹅，压力锐减\n\n![](https://uploadfiles.nowcoder.com/images/20240319/52709072_1710839746061/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599646319153516544?sourceSSR=users",
        "title": "美的结构工程师一面  秋招",
        "content": "美的，秋招投递的，最早的一批吧，当时记录在小🍠发的，现在转到这里  \n  \n1自我介绍  \n2制图软件相关  \n3个人实习项目经历  \n4项目相关  \n5你最大的优势 从哪体现出来的  \n6你认为这个岗位要具备哪些特征  \n7反问:接下来的面试情况，岗位的具体情况  \n8闲聊扯了一会儿，跟谁都喜欢闲扯[狗牛头]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599631603505152000?sourceSSR=users",
        "title": "长亭科技-安全服务实习生（渗透方向）面经（已offer）",
        "content": "一面（电话面试）\n\n  \n\n时间：20min\n\n  \n\n信息收集流程\n\n  \n\nsql注入修复方式\n\n  \n\n看你简历上xx渗透项目中有挖掘很多逻辑漏洞，介绍几个其中遇到的逻辑漏洞\n\n  \n\n在hvv中有对抗waf的经历吗？\n\n  \n\n你是如何绕过的\n\n  \n\n现你已经拿下一台内网堡垒机的普通权限，有什么思路\n\n  \n\n  \n\n  \n\n二面（视频面试）\n\n  \n\n时间：70min\n\n  \n\n介绍一个令你记忆犹新的渗透经历\n\n  \n\n红队打点思路（给你一个企业名怎么做信息收集和漏洞利用）\n\n  \n\n一个商城网站，会存在什么逻辑漏洞\n\n  \n\n怎么绕cdn\n\n  \n\nshiro反序列化漏洞原理\n\n  \n\nshiro550遇到有key无链怎么办\n\n  \n\nshiro框架的特征，550和721的区别\n\n  \n\n在hvv中常见什么框架（回答的springboot）\n\n  \n\nspringboot常见什么漏洞\n\n  \n\n遇到过env泄露吗\n\n  \n\nheapdump知道吗\n\n  \n\nfastjson高低版本的渗透的时候有什么不一样的地方\n\n  \n\n给一个struts2 的post，碰到一个有waf的点怎么去做\n\n  \n\n页面存在sql注入，上传webshell需要什么条件\n\n  \n\nmssql，mysql怎么提权\n\n  \n\n讲一下udf提权\n\n  \n\n使用过计划任务提权吗\n\n  \n\n你一般使用什么方式进行提权的\n\n  \n\n你刚才提到了使用专门的exp进行提权，查看补丁用什么命令\n\n  \n\n实战中隧道搭建你使用什么方式\n\n  \n\nFRP，IOX这些工具你不觉得动静太大吗？并且使用pingtunnel的流量很不稳定，有其他的方式吗？\n\n  \n\n内网渗透思路\n\n  \n\n你刚提到了Impacket，你用过里面的什么工具\n\n  \n\npsexec连接原理\n\n  \n\n有遇到mimikatz抓不到密码的情况吗？怎么解决的？\n\n  \n\n抓不到明文密码怎么喷洒\n\n  \n\nsmbexec工具传递有什么前提条件\n\n  \n\n黄金票据和白银票据有什么区别\n\n  \n\n用什么办法判断存在域\n\n  \n\n怎么锁定域控\n\n  \n\nExchange有了解吗？\n\n  \n\n如果遇到没有没有凭据的情况下有什么渗透思路吗？\n\n  \n\n有审计代码的经历吗？会追CC链吗？\n\n  \n\n还有一些忘了.....\n\n  \n\n总结：主要面试的是渗透/红队方向安服实习，一面主要针对web和项目经历在问。二面比较深入，内网的原理和代码审计都涉及到了（基本就是没问死就往死问）\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599626165711642624?sourceSSR=users",
        "title": "美团实习前端一面",
        "content": "很神奇，没考代码，面半小时就结束了。说是这个岗没二面。\n\n介绍之前实习时的项目\n\nvue2和vue3区别在哪\n\nvue3性能优化了的话，具体在哪里\n\nvue3的tree-shaking具体怎么shaking\n\n你开发时用vite不用webpack，两者区别在哪 用了热更新，两者都用了\n\n既然你说vite是用了原生浏览器导入，用的ES module，具体说说ES module\n\nvue-router具体怎么用\n\nvue的路由方式有两种，分别是什么。是哈希和history，分别讲讲原理。\n\n你讲遇到的困难时组件通信，说说父子组件通信的方法，好的除了ref还有什么。那么兄弟组件的通信方法呢？\n\n做项目过程中的挑战，你提到的这个bug，它的错误原因是什么\n\n学校里面平时怎么学习前端\n\n大概就你是提到一个专业名词，然后让你具体讲讲，说工作原理。\n\n上来一般第一个问题要说项目经历，然后藏点概念在里面，然后引着面试官问你这个概念相关。然而有时一挖深我就不行了...\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599617162306756608?sourceSSR=users",
        "title": "昆仑数智一面",
        "content": "面试主要根据简历来问，八股问的很少，全程围绕实习项目来问\n\n  1. 自我介绍\n  2. 实习项目介绍\n  3. 实习项目简历上写的挨个问\n  4. **线程池** 的参数，提交任务后线程池执行流程\n  5. **可重入** 解释（可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁）\n  6. springboot注解有哪些\n  7. MySQL优化、索引\n  8. 什么是**回表** （通过查询索引获得记录的主键，然后再通过主键查询数据表获取完整记录的过程）\n  9. MySQL增加内存参数\n  10. TCP/IP模型\n  11. HTTPS\n  12. Git提交前怎么做？（先拉取最新代码，解决完冲突再提交）\n  13. 实习做了哪些工作？做得怎么样？\n  14. 和其他人比你的优势是什么？（懵了）\n\n反问\n\n  1. 面试官说学的浅，基础一般\n  2. 公司做哪些业务的\n  3. 面试结果什么时候出\n\n第一次面试，有点紧张，回答的一塌糊涂，实习项目问的很多，很多都没考虑过，感觉凉了[牛泪]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599613098537906176?sourceSSR=users",
        "title": "用连续自然数之和来表达整数-Java-OD统一考试（C卷）",
        "content": "题目描述\n\n一个整数可以由连续的自然数之和来表示。给定一个整数，计算该整数有几种连续自然数之和的表达式，且打印出每种表达式。输入描述\n\n一个目标整数T (1 <=T<= 1000)输出描述\n\n该整数的所有表达式和表达式的个数。如果有多种表达式，输出要求为：自然数个数最少的表达式优先输出每个表达式中按自然数递增的顺序输出，具体的格式参见样例。在每个测试数据结束时，输出一行”Result:X”，其中X是最终的表达式个数。示例1\n输入输出示例仅供调试，后台判题数据一般不包含示例\n\n输入\n\n9\n\n输出\n\n9=9\n\n9=4+5\n\n9=2+3+4\n\nResult:3\n\n说明\n\n整数 9\n有三种表示方法，第1个表达式只有1个自然数，最先输出，第2个表达式有2个自然数，第2次序输出，第3个表达式有3个自然数，最后输出。每个表达式中的自然数都是按递增次序输出的。数字与符号之间无空格示例2\n输入输出示例仅供调试，后台判题数据一般不包含示例\n\n输入\n\n10\n\n输出\n\n10=10\n\n10=1+2+3+4\n\nResult:2\n\n    \n    \n    import java.util.Scanner;\n    import java.util.*;\n    import java.util.stream.Collectors;\n    import java.math.BigInteger;\n    import java.util.stream.Stream;\n    \n    class Main {\n        public static void main(String[] args) {\n            // 使用Scanner类读取标准输入\n            Scanner in = new Scanner(System.in);\n            // 读取输入的第一个整数，代表要进行拆分的目标数\n            int t = in.nextInt();\n            // 直接输出读取的数，用于验证输入是否正确\n            System.out.println(t + \"=\" + t);\n         \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599610479182475264?sourceSSR=users",
        "title": "杭州端点科技 Java实习 一面面经",
        "content": "**一般是没有写面经的习惯的，但是面试体验太好了，面试官人也超好，虽然已经过了几天了，但是还是想记录一下哈哈哈。**\n\n电话面试时长60分钟左右？\n\n首先一道简单难度的算法题。\n\n然后是自我介绍，还有接着问项目，大概有20分钟可能。\n\n**基础问题** ：\n\nJVM内存区域。\n\n常见垃圾回收算法，垃圾回收器。\n\n介绍CMS的回收流程。这一个没有回答的很好，但是面试官引导提示了最后还是大概说出来了。\n\nJVM调优经验。说了个案例，不过实际上不算JVM调优，整个是我自己对JVM调优的概念认知错了。\n\n是否了解AQS，核心实现。\n\nSynchronized底层实现，与ReentrantLock区别。这里答得不是很好。\n\n关于微服务组件在项目中的使用。\n\nSentinel的限流实现方式。这个不会，写在简历的中间件，真的需要了解一些内部核心细节。\n\nKakfa的数据结构组成，文件保存形式。\n\nMysql知道什么存储引擎？MyIsam和innodb区别？\n\nMySql特性，隔离性实现。\n\nMVCC的详细原理，RR和RC级别下的不同。\n\nRedis有什么数据结构？\n\nRedis为什么那么快？\n\n介绍一下Redis对数据结构的优化。\n\nover。面试体验非常好，所以写了第一篇面经记录。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599587634922516480?sourceSSR=users",
        "title": "京东技术产品经理一面面经",
        "content": "面完来写写面经积攒下人品wuwu\n\n为什么想做产品经理？\n\n怎么计算出来的简历上的成果数据？\n\n什么样的产品是一个好的产品？\n\n你认为什么样的产品是好的产品呢？\n\n你最近在学什么样的知识？\n\n你最近学的东西怎么服务于产品经理？\n\n毕业以后三到五年的路线？\n\n在生活或者学习中遇到的比较有挑战的工作？\n\n人员的协作方面有什么样的问题？\n\n有没有遇到过特别急迫要交付的经历？\n\n为自己设定要实现的目标？\n\nC端产品和B端产品有倾向吗？\n\n最近有没有接触一些新鲜的产品或者想法？\n\n如果你要做民宿该怎么去实行这个事情？\n\n\\---------------------------------------\n\n京东的面试体验巨好，面试官跟我娓娓道来，不时点头鼓励，很舒服的一次交流，希望能过吧\n\n\\---------------------------------------\n\n更新一下，一面过啦！进HR面了，来牛客许个愿希望HR面也能过wuwuwuwuwu\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599585936141316096?sourceSSR=users",
        "title": "共致开源 面经",
        "content": "共致开源 一面（电话面 --面经）\n\n自我介绍\n\n校内生活\n\n校外实习\n\njava方面：\n\n线程+锁子（synchronized 和lock的区别？）\n\nString 对象创建+Integer对象的比较\n\nSpring的AOP 应用场景\n\nSpring的 IOC\n\nSpringSecurity 流程 以及关键类\n\n事务的失效场景？ 记住一点：生成代理类才有效\n\nmybatis-plus的特殊机制相较于 mybatis（逻辑删除）\n\n集群中的注册中心： zk和nacos nacos和eureka的区别 优缺点\n\nFlink的应用场景\n\nlinux操作：\n\n权限设置 chmod\n\n读取文本以及必要的复制粘贴工作\n\ndocker部署\n\n数据库：\n\nmysql：\n\n场景题目：mysql 中数据量大 分页查询， 2000w以后的10条数据，id自增，name， 时间；如何优化？\n\nredis\n\n持久化策略 aof和RDB\n\n重启时候的持久化机制\n\n最终一致性策略\n\nredis 为什么快\n\n缓存\n\n数据结构\n\nSDS 简单动态字符串\n\n单线程模型 ， 避免锁竞争\n\nredsi节点启动加载顺序\n\n注意：在同时开启rdb和aof持久化时，重启时只会加载aof持久化文件，不会加载rdb持久化文件。\n\nRocketMQ\n\n应用场景\n\n信息丢失的场景以及处理方案 （自带事务机制+异步刷盘-->同步刷盘）\n\n重复消费的问题 offset+消息发送时异常\n\n（比如生产者发送消息的时候使用了重试机制，发送消息后由于网络原因没有收到MQ的响应信息，报了个超时异常，然后又去重新发送了一次消息）\n\n多数据源匹配\n\nspring:\n\n  datasource:\n\n    example:\n\n      type: com.alibaba.druid.pool.DruidDataSource\n\n      driver-class-name: com.mysql.jdbc.Driver\n\n      url: jdbc:mysql://localhost:3306/example\n\n      username: root\n\n      password: 123456\n\n    test:\n\n      type: com.alibaba.druid.pool.DruidDataSource\n\n      driver-class-name: com.mysql.jdbc.Driver\n\n      url: jdbc:mysql://localhost:3306/test\n\n      username: root\n\n      password: 123456\n\n反问part：\n\n具体的工作内容\n\n几轮面试\n\npd 和mysql 除了非结构化的处理方式区别， 在技术选型中考量什么？\n\n政策，公司， 开源， 国产替换；sql语言类似，查询函数不同\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599575331401371648?sourceSSR=users",
        "title": "腾讯CSIG暑期实习前端一面",
        "content": "3.4投递 3.13一面改时间到3.19\n\n面试不难，少八股，但是没准备好答得很差\n\n1\\. 自我介绍\n\n2\\. 为什么学前端（最烦这问题…）\n\n3\\. 介绍一下项目，自己项目里有什么难点\n\n4\\. 为什么离职？\n\n5\\. 职业规划？\n\n6\\. 怎么性能优化？如果国外用户打开国内网站怎么优化？（前面提到了性能优化）\n\n7\\. 怎么和后端协同开发？\n\n8\\. 怎么mock数据\n\n9\\. 登陆问题cookie jwt\n\n10\\. 做三道题（但我只看到两道就只做了两道）\n\n11\\. 写一个sleep函数\n\n12\\. 这个错误是啥（中途写了个错误…在顶级模块用了await ）\n\n13\\. Async返回什么\n\n14\\. 箭头函数和普通函数区别（写了箭头函数）\n\n15\\. 我写的函数this指向哪里（前面提到）\n\n16\\. 写一个把对象值里的http替换成https\n\n看错题目了，过程面试官一直在提示，比如考虑对象嵌套，考虑怎么识别url\n\n  \n\n25届暑期第一面，一直在上班没时间复习，要开始查缺补漏了qaq\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599574075647725568?sourceSSR=users",
        "title": "4399 3月19日的java笔试 算法题",
        "content": "三道算题均只能提交样例 思路不一定对\n\n1.有n座基地并排相连，每座基地有一定数额的财宝，对应一定的价值。一个小偷可以拿走任意座基地的财宝，为了不被发现他不能拿走相邻基地的财宝。求出它可以获得的最大财报价值。\n\n    \n    \n    public class Main {\n        public static void main(String[] args) {\n            Scanner in = new Scanner(System.in);\n            String[] data = in.nextLine().split(\",\");\n            data[data.length - 1] = data[data.length - 1].trim();//去掉最后一个数后可能会有的空格\n            int[] nums = new int[data.length + 5];\n            for (int i = 0; i < data.length; ++i) {\n                nums[i + 1] = Integer.parseInt(data[i]);\n            }\n            int[] get = new int[data.length + 5];\n            int result = 0;\n    \t\t//首先拿取的基地的价值要相邻周围基地的价值\n            for (int i = 1; i <= data.length; ++i) {\n                if (nums[i] > nums[i - 1] + nums[i + 1]) {\n                    result += nums[i];\n                    get[i] = 1;\n                }\n            }\n    \t\t//然后拿取一下剩余还可以拿的其它基地的价值\n            for (int i = 1; i <= data.length; ++i) {\n                if (get[i] != 1 && get[i - 1] != 1 && get[i + 1] != 1) {\n                    result += nums[i];\n                    get[i] = 1;\n                }\n            }\n            System.out.println(result);\n    \n        }\n    \n\n2.一个大数a减去一个大数b（a>=b），用字符串来接收数据，然后计算a-b的结果。\n\n    \n    \n    public class Main {\n        public static void main(String[] args) {\n            Scanner in = new Scanner(System.in);\n            String a=in.next();\n            String b=in.next();\n            int la=a.length();\n            int lb=b.length();\n            int[] A=new int[la+1];\n            int[] B=new int[lb+1];\n            for (int i = 1; i <= la; i++) A[i]=Integer.parseInt(\"\"+a.charAt(i-1));\n            for (int i = 1; i <= lb; i++) B[i]=Integer.parseInt(\"\"+b.charAt(i-1));\n            int result=0;\n            int p=1;\n    \t\t//手算加减法的模拟\n            for (int i = la,j=lb; i >=1&&j>=1; i--,j--) {\n                int temp=A[i]-B[j];\n                if(temp>=0) result+=p*temp;\n                else {\n                    int k=i-1;\n                    while (k>=1){\n                        if (A[k]>0) {\n                            A[k++]--;\n                            while(k!=i) {\n                                A[k++]+=9;\n                            }\n                            A[k]+=10;\n                            result+=p*(A[k]-B[j]);\n                            break;\n                        }\n                        else --k;\n                    }\n                }\n                p=p*10;\n            }\n            System.out.println(result);\n    \n\n3.有n+1座基地，从0到n编号，从1号基地到n号基地每座基地有一定的高度。一个人位于第0号基地,他的初始能量为E，他需要从0号基地逐个跳到第n号基地。如果下一座要跳的第i号基地的高度比自身的能量E大，那么他会损失（height[i]-E）的能量，反之他会获得（E-height[i]）的能量。在跳至n号基地的过程中，他的E值不能为负数，求出满足题意的最小能量值。\n\n    \n    \n    public class Main10 {\n        public static void main(String[] args) {\n            Scanner in = new Scanner(System.in);\n            int n=in.nextInt();\n            int[] height=new int[n+5];\n            int maxHeight=0;\n            for (int i = 1; i <=n; i++) {\n                height[i]=in.nextInt();\n                maxHeight=Math.max(maxHeight,height[i]);\n            }\n    \n    \t\t//可以用二分找出满足条件的最小值\n            int left=0,right=maxHeight;\n            int result=right;\n            while (left<right){\n                int mid=(left+right)>>1;\n                int curE=mid;\n                boolean flag=true;\n                for(int i=1;i<=n;++i){\n                    if (mid>=height[i]) mid+=mid-height[i];\n                    else mid-=height[i]-mid;\n                    if (mid<0) {\n                        flag=false;\n                        break;\n                    }\n                }\n                if (flag) {\n                    result=Math.min(result,curE);\n                    right=mid;\n                }else {\n                    left=curE+1;\n                }\n    \n            }\n            System.out.println(result);\n        }\n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599571948808564736?sourceSSR=users",
        "title": "2年测试岗面经--发帖子攒人品",
        "content": "社招岗位，base北京，开到13k（外包，应该是可以argue到14但是不想去 终止流程了）\n\n整体问题比较偏重于业务，没问算法题。\n\n#### **一面一小时：**\n\n1\\. 介绍下自己\n\n2\\. 介绍项目，项目分为哪些模块以及各个模块之间的关系、使用的中间件\n\n3\\. 你负责模块的用户业务流程说一下\n\n4\\. 作为测试你在一个迭代的全部工作\n\n5\\. 你们的自动化是平台还是自己搭？\n\n6\\. 为什么要重构这个自动化？意义是什么？\n\n7\\. 自动化有没有发现什么比较严重的问题？\n\n8\\. CICD怎么做的？ 你参与了多少？\n\n9\\. 学物联网为什么做测试？\n\n10\\. 数据库你熟哈？工作常用的sql有什么？\n\n11\\. 力扣sql题 筛选各科都及格的学生\n\n12\\. 接触过慢查询吗？如何排查慢查询以及解决方式？ --说了索引失效的情况以及使用explain\n\n13\\. 有做过关于边界值的测试吗？\n\n14\\. 了解项目的缓存吗？ Redis缓存雪崩？\n\n15\\. session和cookie的具体区别？\n\n16\\. 了解关系数据库和非关系型数据库吗？ 区别是什么？\n\n17\\. get和post的区别？\n\n18\\. Linux命令常用的场景，常用的命令是什么？\n\n19\\. 查第十行的log\n\n20\\. python的数据结构有哪些？\n\n21\\. 装饰器和生成器用过吗？\n\n22\\. pytest的fixture是用什么实现前置后置步骤的？\n\n23\\. 发红包测试用例\n\n24\\. 反问 --业务内容，人员构成\n\n#### **二面50分钟：**\n\n1\\. 过往的两段项目的测试重点和难点，以及测试人员在其中起的作用。\n\n2\\. 第一段做微服务迁移，你的工作亮点是什么？\n--迁移过程不但保证原有业务完整平稳也修正了一些历史bug、统一了接口规范，追问你能举个具体历史问题的例子吗？\n\n3\\. 你们的拆分是基于什么排期原则拆分呢？原本的架构是什么，拆分后的架构是什么？\n\n4\\. 第二段做出海平台，你的测试难点是什么？针对难点有没有整合出一些方法论？\n--提到进度管理里营销视频非常规状态的展示容易出问题，追问这是产品层面该决策的问题，为什么评审环节没有明确而是测试流程中再倒逼开发统一？\n\n5\\. 你所在的流程化这个模块，在进度管理的时候只是摆出客观的数据，还是针对数据有投放情况分析和建议这种功能呢？ --目前只有客观功能，投放分析需求在排期\n\n6\\. 项目有没有出过严重的问题？以及如何响应解决的。\n--提到线上用户登录的问题、定位过程和推动解决，追问这个问题以前没有出现吗？--刚刚修改过配置就被自动化复现然后解决了。\n\n7\\. 你们的自动化是什么执行策略？每次迭代的时候上还是日常轮检？如果有不稳定出现的问题呢？\n\n8\\. 你觉得做自动化的意义？除了你自己负责模块的用例，对公共模块还参与了什么？\n\n9\\. 提到CICD建设，你做的工作只是在flow里进行了一些简单的配置吗？ --还有不同环节下不同测试范围以及异常情况的回调配置。\n\n10\\. 针对简历里压测的部分，很具体问了有关压测的需求背景、目标、关注点、以及如何设计的压测计划。\n\n11\\. 搭建压测环境的时候，怎么认定模拟环境的测试结果也能符合线上的预期？\n--按比例缩小集群环境来模拟，追问业务逻辑可以缩小但是基层数据呢？回答用ES影子库，来自测试机器ip的请求代理到影子库，不会对线上环境产生影响。\n\n12\\. 项目里互相依赖的上下游之间是怎么划分测试区域的？对于业务传递过程中非常规的场景测试如何覆盖的？\n\n好运好运接心仪offer！看到帖子的家人成功涨薪上岸！\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599570860160184320?sourceSSR=users",
        "title": "快手数据分析面经｜快手电商实习",
        "content": "[面试必过]【快手电商数据分析实习面经】\n\n1️⃣自我介绍\n\n2️⃣现场写SQL给定date（日期）,user_id（打赏人）,author_id（主播）,total_cost（打赏金额），求总打赏金额超过100000的打赏人中，打赏金额前3名的主播id和打赏给他们的总金额\n\n3️⃣讲一个实习中的项目\n\n4️⃣GMV环比上周下降20%，从哪些原因分析？\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599569106760634368?sourceSSR=users",
        "title": "给我拷打红温了，24校招字节跳动-测试开发工程师二面（下）",
        "content": "**大家好，我是chowley**\n\n本篇来记录一下我之前参加「字节跳动」-「测试开发工程师」的第二次技术面试过程，针对其中一些问题给出了我的答案。\n\n部门：番茄小说-shenzhen\n\n时间：50min\n\n平台：飞书\n\n## 过程\n\n  14. ADB辅助测试活动做了哪些？\n\na. 安装和卸载应用程序： 可以使用ADB命令安装和卸载应用程序。\n\nb. 启动和停止应用程序： 可以使用ADB命令启动和停止应用程序。\n\nc. 发送键事件： 可以使用ADB命令发送各种键事件，如点击、滑动等，以模拟用户操作。\n\nd. 录制和回放操作： 可以使用ADB命令录制用户操作，并进行回放，用于自动化测试。\n\ne. 查看日志信息： 可以使用ADB命令查看设备和应用程序的日志信息，用于排查问题和分析性能。\n\nf. 文件传输： 可以使用ADB命令在设备和计算机之间传输文件。\n\n  15. ADB监控活动怎么做的？啥命令？ADB push /install\n\na. 查看设备状态：adb devices，用于查看设备是否连接。\n\nb. 查看设备日志：adb logcat，用于查看设备的日志信息。\n\nc. 监控应用程序内存使用情况：adb shell dumpsys meminfo <package_name>，用于查看指定应用程序的内存使用情况。\n\nd. 监控应用程序CPU使用情况：adb shell top -n 1 | grep <package_name>，用于查看指定应用程序的CPU使用情况。\n\ne. 监控应用程序启动时间：adb shell am start -W <package_name>，用于查看指定应用程序的启动时间。\n\nf. 监控应用程序网络使用情况：adb shell dumpsys netstats detail | grep <package_name>，用于查看指定应用程序的网络使用情况。\n\n  16. ADB是消息通道\n\n  17. 监听了哪些操作？\n\na. 日志信息： 使用adb logcat命令可以监听设备的日志信息，包括应用程序的运行日志、系统日志等。\n\nb. 事件信息： 使用adb shell getevent命令可以监听设备的事件信息，如触摸事件、按键事件等。\n\nc. 网络状态： 使用adb shell dumpsys netstats命令可以监听设备的网络状态，包括网络使用情况等。\n\nd. 应用程序状态： 使用adb shell dumpsys activity命令可以监听设备上应用程序的状态，如运行状态、堆栈信息等。\n\ne. 内存信息： 使用adb shell dumpsys meminfo命令可以监听设备的内存使用情况，包括应用程序的内存占用情况等。\n\n  18. 游戏发版流程咋做的？\n\na. 版本规划： 确定新版本的功能和改进，制定版本开发计划。\n\nb. 开发与测试： 开发团队根据规划实现新功能，并进行内部测试，包括单元测试、集成测试和系统测试。\n\nc. 灰度测试： 将新版本部分用户，通常是小部分用户，进行测试，以确保新版本稳定性和兼容性。\n\nd. 发布： 将通过测试的新版本发布到线上环境，供所有用户下载和使用。\n\ne. 监控与反馈： 发布后，持续监控新版本的性能和用户反馈，及时处理bug和问题。\n\nf. 迭代优化： 根据监控和反馈结果，进行版本迭代和优化，不断提升用户体验和产品质量。\n\n  19. Android是咋控制百分之5的灰度？\n\n通过Google Play\nConsole的发布管理功能实现。在发布新版本时，可以选择将新版本发布给指定的一小部分用户，从而进行灰度测试。随后，根据测试结果，可以逐步增加灰度比例，直至完全发布给所有用户。\n\n  20. 怎么实现灰度放量？\n\na. 确定放量策略： 确定放量的比例和递增步长，如每天增加百分之5的用户。\n\nb. 监控和反馈： 放量后，持续监控新版本的性能和用户反馈，及时发现和解决问题。\n\nc. 逐步增加比例： 根据监控和反馈结果，逐步增加放量比例，直至完全发布给所有用户。\n\nd. 紧急回滚： 如果放量过程中发现严重问题，及时回滚到上一个稳定版本。\n\n  21. 分发用户，在技术上的操作？\n\na. 用户分组： 根据需求和策略，将用户分为不同的组别，如测试用户组、内部员工组、外部用户组等。\n\nb. 版本控制： 确定要发布的版本，并控制版本的发布时间和范围。\n\nc. 分发方式： 根据分组情况选择合适的分发方式，可以是通过应用商店（如Google Play、App Store）、推送服务（如Firebase\nCloud Messaging、APNs）等方式进行分发。\n\nd. 发布控制： 控制发布的速度和范围，可以采用灰度发布、AB测试等方式逐步扩大发布范围。\n\ne. 监控和反馈： 发布后持续监控用户的使用情况和反馈，及时处理问题和改进。\n\n  22. 灰度系统是咋实现的？\n\na. 分布式系统设计： 灰度发布需要考虑分布式系统的设计和部署，保证灰度发布的可靠性和稳定性。\n\nb. 流量控制： 通过流量控制和负载均衡技术，控制不同灰度发布阶段的流量比例。\n\nc. 动态配置： 使用动态配置管理工具，实现灵活的灰度发布策略和配置管理。\n\nd. 监控和反馈： 使用监控工具和数据分析技术，实时监控灰度发布的效果和用户反馈，及时调整发布策略。\n\n  23. hotfix发版是版本覆盖还是动态插件下发的形式？\n\nhotfix发版通常是版本覆盖的形式。在发现线上问题需要紧急修复时，开发人员会进行代码修复并生成新的版本，然后通过版本覆盖的方式将修复后的版本发布到线上，以快速解决问题。\n\n  24. 手撕：三数之和\n\n  25. 反问\n\n## 总结\n\n难度：4/5，面试官从我的经历入手，持续询问底层原理，如果不是真的有切身体会和研究，真的很难给出满意的答案\n\n面试官专业程度：专业，技术覆盖面很广，对我的经历形成了全包围\n\n体验打分：4/5，虽然被拷打的浑身发热，但这次经历让我对过去的经历有了更清晰的认识，也知道了自己应该在哪方面继续加强，感谢！\n\n**好了，以上就是本文的全部内容，如有问题可留言讨论。**\n\n**本人正在组建校招测试开发方向的交流社区，如果您对测试求职方面感兴趣，欢迎加入了解。**\n\n**我是chowley，一个专注互联网技术和产品质量保障领域的博主，我们下次再见！**\n\n**欢迎点赞、评论、收藏，it's important for me.**\n\n**Searching for QALog.**\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599568435944624128?sourceSSR=users",
        "title": "网易（外包）",
        "content": "三消项目，最近心情不太好，没准备\n\n  1. 自我介绍（卡壳）\n  2. 针对游戏策划经历及求职意向询问\n  3. 询问关卡设计\n  4. 玩过什么三消游戏\n  5. 对三消游戏的关卡了解\n  6. 开心消消乐的优点或者不足\n  7. 开心消消乐的障碍有哪些比较有意思\n  8. 设计一个障碍\n  9. 反问环节\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599562484881661952?sourceSSR=users",
        "title": "学生重新排队-java-OD统一考试（C卷）",
        "content": "# 题目描述\n\nn 个学生排成一排，学生编号分别是 1 到 n，n 为 3 的整倍数。\n\n老师随机抽签决定将所有学生分成 m 个 3 人的小组（n == 3 * m） ，\n\n为了便于同组学生交流，老师决定将小组成员安排到一起，也就是同组成员彼此相连，同组任意两个成员之间无其它组的成员。\n\n因此老师决定调整队伍，老师每次可以调整任何一名学生到队伍的任意位置，计为调整了一次， 请计算最少调整多少次可以达到目标。\n\n注意：对于小组之间没有顺序要求，同组学生之间没有顺序要求。\n\n# 输入描述：\n\n两行字符串，空格分隔表示不同的学生编号。\n\n第一行是学生目前排队情况第二行是随机抽签分组情况，从左开始每 3 个元素为一组n 为学生的数量，n 的范围为 [3, 900]，n 一定为 3 的整数倍\n\n第一行和第二行元素的个数一定相同\n\n# 输出描述\n\n老师调整学生达到同组彼此相连的最小调整次数\n\n# 备注：\n\n同组相连：同组任意两个成员之间无其他组的成员，比如有两个小组 [4, 5, 6] 和 [1, 2, 3]，\n\n以下结果都满足要求：\n\n1,2,3,4,5,6；\n\n1,3,2,4,5,6；\n\n2,3,1,5,6,4；\n\n5,6,4,1,2,3；\n\n以下结果不满足要求：\n\n1,2,4,3,5,6；（4与5之间存在其他组的成员3）\n\n# 示例1：\n\n输入：\n\n    \n    \n    4 2 8 5 3 6 1 9 7\n    6 3 1 2 4 8 7 9 5\n    \n\n输出：\n\n1\n\n说明：\n\n分组为[6,3,1],[2,4,8],[7,9,5]，那么初始排序中，只需要将5移到1后面即可\n\n428 361 597即可满足要求，只需要一次调整。\n\n# 示例2：\n\n输入：\n\n    \n    \n    8 9 7 5 6 3 2 1 4\n    7 8 9 4 2 1 3 5 6\n    \n\n输出：\n\n0\n\n# 示例3：\n\n输入：\n\n    \n    \n    7 9 8 5 6 4 2 1 3\n    7 8 9 4 2 1 3 5 6\n    \n\n输出：\n\n1\n\n    \n    \n    import java.util.Scanner;\n    import java.util.*;\n    import java.util.stream.Stream;\n    import java.util.HashMap;\n    import java.util.regex.Matcher;\n    import java.util.regex.Pattern;\n    import java.util.stream.Collectors;\n    \n    public class Main {\n        // 当前顺序列表\n        public static List<Integer> cur_order = new ArrayList<>();\n        // 最终顺序列表\n        public static List<Integer> final_order= new ArrayList<>();\n        // 标记列表，用于记录每个组的移动状态\n        public static List<Integer> order_flags= new ArrayList<>();\n        // 学生总数\n        public static int n=0;\n        // 学生编号与组号的映射关系\n        public static Map<Integer, Integer> relations=new HashMap<>(); \n        // 记录操作次数的结果\n        public static int result = 0;\n        \n        // 检查当前的顺序是否每三个学生都在同一个组内\n        public static boolean check_order(){\n            for (int i = 0; i < cur_order.size(); i += 3) {\n                if (!(relations.get(cur_order.get(i)) == relations.get(cur_order.get(i + 1)) && \n                    relations.get(cur_order.get(i)) == relations.get(cur_order.get(i + 2)))){\n                    return false;\n                }\n            }\n            return true;\n        }\n        \n        // 移动学生的位置\n        public static void move(int cur_student, int remove_index, int append_index){\n            if (relations.get(cur_order.get(remove_index)) == relations.get(cur_student)) {\n                int remove_element = cur_order.get(remove_index);\n                cur_order.remove(remove_index);\n                cur_order.add(append_index, remove_element);\n            }\n        }\n        \n        // 执行两步移动操作\n        public static void two_step_move(){\n            for (int i =\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599560893734690816?sourceSSR=users",
        "title": "任务处理-Java-OD统一考试（C卷）",
        "content": "# 题目描述：\n\n在某个项目中有多个任务（用 tasks 数组表示）需要您进行处理，其中 tasks[i] = [si, ei]，你可以在 si <= day <= ei\n中的任意一天处理该任务。请返回你可以处理的最大任务数。\n\n注：一天可以完成一个任务的处理。\n\n# 输入描述：\n\n第一行为任务数量 n，1 <= n <= 100000。后面 n 行表示各个任务的开始时间和终止时间，用 si 和 ei 表示，1 <= si <= ei\n<= 100000。\n\n# 输出描述：\n\n输出为一个整数，表示可以处理的最大任务数。\n\n# 示例1\n\n输入：\n\n    \n    \n    3\n    1 1\n    1 2\n    1 3\n    \n\n输出：\n\n3\n\n说明：\n\n第一天处理任务 1，第二天处理任务 2，第三天处理任务 3。\n\n    \n    \n    import java.util.*;\n     \n     \n    public class Main {\n        publi\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599560057759469568?sourceSSR=users",
        "title": "电脑病毒感染-java-华为OD统一考试（C卷）",
        "content": "> OD统一考试（C卷）\n>\n> 分值： 100分\n>\n> 题解： Java\n\n![](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n题目描述：\n\n一个局域网内有很多台电脑，分别标注为0 -\nN-1的数字。相连接的电脑距离不一样，所以感染时间不一样，感染时间用t表示。其中网络内一个电脑被病毒感染，其感染网络内所有的电脑需要最少需要多长时间。如果最后有电脑不会感染，则返回-1给定一个数组times表示一个电脑把相邻电脑感染所用的时间。如图：path[i]=\n{i,j, t} 表示电脑i->j 电脑i上的病毒感染j，需要时间t。输入描述：\n\n432 1 12 3 13 4 12\n\n输出描述：\n\n2\n\n补充说明：\n\n第一个参数:局域网内电脑个数N 1<=N<=200;第二个参数：总共多少条网络连接第三个 1 2 1\n表示1->2时间为1第七行：表示病毒最开始所在的电脑号1\n\n示例1\n\n输入：\n\n    \n    \n    4\n    3\n    2 1 1\n    2 3 1\n    3 4 1\n    2\n    \n\n输出：\n\n2\n\n    \n    \n    import java.util.*;\n     \n    public class Main {\n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n     \n            int computer_nums = Integer.parseInt(scanner.nextLine().trim());\n            int link_nums = Integer.parseInt(scanner.nextLine().trim());\n            Map<Integer, List<int[]>> network = new HashMap<>();\n     \n            for (int item = 0; item < link_nums; item++) {\n                String line = scanner.nextLine().trim();\n                String[] values = line.split(\" \");\n                int i = Integer.parseInt(values[0]);\n                int j = Integer.parseInt(values[1]);\n                int k = Integer.parseInt(values[2]);\n     \n                if (network.cont\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599558732590202880?sourceSSR=users",
        "title": "海康威视前端实习 （用的是angular，去学这个有用吗？）",
        "content": "flex布局方法\n\ncss盒子模型\n\njs数组方法\n\n怎么判断是不是数组\n\njs闭包 闭包常见使用场景\n\njs原型\n\nthis指向\n\nmvvm框架\n\n防抖和节流 怎么实现\n\nhttp常见状态码\n\n404是客户端错误为什么找不到服务器资源？\n\n浏览器输入url的全过程\n\n了解less吗 主要用来做什么\n\n可以转angular吗\n\n  \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599554680632504320?sourceSSR=users",
        "title": "二战腾讯云一面面试",
        "content": "第一次面被挂后三天后被捞面\n\n**和项目非常相关**\n\n1.常规自我介绍，问实习中做的事情和思考\n\n2.介绍一下LRU缓存，在实际场景下需要考虑的问题\n\n3.如果两个LRU节点同时被访问到，会发生什么\n\n4.redis如何保证与数据库的一致性\n\n5.java中string如果需要频繁修改的情况下应该怎么做（StringBuffer和StringBuilder）\n\n6.如何使用zookeeper进行服务注册\n\n7.netty中沾包问题\n\n8.raft节点如何进行选举的\n\n9.项目中为什么会使用threadLocal\n\n10.大文件排序问题（内存不够采用外排）\n\n11.算法题：无重复字符的最大子串\n\n  \n\n更新：已约二面\n\n  \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599540710571773952?sourceSSR=users",
        "title": "最多购买宝石数目 - 华为OD统一考试",
        "content": "> OD统一考试（C卷）\n>\n> 分值： 100分\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n橱窗里有一排宝石，不同的宝石对应不同的价格，宝石的价格标记为 gems[i],0<=i<n, n = gems.length\n\n宝石可同时出售0个或多个，如果同时出售多个，则要求出售的宝石编号连续；\n\n例如客户最大购买宝石个数为m，购买的宝石编号必须为gems[i],gems[i+1]...gems[i+m-1](0<=i<n,m<=n)\n\n假设你当前拥有总面值为value的钱，请问最多能购买到多少个宝石,如无法购买宝石，则返回 0。\n\n## 输入描述\n\n第一行输入n，参数类型为int，取值范围：[0,10^6]，表示橱窗中宝石的总数量。\n\n之后n行分别表示从第0个到第n-1个宝石的价格，即gems[0]到gems[n-1]的价格，类型为int，取值范围：(0,1000]。\n\n之后一行输入v，类型为int，取值范围：[0,10^9]表示你拥有的钱。\n\n## 输出描述\n\n输出int类型的返回值，表示最大可购买的宝石数量。\n\n## 示例1\n\n    \n    \n    输入：\n    7\n    8\n    4\n    6\n    3\n    1\n    6\n    7\n    10\n    \n    输出：\n    3\n    \n\n## 示例2\n\n    \n    \n    输入：\n    0\n    1\n    \n    输出：\n    0\n    \n    说明：\n    因为没有宝石，所以返回 0\n    \n\n## 示例3\n\n    \n    \n    输入：\n    9\n    6\n    1\n    3\n    1\n    8\n    9\n    3\n    2\n    4\n    15\n    \n    输出：\n    4\n    \n\n## 题解\n\n> **滑动窗口** 的方法来解决。具体步骤如下：\n>\n>   1. 初始化滑动窗口的左边界和右边界为0。\n>   2. 遍历右边界，累加宝石的价格，直到总价格大于等于拥有的钱或者遍历完所有宝石。\n>   3. 如果总价格小于等于拥有的钱，更新最大购买宝石数量。\n>   4. 移动左边界，减去左边界对应的宝石价格，直到总价格小于拥有的钱。\n>   5. 重复步骤2到步骤4，直到右边界遍历完所有宝石。\n>\n\n### Java\n\n    \n    \n    import java.util.Scanner;\n    \n    /**\n     * @author code5bug\n     */\n    public class Main {\n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n    \n            // 输入宝石数量\n            int n = scanner.nextInt();\n            int[] gems = new int[n];\n    \n            // 输入宝石价格\n            for (int i = 0; i < n; i+\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599527304850677760?sourceSSR=users",
        "title": "26届双非大佬挑战大厂后端实习面经解析",
        "content": "1.一分钟介绍一下自己  \n2.看简历是26届 多久开始学的java 项目做的时间点 学习方式  \n3.介绍一下两个项目 亮点以及架构  \n4.第二个项目用到了哪些技术栈 遇到了哪些问题  \n5.聊了聊关于mp的使用  \n答：MQ（Message\nQueue）主要用于在分布式系统之间进行通信，是一种存储消息的容器。它的基本模型包括生产者、消费者和消息队列，生产者发送消息到队列，消费者从队列中获取并处理消息。  \n  \n在实际应用中，MQ有许多重要的应用场景。比如，它可以用于异步处理，就像用户注册后需要发送注册邮件和短信，通过MQ可以异步地完成这些任务，提高处理效率。同时，MQ还可以用于服务解耦，降低系统之间的耦合度，提高系统的稳定性和可维护性。在流量削峰方面，MQ也发挥着重要作用，它可以把流量的高峰和低谷做一个平衡，避免系统过载。  \n  \n此外，MQ的工作原理也非常巧妙。它保证了消息的可靠性，即使消息在传输过程中丢失，MQ也会进行重传。同时，MQ还支持消息的顺序性，确保消费者按照生产者发送消息的顺序来处理消息。  \n  \n6.登录的具体流程 讲讲md5怎么加密的？  \n  \n答：MD5（Message-Digest Algorithm\n5）是一种广泛使用的密码散列函数，它可以将任意长度的“字节串”映射为一个128位的大数，并且以32位十六进制数字表示的字符串形式给出。这个加密过程是不可逆的，意味着一旦原始数据被MD5加密，就不能直接从这个加密后的哈希值恢复出原始数据。  \n  \n下面是MD5加密的大致步骤：  \n  \n填充：MD5首先会对输入数据进行填充，使得其长度对512取模后余数是448。填充的方式是在原始数据的后面先添加一个1，然后是若干个0，直到满足上述条件。  \n  \n附加长度值：在填充后的数据后面附加一个64位表示原始数据长度的二进制值。这样，处理后的数据长度就是512的倍数。  \n  \n初始化缓冲区：MD5算法使用四个32位的寄存器（A, B, C, D）来保存中间结果和最终结果。这四个寄存器被初始化为特定的值。  \n  \n处理数据块：将填充和附加长度值后的数据分成若干个512位的数据块，然后对每个数据块进行如下处理：  \n  \n将数据块分为16个32位的子块。  \n进行四轮处理，每轮包含16个步骤，每个步骤都会根据一定的算法和当前寄存器的值以及子块的值来更新寄存器的值。  \n  \n输出：处理完所有的数据块后，寄存器A、B、C和D中的值就是最终的哈希值。这四个值连接在一起，形成一个128位的二进制数，然后通常被转换为32个十六进制数字表示的字符串形式。  \n  \nMD5算法的安全性在过去曾经被广泛讨论。虽然它对于防止数据被篡改或确保数据的完整性非常有用，但由于存在所谓的“碰撞”问题（即不同的输入数据可能产生相同的MD5哈希值），MD5不再被视为安全的密码散列函数，特别是在需要高安全性的场合，如密码存储。在这些情况下，通常推荐使用更安全的算法，如SHA-256或bcrypt。  \n  \n7.jwt是什么？  \n  \n答：JWT，全称JSON Web Token，是一种开放标准（RFC\n7519），它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。这些信息可以被验证和信任，因为它们是数字签名的。JWT可以使用HMAC算法或者是RSA的公私密钥对进行签名。\n\n  \n\nJWT由三部分组成：头部（Header）、载荷（Payload）和签名（Signature）。头部通常包含两部分信息：令牌的类型（即JWT）和所使用的签名算法（如HMAC\nSHA256或RSA）。载荷部分包含有关用户和其他数据的信息。签名部分是对头部和载荷进行签名，以确保数据没有被篡改。\n\n  \n\nJWT通常用于以下场景：\n\n  \n\n身份验证：一旦用户登录，每个后续请求都将包含JWT，允许用户访问该令牌授权的路由、服务和资源。单点登录是JWT的典型用例，因为它的开销很小，并且在跨多个域/子域时很容易使用。\n\n信息交换：JWT是在各方之间安全传输信息的好方式。因为JWT可以被签名（例如，使用公钥/私钥对），所以你可以确定发件人是谁以及消息是否被篡改。\n\n  \n\n8.缓存三兄弟？  \n  \n答：缓存三兄弟指的是在使用缓存系统时可能遇到的三种常见问题，它们分别是：缓存穿透、缓存击穿和缓存雪崩。这名字有点搞笑。  \n  \n9.项目里的互斥锁？  \n  \n10.超卖问题如何解决？  \n  \n答：分布式锁：在分布式系统中，使用分布式锁可以实现跨机器共享互斥控制机制，保证操作的原子性和数据的一致性。这样可以防止多个请求同时访问和修改库存，从而避免超卖现象。  \n乐观锁机制：乐观锁机制通过版本号来判断提交的更新操作是否有冲突。当多个请求尝试修改同一数据时，只有版本号与原始数据相匹配的请求才能成功更新数据，从而避免超卖。  \n  \n库存预扣：在订单生成时，可以先预扣库存，并在订单支付成功后再真正扣除库存。这样可以防止用户在生成订单后长时间不支付而导致的库存占用问题。  \n  \n库存缓存：将库存信息映射到缓存中，可以快速响应库存查询和扣减操作。通过缓存，可以减少对数据库的访问压力，提高系统的响应速度。  \n唯一索引约束：在网络不好的情况下，用户可能多次点击提交导致多订单问题。通过在秒杀表中对用户ID、商品ID和本次活动的code设置唯一索引约束，可以避免多插入问题，从而防止超卖。  \n  \n布隆过滤器：布隆过滤器可以实现重复提交的限制，防止用户多次点击导致的超卖问题。  \n事务隔离级别：可以将数据库的事务隔离级别设置为串行，但这可能会让原来没有冲突的事务也得串行执行，影响系统性能。因此，这种方法需要谨慎使用。  \n  \n11.秒杀场景你的具体实现 聊聊代码  \n12.websocket 讲一下 具体的操作 （有点忘了 说了个大概以及记得的注解）  \n答：WebSocket是一种在Web应用程序中实现实时双向通信的协议，它基于TCP连接，提供了持久化的、全双工的通信通道，使得服务器和客户端之间可以实时地推送和接收数据，无需客户端每次发起请求。WebSocket协议由通信协议和编程API组成，它的数据格式比较轻量，性能开销小，通信高效，可以发送文本和二进制数据。  \n  \nWebSocket的具体操作主要涉及浏览器通过JavaScript向服务器发出建立WebSocket连接的请求，一旦连接建立，客户端和服务器端就可以通过TCP连接直接交换数据。以下是一些关键的操作步骤：  \n  \n创建WebSocket对象：在客户端（通常是浏览器），使用JavaScript创建一个WebSocket对象，指定要连接的WebSocket服务器的URL。  \n建立连接：WebSocket对象尝试与服务器建立连接。在连接过程中，可以进行必要的握手和认证操作。  \n发送数据：一旦连接建立成功，客户端可以通过WebSocket对象的send()方法向服务器发送数据。这些数据可以是文本、二进制数据或其他格式的数据。  \n接收数据：服务器可以通过WebSocket连接向客户端推送数据。在客户端，可以通过WebSocket对象的事件监听机制（如onmessage事件）来接收服务器发送的数据。  \n关闭连接：当不再需要WebSocket连接时，客户端或服务器可以主动关闭连接。这可以通过调用WebSocket对象的close()方法来实现。  \n  \n在WebSocket的使用过程中，还需要注意一些细节，如处理连接失败、重连机制、消息编码和解码等。此外，由于WebSocket是基于TCP连接的，因此在分布式场景下需要特别注意session的管理和同步问题。  \n  \nWebSocket的应用场景非常广泛，包括实时聊天室、在线游戏、实时数据展示（如股票行情、天气预报等）、社交聊天、弹幕、多玩家游戏、协同编辑、股票基金实时报价、体育实况更新、视频会议/聊天、基于位置的应用、在线教育、智能家居等需要高实时的场景。在这些场景中，WebSocket能够提供实时、高效的双向通信能力，为应用程序带来更好的用户体验和功能实现。  \n  \n13.项目里布隆过滤器怎么自定义的  \n14.分布式锁具体的实现 项目里优化的思路  \n15.乐观锁悲观锁  \n16.AOP怎么用的 用在哪的  \n17.hashmap底层讲一下  \n18.为什么引入红黑树 红黑树的性质 优点  \n19.mysql的锁了解吗  \n20.mysql索引数据结构  \n21.为什么用b+树 有什么特性 区别在哪  \n22.创建索引需要考虑些什么 索引优化有没有相关经验  \n23.用过linux吗 linux常用的命令有哪些  \n文件里过滤用什么（一时没想起来）  \n24.聊聊国奖项目 讲讲极小化极大算法怎么实现的  \n25.反问\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599382577346101248?sourceSSR=users",
        "title": "腾讯HR面",
        "content": "看到有牛友问HR面的内容，这里补充下，其余面经内容在主页上一篇帖子。\n\n另外HR面的内容比较广泛，按理说正常答就可以过的。[赞]\n\n![](https://uploadfiles.nowcoder.com/images/20240318/987863177_1710775848406/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599356939423838208?sourceSSR=users",
        "title": "腾讯 微信公众号&&小程序 暑期实习 一面秒挂",
        "content": "全程一小时40分钟；\n\n**自我介绍；**\n\n**50分钟内做3道算法题**\n\n力扣33搜索旋转排序数组(思路和题解一样，但是在腾讯的编辑器里死活不对)\n\n多线程打印 多线程打印斐波那契数列 (ac)\n\n力扣 2976. 转换字符串的最小成本 I（放弃）\n\n**然后开始八股拷打，基本都没啥问题，很基础的八股**\n\nHTTP与HTTPS的区别;\n\nssl认证；\n\nosi七层模型分别是什么和各层常用协议，以及各个层之间的联系；\n\nurl输入网页流程；\n\nMysql事务四大特性并解释；\n\n行锁；\n\nc++多态;\n\n小结：人生第一次面试，很紧张，挂的也很快，算法太差了。。。。腾子，我还会回来的！\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599355593933037568?sourceSSR=users",
        "title": "腾讯TEG一面",
        "content": "![](https://uploadfiles.nowcoder.com/message_images/20240318/142471155_1710768721774/discuss_1710768720528.jpeg)说一下GMP模型  \n你刚刚提到协程比线程要小，什么意思，怎么理解？  \n一个协程大小是多大？  \n说一下Go的垃圾清扫算法  \n我看了一下你的项目中，用了JWT，你的JWT是放在Gin的哪里？  \nGin的中间件怎么理解？  \n我看你的项目中，用了GORM，GORM怎么批量更新数据？  \n说一说Mysql中的锁  \n什么是回表？  \n说一说你的项目  \n你的项目中rabbitmq的作用是什么？  \n你对微服务怎么理解  \n在你做项目的过程中，遇到过什么困难？  \n你本科自动化，硕士生物，怎么就想来互联网呢？那你接下来就坚定走互联网这条路咯？  \n什么时候能来，实习到什么时候  \n  \n最害怕的手撕没有出，谢天谢地。  \n  \n反问：  \n我还需要提升什么地方？(数据库的基础还要提高)  \n接下来还有几面(2, 他的leader和hr)  \n我的项目还可以怎么提升？  \n  \n后记：  \n我的项目一共两个，字节训练营的抖音，个人的课题~基于微服务****。  \n投了好多简历，小厂中厂大厂都有，只有蔚来和腾讯约面了，一度自信心受挫[牛泪]  \n面试完十分钟后刷新，进入复试了～但是二面的通知还没收到，有木有同学知道是什么情况[叹息]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599352021463863296?sourceSSR=users",
        "title": "熙牛医疗 一面面经",
        "content": "1）自我介绍\n\n2）List、Set、Map 的差别和各自的特性\n\n3）Set 底层是通过什么实现的？\n\n4）Map 中的 key 可以为 null 吗？\n\n5）Hash 冲突常见的解决方案有什么？\n\n6）介绍一下泛型\n\n7）介绍一下 JVM\n\n8）程序计数器用来干什么的？\n\n9）**Java 堆中被分为三个部分（新生代、老年代、永久代），说一下他们之间的关系（不会）**\n\n10）有没有用过一些工具去研究过 JVM 这一块（答了 Arthas）\n\n11）说一下 Spring 的 IOC\n\n12）**Mybatis 的实现原理有了解过吗（不会）**\n\n13）MySQL 的四个隔离级别\n\n14）幻读和不可重复读的区别\n\n15）**MySQL 怎么解决幻读和不可重复的？**\n\n答：将隔离级别提升为可串行化、加表锁、加间隙锁（面试官说不是，涉及到 MVCC 多版本控制的知识）\n\n16）MySQL 的读锁和写锁\n\n17）**MySQL 的悲观锁是基于什么实现的？（不会）**\n\n18）避免索引失效的几种场景（这里把索引失效的场景反过来答的）\n\n19）说一下模板模式\n\n20）BIO、NIO、AIO 三种 IO\n\n21）讲一下项目中的难点或者说复杂业务\n\n22）平时是怎么学习技术的？\n\n23）自己的优缺点说一下\n\n24）作为一个实习生，分配给你一个需求，你会怎么去做呢？\n\n25）写完需求之后怎么去做测试呢？\n\n评价：\n\n面试官人挺好，答不上来会给提示\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599349258868756480?sourceSSR=users",
        "title": "4399c++游戏开发笔试",
        "content": "10道选择题，堆，vector源码，RNN参数个数（离谱的问题，看不懂）都是基础知识。  \n3道编程题：  \n一道是找最长连续子数组，如12345  \n一道是把数组划分为k个连续子数组，子数组的和的最大值最小。  \n一道是英雄池里给出最优的选择，m个英雄池，选n个英雄，每个英雄池最多选一个。但是每个英雄都有花费，给花费为t。应该是贪心，不会做。  \n后面两道是简答题：是对大学四年反思的问题。  \nPS：其实我也没想过我简历会过，因为我简历写的项目都是前端。以前还幻想着会点c++可以找对应的工作，这下幻想破灭了。认清现实，前端就是前端。[牛泪]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599348353419296768?sourceSSR=users",
        "title": "顺丰前端一面面经20min   3.18",
        "content": "下午面晚上就收到了二面短信\n\n1、自我介绍\n\n2、知道哪些排序算法，具体讲快排和简单选择排序\n\n3、HTTP/HTTPS具体内容\n\n4、XSS、CSRF\n\n5、Vue组件通信\n\n6、知道哪些设计模式，具体讲了一下工厂模式\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599341591031050240?sourceSSR=users",
        "title": "字节后端实习一面——秒挂",
        "content": "自我介绍\n\n1\\. 你项目中mysql怎么分区的（\n\n2\\. 分区后原本的索引还有效吗\n\n3\\. 回表查询？\n\n4\\. 脏读、幻读讲一下\n\n5\\. 脏读怎么解决（答了读已提交，问：底层怎么实现的——mvcc\n\n6\\. 幻读怎么解决\n\n7\\. 事务的ACID怎么保证的（人要碎了，没答上来\n\n比如原子性怎么保证的，怎么保证的。。。——应该是undo日志+回滚\n\n8\\. Mysql有哪些日志了解吗\n\n——undo日志、redo日志\n\n9\\. 这两个日志都是做什么的\n\n答了redo日志用于故障恢复\n\n10\\. 为什么用redo日志来修复（没答出来\n\n11\\. redis缓存穿透、缓存击穿讲一下\n\n12\\. 那你怎么解决缓存击穿——答先获取分布式锁再请求MySQL并写入redis\n\n问：那你的分布式锁怎么实现的\n\n答：用redis\n\n问：那不还是很多请求访问到你的redis吗\n\n答：但是不会直接都访问到mysql，redis流量容纳度比较大吧\n\n问：那比如流量大到你redis承受不了\n\n答：稀里糊涂答了句设置热点数据不过期\n\n问：那你过期怎么保证一致性呢\n\n尬住了……\n\n13\\. Redis有哪些数据类型\n\n14\\. Zset的怎么实现的（底层数据结构没答出来\n\n15\\. Redis淘汰策略\n\n手撕算法：leetcode53、最大子数组和（并输出这个子数组\n\n最大子数组和3分钟秒了，输出子数组折腾半天…\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599335695446032384?sourceSSR=users",
        "title": "腾讯WXG 后端开发实习凉经",
        "content": "面完秒挂\n\n自我介绍\n\n项目为什么用到 kafka\n\nkafka 的缺点\n\nHyperLogLog 的数据结构\n\nzset 的数据结构\n\n项目里如何使用的 zest\n\nTCP 断开连接\n\n什么情况下可以三次挥手\n\nTCP 传送数据过程中断电和崩溃的区别（题面记不清了）\n\n手撕 二叉树的中序遍历（递归、非递归）\n\n货车和客车的比例是 1：2，货车修车概率 a1，客车修车概率 a2，已知有一辆车修车，问是货车的概率\n\nRedis 的持久化\n\nRDB 快照具体过程\n\n8G 空间，Redis 能存多少数据（题面记不清了）\n\n学没学过操作系统（没学过）\n\n进程和线程的区别\n\n一个进程中线程的共享数据\n\n进程间通信\n\n反问\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599333220152360960?sourceSSR=users",
        "title": "顺丰3-18笔试",
        "content": "\n    1.小红在转圈圈，一个有3个圈圈，每个圈圈耗时1秒，一共要转完3个圈圈不失败就算成功。\n    现在给出在第x个圈时，一共失败了v次，一共耗时了t秒才成功一次性转完3个圈。\n    问一共失败次数的最大值和最小值。\n    \n    public class Main {\n        public static void main(String[] args) {\n            Scanner in = new Scanner(System.in);\n            while(in.hasNext()) {\n                String param = in.nextLine();\n                String[] paramList = param.split(\" \");\n                String x = paramList[0];\n                int v = Integer.parseInt(paramList[1]);\n                int t = Integer.parseInt(paramList[2]);\n                \n                int minn = 0, maxx = 0;\n                t -= 3;\n                if(x.equals(\"a\")) {\n                    t -= v;\n                    int time1 = t / 2;\n                    maxx = time1 + v;\n                    \n                    int time2 = 0;\n                    if(t % 3 == 0) {\n                        time2 = t / 3;\n                    } else {\n                        time2 = t / 3 + 1;\n                    }\n                    \n                    minn = time2 + v;\n                } else if(x.equals(\"b\")) {\n                    t -= v * 2; \n                    maxx = v + t;\n                    \n                    int time2 = 0;\n                    if(t % 3 == 0) {\n                        time2 = t / 3;\n                    } else {\n                        time2 = t / 3 + (t % 3);\n                    }\n                    \n                    minn = time2 + v;\n                } else {\n                    t -= v * 3;\n                    maxx = v + t;\n                    \n                    minn = v + t / 2 + (t % 2);\n                }\n                System.out.println(maxx + \" \" + minn);\n            }\n        }\n    }\n    \n    2.钓鱼比赛，一共有n个池塘，每个池塘最多钓一次，比赛时间t秒，\n    每个池塘都有些规则：\n    规则1：在我这个池塘钓了鱼后，你钓鱼的总次数就不能高于某个值x。\n    规则2：在我这里钓鱼需要花y时间。\n    \n    问在有限时间t秒内，能钓到的最大鱼量。\n    \n    做贪心pass 55%\n    \n    \n    \n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599329213241466880?sourceSSR=users",
        "title": "暑期实习第一战，腾讯-提前上岸 （面经+个人分析）",
        "content": "![](https://uploadfiles.nowcoder.com/images/20240318/987863177_1710763819988/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n部门：Pcg--QQ--后端开发 （实习基地专项）\n\n一、TimeLine：\n\n首先是时间线\n\n一面（3.5） 二面（3.6） 三面（3.11） HR面（3.12） 录用评估（3.15） Offer（3.18）\n\n二、面经 (附带本人解答分析)\n\n2.1 一面面经\n\n![](https://uploadfiles.nowcoder.com/images/20240318/987863177_1710761782159/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n一面问题解答思路分析\n\n![](https://uploadfiles.nowcoder.com/images/20240318/987863177_1710762003422/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n2.2 二面面经\n\n![](https://uploadfiles.nowcoder.com/images/20240318/987863177_1710762427725/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n二面问题解答思路分析\n\n![](https://uploadfiles.nowcoder.com/images/20240318/987863177_1710762455495/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n2.3 三面面经\n\n![](https://uploadfiles.nowcoder.com/images/20240318/987863177_1710762531494/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n三、希望有Go的大佬可以指教下呀~~（评论区或者私信指教下，Go的学习路线或者视频等等）感谢感谢\n\n四、最后想问下大家，如果是我这个情况\n\n4.1 暑期实习第一战--腾讯，已经决定去暑期实习了（个人比较喜欢鹅厂，而且在深圳离家近）。\n\n4.2 还会继续面试其他大厂吗（单纯增加面试经验。虽然不想面，但是不面又可惜）\n\n4.3 可能综合上本身是学Java的，然后转Go，之后秋招怎么发展等等如果有相同的同学，也可以一起交流呀。\n\n4.4 我其实挺菜的，但是有点运气在身上（面试难度和竞争压力都比较小吧）[赞]\n\n\\-----------\n\n3.19 更新\n\n挺多人 问怎么背八股、或者学习路线之类的问题。\n\n所以准备今晚或者明天整理下相关的东西。发在小红书 (ID：星星月亮) 或者牛客。\n\n\\-----------\n\n3.20 更新\n\n有些问的比较多的问题，已经整理更新在小红书啦。\n\n因为不想两边都维护，有点耗时间，所以 主要内容 和 评论回复 会在小红书，我用着比较方便[牛泪]。\n\n\\----------\n\n3.23 更新\n\n在小红薯上更新下自己的两年Java学习路线，保姆级学习路线教程\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599323876656541696?sourceSSR=users",
        "title": "华为od前端面经",
        "content": "# 华为od前端面经\n\n## 1.背景\n\n目标院校科班，一年前端工作经验，因为考研所以有半年空档期。\n\n## 2.机试（2.25)\n\n在今年的1月9日我联系到\n@华为HR(OD)郑经理***************这位HR，她给我发了一份题库让我做着试试看。于是我就边刷题库边刷力扣，最后约了年后的机试。我抽到的题目是两道字符串相关，一道逻辑题，难度不算大。机试成绩为360分。关于机试的建议就是多刷下字符串，深搜广搜和动态规划。还有一点就是机试的时候100分的两道题和200分的那道题是分开的两个模块，先答完一个模块提交后，才可以答另一个。所以我的建议是先答200分的，然后再答100分的。\n\n## 3.性格测试(2.26)\n\n这个要注意前后保持一致，尽量选择乐观的，稳定的，抗压的选项即可，其实还是蛮好过的。HR会对此进行辅导的，照做就好。\n\n## 4.资格面(3.1)\n\n性格测试结束后，就开始挑选意向地和部门，选好后就开始资格面了。这一面主要是考察稳定性。面试官人很好，很快就让我放松下来，然后问了我的学习，社团和工作的经历，问了我为什么离开上一家公司，为什么离职后选择考研，之后还会再考吗，问了我对华为的看法，对加班的看法，压力大的时候怎么调节等等。我感觉面试的要点就是要体现自己积极乐观，希望提升技术，打算好好工作。\n\n## 5.技术一面(3.12)\n\n资格面通过后我特意向HR申请了一段时间去准备项目和算法。这段时间基本上就是把力扣比较热门的题目刷一下，项目和八股好好看下。但是我的一面并没有问到我准备的八股。问了下我对npm有多少理解，npm\ninstall具体流程是什么样的，版本号前面的~和^有什么区别等等。（这几个问题印象比较深，别的记不得了）然后就开始手撕算法，题目如下：\n\n    \n    \n    // 给定一个经过编码的字符串，返回它解码后的字符串\n    // 编码规则：k[encodeed_string]，k只表示重复次数\n    // s = '3[a]2[bc]'，返回 aaabcbc\n    // s = '3[ab2[c]]',返回abccabccabcc\n    // s= '2[abc]2[cd]ef',返回abcabccdcdef\n    \n    \n\n## 6.技术二面(3.13)\n\n二面一上来就是手撕算法，要求20分钟写出来，但我应该是写了30分钟。题目如下：\n\n    \n    \n    // 假设有一个内存堆，堆中有很多对象，对象间会存在相互引用；1:（0-n）\n    // 求：1. 这个堆中是否存在环引用？2. 打出环\n    \n    \n\n手撕算法时有两点小建议：一是看完题目后可以先口述一下自己的思路，让面试官知道你要怎么写；二是注意代码规范和勤写注释。做完手撕后问了vite的原理，解释vue-\nfor及其中key的作用。（别的问题忘记了）两次技术面遇到的面试官人都特别特别好，我答不上的问题他们都很耐心的解释了，我边面试边学了挺多东西。\n\n## 7.主管面(3.15)\n\n我本来以为主管面是压力面，但没想到主管人超级好，一点压力没给。就是简单问了下我的工作经历和对加班的看法，然后就说对我的各方面都还挺满意的，很欢迎我。主管面就这样过了，现在就是在等审核和发offer了。\n\n## 8.HR\n\n我觉得在这次经历中很重要的一步就是要找对HR，一个好的HR真的帮助特别大，她会全程辅导每一个步骤，机试应该怎么准备，面试有哪些要点，她都有清清楚楚地告诉我。平时回答问题也超级快，也会帮我监督每一个流程！我现在就是非常非常感谢，希望如果有在找工作的朋友想要去od的话，可以联系她哦。（不是广告！情真意切！HR我上文有@）\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599320706668687360?sourceSSR=users",
        "title": "题解|2024.3.17西山居笔试第二题",
        "content": "题目描述: 给一个长字符串，和若干小字符串，问选哪几个小字符串可以拼成大串\n\n数据范围：保证有且仅有唯一解，没给数据范围，我猜的暴力能过,胡乱写写过了\n\n题目思路：开个map，往下搜一下\n\n笔试感受：总体感觉比米哈游简单，题少问的简单点还行\n\n    \n    \n    #include<bits/stdc++.h>\n    using namespace std;\n    /*\n    测试数据\n    abcefdegh\n    5\n    abc efdeg efde gh ss\n    */\n    map<string,int> mm;\n    vector<int> ans;\n    bool flag=0;\n    void dfs(string s,vector<int> t){\n    \tif(flag) return ;\n    \tif(s==\"\"){ \n                 //因为用了erase是会删没的，唯一解找到直接返回就行了\n    \t\tans=t;\n    \t\tflag=1;\n    \t\treturn ;\n    \t}\n    \tstring k=\"\";\n    \tfor(int i=0;i<(int)s.size();i++){\n    \t\tk+=s[i];\n    \t\tif(mm.count(k)){\n    \t\t\tvector<int> next=t;\n    \t\t\tstring tmp=s;\n    \t\t\tnext.push_back(mm[k]);\n    \t\t\ttmp.erase(0,i+1);  //这里感觉可以传个下标下去，当时想着随便写写\n    \t\t\tdfs(tmp,next);\n    \t\t}\n    \t}\n    }\n    int main(){\n    \tstring str;\n    \tvector<string> s;\n    \tint n;\n    \tcin>>str;\n    \tcin>>n;\n    \tfor(int i=0;i<n;i++){\n    \t\tstring tmp;\n    \t\tcin>>tmp;\n    \t\ts.push_back(tmp);\n    \t\tmm[tmp]=i;\n        }\n        vector<int> k;\n    \tdfs(str,k);\n    \tfor(auto t:ans) cout<<t<<\" \";\n    \tcout<<endl;\n    \treturn 0;\n    }\n    \n    \n\n#西山居#\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599317924087721984?sourceSSR=users",
        "title": "华为od前端面经",
        "content": "## 1.背景\n\n目标院校科班，一年前端工作经验，因为考研所以有半年空档期。\n\n## 2.机试（2.25)\n\n在今年的1月9日我联系到 @华为HR(OD)郑经理*************\n这位HR，她给我发了一份题库让我做着试试看。于是我就边刷题库边刷力扣，最后约了年后的机试。我抽到的题目是两道字符串相关，一道逻辑题，难度不算大。机试成绩为360分。关于机试的建议就是多刷下字符串，深搜广搜和动态规划。还有一点就是机试的时候100分的两道题和200分的那道题是分开的两个模块，先答完一个模块提交后，才可以答另一个。所以我的建议是先答200分的，然后再答100分的。\n\n## 3.性格测试(2.26)\n\n这个要注意前后保持一致，尽量选择乐观的，稳定的，抗压的选项即可，其实还是蛮好过的。HR会对此进行辅导的，照做就好。\n\n## 4.资格面(3.1)\n\n性格测试结束后，就开始挑选意向地和部门，选好后就开始资格面了。这一面主要是考察稳定性。面试官人很好，很快就让我放松下来，然后问了我的学习，社团和工作的经历，问了我为什么离开上一家公司，为什么离职后选择考研，之后还会再考吗，问了我对华为的看法，对加班的看法，压力大的时候怎么调节等等。我感觉面试的要点就是要体现自己积极乐观，希望提升技术，打算好好工作。\n\n## 5.技术一面(3.12)\n\n资格面通过后我特意向HR申请了一段时间去准备项目和算法。这段时间基本上就是把力扣比较热门的题目刷一下，项目和八股好好看下。但是我的一面并没有问到我准备的八股。问了下我对npm有多少理解，npm\ninstall具体流程是什么样的，版本号前面的~和^有什么区别等等。（这几个问题印象比较深，别的记不得了）然后就开始手撕算法，题目如下：\n\n    \n    \n    // 给定一个经过编码的字符串，返回它解码后的字符串\n    // 编码规则：k[encodeed_string]，k只表示重复次数\n    // s = '3[a]2[bc]'，返回 aaabcbc\n    // s = '3[ab2[c]]',返回abccabccabcc\n    // s= '2[abc]2[cd]ef',返回abcabccdcdef\n    \n\n## 6.技术二面(3.13)\n\n二面一上来就是手撕算法，要求20分钟写出来，但我应该是写了30分钟。题目如下：\n\n    \n    \n    // 假设有一个内存堆，堆中有很多对象，对象间会存在相互引用；1:（0-n）\n    // 求：1. 这个堆中是否存在环引用？2. 打出环\n    \n\n手撕算法时有两点小建议：一是看完题目后可以先口述一下自己的思路，让面试官知道你要怎么写；二是注意代码规范和勤写注释。做完手撕后问了vite的原理，解释vue-\nfor及其中key的作用。（别的问题忘记了）两次技术面遇到的面试官人都特别特别好，我答不上的问题他们都很耐心的解释了，我边面试边学了挺多东西。\n\n## 7.主管面(3.15)\n\n我本来以为主管面是压力面，但没想到主管人超级好，一点压力没给。就是简单问了下我的工作经历和对加班的看法，然后就说对我的各方面都还挺满意的，很欢迎我。主管面就这样过了，现在就是在等审核和发offer了。\n\n## 8.HR\n\n我觉得在这次经历中很重要的一步就是要找对HR，一个好的HR真的帮助特别大，她会全程辅导每一个步骤，机试应该怎么准备，面试有哪些要点，她都有清清楚楚地告诉我。平时回答问题也超级快，也会帮我监督每一个流程！我现在就是非常非常感谢，希望如果有在找工作的朋友想要去od的话，可以联系她哦。（不是广告！情真意切！HR我上文有@）\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599306658136846336?sourceSSR=users",
        "title": "用户运营-网易有道",
        "content": "这是我第一份实习，也是我第一次面试，有很多地方已经记不太清了，还是很感谢网易面试我的姐姐，原因给我这个机会，虽然离职的时候闹了一些不愉快，不过我依旧很感谢他们，在网易，是我实习最欢乐的一段时间，开局就是王炸，以至于后面眼高手里了好一阵儿，我只是对运营感兴趣，从而想去互联网大厂更多的体验\n\n1、自我介绍，很紧张，应该是重来了两次\n\n2、面试管自我介绍，有道新开放的一条用户渠道在百度浏览页投放，需要一批0号种子用户\n\n3、介绍项目，说只面试钟意的人，而且面试我的美女姐姐是这个项目的总负责人，以为是骗我的，后面去了发现是真的，一共只面了3个\n\n4、问我的性格如何，身边的朋友多不多，跟身边的人是怎么相处的\n\n5、介不介意繁琐且枯燥的工作方式\n\n6、抗压能力如何，喜不喜欢和人接触，喜不喜欢小动物，\n\n7、你认为自己的做事态度是什么样子的，平时在学校里表现如何\n\n8、你是什么星座\n\n9、你认为的价值观是什么呢？如果让你做一些不符合你世界观的事情你会做吗？\n\n10、开始闲聊，问我工作倦怠期是多少\n\n11、反问，结束\n\n这位姐姐全程的声音都是嗲嗲的，非常好听，后来入职发现了，这位姐姐是一位用最温柔的语气说最狠的话的女强人，真的很强势，眼观六路耳听八方，每天都很忙，因为是刚开始的项目，很忙，各种方向都要尝试，每天都会加班到很晚，会经常开会，每天加班了都会请我们下馆子，每天下午都有下午茶，喜茶和小蛋糕。\n\n离职是我在工作了5个月以后，周围的人都非常好，不过是领导还是同事，真的非常好，遇到困难会耐心教我，做错事了也不会大声指责，细心的给我讲哪里错了，为什么错了。\n\n虽然是实习，但是我也非常满足，因为没有转正的hc，我就提了离职，真的很舍不得，离职的时候还单独请我吃饭，这是我第一次在离职后恋恋不舍而落泪，第一份工作会让刚入职场的学生们定形，我觉得我并没有，我也很庆幸第一次的实习就是这么好的团队，\n\n虽然在离职的前几天，闹了一些不愉快，不过这也不重要了。\n\n我不是托儿哦。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599306316200407040?sourceSSR=users",
        "title": "海量数据 一面 面经 24春招 已凉",
        "content": "个人背景：本9海硕，一段本硕之间的一年工作经验，一段老外研究所实习\n\n岗位：内核研发\n\nTL：boss投递，3/15行测，3/18一面\n\n**一面：**\n\n时间：3/18，长度30分钟\n\n内容：\n\n  1. 自我介绍\n  2. 问实习做的数据库的底层，实习做的工作\n  3. 问数据库的底层实现，问的很深很细，例如建哈希表的适合哈希冲突“具体”是用什么锁解决的，两个表Join的底层实现，数据库文件的设计，不是普通八股，而是真的研究过才能答上来的那种\n  4. 复盘笔试，两个装不进内存的表找交集，如果ID不是有序的怎么办？\n  5. 反问公司数据库\n\n感受：面试官全程比较冷淡，抓住一个点就往最深了问，我就只是做过两三个月数据库，那种问题我觉得只有老油条才会吧。。。然后就是很多问题直接回答不会，两三下就被面试官掏空了。听面试官话里话外的意思，他们还是想要那种研究生一进去就开始做数据库的，我是毕设才开始做，就显得比较薄弱。数据库这块是真的卷啊，岗不多，大神一堆，非大厂也很难进。\n\n结语：春招首寄\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599301825514180608?sourceSSR=users",
        "title": "英雄互娱社区运营2面",
        "content": "1、自我介绍\n\n2、深挖简历\n\n3、实习经历：之前实习主要的工作内容，你从中学到了什么，它给你带来了什么\n\n4、新媒体运营实习经历：你认为的新媒体运营是什么样子的，你在这份实习中学到了什么\n\n5、了解或使用过英雄社区吗，你认为英雄社区的内容能否吸引你，不能吸引的原因是什么\n\n6、平常使用的游戏社区软件有什么，使用时长，使用频率分别是多少\n\n7、你认为小黑盒和steam的区别，你对于二者的看法\n\n8、确认最早入职时间\n\n9、反问\n\n我觉得我稳了家人们哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599300430782373888?sourceSSR=users",
        "title": "24/3/18_先临三维C++开发实习_面试",
        "content": "1.介绍项目\n\n楼主介绍了两个C++项目和自己的课题。\n\n2.在Linux上用什么IDE编译的？\n\nclion\n\n3.用过QT吗？\n\n用的不多\n\n4.STL都用过什么？\n\nvector等容器，算法，迭代器。\n\n5.vector和list的区别？\n\nvector内存空间连续，list动态分配不连续\n\nvector支持随机存取，list不支持\n\nvector连续存储支持动态增长，list非连续结构插入和删除效率高\n\n6.用过的git\n\nclone\n\n7.线程如何实现同步\n\n互斥量、信号量、读写锁、条件变量\n\n8.线程结束如何正确输出\n\n不知道\n\n9.项目中动态增长缓冲区怎么实现的\n\n当容量小于当前元素个数，vector分配一个更大的连续内存，通常是原来大小的两倍，然后将元素添加到vector中，释放原来的vector。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599296719339233280?sourceSSR=users",
        "title": "美团一面40min",
        "content": "团子说18号就是18号，哈哈哈，五点赶完事情就来面试了，面试官有点忙，因为面试可能太多了，把在工作的都叫来了吧[笑cry][笑cry][笑cry]，但是面试官还是很好的。\n\n#### 1：自我介绍\n\n#### 2：前后端请求加载流程（开放性问题，说了蛮多的）\n\n#### 3：跨域问题怎么解决？\n\n#### 4：Java层面的跨域怎么解决（没答上来[牛泪]）\n\n#### 5：Java的跨平台\n\n#### 6：类加载流程（晕了，昨天还看过，就记得那个难记的全限定二进制名了[嘤嘤嘤]）\n\n#### 7：gc的模型\n\n#### 8：gc流程\n\n#### 9：JVM的启动前设置哪些参数：讲了新生代的比例设置以及对应场景\n\n#### 10：Mysql的数据类型以及选用的场景\n\n#### 11：Mybatis和Mybatis-plus的区别\n\n#### 12：Redis常用哪些数据结构，项目里面怎么用的\n\n#### 13：手撕层序遍历，5min秒了\n\n#### 反问：表现如何。 还不错\n\n我背了那么久的Mysql和Redis，就问了几个[牛泪]\n\n  \n\n更新:挂了[牛泪][牛泪][牛泪]，等捞吧[废了]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599291056856866816?sourceSSR=users",
        "title": "火羽科技 游戏服务器 一面",
        "content": "  1. 自我介绍 (主要讲了实习)\n  2. 跨服排行榜的实现\n  3. redis 八股（没听清）\n  4. 内存淘汰策略 (LRU)\n  5. 运营活动每天奖励 刷新/结算 怎么做\n  6. 项目（JSON解析器），怎么解析二进制的 JSON 文件？内存管理？\n  7. TCP，UDP 区别，TCP 拥塞控制和流量控制\n  8. gRPC 有什么优点，为什么选择 gRPC，gRPC 的超时和重传是怎么处理的\n  9. 数据结构，栈，队列，B 树，B+ 树\n\n面试官的网好像很差，中间有些问题听不清。\n\n要做全栈，客户端 Cocos , 服务端 Erlang，PHP。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599288231879884800?sourceSSR=users",
        "title": "神州租车后端面经",
        "content": "# 一面\n\n一面是群面，无领导小组讨论。\n\n一共十几个同学一块面试，估计各自岗位也不同。面试官首先介绍公司情况，然后给出面试规则。每个人都编了号，阅读材料之后有两个和公司产品有关的问题。第一阶段就是每个人花两分钟发表自己的看法，第二部分就是一起讨论最终答案，选个总结人进行最后的总结。\n\n# 二面\n\n时长50分钟\n\n问题聚焦在八股、项目、场景设计，没问实习\n\n  1. Java基本数据类型，Java对象类型，对象类型和基本数据类型的区别\n  2. String为什么不可变\n  3. final修饰的对象是否可变，修饰的方法中的变量是否可变\n  4. hashTable与hashmap，如何保证map的线程安全\n  5. set和list的区别，是否有序\n  6. 线程池参数，工作流程，回收线程时如何区分核心线程与非核心线程\n  7. 项目中redis 的使用，redis的数据类型\n  8. 如何设计的订单超时取消，有其他方案吗\n  9. 是否用到Spring事务，事务的传播方式，Spring事务依赖什么进行，事务失效场景\n  10. mysql索引，索引选择\n  11. 场景：两任务，a先执行5分钟暂停，b接着执行5分钟，然后a，b一起执行\n\n还有些问题记不清了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599281593961791488?sourceSSR=users",
        "title": "华为od面经 c++",
        "content": "本人背景是22届东北某985本文科类专业，面试od之前没有任何工作经验，目前已经上班了，关于具体部门、薪资不要再问了哈，保留一些隐私。\n\n我投的C++开发，都是去年报班+自学学的。投什么语言，机试和面试手撕代码就用什么语言写。另外，投C++不一定会被用C++的部门接收。比如说，我想投C++开发的岗位，机试要用C++写，然后某个用C开发的部门想接收我，我同意进入该部门，那么我后续面试手撕代码还是用C++写，等入职了再转成用C开发。\n\n**机试**\n\n前两题很简单，无非就是数组、字符串的题，第三题有一定难度，目标院校150分及格，非目标院校最好考到300+。不知道自己学校是否是目标院校可以询问hr，hr还会给你发题库。\n\n**综测**\n\n其实就是性格测试，考试前hr会给你辅导的，正常人都能过。\n\n**往部门投递**\n\n准备好简历，让hr给你投到你想去的地点和部门，如果没有想去的部门，hr会给你海投，愿者上钩。如果某部门想接收你，会给你打电话，你要是同意进入这个部门，部门会把你锁定，然后进行后续的hr面、技术面、主管面。hr面和主管面挂了还能换部门重面，开发技术面挂了好像能转投测试（似乎是这样）。\n\n**hr面**\n\n华为也管hr面叫资面，问问你的经历、稳定性什么的，面试之前hr也会给你辅导。\n\n**我的C++开发技术面面经：**\n\n**技术一面 1.24 19:30-20:30**\n\n自我介绍\n\n为什么不从事本专业\n\n为什么不申请双学位\n\n什么时候接触编程\n\n学过什么技术\n\n讲一下项目\n\n项目有多少行代码\n\n讲一下项目里的函数\n\n力扣刷过多少题 什么类型的题\n\n手撕代码 简单的字符串的题 自己写输入输出\n\n写一个二分查找函数 讲一下\n\n100个有序数，最多查找多少次找到目标值\n\nC/C++的内存分布\n\n栈和堆的区别\n\n进程的几种状态\n\nLinux下从源文件到可执行文件的过程\n\nTCP和UDP的区别\n\nTCP为什么可靠\n\n学习过程中遇到的困难的事，怎么解决\n\n遇到问题怎么办\n\n项目里的代码怎么测试\n\n（可能还有一些问题，我没记住，问得挺多😥）\n\n（问的问题也不是这个顺序，没记住顺序，想到哪写到哪了）\n\n**技术二面 1.26 16:00-17:00**\n\n自我介绍\n\n项目用了什么互斥与同步机制\n\n知道有哪些锁吗\n\n会调试吗\n\n学过设计模式吗\n\n学过HTTP吗\n\n传输层什么协议\n\nvector和list的区别\n\n学过数据结构吗\n\n手撕代码 看了几分钟不太会 让面试官换了一个题\n\n为什么高考不报计算机\n\n大学的时候得没得过奖\n\n（半道儿我电脑卡住了，给我吓死了，重启然后重进会议室了😥）\n\n（这个面试官问的不多，但是可能有的问题我也没记住😂）\n\n**主管面**\n\n最后一轮面试了，好好准备，hr会给你辅导的。\n\n也不要太紧张太焦虑，因为主管面挂了还能换部门的[狗牛头]\n\n**审批**\n\n快则一周，慢则我不知道[尴尬]，如果在审批阶段卡住了，问问hr和部门接口人怎么回事，实在不行让部门把你释放吧，转投其他部门。然后，转投其他部门还要再来一次hr面和主管面，技术面就不用再来了。\n\n**发offer**\n\n德科会先跟你商量入职时间，然后就发offer了，然后就可以愉快地入职了，入职之后会分配一个导师，我的导师人非常好，我遇到解决不了的问题，他都会帮我解决[没问题]\n\n另外，找我内推，我可以跟你平分内推奖金，d1-d2 2k，d3-d5\n3k，只有成功入职才会有内推奖金，没有入职就没有奖金。想要投od的下面留言或者私，可以推荐hr\nV，是个很温柔的小姐姐。其实，部门的人也直接招od，但是我建议还是直接跟德科对接。因为直接跟部门对接，就被部门锁定了，万一你想换部门，需要部门给你释放才行。而在德科这里完成机试和综测之后，你可以投任意部门，要是部门想接收你，会给你打电话，你要是同意进入这个部门，部门会把你锁定，然后进行后续的hr面、技术面、主管面。\n\n如果还有什么疑问可以询问我的hr，她经验比较多，会解答你的问题的。（备注V信会被吞，可以下面留言帮忙推荐）\n\n成功入职后我会跟你平分内推奖金的，本人言而有信，童叟无欺[偷笑]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599274803580739584?sourceSSR=users",
        "title": "字节抖音电商一面",
        "content": "问的很细，由项目一个小点入手，一直深问。\n\n  * MVVN与原生js写的优势（每个优势一定跟MVVN有关吗，细问）\n  * http1,2,3的区别——出了个题，问10个请求在tcp的传输下，在不同的http里面各有多少接受，花费多少时间（可能描述错误，因为我压根都听不懂）\n  * http2的里面有头部压缩，二进制，流量控制等，这些如何实现的\n  * 头部压缩在哪个部位，怎么得知是压缩的，流量控制是tcp里实现的吗，为什么在这(可能描述不清，因为他说完我就投降了)\n  * 什么是作用域，如何判断在哪个作用域\n  * let,const,var的区别\n  * 如何设置一个对象里面属性的不允许改变\n  * 一个html+js代码，js的执行结果(是否获取到dom)，问如何延迟js的执行，这些方法各有什么区别\n  * 页面渲染过程，重绘和回流，每个触发之后是否会触发所有流程\n\n手写：数组扁平化\n\n今天上午还有个经纬恒润的面试，但是太早了，大部分忘完了，问的也挺细的，看来以后要注重细节跟深度了\n\n  * axios可以获取到进度条，是如何获取的，底层如何实现的\n  * ajax,axios,fetch的区别\n  * 跨域，为什么会有，如何解决，有什么区别，cros的设置\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599270831088209920?sourceSSR=users",
        "title": "腾讯-QQ-应用研究",
        "content": "吹爆！面试官特别好，问的问题很舒服（回答可能不太舒服），搜推方向  \n基本还是挖简历，根据实习，项目，论文提问，开放题多  \n公共问题：列举10个损失函数  \n做了一题模型搭建/没准备环境 改为了leetcode  \n一共50min  \n  \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599269259390337024?sourceSSR=users",
        "title": "京东二面",
        "content": "1、自我介绍\n\n2、怎么自定义注解\n\n3、springAOP？动态代理？\n\n4、怎么用springAOP收集日志，口述下具体怎么写？\n\n5、个人项目\n\n6、分布式锁用过吗？项目里怎么用的？目的是什么？\n\n7、redis常用的数据结构\n\n8、怎么获取一个hash的所有value用什么命令\n\n9、hashMap和concurrentHashMap\n\n10、spring的注解了解多少\n\n11、实习内容\n\n12、你想怎么优化\n\n13、MVCC机制\n\n14、垃圾收集算法\n\n15、用过什么垃圾收集器，说一下g1\n\n16、反问，闲聊，看过什么书，秋招情况\n\n应该是凉了，太偏实操了。aop和redis命令都不会，我说我去百度一下就会了，场面一度十分尴尬。还问了一些实习项目优化方法，都不会。整个过程就二十多分钟。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599266124580102144?sourceSSR=users",
        "title": "虾皮 安卓一面",
        "content": "3月18 一面\n\n面试官感觉人挺好的\n\n知道我没有安卓开发经验，就问我Java了解吗\n\n问了一些Java的八股\n\ntcp http https什么的\n\n又问了设计模式我说我不会\n\n之后算法是找出出现频率最大的数字，结果语法不太会没写出来，他直接让我讲思路了，然后问我有啥想问的吗\n\n虽然我表现这么糟糕，但是感觉面试官一直都很友好没有看不起人那种，还很耐心地回答我的问题，让我这两天等hr消息，攒个人品，虽然感觉应该没了，太菜了，这么简单的题都没写出来。\n\n收到感谢信了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599262092184633344?sourceSSR=users",
        "title": "24校招，忆恒创源测试开发工程师一面（下）",
        "content": "**大家好，我是chowley，今天回顾一下，我之前参加Memblaze的面试，英文题给我干麻了**\n\n书接上文，继续写\n\n部门：长三角区域\n\n时间：40min\n\n平台：腾讯会议\n\n## 过程\n\n  18. 冯诺依曼结构 冯诺依曼结构（Von Neumann architecture）是计算机系统的一种基本结构模型，由数学家约翰·冯·诺依曼在20世纪提出。它包括计算机系统的五个基本组成部分：运算器、控制器、存储器、输入设备和输出设备。冯诺依曼结构的特点是程序和数据存储在同一存储器中，并且程序可以被视为数据进行处理，从而实现了程序的存储和执行的自动化。\n\n  19. 自己装过计算机吗？\n\n  20. 装过操作系统吗？\n\n  21. OS你用U盘装的吗？\n\n  22. BIOS了解吗？开机引导 当计算机启动时，会首先执行基本输入/输出系统（Basic Input/Output System，BIOS）程序。BIOS是嵌入在计算机主板上的固件，负责初始化硬件设备、检测系统信息，然后加载操作系统引导程序。操作系统引导程序通常存储在硬盘的引导扇区（通常是第一个扇区），BIOS会将其加载到内存中并跳转到该程序的执行点，从而启动操作系统。\n\n  23. 二进制左移右移 二进制左移（<<）和右移（>>）是位运算符，用于将一个数的二进制表示向左或向右移动指定的位数。左移相当于乘以2的移动位数次方，右移相当于除以2的移动位数次方。 例如，对于二进制数1010，左移1位得到结果10100（相当于乘以2），右移1位得到结果101（相当于除以2取整）。\n\n  24. 进程和线程区别 进程（Process）是程序的一次执行过程，是操作系统进行资源分配和调度的基本单位。每个进程都有独立的地址空间和资源，包括内存空间、文件句柄等。 线程（Thread）是进程的一个执行流，是操作系统能够进行运算调度的最小单位。同一个进程中的多个线程共享相同的地址空间和资源，但每个线程有自己的栈空间和局部变量。\n\n  25. 函数之间，变量的影响范围 在函数之间，变量的影响范围取决于这些变量的作用域。作用域定义了变量的可见范围和生命周期。 局部作用域（Local Scope）：在函数内部定义的变量具有局部作用域，只能在函数内部访问。这些变量的生命周期仅限于函数的执行过程。\n    \n        def my_function():\n    local_variable = 10\n    print(local_variable)  # 可以在函数内部访问局部变量\n    \n\nmy_function() print(local_variable) # 会报错，局部变量在函数外部不可访问 全局作用域（Global\nScope）：在函数外部定义的变量具有全局作用域，可以在整个程序中的任何地方访问。这些变量的生命周期从定义开始，直到程序结束。\n\n    \n    \n    ```python\n    global_variable = 20  # 全局变量\n    \n    def my_function():\n        print(global_variable)  # 可以在函数内部访问全局变量\n    \n    my_function()\n    print(global_variable)  # 可以在函数外部访问全局变量\n    \n\n嵌套作用域（Enclosing Scope）：在嵌套函数中，内部函数可以访问外部函数的变量。外部函数中定义的变量对内部函数而言具有嵌套作用域。\n\n    \n    \n    ```python\n    def outer_function():\n        outer_variable = 30\n    \n        def inner_function():\n            print(outer_variable)  # 可以在内部函数中访问外部函数的变量\n    \n        inner_function()\n    \n    outer_function()\n    \n\n在函数之间传递变量时，可以通过函数参数进行传递，或者通过全局变量进行访问，但应当注意作用域的限制，避免出现变量作用域混乱导致的错误。\n\n  26. linux学过吗？\n\n  27. 创建文件/文件夹的命令 touch\\vi\\vim、mkdir\n\n  28. 递归创建一个文件夹 若要递归创建一个文件夹，即在创建文件夹的同时创建其父文件夹（如果不存在），可以使用mkdir命令的-p选项。 mkdir -p path/to/your/directory\n\n  29. 代码版本管理工具，git、svn\n\n  30. 新建分支，git branch\\checkout\\switch\n\n  31. 啥叫白盒测试、啥是黑盒测试？\n\n  32. 回归测试是啥意思？\n\n  33. 反问\n\n## 总结\n\n难度：3.5/5，都是常见面试题\n\n面试官专业程度：专业，但是小姐姐顺着我简历上的链接，把我之前的文章全看了，还问我是不是来刷经验的。。\n\n体验打分：3.5/5，除了英文自我介绍，hr也没提前通知我，没准备成尬聊了\n\n**好了，以上就是本文的全部内容，如有问题可留言讨论。**\n\n**本人正在组建校招测试开发方向的交流社区，如果您对测试求职方面感兴趣，欢迎加入了解。**\n\n**我是chowley，一个专注互联网技术和产品质量保障领域的博主，我们下次再见！**\n\n**欢迎点赞、评论、收藏，it's important for me.**\n\n**Searching for QALog.**\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599256869928038400?sourceSSR=users",
        "title": "小厂凉经（30min）",
        "content": "自我介绍+项目介绍\n\nredis代替session作用及实现\n\n责任链模式作用及实现\n\n幂等注解实现原理\n\njdk动态代理\n\n线程池的参数\n\n常见阻塞队列有哪些\n\nmysql事务\n\nsql如何实现乐观锁\n\nselect * for update\n\nhttps\n\n数字证书的验证逻辑\n\n服务器的日志排查命令等\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599255490194939904?sourceSSR=users",
        "title": "华为od，社招，软件测试",
        "content": "2.28 笔试：分数不高，但是过了\n\n3.6 性格测试很顺利\n\n3.7 HR面：基本情况、期望薪资、base地、对加班的看法\n\n3.13一面：\n\n面试官很和蔼，简单问了项目相关，手撕代码也很简单，题目是买鸡（公鸡5元一只，母鸡4元一只，小鸡1元三只，求100元买100只鸡的解法）很快就写出来了，但是表现的不是很自信，这点HR在面试结束后有专门提出\n\n3.15二面：\n\n面试官稍严肃，上来就手撕代码，本身很简单，题目是数字按位计算平方和，再把结果作为输入计算100次，很快就写出来了。之后让根据题目说一下可以设计哪些测试用例，这里没有说好，实在是抓不到规律。后面就深挖项目了，面试官习惯性皱眉，给我整的挺紧张。但是最终结果是过了\n\n3.17主管面：项目相关、期望薪资、base地\n\n没有告知定级，主管面说绩效工资差不多是3k，代表d2还是d3？\n\n上一份工资低，提的期望薪资高50%，还不知道能不能审核通过[牛泪]#华为od#\n\n还是卡了30%的涨幅........\n\n3.28 打电话确认最终薪资和入职时间\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599261950974992384?sourceSSR=users",
        "title": "24校招，忆恒创源测试开发工程师一面（上）",
        "content": "**大家好，我是chowley，今天回顾一下，我之前参加Memblaze的面试，英文题给我干麻了**\n\n部门：长三角区域\n\n时间：40min\n\n平台：腾讯会议\n\n## 过程\n\n  1. 自我介绍\n  2. 英文自我介绍\n  3. 前两段实习时间很短，为什么？\n  4. 你们需要用python写脚本吗？\n  5. CI/CD用的gitlab、devops、jenkins\n  6. docker用的多吗？\n  7. 你知道SSD HOD（机械硬盘）之间的区别吗？ ● 容量：机械硬盘一般在1T左右，而固态硬盘一般会用的容量125G或者250G。 ● 重量、体积：固态硬盘要更轻、体积更小。 ● 功耗：固态硬盘的功耗也要低于机械硬盘。 ● 防震抗摔型：机械硬盘都是磁碟型的，数据储存在磁碟扇区里。而固态硬盘是使用闪存颗粒制作而成，内部不存在任何机械部件，因此在发生碰撞和震荡时能够将数据丢失的可能性降到最小。 ● 价格：固态硬盘的价格要比机械硬盘高出许多。 ● 噪音：固态硬盘运行基本无噪音，而机械硬盘的噪声相对明显。\n  8. 为啥SSD I/O更快？ 固态硬盘是从存储单元里读写数据，HDD 是机械的，磁头从盘片上读写数据，电子的当然比机械的快。 同时HDD是靠机械的磁头在盘片上读写数据，要经过寻道读写等过程，都需要时间，而ssd 是通过电路选择存储位置进行读取，电的速度是非常快的，所以ssd比hdd更快。\n  9. 学校的项目是咋来的？\n  10. 开发项目\n  11. 比赛\n  12. python面向对象还是面向过程？ Python有很多面向对象的特性，例如类、对象、继承、多态、封装等等。 Python也有很多面向过程的特性，例如函数、变量、流程控制、模块等等。 Python甚至允许在一个程序中混合使用不同的范式，例如在一个类中定义函数，在一个函数中创建对象等等。 因此，我们不能简单地说Python是面向对象的还是面向过程的，而应该说Python是既可以面向对象又可以面向过程的。\n  13. 面向对象的三大基本特征？啥意思？ 面向对象的三大基本特征是封装、继承和多态。\n\n  * 封装（Encapsulation）：封装是指将数据（属性）和行为（方法）封装在类中，并对外部提供访问接口。通过封装，可以隐藏对象的内部状态，只允许通过对象的方法来访问和修改内部状态，从而保证数据的安全性和一致性。\n  * 继承（Inheritance）：继承是指一个类（子类）可以继承另一个类（父类）的属性和方法。子类可以在不修改父类的情况下增加新的功能或修改已有的功能。通过继承，可以实现代码的重用和扩展。\n  * 多态（Polymorphism）：多态是指同一个方法在不同的对象上有不同的表现形式。在面向对象的程序设计中，多态是指通过父类或接口的引用，调用子类的方法，不同子类实例可以具有不同的行为。多态可以提高代码的灵活性和可扩展性。\n\n  14. Python中常用的数据结构？ 包括列表（list）、元组（tuple）、集合（set）和字典（dict）等。其中，列表和元组是有序的数据结构，集合是无序的数据结构，字典是键值对的数据结构。\n\n  15. 列表和元组的区别：\n\n     * 列表是可变的（mutable），可以通过索引修改、添加、删除元素；而元组是不可变的（immutable），一旦创建就不能修改。\n     * 列表使用方括号（[]）来表示，元素之间用逗号分隔；元组使用圆括号（()）来表示，元素之间也用逗号分隔。\n     * 列表适合存储有序的集合，元组适合作为不可变的数据记录。\n  16. 遍历字典的方法： 遍历字典可以使用for循环，通过遍历字典的键或键值对来访问字典的元素。\n\n     * 遍历键：使用字典的keys()方法获取所有键，然后通过for循环遍历键，再通过键访问对应的值。\n        \n                for key in my_dict.keys():\n         print(key, my_dict[key])\n        \n\n     * 遍历键值对：直接使用for循环遍历字典的items()方法返回的键值对元组。\n        \n                for key, value in my_dict.items():\n         print(key, value)\n        \n\n  17. 深拷贝和浅拷贝： 深拷贝（Deep Copy）和浅拷贝（Shallow Copy）是在复制对象时可能遇到的概念。\n\n浅拷贝只复制对象的引用，如果对象中包含可变对象（如列表、字典等），则复制后的对象仍然与原对象共享这些可变对象。浅拷贝可以使用copy模块的copy()方法实现。\n\n    \n        import copy\n    list1 = [1, 2, [3, 4]]\n    list2 = copy.copy(list1)  # 浅拷贝\n    list1[2][0] = 5\n    print(list1)  # [1, 2, [5, 4]]\n    print(list2)  # [1, 2, [5, 4]]\n    \n\n深拷贝会递归地复制对象及其包含的所有可变对象，新对象与原对象完全独立。深拷贝可以使用copy模块的deepcopy()方法实现。\n\n    \n        import copy\n    list1 = [1, 2, [3, 4]]\n    list2 = copy.deepcopy(list1)  # 深拷贝\n    list1[2][0] = 5\n    print(list1)  # [1, 2, [5, 4]]\n    print(list2)  # [1, 2, [3, 4]]\n    \n\n在实际应用中，根据需要选择浅拷贝还是深拷贝来确保程序的正确性和效率。\n\n## 总结\n\n难度：3.5/5，都是常见面试题\n\n面试官专业程度：专业，但是小姐姐顺着我简历上的链接，把我之前的文章全看了，还问我是不是来刷经验的。。\n\n体验打分：3.5/5，除了英文自我介绍，hr也没提前通知我，没准备成尬聊了\n\n后半段见下篇博客\n\n**好了，以上就是本文的全部内容，如有问题可留言讨论。**\n\n**本人正在组建校招测试开发方向的交流社区，如果您对测试求职方面感兴趣，欢迎加入了解。**\n\n**我是chowley，一个专注互联网技术和产品质量保障领域的博主，我们下次再见！**\n\n**欢迎点赞、评论、收藏，it's important for me.**\n\n**Searching for QALog.**\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599252559873810432?sourceSSR=users",
        "title": "杭州端点  项目+八股场景拷打，直接凉",
        "content": "Java里面的常见集合\n\nArraylist和LinkedList的区别\n\n栈和队列的区别\n\n重载和重写\n\njava代码从编写到编码项目的运行，经过哪些阶段\n\n编写的jar文件是如何运行的\n\n项目启动是怎么部署到机器上的\n\n怎么判断添加的索引是否生效\n\nselect语句从java客户端编写，到mysql服务器返回结果呈现给客户端，流程是怎么样的\n\n发到mysql客户端经过哪些操作能返回给java服务端（上面答得一半，所以继续问）\n\n程序中哪些地方用到redis（场景题）\n\nredis分布式锁的目的\n\nMQ的使用场景\n\nSpringCloud里的Eureka的了解\n\nDubbo的了解\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599216882180276224?sourceSSR=users",
        "title": "三一重工—机械工程师",
        "content": "1 自我介绍  \n2 介绍实习项目  \n3 面试官自我介绍  \n4 讲解项目，介绍项目  \n5 机械压力机的工作原理  \n6 影响轧制力的主要原因？  \n7 学习成绩  \n8 做过哪些项目 会哪些软件？  \n9 意向的工地地点  \n10 反问  \n  \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599209751498584064?sourceSSR=users",
        "title": "作业帮广告算法一面",
        "content": "![kMVHt7aeMhBB0gCg0TBkcA0fV8wnkPKU.jpg](https://uploadfiles.nowcoder.com/images/20240318/853190627_1710734730294/1AF84A720EF8C86EE5246D0CF4D1B819)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599252187260252160?sourceSSR=users",
        "title": "3.16 得物青训营  项目+八股",
        "content": "自我介绍 介绍一下自己的项目 在秒杀业务中为什么要使用乐观锁 redis中的分布式锁是怎么实现的 说一下线程池 线程池处理任务的流程\n怎么设置使用线程池的参数 使用线程池使用JDK中封装的？ 讲一下JAVA的内存模型 JAVA中的关键字volatie JAVA的垃圾回收算法\nJAVA中的异常 深拷贝和浅拷贝的区别 MySql中的覆盖索引 spring 中的 IOC控制反转 了解过幂等的概念 分布式CAP的概念\n微服务中base的概念 远程调用RPC框架的实现原理 两个系统之间使用dubbo接口怎么进行通信\n\ngit常见的指令和使用的场景 怎么入手去完成一个业务需求\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599212318051909632?sourceSSR=users",
        "title": "蔚来一面",
        "content": "一面50分钟\n\n以我自我介绍开始，\n\n然后问了我的简历，实习经历，实习内容，实习收获\n\n面试官自我介绍，介绍项目\n\n介绍我在实习当中遇到的困难或者学习中遇到的困难是怎么解决的\n\n介绍实习项目基础，详细过程、本人在这份实习中的身份\n\n未来几年的职业规划\n\n反问环节：对应届生的要求是什么？详细的工作内容、对我的看法\n\n闲聊5分钟\n\n面试结束\n\n"
    }
]