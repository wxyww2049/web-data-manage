[
    {
        "url": "https://www.nowcoder.com/discuss/572927530051665920?sourceSSR=users",
        "title": "❗【经验分享】衣恋秋招测评",
        "content": "衣恋2024届秋招测评\n\n1.测评形式：电脑端\n\n2.测评时长：30-35分钟 单体作答时间60s\\75s\\90s三类\n\n3.测试方式：笔试\n\n4.题目类型：1）阅读理解：\n\n-题目个数：22道题\n\n-答题时长：10分钟\n\n-出题方式：\n\n✔选项个数：4个\n\n-举例：每一个活生生的人的生活中都充溢着各种各样的色彩，然而科学只是却是没有颜色的。一群彩色的人要学会带着没有颜色的态度去追寻科学知识，这就必然会存在着有颜色的力量去催促我们追寻的脚步。这种来自生命的有颜色的力量会决定这一个人对于知识的忠诚度以及追求知识的方向。\n\nQ：文中“有颜色的力量”指的是：A.科研态度B.兴趣爱好C.道德标准D.价值取向\n\n2）计算题：\n\n-题目个数：10道题\n\n-答题时长：10分钟\n\n-出题方式：✔选项个数：3-4个\n\n-举例：下表为我国2020年第一季度旅客运输量统计表，根据图表回答下列问题。\n\n表格：2020年3月客运当期值（万人）38573，客运同比增长（%）为-73\n\n将2020年3月的增长速度转为正数并以此为基础，推测2021年3月客运量为（ ）万人\n\nA. 56901B. 59721C. 66731D. 69101\n\n3）图形题：-题目个数：11道题\n\n-答题时长：10分钟\n\n-出题方式：\n\n✔选项个数：3-4个\n\n✔题目：前几个图形呈现规律，推测最后一个图形是什么图\n\n❗感觉是北森的题库，和前几天科大讯飞的题库一样，可以多刷北森的题\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572919831716962304?sourceSSR=users",
        "title": "Boss直聘 校招",
        "content": "1.Hashmap的低沉数据结构和put元素的流程\n\n2.线程安全的map有哪些(我说了hashtable和cureenthashmap,接着问他们都是怎么实现线程安全的)\n\n3.cas底层实现,有什么问题\n\n4.线程池的参数,工作流程,平时用过线程池吗\n\n5.堆的划分情况\n\n6.有哪些垃圾回收器,讲一下parallel垃圾回收器的工作流程\n\n7.垃圾回收的过程,老年代的垃圾回收\n\n8.查看java线程和堆的工具有了解吗\n\n9.jvm调优有了解吗\n\n8.单例模式的特点,怎么保证每次获取的对象都是同一个\n\n还有几个忘了,每个问题都追着问得挺细的\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572873394757050368?sourceSSR=users",
        "title": "华为od面试记录",
        "content": "技术一面：\n\n1.手撕代码，算法题：\n\n【最小路径和】\n\n![](https://uploadfiles.nowcoder.com/images/20240105/100368147_1704453397033/255CAF0B2F23E5A5FA68C4D9DEE2227E)\n\n手撕代码通过，面试官拍了照片\n\n2.深挖项目，做过的自认为最好的一个项目，描述做过的项目的工作过程，使用到哪些技术？\n\n技术二面：\n\n1.深挖项目，\n\n（1）BI系统和数据源打通的流程，详细描述一下数据采集和数据清洗的步骤、流程、技术；\n\n（2）数据库方面的知识，Oracle的表空间、子表还有数据库的全文索引，解决慢SQL查询的系统方法论和实际经验，Oracle和Mysql的区别是什么？Mysql有表空间吗？Oracle和Mysql的数据管理模式有什么不同？\n\n（3）数据库视图有哪些分类，物化视图和普通视图的区别是什么？在物化视图或者普通视图中使用索引需要注意什么？\n\n（4）询问java基础知识，java内存的使用，java堆栈是什么、堆和栈的区别是什么？线程安全的Map有哪些？工作或者刷算法题用过哪些java基础数据结构？ArrayList是有序还是无序的？\n\n（5）询问大数据组件方面的知识，ES、Hadoop或者Spark、Redis、Mongodb有没有用过？\n\n2.手撕代码，算法题：\n\n给定一个边长为len的表格，把它按边长gridLen来划分为若干等分的格栅。(len为gridLen的整数倍长)。\n\n* 请计算进行格栅化之后，给定的坐标(x,y)出于第几个格栅。格栅编号从1开始\n\n* 如：以下为边长6的表格，格栅边长为3.其中(1,5)出于第二个格栅。输出2\n\n手撕代码通过，面试官拍了照片\n\n技术二面面试官给出的评价：开发能力是短板，算法能力、算法思维不错，有一定的数据库能力，还需综合考量\n\n周一出面试结果，我是菜狗一个[好无辜][好无辜][好无辜]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572924510597349376?sourceSSR=users",
        "title": "❗【经验分享】招商银行深圳分行一面",
        "content": "招商银行深圳分行一面\n\n时长：30-40min\n\n形式：远程群面\n\n问题：招商银行正在推行XXX新卡，且要举办活动宣传低碳环保的理念，还可附赠低碳小杯等赠品，现有4W元，请合理分配，举办此次活动。\n\n过程：1.前10分钟按面试官指定顺序依次发表个人的意见，每人1分钟时间\n\n2.后30分钟要讨论出一个结果并做最终陈述\n\n❗关键是后30分钟，因为人数多，所以先有发言权比较重要和最后的总结陈述比较重要。（因为面试官要求不能屏幕共享，所以我是拿笔记在纸上，其他人都没有记，所以争取到了陈述机会）\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572865433066340352?sourceSSR=users",
        "title": "武汉腾佳实习生面试",
        "content": "我们这次的面试是学校组织的专场面试，到腾讯后，讲解员先带我们逛了一下公司 环境相当的好\n\nhr简单做了个ppt介绍腾佳 待遇还蛮好 实习生230/天 班车接送、下午茶等等\n\n后面开始进行一面 因为我们大概有30个人 所以一面理所当然是群面\n\n学校档次是211 大多数同学并不是人力相关专业\n\n每组六个人 然后抽题目 每一个30s的自我介绍 然后无领导讨论 最后三分钟汇报 全程40分钟\n\n我们组抽到的题目的：讨论现如今越来越多大学生选择“慢就业”的现象、原因以及应对措施\n\n总体上比较常规 但由于自己并没有太多的无领导经验 整体表现一般 也没有抢着当leader和汇报人 所以群面没有通过\n\n群面结束后，那两个面试管出去讨论了两分钟 就告诉我们面试结果，最后是leader和汇报人进了第二面\n\n第二面也是当场进行 不过是一对一的面试 据我同学所言 二面就比较轻松了 就让你再做一个自我介绍 以及一些简单的问题 氛围比较融洽\n\n最后是面试总结吧：个人感觉无领导还是得抢着做leader和汇报人，才有机会脱颖而出，特别是竞争压力比较大的情况下。单纯的提供零碎的想法 哪怕最后被团队采用了\n也很难成功，很难给面试官留下比较深的印象。其次是多多锻炼、不断训练自己逻辑和表达的能力。最后简历可能也是比较重要的一点，进二面的那两个同学都是保研的学生，如果你的成绩优秀可能会给你带来更多的机会，而简历相对没那么漂亮的同学呢，我感觉可以积极地表达自己。毕竟面试嘛，充分表现自己为主，不用过度的谦让，不然很难成功。\n\n企业的人力岗群面其实都大差不差，多多锻炼自己的表达能力才是王道。哈哈，我去投简历去了 做越挫越勇的小强！！\n\n最后，祝愿大家都能面试成功，加油加油加油~\n\n#\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572859889337335808?sourceSSR=users",
        "title": "字节跳动-C++数据库开发实习-bytehouse面经",
        "content": "一面 12月28日 15：00 1h\n\n  1. 了解分布式吗，看过哪些相关的分布式数据库和知识\n  2. 看过哪些论文\n  3. 深挖minisql项目\n  4. 2PL\n  5. 脏读，幻读，不可重复读\n  6. 这个项目是怎么实现的，从0到1吗，介绍一下实现的过程\n  7. 支持哪些SQL数据类型\n  8. 日志系统的设计（支持哪些日志格式）\n  9. 如果用户写入一个大的blob日志怎么处理\n  10. fsync怎么处理的\n  11. redo log在commit之前还是之后处理的\n  12. 是否有丢失数据的风险\n  13. 有什么难点（LRU冷热分离+阈值）\n  14. 介绍一下怎么发现这个问题的\n  15. LRU有哪些变形\n  16. 布隆过滤器的原理\n  17. flexdb项目\n  18. 使用mmap来读取hint文件构建索引加速数据库启动介绍一下\n  19. WAL格式的设计\n  20. 一个chunk的大小是多少\n  21. lsm-tree\n  22. compaction机制介绍一下\n  23. memtable是什么数据结构\n  24. level1和level2的数据有什么类型\n  25. git有哪些命令\n  26. static这个关键字的作用,初始化值是多少\n  27. TCP三次握手及各个状态\n  28. TCP为什么要4次挥手，为什么不能是3次\n  29. 算法题：n个数组求交集\n  30. 时间复杂度是多少\n  31. 只扫描一次怎么实现\n\n二面 1月3日 19：30 45min\n\n  1. mysql为什么使用B+树作为存储引擎\n  2. 对比其他数据结构的优缺点\n  3. B+树的时间复杂度是多少\n  4. B+树和lsm-tree的读写性能对比\n  5. lsm-tree中的sstable如何快速的进行查询数据\n  6. 数据库是怎么学习的\n  7. 参与到开源社区有什么收获\n  8. 看过哪些开源数据库\n  9. 空闲的时候做些什么\n  10. 算法题:手写json解析器\n\n\\----\n\n1月5日更\n\n二面挂了，面试官问的问题都答上来了，题也都写出来了，面试官还说各方面的知识掌握的很好，面完还感觉非常良好。结果今天通知二面没过，真是当头一棒，可能年末部门hc变动吧，难受。\n\n  \n\n  \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572825043252645888?sourceSSR=users",
        "title": "唯品会（校招实习）",
        "content": "12月份在老板上投的，应该是校招岗位，但是要求先实习一到两个月，然后走转正流程。\n\n咋说呢，和一、二面的面试官聊的挺来的，当场感觉就能过。三面那个面试官，他说了会问一些开放性问题，随便回答，我回答之后其实心里挺没底的，以为寄了，但没想到最后给过了。\n\nps：感觉唯品会实习挺好的，电商业务线、在广州、包饭吃，如果时间再往回退一些，确实值得考虑。\n\n一二面：场均面试时间60min，总是会有基础八股，但又不缺乏难度（附带一些奇奇怪怪的内容）。\n\n三面：30多min，大多都是开放性问题和场景题，问有没有实践过、如果是你该如何考虑。\n\nhr面：30多min，基本都是常规问题。\n\n面试体验：面试官都提前进入了会议，基本上不会出现候选人等待较久的问题；面试流程推进很快，一天一面；面试过程总体来说还算**愉悦** 。\n\n### 12.27（一面）\n\n面试过程中时不时哈哈哈，呵呵呵。\n\n  * 实习做什么的，工作辛不辛苦\n  * double几个字节，int几个字节，引用类型几个字节\n  * 64位机器的引用类型能不能用4个字节存（想问指针压缩的内容）\n  * Integer几个字节（其实想问对象结构）\n  * 对象头里面有啥\n  * 集合体系\n  * HashMap如何判断key-value对是否存在\n  * HashMap是否线程安全，为什么呢\n  * 假设一个整数值为100，多个线程对其进行递减，保证其值不能小于0\n  * synchronized 和 AtomicInteger都可以\n  * 使用AtomicInteger时，满脑子都是decrment，然后发现这个API不好使线程池相关\n  * JVM相关\n  * 垃圾回收机制\n  * CMS流程，如何减少serial old兜底的次数\n  * G1与CMS相比先进在哪，部分回收时会不会存在跨代引用，如何解决\n  * 是否有了解过最新的垃圾收集器MySQL索引最左匹配原则如何理解\n  * 扣减库存，如何不超卖\n  * update语句为什么能保证不超卖\n  * 仅使用update语句，数据库压力大怎么办\n  * 用了Redis之后，如果库存正在卖，商家告诉你根本没这么多库存，如何扣减掉多出的库存Redis的部署架构有哪些\n  * cluster模式下，key如何定位存储节点\n  * cluster模式下，增加新的Redis节点到集群，期间数据迁移的过程\n\n### 12.28（二面）\n\n  * 聊聊集合体系（数组、列表、Map之类的），举一两个场景，比如什么时候用Map\n  * 聊聊时间，怎么获取时间戳，如何格式化显示，有什么坑，比如24小时制和12小时制\n  * 聊聊并发，讲讲ThreadLocal，讲讲线程间的同步（Synchronized锁定的对象有什么要求）\n  * 如何发现当前进程是否内存泄露？是的话泄露在哪些地方\n  * Linux命令，如何查看端口号被那个进程占用？JAVA进程占用了哪些端口？\n  * 除了grep之外，还知道其它文本处理工具吗\n  * 聊聊开发规范，写过测试吗？Idea 为什么报warning？\n  * 如何设计数据库表？或者说在设计时有没有什么要注意的地方？除了范式之外呢？\n  * 聊聊实习和项目\n  * RPC调用过程中为什么要有序列化和反序列呢\n  * RPC调用过程中，调用方是如何得知被调用方在哪呢\n  * 服务提供方是如何保证自己唯一的呢\n  * 对于Redis中的hash结构，hget一个不存在的key会发生什么\n  * Redis Cluster的key是如何定位存储节点的\n  * 写个排序算法，随机生成一个长度为100的数组，数组中每一个值的大小为[-10000,2000]，对数组进行排序（我选择的是归并排序）\n  * 如何学习的\n  * 有啥其它的兴趣爱好\n\n### 12.29（三面）\n\nCPU被干烧了。\n\n  * 讲讲你理解的IOC和AOP\n  * 用过Cglib吗\n  * 一个Java进程线上运行CPU利用率飙升，如何定位问题\n  * 假设一个服务要启动，与Spring结合的，要求Spring所有的Bean准备好之后，再启动，如何做\n  * 既然服务启动之后要注册，那这个注册的过程做了什么呢\n  * 单元测试要注重哪些指标\n  * 假如我要上线一个服务，服务本身所占用的资源该如何分析（比如给它分配多少内存、多少CPU核心）\n  * 有没有做过压测，压测的过程及其结果有哪些部分让你受益，举个例子\n  * 一次请求，可能会经过若干服务调用（A->B->C->D这种）。同时这次请求响应时间过长，我该如何知道主要耗时在哪呢（调用链路中，哪段调用占用时间最多）\n  * 查库存，若干步骤，减库存，保证不能超卖如何做\n  * Netty的线程模型讲一下\n  * IO多路复用的实现讲一下\n  * 客户端100个请求过来，服务端这边会开多少个TCP连接呢（持续坐牢）\n  * 服务端能够同时处理2w个请求吗，能维持2w个TCP连接吗\n  * 或者说限制服务端TCP连接数的因素有什么呢\n\n### 1.3（hr面）\n\n聊天环节，不要表现的自己有沟通障碍就行。\n\n围绕着 经历（比赛经历、实习经历、社团经历），选择（城市选择、offer选择、行业选择），个人规划等等展开的，以软技能为主。\n\n只能说被hr牵着走，也不知道她会从回答中得到啥，有可能自己的老底都被挖出来了。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572792104997363712?sourceSSR=users",
        "title": "快手校招 容器云平台开发 面经1.05(二面挂)",
        "content": "**一面**\n\n1.实习主要做些什么，遇到哪些比较有困难有挑战的事情\n\n2.正在面试的页面用到了那些协议？比如哪些应用层协议\n\n3.http与https之间的区别\n\n4.传输层有哪些协议？视频用到了哪种？\n\n5.浏览器打开页面时是如何与服务器做交互进行数据传输的？TCP三次握手的过程\n\n6.实习的时候后端服务如何部署到线上的\n\n7.docker容器用到了什么样的技术？docker是通过什么技术实现的虚拟？如何进行资源的限制？\n\n8.线上服务有没有出现过CPU性能差或者是进程被操作系统杀掉的场景？\n\n9.linux系统下在程序没问题的情况下有哪些场景会使某个进程突然停止运行？这种操作系统杀掉进程操作的机制专有名词叫什么\n\n10.linux操作系统要写文件或者写日志的大概过程\n\n11.linux写文件要先从用户态拷贝到内核态，然后在内核态间还要进行一次拷贝，有没有更高效的方式?考察零拷贝\n\n12.TCP的包是怎么发出去的，怎么通过协议栈一步步封装交给网卡？怎么跟网卡做交互的\n\n13.讲讲TCP的拥塞控制\n\n14.讲下Java中 HashMap的实现\n\n15.Redis中Zset是用什么数据结构实现的？\n\n**算法题：**\n\n先问我堆会写吗，我说手写数组实现的二叉堆要点时间，换了一道题；leetcode 146.LRU 缓存\n\n二面\n\n基本没有八股，拷打项目，手撕没写出来，已挂\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572757912003608576?sourceSSR=users",
        "title": "米哈游国际化岗位面试笔试注意事项",
        "content": "在应聘此类岗位之前，你需要了解这些\n\n1.什么是游戏出海？\n\n游戏出海是指中国大陆地区游戏公司研发的移动游戏在海外上线并成功发行的模式。（这里出海的地区也包括港澳台地区哦）\n\n2.聊聊游戏出海的成绩\n\n2022年中国自主研发游戏在海外市场的实际销售收入为173.46亿元；其中，美、日、韩市场是主要海外市场，占比分别为32.31%、17.12%和6.97%（结合出海游戏行业报告总结）\n\n3.哪些公司做得好，国际化岗位多\n\n中国手游出海收入表现优异的有《原神》、《PUBG》、《荒野行动》、《万国觉醒》、《使命召唤手游》、《王国纪元》、《明日方舟》等；\n\n所以米哈游、腾讯、网易、莉莉丝、funplus、三七互娱、1GG悠星网络等都可以投递\n\n4.为什么越来越多的公司做出海\n\n1）受制于政策、版号审核严格，且版号下发等待周期长，未成年人保护趋向严格。\n\n2)海外市场庞大且处于蓝海期，出海做的好的能为国内企业带来很大的利润空间\n\n3)国家也在大力扶持游戏出海。政策之一是文化出口，即鼓励优秀的游戏作品通过游戏出海的方式传播中华优秀传统文化。\n\n5.怎么快速准备笔试和面试\n\n首先rpg类型和slg类型的游戏在出海的表现更好，也就是说，这类游戏才能诞生出更多的国际化运营、国际化市场等岗位。\n\n其次，需要自己多玩这类游戏，能够总结出这些游戏做国际化推广、国际化社区运营等的成功要素。\n\n最后，要分析你选定区域的目标用户画像、当地市场环境、对人文有一定了解。列如“在rpg手游市场上，日韩区域的男性玩家超过60%年龄分布在21-35，有全职工作，收入属于中高水平，受教育水平较高，付费意识明显。”等等=（这类分析是需要自己花功夫做的）\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572737199075065856?sourceSSR=users",
        "title": "深信服测开社招一、二、三、HR面面经",
        "content": "时间线：\n\n2024年1月4日\n\n2024年1月10日\n\n2024年1月12日\n\n2024年1月25日\n\n**一面内容：**\n\n面试官迟到十分钟，刚准备给HR打电话，面试官进来了\n\n1、自我介绍\n\n2、手画自己开发的测试提效平台架构\n\n因为面试官迟到这么久，加上给面试官讲解他总是误解，把自己快给讲急眼了，最后才给他讲明白了\n\n3、接口自动化，难点是什么？断言校验的正则如何编写？然后给出了几个正则的匹配，让现场写\n\n4、项目拷打\n\n5、算法题\n\n括号合法性校验，输入除了各种括号之外还包括数字、ACCII码等等\n\n6、反问\n\n整体面试的感觉是都回答上了，面试之后收到面试评价，关于有一条是面试官是否迟到十分钟及以上，果断选择了是，面试是双向的，我没做出来题但是其他的回答的都很好面试官可能也会给我挂掉，并不会因为你其他的表现而就给你过；同理，你迟到了我就给你差评，不会因为你给我面试通过我就掩盖你的缺点。\n\n**二面内容：**\n\n面试官说他是部门的架构师，我说我不是面的测试开发岗位吗？他说他原本也是测试开发，后来转架构了，也是同一个部门，现在由他来做一个二面的考核。\n\n1、自我介绍\n\n2、项目拷打（接口自动化、UI自动化、埋点自动化、大促质量保障、平台开发）\n\n3、和其他部门之间的协同？\n\n4、目前所在部门的人力安排？\n\n5、怎么做到QA之间的信息同步？\n\n6、反问\n\n整体面试也比较愉快，没写算法题，面试官说现在招聘的测试开发岗位，倾向于既能做业务，也能做开发类建设的，不是业务和效能建设分开的人，说我还比较符合要求。\n\n**三面内容：**\n\n1、你是哪里人？\n\n2、为什么离职？\n\n3、给我讲讲你们现在的业务吧，也聊了聊项目还有工具能力建设，整体得20多分钟\n\n4、什么时候可以入职？现在在Shopee的工作强度？\n\n5、对象家哪的？给了多少彩礼？（妈耶，我对象和他对象是老乡）\n\n6、反问\n\n反问中告诉了要安排我去做大模型方向，看我研究生期间主要是做的这一方面。\n\n给介绍了下工作强度：\n\n周一二四：9:00-20:00\n\n周三五：9:00-18:00\n\n说后续会有HR找我面试，到时候就是会问一些HR常问的内容还有谈薪之类的。\n\n**HR面内容：**\n\n1、自我介绍\n\n2、目前处于离职还是在职状态？提离职了吗？\n\n3、在虾皮有什么突出贡献\n\n4、在百度有什么突出贡献\n\n5、现在的职级\n\n6、为什么离职\n\n7、对未来的职业规划\n\n8、期望薪资\n\n回答他这个问题前我先问了几个问题，大体如下：\n\n公积金**5%**\n\n社保**12%**\n\n年假**5** 天，过年会多放**6** 天，年前多3天，年后多3天\n\n每周一三五入职\n\n吃饭**三餐免费**\n\n薪资说是**15** 薪\n\n工作时间**965** ，**每个月第一周的周六上午会上班** ，每天也可能会加班，会看业务部门；结合三面面试官给出的时间，应该就是\n\n周一二四：9:00-20:00\n\n周三五：9:00-18:00\n\n9、有没有别的offer\n\n10、可入职时间\n\n1月25日当晚收到性格测评，让有时间的时候把测评做了，100个题，量有点大。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572705947567620096?sourceSSR=users",
        "title": "去年面快手时候的面经",
        "content": "# 实验室的bug没改明白，我烦了，写个面经换换心情哈\n\n碎碎念：从研一开始学Java相关的东西，到现在，非科班加油！  \n9月20日我生日当天晚上九点半开完组会投递了实习；  \n没想到第二天一点多就安排面试；  \n\n安排到9月22日一面\n\n楼主是摆烂工硕士非科班\n\n  \n\n# 一面(1h)\n\n  * 人生第一次求职面试，面试官人很好，问的也都是基础的问题；(可能有遗漏，但是大体上都还记得)\n  *   \n\n  * 说说java的集合；\n  * 从分类以及特点进行了详细诉述；\n  * ![](https://uploadfiles.nowcoder.com/images/20221014/159684783_1665746954157/88DE8EA7E96002F3ACCFDD1E017A49E9?x-oss-process=image%2Fresize%2Cp_50)  \n\n  * 讲讲JVM垃圾回收器的CMS和G1\n  * 常规八股\n  * 听过JUC把，那除了ConcurrentHashMap还了解啥？\n  * （我简历写了用过，然后还强调了一下ConcurrentHashMap，所以面试官就不问我这个）\n  * 我说了一堆，从JUC锁说道JUC集合再说到JUC工具类，但是感觉面试官并没有让我停下来的意思，我突然想到，怕不是问我线程池吧，然后说了线程池，面试官才接下来话茬；\n  * 说说你怎么用的线程池？\n  * （说了两种创建线程池的方式，以及阿里巴巴手册上不推荐使用其中一种的详细原因，感觉面试官还挺满意（大概））；\n  * 我把那7个核心参数也说了；\n  * 听过多路复用嘛？\n  * 听过，老八股了，select、poll、epoll的区别说了下；\n  * 我看你写了用过Redis，那你说说他的数据结构吧；\n  * 5个基本数据结构，3个特殊的；\n  * 那讲讲跳表吧\n  * 依然还是老八股，巴拉巴拉……\n  * 说说缓存一致性问题？\n  * 这好啊，我这博客正好写过\n  * [如何保证缓存和数据库数据的一致性？【重点】【阿里云面试】_加油当当的博客-CSDN博客_如何保证缓存和数据库数据的 致性?](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgw-c.nowcoder.com%2Fapi%2Fsparta%2Fjump%2Flink%3Flink%3Dhttps%253A%252F%252Fblog.csdn.net%252Fjiayoudangdang%252Farticle%252Fdetails%252F123330774%253Fops_request_misc%253D%2525257B%25252522request%2525255Fid%25252522%2525253A%25252522166427002916800182727099%25252522%2525252C%25252522scm%25252522%2525253A%2525252220140713.130102334.pc%2525255Fblog.%25252522%2525257D%2526request_id%253D166427002916800182727099%2526biz_id%253D0%2526utm_medium%253Ddistribute.pc_search_result.none-task-blog-2%257Eblog%257Efirst_rank_ecpm_v1%257Erank_v31_ecpm-1-123330774-null-null.nonecase%2526utm_term%253D%2525E9%252598%2525BF%2525E9%252587%25258C%2525E4%2525BA%252591%2526spm%253D1018.2226.3001.4450)\n  * 用过消息队列吧？\n  * 用过\n  * 那说说RabbitMQ……\n  * 没用过这个，用的kafka\n  * 哦，那说说Kafka如何保证消息的消费顺序？\n  * 巧了啊，又是老八股\n  * 说说kafka为啥这么快？\n  * 这个我卡了，我想了10s没有想法，面试官提示说，想想kafka存储的方式？\n  * 又想了想，突然想起来：\n  * [Kafka的性能好在什么地方：kafka为何这么快？kafka高效读写【重点】_加油当当的博客-CSDN博客_kafka性能为什么好](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgw-c.nowcoder.com%2Fapi%2Fsparta%2Fjump%2Flink%3Flink%3Dhttps%253A%252F%252Fblog.csdn.net%252Fjiayoudangdang%252Farticle%252Fdetails%252F125811853%253Fops_request_misc%253D%2525257B%25252522request%2525255Fid%25252522%2525253A%25252522166427014216800182168466%25252522%2525252C%25252522scm%25252522%2525253A%2525252220140713.130102334.pc%2525255Fblog.%25252522%2525257D%2526request_id%253D166427014216800182168466%2526biz_id%253D0%2526utm_medium%253Ddistribute.pc_search_result.none-task-blog-2%257Eblog%257Efirst_rank_ecpm_v1%257Erank_v31_ecpm-1-125811853-null-null.nonecase%2526utm_term%253Dkafka%2526spm%253D1018.2226.3001.4450)\n  * 内心OS还好没多问，再多问我就不会了：\n  * [Kafka数据存储设计：【必会】_加油当当的博客-CSDN博客_实时数仓kafka存储设计【必会】Kafka基本概念(topic、partition、offset、broker、生产者、消费者、消费者组等)【知识点速记速查】_加油当当的博客-CSDN博客_kafka topic是什么Kafka数据存储设计：【必会】_加油当当的博客-CSDN博客_实时数仓kafka存储设计](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgw-c.nowcoder.com%2Fapi%2Fsparta%2Fjump%2Flink%3Flink%3Dhttps%253A%252F%252Fblog.csdn.net%252Fjiayoudangdang%252Farticle%252Fdetails%252F125811429%253Fops_request_misc%253D%2525257B%25252522request%2525255Fid%25252522%2525253A%25252522166427014216800182168466%25252522%2525252C%25252522scm%25252522%2525253A%2525252220140713.130102334.pc%2525255Fblog.%25252522%2525257D%2526request_id%253D166427014216800182168466%2526biz_id%253D0%2526utm_medium%253Ddistribute.pc_search_result.none-task-blog-2%257Eblog%257Efirst_rank_ecpm_v1%257Erank_v31_ecpm-3-125811429-null-null.nonecase%2526utm_term%253Dkafka%2526spm%253D1018.2226.3001.4450)\n  * 知道RPC吗?\n  * 我说我只知道他是远程过程调用以及他的简单原理，实际上我并没有用过，面试官也就没有继续问；\n  * 好，感觉目前为止我和面试官都比较开心\n  * 那来个算法题吧~\n  * 出了一个十分基础的题，但是我第一次搞面试，面试官都看出来我紧张了……主逻辑没问题，但是输入输出乱套了；\n  * 跟面试官道歉了一下，因为确实是个简单题，写的还半拉柯基的我已经不原谅我自己了\n  * 面试官说没关系，再来个常规的；\n  * 出了一个统计二叉树层数，十分简单；\n  * 反问：\n  * 问了技术栈；\n  * 问了部门方向；\n  * 面试官不太满意，说再问点，然后我支支吾吾，他就说我直接说吧，然后他就介绍部门巴拉巴拉巴拉……\n  * 然后就让等二面了；\n  * ps：后续：\n  * 后来一面的面试官变成我的mentor啦，人很和善，超级棒！！\n\n# 二面(0.5h)\n\n  * 面试官依然很和蔼，就是面试官网很卡；\n  * 问了点Spring的启动过程；\n  * 然后直接算法题；\n  * [快手主站技术部二面的小算法题-三数之和小变种_加油当当的博客-CSDN博客](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgw-c.nowcoder.com%2Fapi%2Fsparta%2Fjump%2Flink%3Flink%3Dhttps%253A%252F%252Fblog.csdn.net%252Fjiayoudangdang%252Farticle%252Fdetails%252F127020851%253Fspm%253D1001.2014.3001.5501)\n  * 然后就让我反问：\n  * 我问了为了更好的适应实习还应该学啥？    \n  * 面试官说，还应该多实习（大概就这意思）；\n\n# HR面(0.5h)\n\n  * 就聊呗；\n  * HR说有面试官催他赶紧面，所以就昨天晚上7点电话面的；\n  * 后续，HR今天中午说了给审批Offer，让我注意邮箱（虽然我现在还没收到）；\n  * 周三晚上收到了，周五入职（国庆前一天），到工位之后大家还调侃是不是掐点来的（系统安排的，面试者根本选不了入职时间好像，我记得当时跟HR说的可以尽快入职，然后就这样了QAQ）\n\n#\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572567842537701376?sourceSSR=users",
        "title": "面试官问：“讲讲你最有成就感的一个项目?” 千万别讲偏了",
        "content": "面试过程中，每个同学的简历都会写几个项目经历，作为面试官，我常让候选人讲讲你最有成就感的一个项目开始专业能力考察。最有成就感项目，候选人相对比较熟悉，容易缓解紧张，更好的进入状态。\n\n**项目很多怎么问**\n\n特别是社招同学，多年工作经历，项目很多，很多面试官简单粗暴，让候选人自己选一个最有成就感项目，这里面也要注意，同学们选择的项目不要时间太久远，反向证明最近一段时间没什么拿得出手项目。\n\n**面试官想讨论什么**\n\n面试官核心想了解项目中，总体系统的架构，你所负责的模块，用到的主要技术点，主要难点，系统的不足和待优化点。通过这些方面展开考察。\n\n**你该怎么讲？**\n\n同学们首先讲解系统总体架构，这块大家要注意，讲解的时候，一定不要太着急，在纸上完整清晰的画出自己系统的架构图，如果线上面试，可以打开画图软件演示。\n\n讲解的时候分层分模块的讲解，这块的内容之前也跟同学们强调过，一定是提前有所准备的。讲解过程中我常会提问一些自己感兴趣的跟系统相关的业务和数据流程等问题。让候选人慢慢进入状态，同时我也逐渐熟悉项目系统。\n\n总体架构讲完，讲自己负责了哪些模块，负责的一定是比较核心的模块，细致讲解负责核心模块的设计架构，用到了哪些技术，研发过程中遇到的难点问题，比如数据量大，逻辑复杂，算法比较难等等。这个时候我会提问所用到的技术知识点，同时扩展对应的知识点，比如用到了thinkphp框架，介绍下框架的处理流程及MVC设计原理等，来进一步考察相关技术栈的掌握情况。\n\n同时对于难点和系统设计提出个人的疑问，为什么这么设计，为什么不用xx方法，这个难点为什么这么解决，不考虑用xx技术或策略等。来考察候选人的临场应变和技术视野等方面能力。这块也是整个项目讲解考察的核心步骤，占用时间比较长。\n\n**该怎么回答面试官问题**\n\n对于面试官各类问题，特别是对技术点的考察，同学们在回答过程中几个经验和宗旨希望大家借鉴参考：\n\n要自信，在校生实战能力普遍不高，大多数同学都差不多，我们更多是考察同学们在校学习能力，综合素质，不会特别在意某个技术点没答出来就failed掉某个同学。重要的是对自己的项目和系统要认真总结准备，主动思考我刚才说的那些内容。让自己更具有专业性。\n\n对于不会的知识点或技术点，该认怂就认怂，不会就不会，但是告诉面试官，这个问题如果可以这么解决，我下来调研学习下应该是个不错的尝试。讨论涉及的技术点，主动告诉面试官，基于这个项目所用到的技术，我还较系统的学习了相关的技术点，比如会xx技术等，面试官会觉得这个同学比较认真，主动学习。会加不少技术分。\n\n技术点深入主动沟通，不要一味的面试官问什么答什么，可以适当的告诉面试官，您问的这个技术点我了解的同时，我还了解什么技术，做了什么项目等等，如果面试官感兴趣，就可以继续详细讲解。\n\n如果面试官问的技术点不懂，可以主动告诉他这块我不了解，我了解xx方法或技术能够同样解决这个问题。线下我可以再了解下您说的方法等等，总之就是避免问答式讨论，更加深入主动沟通。\n\n**思考和优化很重要**\n\n某个项目考察完，我一般会再问某个项目，但是不会跟上个项目那么完整流程去问，会挑简历项目中感兴趣的技术点去展开讨论，考察候选人掌握的知识和技术，比如候选人用图方法实现了课程设计校园导航系统，实质是图最短路径算法，我会考察这个算法的原理及伪代码的编写。同时探讨候选人系统的时空复杂度等。进一步考察候选人简历涉及技术或知识点的综合能力。\n\n同时很重要一点，提问候选人对自己项目不足及优化点的思考，考察候选人深度思考和总结规划能力，这在实际项目上非常重要的习惯。\n\n**项目制思维适用于所有岗位**\n\n项目制思维不止局限于技术岗位，产品，运营甚至行政类岗位，在日常公司运作中都是基于项目推进，非技术岗位，强烈建议同学们具备项目制思维，提炼总结自己亮点。\n\n同学们一定按照套路提前准备，临场自信发挥，自我主动沟通，主动推销自己。\n\n我是涛哥，曾任某互联网大厂技术总监，十年面试过500人，培养新人超百人。专注简历辅导/面试辅导/求职咨询等，24年目标帮助1000人求职和成长。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572520465516789760?sourceSSR=users",
        "title": "汇量科技Mobvista  数据分析实习面经",
        "content": "业务面 18min\n\n1.职业规划 从数开转到数分实习原因\n\n2.Python能力怎么样\n\n3.如何用Python去访问底层数据库，读取数据，运算后生成到某个路径中。\n\n4.Excel：数据透视表\n\n5.Excel能力不够怎么用其他工具替代\n\n6.Excel和SQL分别实现：1.多个数组数据合并排序 2.日期如何转换成时间戳或其他格式\n\n7.已有秋招offer了吗\n\n8.实习可视化方式\n\n9.分析为什么xx市近期可乐销售量下降\n\n10.如何看待业务关键指标 如拉新业务指标 具体转化漏斗\n\n11.认为哪一个环节对用户后续是否付费是影响最大的\n\n12.怎么和产品运行对需求的 举个案例，要求反映出会有冲突的地方是怎么解决的\n\n13.三个词 形容自己\n\n14.毕设进度如何\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572497138937073664?sourceSSR=users",
        "title": "微众银行社招测开一、二、三、HR面面经",
        "content": "时间线：\n\n2024年1月4号\n\n2024年1月8号\n\n2024年1月15号\n\n2024年1月23号\n\n**一面内容：**\n\n1、自我介绍\n\n2、项目拷打\n\n结合业务场景问了很多深入的问题，比如资损防控、风控接入、技术设计，自己开发的平台的原理和效果\n\n3、有带过外包吗\n\n4、为什么离职\n\n5、期望薪资（让说总包）\n\n6、反问\n\n反问了负责的业务，给讲解很细，工具能力建设也有，给我说了工作强度10105，卧槽，问我能不能接受，他说虾皮现在都很轻松，但是他们这里节奏快很多，有没有在虾皮考虑转岗？\n\n就这么点问题面了一个半小时，问题2占用的时间得有一小时，没写算法。\n\n**二面内容：**\n\n前言：面试官说那我们快开始吧，听HR说你后面还有别的面试。emmm，我说是我没安排和投递好，导致面试约的时间都挤在一起了。面试官：那你是离职了吗现在？这么着急找工作？我说还没呢，看看机会。\n好尴尬，想想之前和HR约面试时间的时候表达的比较直接，哎，现在不会因为这个挂了吧？\n\n1、自我介绍\n\n2、埋点自动化怎么做的？（这是我面试以来，第一次有面试官感兴趣我的埋点自动化，长篇大论了一番）\n\n3、埋点自动化在整个项目保障中占比多少？还需要多少人力投入？\n\n4、你们业务中核心的内容是什么？怎么保障用户的资金或者账户安全？如何做安全测试？\n\n5、为什么离职？\n\n6、目前在Shopee的工作时间？\n\n7、目前薪资多少？期望薪资？\n\n8、我看你简历有写一些爱好，拿出一个你觉得做的好的地方给讲讲？\n\n9、反问\n\n反问的时候面试官给讲解了很多，除了业务和效能建设之外，还说了微众目前的现状还有对现在想要招聘的同学的要求。整体面试时长35分钟，说不耽误我下面的面试。再一次尴尬\n/尴尬牛。\n\n**三面内容：**\n\n前言：二面完之后当天晚上就有一个人加微信说要再进行一轮面试，我问是三面吗，他说是，是他三面，看起来应该是个大领导，如果入职也不会经常接触到的那种。先是约了1.10号下午4点半的面试，我都准备好开始面试了，临时告诉我说他有紧急会议，改到了1.15号下午3点，在1.14号又告诉说1.15下午临时有安排，改到晚上8点，我8点没空，他说那就9点？内心OS：我上一场面试可能结束不了，告诉他我8点有会，可能不一定准时结束。他说那就9点吧，我还没结束的话就等我一会。结果我9:02结束了，他还没进会议，又让我等了3分钟，微信上一直在回我消息说让我等一会。开始了之后我道歉说迟到了两分钟，他说没事，五分钟之内都可以等我。卧槽？要是超了五分钟是我的不对，但是你一直修改时间是我的原因吗，而且你连会议都不进，还说是等我五分钟？\n\n1、自我介绍\n\n2、现在所负责的业务介绍\n\n3、强行给他介绍了做的项目，看出来他不是很感兴趣，对技术没有热情\n\n4、问我测试工程师和测开工程师的区别？我说了个测开是可以在测试做好的基础上开发沉淀一些工具和自动化之类的，他说你意思是测开比测试要高一个level？测试工程师对业务的理解深度可远比测开的理解要深，这个你怎么解释？吧啦吧啦解释了一遍。然后他问我，你想做测开还是测试？我说保障好业务的同时有精力的话可以做一些工具类的开发是OK的。他说你直接回答我问题，是想做测试还是测开？我看他急了，我说测开。然后他说测开的话是需要对业界主流的一些技术做一些探索的，看着他估计是现场开始搜一些问题问我，接下来的问题：\n\n5、用什么语言比较多？我说Python，他问Python怎么起20个协程？如何发送http请求？接口编写是怎么编写？直接给他秒了\n\n6、Linux系统下如何实现两台机器间的通信，至少说出两种方式？\n\n7、接口自动化如何改进？\n\n8、UI自动化使用的框架的缺点在哪里？如何改进？\n\n9、你在百度也是测开，突出贡献是什么？（基于AI-ops的客户端crash监控，他问什么是AI-ops？AI的能力体现在哪？）\n\n10、期望薪资。三次面试每次都问期望薪资，如果我进去的话，一面的面试官应该是我mentor，那他不就知道我的薪资了吗？就这么关心别人的薪水吗，我的薪资也不是他可以定下来给到的啊。面试完反思面试内容的时候越想越不对劲，他要是知道我薪资倒挂他不还得疯狂给我安排活？\n\n11、反问\n\n问了一些如果可以进去的话，负责的业务是什么？他说是银行对中小企业的贷款方面。\n\n反问他倾向于招测试工程师还是测开？他说优先保业务质量，倾向于测试工程师，岗位就是系统测试工程师，我说我刚才的回答就是先保业务质量，有时间和精力的话可以做一些开发类的东西，不能只靠经验，没有东西沉淀下来，对后来的新人来说也不能快速上手。真是把自己说急眼了，我也没说测开比测试高一个level，我说是一种协同关系，非要给我扣帽子，然后让我解释。\n\n说实话三次面试完，对微众的好感是越来越低。\n\n**HR面内容：**\n\n1、自我介绍\n\n2、离职原因（包括百度到Shopee，从Shopee为什么离职）\n\n3、对微众的了解\n\n4、自己的优缺点\n\n5、有没有别的offer，具体offer薪资多少\n\n6、期望薪资\n\n7、闲聊：她说每年3月份会有职级的晋升，说我等到3月份的话可能会更高一个职级，到时候会有相应的涨薪，就是3月份之后入职。HR是同意的，问我同意吗，我说也同意(内心非常同意，又能涨薪，我现在还可以休休假)，她说还要去问下用人部门，如果部门觉得3月份也OK，那就3月份，薪资会涨。如果部门觉得现在缺人，必须在3月之前入职，那就不会涨薪。这两天会给我定我的职级。\n\n8、反问\n\n公积金比例：**12%**\n\n有无餐厅：**有**\n\n是否双休：**是**\n\n年终奖怎么发：比如你的offer上写的5W，那就是5W，**不按月份来** ，不是比如15薪、16薪年终是3、4个月薪资那些\n\n看有些岗位说是银行正编，有什么区别：都是统一的正式员工招聘，**不存在正编非正编** ，HR说有些是为了吸引眼球\n\n年假天数：**7天**\n\n有病假吗：**有** ，但是需要拿假条审批，可能不会全薪病假？\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572451983311863808?sourceSSR=users",
        "title": "网易互娱 游戏开发 上岸面经",
        "content": "base：211本国科大硕，鹅厂实习8个月\n\n### 一面：2023.12.13\n\n比较常规，主要集中在C++和图形学八股上，项目和实习没怎么问，时间比较久了可能不太全\n\n#### C++（30min）\n\nconst关键字的用法，分别对函数，对象，类的成员，入参，临时变量，全局变量都有什么作用\n\n虚函数相关，虚表存在哪里\n\n堆和栈的区别，为什么区分堆栈\n\n智能指针哪几种，weak_ptr的lock底层原理是什么，口撕一下shared_ptr\n\nSTL用过哪些，讲一下红黑树底层原理，源码是否看过\n\n#### 图形学（30min）\n\n主要针对简历上的渲染器和软光栅项目来问\n\n讲一下模型从读取到屏幕显示的整个过程（其实就是渲染管线）\n\n软光栅如何进行三角形遍历，讲一下如何判断点在三角形内\n\n剔除有哪些，分别讲一下\n\n通常有哪些优化方式（剔除，LOD，合批分别都要讲一下）\n\n讲一下FXAA的原理（简历上写的）console版本原理的区别\n\n冯和布林冯的区别（半程向量解决了什么问题，不只是性能，在反射方向和实现大于90度的时候不会漏光）\n\nCook Torrance的三项\n\n光线追踪用了哪些优化算法（多线程优化，BVH优化）\n\nPCF的原理，PCSS原理，为什么要用泊松采样，CSM如何实现\n\nMipmap和各向异性mipmap都额外用了多大的内存\n\n延迟渲染比正向渲染复杂度降低在了哪里\n\n几种数学推导，变换矩阵上的每一位置分别代表什么\n\n欧拉角和四元数如何转换，四元数的优势和劣势\n\n#### 手撕（10min）\n\n给你一个数组，手动随机打乱，并且同时删掉其中3的倍数（Knuth-Durstenfeld洗牌算法，删3的倍数就双指针和末尾交换），中等难度\n\n#### 反问\n\n项目组是否能透露\n\n具体用的引擎（自研）\n\n工作地点在哪里\n\n### 二面：2023.12.20\n\n本来一面听说项目用的是自研引擎就没怎么准备UE的问题，结果这面疯狂拷打UE和各种前沿，压力拉满\n\n上来先说，看起来你的简历和我们没那么相关啊（因为在腾讯的实习是做的前沿落地，并不是游戏项目组），当时直接慌了。\n\n#### 引擎相关问题（40min）\n\n你的UE游戏项目的gameplay部分用没用过框架，还是纯手写的，有没有了解过UE的框架（GAS）\n\nUE的网络模块，有没有了解过UE的RPC那一套\n\nFPS一般使用帧同步还是状态同步，如果客户端和服务端的位置有很大区别如何逼近服务端\n\n具体说一下lumen（说的很乱，只说了基于SDF和VXGI）\n\n你的软光栅是否做了透视矫正\n\n你的opengl渲染器中的PBR的金属度原理是什么，一般有一个默认的金属度0.08为什么是这个数值\n\n你在动捕项目中具体做了什么，是否参与了神经网络模型的训练，讲一下IK的几种算法和各自的优点\n\n看你研究生是做deeplearning的，那ue最新版本中有哪些dl技术\n\n腾讯实习中遇到过哪些困难，如何解决的\n\n#### 反问（10min）\n\n工作地点在网易哪个楼，反反问：身为北方人是否能够接收在广州工作，Python水平怎么样\n\n### HR面：2023.12.22\n\n因为当天中午发了那封让网易股价暴跌25的文件，所以面试的时候聊了聊。其余的就比较常规\n\n### Offer：2023.12.26\n\nhrbp面试完之后，负责联系的hr就来问我是否有其他公司的offer，多少钱\n\n25号联系我说offer在审批了（应该就相当于oc了？）\n\n26号电话谈薪，有房补有股票，晚上十点正式offer\n\n27号寄了三方，秋招结束，解放了。\n\n顺便点名批评快手，被我们宿舍评为秋招最大恶人（给我泡池子20天挂了，不给室友实习转正）\n\n![](https://uploadfiles.nowcoder.com/images/20240104/327990125_1704355032053/DDBA7981F3EFD46B52193EEC9F2295FB)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572451388366618624?sourceSSR=users",
        "title": "杭州小厂三面面经 已OC",
        "content": "问的好广啊，不过没怎么深入拷打[赞]好在是HE，希望流程能加速，已经等不及去杭州找小女友了[羞涩]\n\n自我介绍\n\n又又拷打项目\n\n八股：\n\n  1. 布隆过滤器\n  2. Java首部线程（没听说过）\n  3. 乐观锁与悲观锁 以及使用场景\n  4. 乐观锁会出现什么问题 怎么解决（ABA，时间戳）\n  5. 类加载器都有哪些\n  6. 类加载过程\n  7. RabbitMQ可靠性怎么保证\n  8. 分布式RabbitMQ怎么实现\n  9. MySQL索引\n  10. LSM树了解吗（没听过）\n  11. MySQL事务隔离级别以及产生的问题\n  12. Redis数据类型 平常使用过哪些\n  13. HyperLogLog应用场景\n  14. 讲讲Redis持久化\n  15. RDB和AOF区别\n  16. Redis为什么速度快\n  17. 谈谈IO多路复用\n  18. Redis内存淘汰机制\n  19. 详细讲讲LRU\n  20. TCP/IP怎么分层的\n  21. TCP是哪层 HTTP呢\n  22. TCP是怎么保证可靠性的\n  23. HTTP2.0相对于HTTP1.1增加了什么\n  24. HTTPS原理了解吗\n  25. 公钥和私钥怎么保存\n  26. 大数据开发了解吗\n  27. 为什么来杭州（打算定居在杭州）\n  28. 为什么定居在杭州（说了女朋友在杭州，双方都乐了）（你怎么知道我可爱的女朋友真的在杭州[打call][打call][打call]）\n\n反问：\n\n1.如何评价这次面试？\n\n不错，中上等了\n\n2.进公司具体学习哪些技术？\n\nHadoop，k8s等大数据开发项目，底层是Java\n\n3.HR面能不能push一下[牛泪]\n\n哈哈，尽快安排，大概明天就能安排\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572441634638499840?sourceSSR=users",
        "title": "🌟面经分享｜美团测试开发岗位面试问题（详细）",
        "content": "#### 一、一面（70min）\n\n  * 自我介绍\n\n* 项目介绍\n* 深挖项目\n* 消息队列ActiveMQ应用场景\n* mongo & redis应用场景\n* 可靠性保证\n* springboot核心点\n* 单例模式\n* IOC如何实现\n* AOP\n* Mybatis工作机制\n* Mybatis事务\n* mysql & mongo 对比\n* RPC协议\n* DuBBo实现原理\n* 测试角度\n* 消息队列测试\n* 测试工具postman\n* http请求关注点\n* 状态码\n* 鉴权测试（如何测试）\n* HashMap\n* 树化链化\n* 单链表 & 双链表 修改节点时间\n* JVM内存机制\n* 新生代、老年代\n* full gc\n* STW时间\n* linux查看日志 前五行\n* a.log日志关键词定位转到新文件\n* 代码题目：[异位词分组](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F311803019)\n* 优化代码\n\n#### 二、二面（主管面）（70min）\n\n  * 项目相关：参考一面\n\n* 算法题目\n* 算法优化\n\n#### 三、HR面（20min）\n\n  * 自我介绍\n\n* 有实习经历吗？\n* 简单介绍项目，自己负责的部分\n* 职业规划\n* 为什么选择测试开发\n* 项目中遇到的问题，怎么解决\n* 如何去学习一门新技术\n* 面试流程，如何选择企业\n* 北京 & 济南\n\n![](https://uploadfiles.nowcoder.com/images/20240104/466262770_1704352682187/D2B5CA33BD970F64A6301FA75AE2EB22)![](https://uploadfiles.nowcoder.com/images/20240104/466262770_1704352701223/3957070A9D41CC534E61EC2B476672E9)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572379909444702208?sourceSSR=users",
        "title": "春招必看！不同面试类型如何应对",
        "content": "面试遇到卡壳的地方不知道怎么回答？ 不懂面试官为什么提出这个问题？不知道面试官想听什么回答？今天这一篇文章，学姐教你不同面试类型如何应对。\n\n**1.通过一个问题进行挖掘性提问。也就是我们面试官常用的“不断深挖法则”，他主要考察的是：候选人的参与程度、前后逻辑、表达能力等。\n在专业上讲叫“唯一”问题面试。**\n\n**举个例子：** 举个你在社团活动中发挥领导力的例子\n\n你回答之后继续问：--->如何分配或调动他成员完成相应工作\n\n再继续问：--->这期间遇到了哪些问题？如何解决的？\n\n再继续问：--->你在其中犯的最大错误是什么？--->你在这其中的成长和改变是什么？\n\n再继续问：--->如果重来一遍，哪些需要改变？（有情提示，这里可以呼吸）这种问题大家在实际面试中应该非常常见，\n\n那我们有以下解题思路：准备1-2个真实发生过关键事例，注意进行行为描述且行为要反应该岗位某一胜任力要素（比如上题要求的领导力），需整体经得起推敲和追问。\n\n行为描述要使用\nSTAR法则，即情境（Situation）、任务（Task）、行动（Action）和结果（Result），翻译过来就是在什么情况下接到了什么任务，自己付出了哪些行动，最后的结果如何\n。\n\n**2.角色扮演\n（有时也是压力面的一种）通常面试官会扮演各类角色向求职者提出假设性的问题，同时也可能涉及到压力问题进行发难。这时候主要考察候选人的情绪稳定性、反应力、判断力、决策力等。**\n\n**举个例子：** 假如你是营销策划岗位，我是你的上级，给你批准2万元负责某产品的营销宣发活动，你准备怎么策划？\n\n当你回答之后可能会问：---> 那你是具体怎么考虑这个策划方案的？\n\n再继续问：--->如果这时候，我给你的预算砍了一半，你会怎么办？\n\n再继续问：--->如果问对你的策划案不满意，需要你再出5版案子，你会怎么办？这种问题大家在实际面试中也有可能遇见，\n\n那我们有以下解题思路：通过想象代入设定的角色（这个很重要），有逻辑性、条理性的说出你的方案，注意方案一定不能空，要落地！最好是考虑的周全，例如在活动前--\n活动中--活动后分别需要注意什么。同时当压力面出来的时候，运用抗压性和应变能力及清晰的表达去回复！\n\n**3.一些不知道怎么就突然问出来的问题，可能来自笔试---行测！！**\n\n注意同一类型题目前后回答内容一致性及答题时长。若报告结果中有明显异常部分，HR在现场面试的环节中将会重点追问。\n也许是突然冒出来的一个问题，但可能背后就是因为你在行测的时候有一些异常～\n\n整体来说，同学主要不断调整状态、换位思考，通过不同角色的立场给予相应的面试回复，就可以掌握通用面试技巧。常见的面试类型就分享到这里啦，同学们还遇到过哪些很难的面试题？\n欢迎大家在评论区讨论 ～\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572364842707779584?sourceSSR=users",
        "title": "阿里测开社招一、二面面经(ICBU)，三面被鸽了，没HC了",
        "content": "时间线：\n\n2024年1.3号一面\n\n2024年1.11号二面\n\n**一面内容：**\n\n1、自我介绍\n\n2、你自己开发的测试提效工具平台的架构\n\n3、结合两个工具的使用，详细展开\n\n4、线上问题定位工具的实现原理\n\n5、业务质量保障和工具效能建设投入时间占比，ROI？\n\n上面介绍说完已经50分钟了\n\n6、算法题\n\n①给定字符串，不能使用内置函数，判断是当年的第几天？（如：20200601）被追问异常情况处理，异常情况包括输入的字符串不是公元纪年时间、字符串含有其他非数字字符等等\n\n②给定两个数组，输出两个数组的交集，不能使用内置函数\n\n7、业务需求比较重的时候，如何进行人力安排？实在排不开怎么办？如何让新人或者OD同事快速投入到业务质量保障中来？\n\n8、反问\n\n反问了下工具还有自动化能力建设方面，面试官给讲解了很多，整体面试过程很愉快，体验很好，等待一下面试结果。\n\n二面内容：\n\n理论上这次应该是三面，一二面合一块了，电话面+笔试面在一面的时候就都完成了\n\n面试前十五分钟打电话告知没有HC了，不继续推进了。emmm，也是好事吧，长痛不如短痛，到HR发offer阶段再给说没有HC也是一样的结局，过程中还省的浪费时间了。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572339408033124352?sourceSSR=users",
        "title": "字节飞书后端面试（日常实习）",
        "content": "## 一面（2024.1.3，85min）\n\n  * 自我介绍\n  * 项目（聊了蛮久）\n  * Redis\n  * Redis单线程结构\n  * Kafka（项目中用到了）\n  * 架构说一下\n  * consumer如何进行消费的过程\n  * 分布式当扩充新的机器，数据如何进行调整？（唯一没答出来的八股）\n  * 集群只用2个节点可以吗？为什么不行？\n  * MySQL\n  * B+树，B树与B+树区别？存相同的数据哪个树高？\n  * MySQL如何实现乐观锁？\n  * 不停机扩容如何实现？\n  * Dubbo（项目中用到了）\n  * Dubbo架构简单介绍\n  * 乐观锁与悲观锁介绍\n  * TCP三次握手变2次会有什么问题？答了防历史连接和耗损服务端资源。反问为什么会耗损服务端资源？\n  * ConcurrentHashMap如何实现线程安全的？底层结构？\n  * 算法题：LeetCode找重复的数（思路出来了，代码没写出来[牛泪]）\n\nps：面试官说我基础挺扎实，算法题做的时候有点紧张，抚慰了菜菜的我，这几天一定爆刷算法题……\n\n最新进度：一面挂，估计就是算法题没做出来挂的[牛泪]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572195205898670080?sourceSSR=users",
        "title": "【3 期】面试官：this 与 super 的区别",
        "content": "**this** 和 **super** 是在 Java 中用于引用对象的两个关键字，它们在使用场景和作用上有一些共同点，但也有明显的区别。\n\n**共同点** ：\n\n  1. **用于引用对象** ：**this** 和 **super** 都是用于引用对象的关键字。\n  2. **在构造函数中调用** ： 两者通常在构造函数中使用。**this** 用于调用同一类中的其他构造函数，而 **super** 用于调用父类的构造函数。\n\n**不同点** ：\n\n  1. **引用对象的范围不同** ：\n  2. **this** 引用的是当前对象的实例。\n  3. **super** 引用的是父类的实例。\n  4. **用途不同** ：\n  5. **this** 主要用于处理同一类中的字段、方法或构造函数之间的引用，以区分成员变量和局部变量，或者在构造函数中调用其他构造函数。\n  6. **super** 主要用于在子类中调用父类的字段、方法或构造函数。在子类中，可以使用**super** 关键字访问父类的成员。\n  7. **语法不同** ：\n  8. **this** 可以出现在方法、构造函数和代码块中，并且可以用于调用其他构造函数、访问实例变量等。例如，**this.method()** 或者 **this.variable** 。\n  9. **super** 主要用于在子类中访问父类的成员，例如，**super.method()** 或者**super.variable** 。\n\n总的来说，**this** 和**super**\n在引用对象的范围、用途和语法上有一些共同点，但它们主要是用于不同的场景，分别处理同类中和父子类中的对象引用。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572152331547021312?sourceSSR=users",
        "title": "字节测开面经，瑟瑟发抖",
        "content": "![1704282931112](https://git.acwing.com/Hasity/interview_hunter/-/raw/master/2024/image/%E9%9D%A2%E7%BB%8F5_%E5%AD%97%E8%8A%82%E6%B5%8B%E5%BC%801.png)\n\n## 2.java的set、map、list的区别，map中key是否能为空的问题\n\n在Java中，Set、Map和List是常见的集合框架，它们分别用于不同的目的。\n\n  1. **Set（集合）** ： \n     * Set是一种不允许包含重复元素的集合。\n     * 实现了Set接口的类通常包括HashSet、TreeSet等。\n     * 不保证元素的顺序，因为它主要关心元素是否存在。\n\n    \n    \n    Set<String> stringSet = new HashSet<>();\n    \n\n  2. **Map（映射）** ： \n     * Map是一种键值对的集合，每个键都映射到一个值。\n     * 不允许重复的键，但可以有重复的值。\n     * 常见的实现包括HashMap、TreeMap等。\n\n    \n    \n    Map<String, Integer> stringIntegerMap = new HashMap<>();\n    \n\n  3. **List（列表）** ： \n     * List是一个有序的集合，允许重复元素。\n     * 实现了List接口的类通常包括ArrayList、LinkedList等。\n     * 可以通过索引访问元素，元素按照插入顺序排列。\n\n    \n    \n    List<String> stringList = new ArrayList<>();\n    \n\n一般来说，Map的实现对于key是不允许为null的，因为在Map中，每个键都应该是唯一的。如果允许key为null，就无法保证唯一性了。但是，在某些特殊的情况下，也有一些实现允许null作为key，例如HashMap。在使用时，要注意特定实现的规定。\n\n>\n> **[面经专栏直通车](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fcreation%2Fmanager%2FcolumnDetail%2F0xKkDM)**\n\n>\n> **[面经专栏下载](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgit.acwing.com%2Flicw%2F24_job_hunter)**\n\n## 3.java中进程和线程的区别，\n\n在Java中，进程和线程是多任务处理的两个关键概念，它们有一些本质的区别。下面是它们的主要区别：\n\n  1. **定义** ：\n\n     * **进程（Process）** ：是一个独立的执行单元，有独立的内存空间。一个进程包括一个或多个线程。\n     * **线程（Thread）** ：是一个轻量级的执行单元，是进程中的一个实体，执行任务的基本单位。\n  2. **资源占用** ：\n\n     * **进程** ：拥有独立的内存空间，相互之间不会直接共享内存，通信需要使用特殊的机制。\n     * **线程** ：共享所属进程的内存空间，因此线程间的通信更加方便，但也需要考虑同步和互斥问题。\n  3. **启动速度和资源开销** ：\n\n     * **进程** ：启动速度相对较慢，占用的资源较多。\n     * **线程** ：启动速度快，占用的资源相对较少。\n  4. **独立性** ：\n\n     * **进程** ：相互独立，一个进程的崩溃不会影响其他进程。\n     * **线程** ：线程是进程的一部分，彼此之间共享进程的地址空间和资源，一个线程的问题可能会影响整个进程。\n  5. **通信机制** ：\n\n     * **进程** ：通信需要使用进程间通信（Inter-Process Communication，IPC）的机制，如管道、消息队列等。\n     * **线程** ：线程间可以通过共享内存等轻量级的方式进行通信。\n  6. **切换开销** ：\n\n     * **进程** ：进程切换的开销相对较大。\n     * **线程** ：线程切换的开销相对较小，因为它们共享了相同的地址空间。\n\n在Java中，线程是通过`java.lang.Thread`类来实现的，而进程则是由操作系统管理的。Java也提供了`java.lang.Process`类用于处理进程相关的操作，但在Java中，通常更多地关注于线程的使用，因为线程更轻量、更容易管理。在多核处理器的情况下，线程的并行执行可以提高程序的性能。、\n\n## 4.java的锁机制\n\n在Java中，锁（Lock）是一种用于控制多线程对共享资源访问的机制，以确保在同一时刻只有一个线程可以访问共享资源，从而避免竞争条件和数据不一致性问题。Java提供了多种锁机制，其中最常见的是synchronized关键字和Java.util.concurrent包中的锁。\n\n以下是Java中常见的锁机制：\n\n  1. **synchronized关键字** ：\n\n     * `synchronized`关键字用于创建同步方法和同步块，确保在同一时刻只有一个线程可以执行被保护的代码。\n     * 它可以用于实例方法、静态方法和代码块。\n     * 通过在方法上使用`synchronized`关键字，可以实现对整个方法的同步。\n     * 通过在代码块内使用`synchronized`关键字，可以实现对指定的代码段的同步。\n    \n        public synchronized void synchronizedMethod() {\n        // 同步方法的代码块\n    }\n    \n    public void someMethod() {\n        synchronized (lockObject) {\n            // 同步代码块\n        }\n    }\n    \n\n  2. **ReentrantLock** ：\n\n     * `ReentrantLock`是Java.util.concurrent包中提供的显式锁。\n     * 与`synchronized`不同，`ReentrantLock`允许重入，即同一个线程可以多次获得同一个锁。\n     * 它提供了更灵活的锁定机制，例如可中断锁、定时锁等。\n    \n        import java.util.concurrent.locks.Lock;\n    import java.util.concurrent.locks.ReentrantLock;\n    \n    public class Example {\n        private final Lock lock = new ReentrantLock();\n    \n        public void someMethod() {\n            lock.lock();\n            try {\n                // 保护的代码块\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n    \n\n  3. **Read/Write Locks** ：\n\n     * `ReadWriteLock`接口定义了读写锁，其中包括`ReentrantReadWriteLock`的实现。\n     * 读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。\n    \n        import java.util.concurrent.locks.ReadWriteLock;\n    import java.util.concurrent.locks.ReentrantReadWriteLock;\n    \n    public class Example {\n        private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n    \n        public void readMethod() {\n            readWriteLock.readLock().lock();\n            try {\n                // 读取共享资源的代码块\n            } finally {\n                readWriteLock.readLock().unlock();\n            }\n        }\n    \n        public void writeMethod() {\n            readWriteLock.writeLock().lock();\n            try {\n                // 写入共享资源的代码块\n            } finally {\n                readWriteLock.writeLock().unlock();\n            }\n        }\n    }\n    \n\n这些锁机制都用于解决多线程并发访问共享资源时可能出现的问题，选择哪种锁取决于具体的需求和情境。\n\n## 5.数据库的索引如何使用\n\n数据库索引是一种优化数据库查询性能的关键工具。通过使用索引，可以快速定位和检索数据库表中的数据，降低查询的时间复杂度。以下是数据库索引的基本使用和一些建议：\n\n  1. **创建索引** ：\n\n     * 在数据库表中，可以通过在某一列或一组列上创建索引来加速查询。\n     * 在大型表中，对于经常用于过滤和排序的列，索引的作用更为显著。\n     * 常见的索引类型包括单列索引、组合索引和唯一索引。\n    \n        -- 创建单列索引\n    CREATE INDEX index_name ON table_name(column_name);\n    \n    -- 创建组合索引\n    CREATE INDEX index_name ON table_name(column1, column2);\n    \n    -- 创建唯一索引\n    CREATE UNIQUE INDEX index_name ON table_name(column_name);\n    \n\n  2. **选择合适的列** ：\n\n     * 选择适当的列进行索引是很重要的，通常选择经常用于查询条件的列。\n     * 避免对经常修改的列创建过多索引，因为每次修改都会涉及到索引的更新。\n  3. **避免创建过多的索引** ：\n\n     * 虽然索引可以提高查询性能，但过多的索引也会增加插入、更新和删除操作的开销。\n     * 在创建索引时要权衡查询性能和维护成本。\n  4. **使用覆盖索引** ：\n\n     * 覆盖索引是指索引包含了查询所需的所有数据，而不需要回表到实际数据行。\n     * 这样可以减少IO操作，提高查询效率。\n  5. **定期维护和优化索引** ：\n\n     * 定期检查数据库中的索引性能，删除不再需要的索引，重新构建或重新组织现有索引。\n     * 数据库系统通常提供了优化工具和命令，如`ANALYZE TABLE`、`OPTIMIZE TABLE`等。\n    \n        -- 分析表的索引信息\n    ANALYZE TABLE table_name;\n    \n    -- 优化表的索引\n    OPTIMIZE TABLE table_name;\n    \n\n  6. **理解查询优化器** ：\n\n     * 数据库查询优化器会根据查询条件、表结构和索引情况来选择最优的执行计划。\n     * 使用`EXPLAIN`语句可以查看查询执行计划，帮助理解优化器的决策过程。\n    \n        EXPLAIN SELECT * FROM table_name WHERE column_name = 'value';\n    \n\n  7. **考虑使用全文索引** ：\n\n     * 对于包含文本数据的列，可以考虑使用全文索引（Full-Text Indexing）来支持全文搜索。\n     * 全文索引可以更有效地处理文本搜索查询。\n    \n        CREATE FULLTEXT INDEX index_name ON table_name(column_name);\n    \n\n数据库索引的使用需要根据具体的业务场景和查询需求来进行优化。合理的索引设计可以明显提高数据库查询性能，但不当使用可能会导致性能下降。在设计和维护索引时，需要深入了解数据库引擎的特性和查询优化原理。\n\n## 6.SQL题，有两张表，用户表和订单表，查找每个用户购买商品的最大值\n\n假设有两张表，一张是用户表（`users`），包含用户的信息，另一张是订单表（`orders`），记录了用户的订单信息。假设订单表中有两个字段：`user_id`表示用户ID，`amount`表示订单金额。\n\n要查找每个用户购买商品的最大值，可以使用以下SQL查询：\n\n    \n    \n    SELECT \n        u.user_id,\n        u.username,\n        MAX(o.amount) AS max_purchase_amount\n    FROM \n        users u\n    JOIN \n        orders o ON u.user_id = o.user_id\n    GROUP BY \n        u.user_id, u.username;\n    \n\n这个查询使用了`JOIN`操作将用户表和订单表关联在一起，然后使用`GROUP\nBY`按用户分组。最后，使用`MAX(o.amount)`计算每个用户购买商品的最大值，并将结果呈现在查询的结果集中。\n\n![](https://git.acwing.com/Hasity/interview_hunter/-/raw/master/2024/image/%E9%9D%A2%E7%BB%8F5_%E5%AD%97%E8%8A%82%E6%B5%8B%E5%BC%802.png)\n\n分享者：[小牛哥永不退缩](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fusers%2F418214573)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572142329084051456?sourceSSR=users",
        "title": "24届往逸蕾钬秋招 游戏研发工程师-客户端引擎方向",
        "content": "还有一些之前面腾讯游戏客户端的问题，索性也写在这里吧  \n  \n个人背景：首都某不错酒吧舞本科，非cs科班，无实习，有一些UE的使用经验，还有一些离线和实时的渲染器项目  \n  \n一面：  \n1-对c++内置数组和指针的应用的考察，给你一个int numbers[10]，问你输出number是多少，对number加加减减后输出多少  \n  \n2-给几个类，有各种数据成员，有的虚函数，问大小  \n  \n3-问有哪些分配内存的函数  \n  \n4-给你几个char，问printf输出什么，比如char a='3'，问printf(\"%c\"，2+a++)输出什么。。麻了捏，哥们平时都cin\ncout啊，哪会这个  \n  \n5-在析构函数函数中delete this有什么问题，类似的还有拷贝构造函数中参数里面能不能略去&  \n  \n6-一段代码，问里面声明的各种变量，有的在main外，有的在main内等等等等，放在内存的哪一区域  \n  \n7-单例模式怎么写  \n  \n8-渲染管线是怎么样的？alpha测试，模板测试，深度测试的顺序？  \n  \n9-pbr相关的，俄罗斯轮盘赌有偏无偏？法向分布函数能不能直接拿来采样？  \n  \n10-虚拟内存的管理，页表的替换算法  \n  \n11-线程，进程的概念，区别  \n  \n12-简单的条件概率踢  \n  \n13-有若干面值的纸币，要组成给定的数额，最少用多少张？我一开始说用dfs，面试官问递归比较慢而且占空间怎么办，我就说可以用动态规划  \n  \n14-帧同步，状态同步，moba类型应该用哪一种比较好？  \n  \n15-你知道有哪些类型的游戏？  \n  \n16-你知道哪些brdf？  \n  \n一面还有一些问题，但是时间久了有些忘了。。  \n  \n二面：  \n1-给你一个struct，问你大小，还问#pragma pack(8)是干嘛的  \n  \n2-给你一个简单的类，写一写拷贝构造函数，移动构造函数  \n  \n3-构造和析构的顺序  \n  \n4-lambert的brdf的原理，推导  \n  \n6-cache命中的问题，经典的矩阵按行优先遍历和列优先遍历  \n  \n7-c++中的static  \n  \n8-你知道哪些后处理算法？FXAA的原理？bloom的原理？  \n  \n9-次表面散射怎么做  \n  \n10-法线的变换矩阵怎么推导  \n  \n11-颜色空间相关的，伽马2.2相关的  \n  \n12-一个点是否在三角形内？  \n  \n13-怎么确定要用mipmap的哪一个层级？  \n  \n14-vector的内存管理  \n  \n15-并归排序  \n  \n16-最短路径算法的复杂度  \n  \n17-vector  map set的底层，使用时的复杂度  \n  \n18-给一基类和一些派生类，这些类有的有static的成员函数，有的有virtual，把空指针别赋给这些类的类型的指针，比如A\np=nullptr，问p->某个成员函数会发生什么  \n  \n19-一个简单的括号匹配的编程题  \n  \n20-shared_ptr的引用计数怎么实现？  \n  \n大概就是这些  \n  \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/572086626562613248?sourceSSR=users",
        "title": "睿智合创一面 1h",
        "content": "快排 没写出来，说了说思想×\n\n其他排序\n\n图里面最主要是什么\n\n希尔排序\n\n最近看了什么\n\nJVM内存结构\n\n蓝桥杯\n\n计算机设计大赛\n\n介绍项目\n\n图片和文件怎么存的\n\nSpringBoot特点\n\nSpringSecurity是什么\n\n基于IOC还是AOP\n\n具体项目中怎么做的\n\n介绍Redis\n\nRedis为什么快\n\nRedis存储类型\n\n关系数据库用过哪些\n\nMysql一般存什么东西\n\nCRUD\n\n非关系型数据库用过哪些\n\n搭过Redis集群吗\n\nMongoDB了解吗\n\n中间件用过哪些\n\nJava三大特性\n\n多态\n\n集合框架\n\n链表怎么添加节点\n\n字符串拼接用什么方法\n\n为什么不直接用String\n\n比较擅长什么\n\n**反问** ：\n\n回答问题的思路怎么样？ 需要注意整体框架，组织好再说。概括，部分，例子\n\n去实习的话做什么业务？\n\n有没有回答的问题有些问题或者太浅了？\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/571826973274603520?sourceSSR=users",
        "title": "记录一下：星环科技Hadoop实习生岗位面试",
        "content": "面试的流程肯定是老一套啦，首先巴拉巴拉的来一顿自我介绍，然后就是面试官的提问。\n\n面试官的总体来说是挺好说话的。\n\n下面是面试官的问题\n\n  1. Linux中查看磁盘内存情况的命令（面试官解释到这是用来监控采集数据所要用的）\n\n我回答了一个df-h,然后面试追问怎么看某个目录占用磁盘的百分比，然后我就没回答出来了\n\n正确答案：du -sh /xxx/xxx/xxx\n\n2.hive中允许储存的数据类型，其实就是指创建表的时候所指定的数据表类型（我还是答不出）\n\n正确答案：TextFile、SequenceFile、RCFile、ORC、Parquet、AVRO。\n\n3.Hadoop八股文：secondname的作用是啥(没练过八股文，答不出)\n\n正确答案： Secondary\nNameNode在Hadoop中扮演着重要的角色，它并不是NameNode的备份。其主要功能是对主NameNode的补充，周期性地进行fsimage文件的合并，防止edits文件过大，这样可以缩短NameNode的启动时间。此外，Secondary\nNameNode会定期与NameNode进行通信以完成整个的合并操作。因此，Secondary\nNameNode对于维护HDFS的稳定性和效率起着重要的作用。\n\n最后，这次面试肯定挂了，但是也长了见识，了解了自身对Hadoop简单的理论知识掌握不牢靠。吸取经验吧家人们！！！\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/571802076095807488?sourceSSR=users",
        "title": "富途测开社招一、二面面经",
        "content": "面试时间：\n\n2024年1月2号\n\n2024年1月4号\n\n目前在等待面试结果\n\n**一面内容：**\n\n1、自我介绍\n\n2、为什么跳槽\n\n3、接口自动化实现原理，接口自动化和人工测试怎么相辅相成\n\n4、计网八股\n\n5、数据库八股\n\n八股加起来得问了四五个问题，追问原理与改进\n\n6、算法题--写出给定数字区间内的质数\n\n7、SQL实战\n\n加问了个八股：内连接和外连接有什么区别，左外连接和右外连接的区别\n\n8、印象深刻的困难，怎么解决的\n\n然后被追问技术问题\n\n9、为什么从百度离职？\n\n10、除了我问到的问题之外，有什么想补充的点吗，技术或者其他方面都可以，可以让我更好地记住你或者了解你？\n\n11、反问\n\n反问了业务形态，面试官说了很多，还说了现有的自动化能力，3分钟之内没插上话，专注倾听了。\n\n整体面试体验还是不错的，貌似听起来有可能比较养老？业务方向基本上都是ToB的业务，听起来需求也不很多。\n\n**二面内容：**\n\n1、自我介绍\n\n2、项目拷打\n\n3、猴子分桃问题，类似于口算的智力题（若干猴子若干桃，一个猴子3个桃剩59个桃，一个猴子5个桃，最后一个猴子分不满5个，问多少猴子多少桃）；扑克牌出去大小王还剩52张牌，随机抽取两张，是相同颜色的概率是多少？\n\n4、7升和5升的水杯，如何量出4升水\n\n5、算法题：\n\n根据业务需求出的，一个梯度计算费用的问题，边界值处理的时候g了，有些异常情况怎么都兼容不了。面完反思了下，自己写的代码的Map最初设计拉胯了，导致后面写代码费劲\n\n6、八股：\n\nTCP的三次握手，ACK包的内容和原理\n\n同步和异步的实现方式\n\nhttp是什么，https呢\n\n知道什么是质量内建吗？知道什么是质量左移吗？\n\n7、业务质量保障的方式，如何构建完整的质量保障系统\n\n8、反问\n\n反问的时候感觉面试官不愿意多说，就简单地一句话回答一下我的每个反问，真想让他详细说说，啥也不是，\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/571797218592657408?sourceSSR=users",
        "title": "硬件工程师笔试面试理论题目-初版20240102",
        "content": "整理了一些硬件工程师笔试面试理论题目，正在完善中-初版20240102\n\n无源器件：\n\n1 电阻的功能\n\n2 0欧电阻的功能\n\n3 电阻选型\n\n4 电容的功能\n\n5 电容随温度、电压等容值变化，X5R C0G等含义\n\n6 高频电容模型-RCL模型；频率-阻抗曲线图\n\n7 电源或芯片去耦电容为何要不同封装不同容值并联\n\n8 电感的功能\n\n9 电感参数解读\n\n10 磁珠的功能\n\n11 磁珠和电感的区别\n\n二极管三极管MOS\n\n1 二极管原理\n\n2 二极管功能\n\n3 三极管原理\n\n6 三极管功能\n\n7 三极管工作点计算-共射，共集，共基\n\n8 带温度补偿的三激光工作点计算\n\n9对比共射，共集，共基三极管电路优缺点\n\n10场效应功能\n\n11场效应管与三极管区别，优缺点\n\n12MOS管能否并联使用？BJT能否并联？\n\n13MOS管设计缓启动电路\n\n电源类\n\n1 画出DC-DC开关电源BUCK电路拓扑，并简述BUCK工作原理\n\n2 画出DC-DC开关电源BOOST电路拓扑，并简述BUCK工作原理\n\n4 CCM、DCM模式区别\n\n5 伏秒平衡原理\n\n6 LDO原理\n\n7 LDO和DC-DC的区别、对比、优缺点\n\n8 LDO效率、损耗、温升计算\n\n9 常用电源芯片供应商\n\n接口类\n\n1 IIC接口简述\n\n2 为什么IIC接口要上拉电阻，上拉电阻阻值选型\n\n3 IIC的ACK功能\n\n4 SPI是几线？基本功能？\n\n5 SPI接口的建立时间、保持时间定义\n\n6 RS232接口描述\n\n7 RS485接口描述\n\n8 RS232和485的区别\n\n9 LVDS接口原理与电平标准\n\n10 为什么LVDS接口可以高速率？\n\n11 为什么差分信号抗干扰能力强？\n\nPCB Layout类 &SI/PI类\n\n此部分较多，整理中。。。\n\nEMC防护类\n\n此部分题目难度不好把握，整理中。。。\n\n芯片类\n\n1 单片机最小系统架构\n\n2 常见的单片机供应商\n\n3 单片机不能正常启动时，如何排查问题\n\n4 FPGA的特点，与SOC异同\n\n5 FPGA上电时序\n\n6 常见FPGA供应商\n\n7 DDR哪些信号线可以交换，哪些不可以交换\n\n8 DDR走线等长准则\n\n9 常用DDR供应商\n\n10 简述DDR的配置与读写流程\n\n11 常用FLASH供应商\n\n有些做了讲解视频，标绿\n\n应聘职场类\n\n![](https://uploadfiles.nowcoder.com/images/20240102/285305325_1704198954348/5BDD83584D5ABC4D7723E03B41B8167B)\n\n设计规范，硬件设计方案\n\n![](https://uploadfiles.nowcoder.com/images/20240102/285305325_1704199013266/E64BAA49AF96C3F113896E2CD7076B57)\n\n理论知识点讲解\n\n![](https://uploadfiles.nowcoder.com/images/20240102/285305325_1704199039496/E2F1F7A00D0789777C91BBB11FF0C44E)\n\n![](https://uploadfiles.nowcoder.com/images/20240102/285305325_1704199048450/4BB77FD2A2D89EAC4C181BBE1C491A81)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/571792289920458752?sourceSSR=users",
        "title": "游卡2024校招游戏策划岗位面经（已oc）",
        "content": "因为offer了来还愿一下，写一个面经。\n\n流程走了一个月，拥有了2023的最后的奇迹，非常开心。\n\nbg双非建筑，有两端游戏策划岗位经历的实习，转行。\n\n————————————————\n\n12.12群面，14个人+一个面试官+一个hr\n\n轮流自我介绍1min\n\n轮流主题演讲1min\n\n小组讨论30min+展示10min\n\n面试官提问10min\n\n小组重视“组”“整体”两个概念（个人认为）；大家bg都很强，蛮多硕士和海本海硕\n\n12.20二面 hrbp+业务面试官\n\n非常亲切温和的两位面试官\n\n业务面试官：\n\n实习经历主要工作内容\n\n实习经历最有成就感的设计\n\n设计是如何从思维到落地的\n\n实习中，战斗数值的实现方式是怎么样的\n\nmoba英雄设计流程是怎么样的\n\n最想要成为策划类型\n\n为什么以及认为自己不合适成为其他类型策划的原因\n\n如果成为策划会怎么样规划自己的工作生活（2—3年内）\n\nhr面：\n\n校园经历\n\n自我评价\n\n对于杭州和上海喜欢哪个城市\n\n期望薪资\n\n喜欢的游戏类型\n\n一到两周给回复\n\n12.28oc\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/571758696712212480?sourceSSR=users",
        "title": "腾讯测开社招一面面经(金融科技方向)",
        "content": "面试时间线\n\n2024年1.2日一面\n\n刚面完一面，在等待结果，有后续再补充\n\n**一面内容：**\n\n1、自我介绍\n\n2、自我介绍里面的内容哪些是自己主要负责的？（都是自己主要负责的，面试官说那你给我介绍下你开发的测试提效平台吧，技术架构共享屏幕画一下。emmm，画的跟shi一样，面试官说你这个画的啊，太潦草了...，我就又解释哪一块干啥用的，面试官看起来应该听懂了吧）\n\n3-7是一些八股，问的还是有点深入的：\n\n3、进程之间通信方式，多进程和多线程的取舍\n\n4、网络的五层结构，传输层有哪些协议，TCP和UDP的区别\n\n5、讲解下数据库的索引（从原理、使用和优缺点上说了下）\n\n6、select和什么的区别？（不好意思，没听清，辛苦您再说一下？select和什么什么的区别，听清了，这个是什么是啥玩意？我说不是很了解）\n\n7、给出一个程序，说一下功能（给了个C++的递归，用在链表上的，没看出来）\n\n8、C++内存管理方式？听到就懵了，8年没写C++了，我说现在C++了解的不多，目前基本上只能看得懂现有程序，说完这句话就后悔了，面试官说那你再好好看看刚才给你的程序是什么功能。妈耶，就10行代码，看了一个世纪的感觉，这是啥？\n\n9、场景题，写个SQL查询\n\n10、算法题，最长无重复子串\n\n11、反问\n\n先反问了下问题7是干啥的？面试官说你再看看，你能看出来递归遍历了，那之后呢？一道题悔恨三次，最后面试官给说是反转链表？what？反转链表这样写吗？\n\n我是不是撞枪口了？简历里其实就提了一句了解C++，没想到问了八股还有出题，面试官感觉是个C++大佬。\n\n回过头来写这个面经，感觉没被问多少问题，但是每个都问得很深，\n\n、\n\n面经写到最后加上回忆一下自己的回答，感觉无了，后续内容大概补充不了了。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/571746930573807616?sourceSSR=users",
        "title": "任子行 实习",
        "content": "鸽了45min 面就面了20min\n\n1.你要记录一些日志包括参数,记录时间...等内容,数据量非常大你要怎么实现(说了一个方案,又问怎么存储)\n\n2.平时怎么学习,怎么提升技能\n\n3.讲一下反射\n\n4.ioc,aop\n\n5.springboot的特性\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/571739680476037120?sourceSSR=users",
        "title": "24暑期实习(2023.3.5)米哈游笔试真题解析",
        "content": "## T1 玫瑰鸭\n\n塔子哥是一名厨艺达人，最近特别喜欢做玫瑰鸭，因为这种菜式的口感鲜美且具有一定的艺术性。\n\n塔子哥的厨房里，堆满了新鲜的食材，其中包括大量的鸭肉和玫瑰花。\n\n然而，当他想要烹制一些玫瑰鸭时，他发现他的材料可能不够用。他有\n![](https://www.nowcoder.com/equation?tex=a&preview=true) 个玫瑰花，\n![](https://www.nowcoder.com/equation?tex=b&preview=true) 个鸭肉，以及\n![](https://www.nowcoder.com/equation?tex=c&preview=true)\n个神秘的魔法食材，可以当作玫瑰花或者鸭肉使用。\n\n塔子哥知道做一只玫瑰鸭需要 ![](https://www.nowcoder.com/equation?tex=2&preview=true) 个玫瑰花和\n![](https://www.nowcoder.com/equation?tex=2&preview=true)\n个鸭肉。他希望尽可能多地制作玫瑰鸭，而不浪费任何食材。\n\n现在他需要你的帮助，来计算他最多能制作多少只玫瑰鸭。\n\n## 输入描述\n\n输入三个整数 ![](https://www.nowcoder.com/equation?tex=a%2Cb%2Cc&preview=true) ，\n用空格隔开。\n![](https://www.nowcoder.com/equation?tex=0%5Cle%20a%2Cb%2Cc%5Cle%2010%5E9&preview=true)\n\n## 输出描述\n\n一个整数，代表可以制作的玫瑰鸭的最大数量。\n\n## 样例\n\n**输入**\n\n    \n    \n    3 3 3\n    \n\n**输出**\n\n    \n    \n    2\n    \n\n**样例解释**\n\n可以将两个万能食材当作一个玫瑰花和一个鸭肉，所以是 `4 4 1` 可以制作两个玫瑰鸭。\n\n## 题解：贪心\n\n由于是选用等量的食材，因此一定是希望最大化![](https://www.nowcoder.com/equation?tex=min\\(a%2Cb\\)&preview=true)\n\n假设![](https://www.nowcoder.com/equation?tex=a%3Cb&preview=true)，则首先尽可能让![](https://www.nowcoder.com/equation?tex=a%3Db&preview=true)，然后在平分剩下的![](https://www.nowcoder.com/equation?tex=c&preview=true)\n\n## 代码\n\n**C++**\n\n    \n    \n    #include<bits/stdc++.h>\n    using namespace std;\n    #define ll long long\n    int main()\n    {\n        ll a , b , c;\n        cin >> a >> b >> c;\n        if (a > b) swap(a , b);\n        ll f = min(b - a , c);\n        c -= f;\n        a += f;\n        a += c / 2;\n        cout << a / 2 << endl;\n        return 0;\n    }\n    \n    \n\n**Java**\n\n    \n    \n    import java.util.*;\n    public class Main{\n        public static void main(String[] args){\n            Scanner sc = new Scanner(System.in);\n            while(sc.hasNextInt()){\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                int c = sc.nextInt();\n                int result = 0;\n                if(Math.abs(a-b) >= c){\n                    result = (Math.min(a,b)+c)/2;\n                }else{\n                    result = ((c - Math.abs(a-b))/2+Math.max(a,b))/2;\n                }\n                System.out.print(result);\n            }\n        }\n    }\n    \n\n**Python**\n\n    \n    \n    a, b, c = map(int, input().split())\n    if c <= abs(a - b):\n        print((min(a, b) + c) // 2)\n    else:\n        print((max(a, b) + (c - abs(a - b)) // 2) // 2)\n    \n\n## T2 N皇后\n\n塔子哥是一个热衷于国际象棋的棋手，他最近在研究\n![](https://www.nowcoder.com/equation?tex=n&preview=true)\n皇后问题。在国际象棋中，皇后是一种强大的棋子，能够沿着横、竖、斜线攻击其他棋子。\n\n而在 ![](https://www.nowcoder.com/equation?tex=n&preview=true)\n皇后问题中，皇后也是一种强大的棋子，它能攻击同一行、同一列以及同一\n![](https://www.nowcoder.com/equation?tex=45&preview=true) 度角斜线和\n![](https://www.nowcoder.com/equation?tex=135&preview=true) 度角斜线上的其他皇后。\n\n塔子哥手上拿着一个\n![](https://www.nowcoder.com/equation?tex=n%5Ctimes%20n&preview=true)\n的棋盘，上面已经放置了一些皇后。他希望再放置一个皇后，使得所有的皇后不会互相攻击。\n\n对于一个 ![](https://www.nowcoder.com/equation?tex=n%5Ctimes%20n&preview=true)\n的棋盘，有多种不同的摆放皇后的方式，而有些摆法可能会导致皇后之间发生攻击，有些摆法则不会。\n\n因此，塔子哥需要找到所有满足条件的摆法，以便让他更好地研究\n![](https://www.nowcoder.com/equation?tex=n&preview=true)\n皇后问题，你能帮塔子哥求出有多少种放置方案吗？\n\n## 输入描述\n\n第一行输入一个正整数 ![](https://www.nowcoder.com/equation?tex=n&preview=true) ，代表棋盘大小。\n\n接下来的 ![](https://www.nowcoder.com/equation?tex=n&preview=true) 行，每行输入一个仅由\n![](https://www.nowcoder.com/equation?tex=.%20&preview=true) 和\n![](https://www.nowcoder.com/equation?tex=*&preview=true) 组成的字符串，其中\n![](https://www.nowcoder.com/equation?tex=*&preview=true) 代表放置了一个皇后，\n![](https://www.nowcoder.com/equation?tex=.&preview=true) 代表未放置皇后。\n\n保证输入的棋盘中没有两个皇后会互相攻击。\n\n![](https://www.nowcoder.com/equation?tex=1%5Cle%20n%5Cle%201000&preview=true)\n\n## 输出描述\n\n输出塔子哥有多少种放置方案。\n\n## 样例\n\n**输入**\n\n    \n    \n    3\n    .*.\n    ...\n    ...\n    \n\n**输出**\n\n    \n    \n    2\n    \n\n## 题解：模拟\n\n我们可以根据当前棋盘已经放置的皇后位置，来对棋盘的任意一个位置![](https://www.nowcoder.com/equation?tex=\\(i%2Cj\\)&preview=true)是否可以放置皇后来做一个标记，如果![](https://www.nowcoder.com/equation?tex=\\(x%2Cy\\)&preview=true)点已经放置了皇后，那么第![](https://www.nowcoder.com/equation?tex=x&preview=true)行，第![](https://www.nowcoder.com/equation?tex=y&preview=true)列，以及![](https://www.nowcoder.com/equation?tex=\\(x%2Cy\\)&preview=true)的两个对角线都不可放置皇后，对于行和列我们可以使用两个数组来标记，对于两个对角线，我们可以使用![](https://www.nowcoder.com/equation?tex=dig%5Bx-y%5D&preview=true)和![](https://www.nowcoder.com/equation?tex=idig%5Bx%2By%5D&preview=true)这两个标记数组来判断是否可以放置，这样模拟一遍，最终我们再枚举每一个位置是否可以放置皇后，输出对应的合法数量即可。\n\n**C++**\n\n    \n    \n    #include<bits/stdc++.h>\n    using namespace std;\n    #define ll long long\n    const int maxn = 1005;\n    int a[maxn][maxn];\n    // 记录行，列，正负对角线的皇后个数\n    int c[maxn] , r[maxn] , x[maxn * 2] , y[maxn * 2];\n    int main()\n    {\n        int n;\n        cin >> n;\n        bool ok = true;\n        for (int i = 1 ; i <= n ; i++){\n            string t;\n            cin >> t;\n            t = '#' + t;\n            for (int j = 1 ; j <= n ; j++){\n                if (t[j] == '*'){\n                    a[i][j] = 1;\n                    if (r[i] || c[j] || x[i - j + n] || y[i + j]){\n                        ok = false;\n                    }\n                    r[i]++;\n                    c[j]++;\n                    x[i - j + n]++;\n                    y[i + j]++;\n                }\n            }\n        }\n        if (!ok){\n            cout << \"0\" << endl;\n            return 0;\n        }\n        int cnt = 0;\n        for (int i = 1 ; i <= n ; i++){\n            for (int j = 1 ; j <= n ; j++){\n                if (a[i][j] == 1) continue;\n                if (r[i] || c[j] || x[i - j + n] || y[i + j]) continue;\n                cnt ++;\n            }\n        }\n        cout << cnt << endl;\n        return 0;\n    }\n    \n\n**Java**\n\n    \n    \n    import java.util.*;\n    public class Main{\n        public static void main(String args[]){\n            queen();\n        }\n        public static void queen(){\n            Scanner scanner=new Scanner(System.in);\n            int n=scanner.nextInt();\n            scanner.nextLine();\n            HashSet<Integer> row=new HashSet<>();\n            HashSet<Integer> col=new HashSet<>();\n            HashSet<Integer> dia1=new HashSet<>();\n            HashSet<Integer> dia2=new HashSet<>();\n            int c;\n            for(int i=0;i<n;i++){\n                String s=scanner.nextLine();\n                c=s.indexOf(\"*\");\n                if(c!=-1){\n                    row.add(i);\n                    col.add(c);\n                    dia1.add(i+c);\n                    dia2.add(i-c);\n                }\n            }\n            int count=0;\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    if(row.contains(i)||col.contains(j)||dia1.contains(i+j)||dia2.contains(i-j)){\n                        continue;\n                    }\n                    count++;\n                }\n            }\n            System.out.println(count);\n        }\n        \n    }\n    \n\n**Python**\n\n    \n    \n    import sys\n    def dataProcess():\n        n = int(input())\n        grid = []\n        for i in range(n):\n            temp = input()\n            grid.append(list(temp))\n        return n,grid\n    \n    # I only add one queen for next backtracing operation\n    def nQueen(n, grid):\n        c = [0] * n\n        r = [0] * n\n        x = [0] * 2 * n\n        y = [0] * 2 * n\n        a = [[0 for i in range(n)] for j in range(n)]\n        ans = 0\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == \"*\":\n                    a[i][j] = 1\n                    r[j] += 1\n                    c[i] += 1\n                    x[i-j+n] += 1\n                    y[i+j] += 1\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] == 1:\n                    continue\n                if c[i]!=0 or r[j]!=0 or x[i-j+n]!=0 or y[i+j]!=0:\n                    continue\n                ans += 1        \n        return ans\n    \n    \n    if __name__ == \"__main__\":\n        n,grid = dataProcess()\n        ans = nQueen(n, grid)\n        print(ans)\n    \n    \n\n## T3 最长的通讯路径\n\n塔子哥是一位研究者，他在研究网络传输时遇到了一个问题。\n\n他拿到了一张通讯网络的拓扑结构图，其中每条通讯线路被染成了红色或者蓝色。\n\n他想找到一条长度最长的通讯路径，使得路径上相邻的两条线路颜色不同。\n\n## 输入描述\n\n第一行输入一个正整数 ![](https://www.nowcoder.com/equation?tex=n&preview=true) ， 代表节点数量。\n\n接下来的 ![](https://www.nowcoder.com/equation?tex=n-1&preview=true) 行，每行输入两个正整数\n![](https://www.nowcoder.com/equation?tex=u%2Cv&preview=true) 和一个字符\n![](https://www.nowcoder.com/equation?tex=chr&preview=true) ，代表节点\n![](https://www.nowcoder.com/equation?tex=u&preview=true) 和节点\n![](https://www.nowcoder.com/equation?tex=v&preview=true) 有一条边连接。\n\n若为 ![](https://www.nowcoder.com/equation?tex='R'&preview=true) 代表这条边是红色，\n![](https://www.nowcoder.com/equation?tex='B'&preview=true) 代表这条边是蓝色。\n\n![](https://www.nowcoder.com/equation?tex=1%5Cle%20n%20%5Cle%2010%5E5&preview=true)\n\n![](https://www.nowcoder.com/equation?tex=1%5Cle%20u%2Cv%5Cle%20n&preview=true)\n\n保证输入的是一颗树。\n\n## 输出描述\n\n一个正整数，代表塔子哥可以选择的路径最大长度。\n\n## 样例\n\n**输入**\n\n    \n    \n    4\n    1 2 R\n    2 3 B\n    3 4 B\n    \n\n**输出**\n\n    \n    \n    2\n    \n\n**样例解释**\n\n选择 ![](https://www.nowcoder.com/equation?tex=1-2-3&preview=true) 的路径即可。\n\n## **题解：树形DP**\n\n默认以1为根节点进行DFS遍历。\n\n![](https://www.nowcoder.com/equation?tex=dp%5Bi%5D%5B0%5D&preview=true)表示在以![](https://www.nowcoder.com/equation?tex=i&preview=true)为根节点的子树中，且与![](https://www.nowcoder.com/equation?tex=i&preview=true)的连边为蓝色所有路径中最长的。![](https://www.nowcoder.com/equation?tex=dp%5Bi%5D%5B1%5D&preview=true)表示以![](https://www.nowcoder.com/equation?tex=i&preview=true)为根节点的子树中，与![](https://www.nowcoder.com/equation?tex=i&preview=true)的连边为红色的所有路径中最长的。那从前面两个dp我们可以知道以![](https://www.nowcoder.com/equation?tex=i&preview=true)为根节点，且选择了节点![](https://www.nowcoder.com/equation?tex=i&preview=true)的最长路径肯定是![](https://www.nowcoder.com/equation?tex=dp%5Bi%5D%5B0%5D%2Bdp%5Bi%5D%5B1%5D&preview=true)。那假如我们讨论了所有子树，那么最长路径也肯定知道了。\n\n现在问题在于如何得到所有节点的dp值呢。我们发现假如我们知道了一个节点![](https://www.nowcoder.com/equation?tex=u&preview=true)的所有子节点![](https://www.nowcoder.com/equation?tex=v&preview=true)的![](https://www.nowcoder.com/equation?tex=dp&preview=true)值，那么![](https://www.nowcoder.com/equation?tex=u&preview=true)的![](https://www.nowcoder.com/equation?tex=dp&preview=true)值也就知道了。因为节点![](https://www.nowcoder.com/equation?tex=u&preview=true)的![](https://www.nowcoder.com/equation?tex=dp%5Bu%5D%5Bx%5D%3Dmax\\(dp%5Bu%5D%5Bx%5D%2Cdp%5Bv%5D%5Bx%5Coplus%201%5D%2B1\\)&preview=true)所以我们需要先知道所有子节点的值![](https://www.nowcoder.com/equation?tex=dp&preview=true)值，再用子节点的![](https://www.nowcoder.com/equation?tex=dp&preview=true)值去更新父节点。这个我们用dfs处理\n\n**C++**\n\n    \n    \n    #include <bits/stdc++.h>\n    using namespace std;\n    const int MAXN = 2e5 + 5;\n    typedef pair<int, int>pii;\n    int n;\n    vector<pii>edge[MAXN];\n    int dp[MAXN][2];\n    int maxn = 0;\n    void dfs(int u, int fa){\n    \tif(edge[u].size() == 1 && edge[u][0].first == fa)return;//叶子节点直接return，因为叶子节点的两个dp值肯定是0\n    \tfor(int i = 0; i < edge[u].size(); i++){\n    \t\tpii now = edge[u][i];\n    \t\tint v = now.first;\n    \t\tif(v == fa)continue;//如果是父节点，continue，因为我们讨论的是以u为根节点的子树，而u的父节点肯定不属于这颗子树的\n    \t\tdfs(v, u);//得到子节点答案\n    \t\tint col = now.second;\n    \t\tdp[u][col] = max(dp[u][col], dp[v][col ^ 1] + 1);//dp状态转移，用子节点v更新u\n    \t\tmaxn = max(maxn, dp[u][0] + dp[u][1]);//记录答案\n    \t}\n    }\n    int main(){\n    \tcin >> n;\n    \tint u, v;\n    \tchar ch;\n    \tmemset(dp, 0, sizeof dp);//dp初始化\n    \tfor(int i = 1; i <= n - 1; i++){\n    \t\tscanf(\"%d%d\", &u, &v);\n    \t\tcin >> ch;\n    \t\tedge[u].push_back({v, ch == 'R'?1:0});\n    \t\tedge[v].push_back({u, ch == 'R'?1:0});//建图\n    \t}\n    \tdfs(1, 0);\n    \tcout << maxn << endl;\n    }\n    \n    \n\n**Java**\n\n    \n    \n    import java.util.ArrayList;\n    import java.util.List;\n    import java.util.Scanner;\n    \n    class TreeNode{\n        List<TreeNode> friends;\n        List<Character> colors;\n    \n        public TreeNode(){\n            friends = new ArrayList<TreeNode>();\n            colors = new ArrayList<Character>();\n        }\n    }\n    \n    public class Main {\n    \n        public static void main(String[] args) {\n            Scanner in = new Scanner(System.in);\n            int n = in.nextInt();\n            in.nextLine();\n            TreeNode[] tree = new TreeNode[n];\n            for(int i = 0; i < n; i++) tree[i] = new TreeNode();\n            for(int i=0;i<n-1;i++){\n                String[] s = in.nextLine().split(\" \");\n                int x = Integer.parseInt(s[0])-1;\n                int y = Integer.parseInt(s[1])-1;\n                char c = s[2].charAt(0);\n                if(x>y){\n                    int temp = x;\n                    x = y;\n                    y = temp;\n                }\n                tree[x].friends.add(tree[y]);\n                tree[x].colors.add(c);\n                tree[y].friends.add(tree[x]);\n                tree[y].colors.add(c);\n            }\n            int result = 0;\n            for(int i=0;i<n;i++){\n                result = Math.max(result, dfs(tree[i], null, 'B'));\n                result = Math.max(result, dfs(tree[i], null, 'R'));\n    \n            }\n            System.out.println(result);\n    \n        }\n    \n        public static int dfs(TreeNode tree, TreeNode parent, char color){\n            if(tree==null) return 0;\n            int res = 0;\n            for(int i=0;i<tree.friends.size();i++){\n                if(tree.friends.get(i)==parent) continue;\n                if(tree.colors.get(i)==color) {\n                    if(color=='R')\n                        res = Math.max(res,dfs(tree.friends.get(i),tree,'B')+1);\n                    else\n                        res = Math.max(res,dfs(tree.friends.get(i),tree,'R')+1);\n                }\n            }\n            return res;\n        }\n    \n    }\n    \n\n**Python**\n\n    \n    \n    from collections import defaultdict\n    \n    MAXN = 200005\n    n = 0\n    edge = defaultdict(list)\n    dp = [[0] * 2 for _ in range(MAXN)]\n    maxn = 0\n    \n    \n    def dfs(u, fa):\n        global maxn\n        if len(edge[u]) == 1 and edge[u][0][0] == fa:\n            return\n    \n        for now in edge[u]:\n            v = now[0]\n            if v == fa:\n                continue\n            dfs(v, u)\n            col = now[1]\n            dp[u][col] = max(dp[u][col], dp[v][col ^ 1] + 1)\n            maxn = max(maxn, dp[u][0] + dp[u][1])\n    \n    \n    def main():\n        global n\n        n = int(input())\n        for _ in range(n - 1):\n            u, v, ch = input().split()\n            u, v = int(u), int(v)\n            edge[u].append((v, 1 if ch == 'R' else 0))\n            edge[v].append((u, 1 if ch == 'R' else 0))\n    \n        dfs(1, 0)\n        print(maxn)\n    \n    \n    if __name__ == \"__main__\":\n        main()\n    \n    \n\n********[******](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxuq7bkgch1.feishu.cn%2Fdocx%2FBodwdmrbnojrdlxDmYLc6vzsnxe)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/571718358274506752?sourceSSR=users",
        "title": "爱立信-无线通信网络优化工程师面经",
        "content": "1.自我介绍（中文，没有考察英文）\n\n2.一些聊天。为什么选择这座城市、班级的情况、为什么选择通信专业等。\n\n3.技术主管开始提问。问了通原的知识，香农信道公式、信道的类型、调制方法。\n\n4.详细问了实习项目。\n\n5.让我介绍了自己的项目，一个fpga的项目，两项微信小程序的项目。\n\n6.关于毕业设计。\n\n  \n\n反问\n\n1.如果入职的话面临哪些工作\n\n2.还需要提升些什么\n\n3.面试结果通知时间\n\n  \n\n我是本科，接到这个面试邀请很开心，准备了很久，但是答得确实不好……很不好……主要通原太差了。难过ing\n\n  \n\n已挂，中途因为我的休学经历向我要了成绩单等材料，企业hr还是比较严谨认真的。前后两周左右。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/571718299801718784?sourceSSR=users",
        "title": "帆书实习",
        "content": "1.SpringCloud的启动流程(她要我讲注册发现的内容)\n\n2.值对象和应用对象\n\n4.MySQL的优化话方案\n\n5.你项目中断点续传是怎么实现的\n\n6.es的应用场景和优缺点\n\n7.Object的常用方法\n\n8.你常用的并发工具类\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/571704462708936704?sourceSSR=users",
        "title": "（双非本菜鸡 实习/秋招总结）京东 后端开发 面经",
        "content": "JD投的很早了，一直没消息，但是十二月份被捞起来了，写面经之前想先感慨一下吧，也算是总结下鼠鼠的秋招经历。不想看的可以直接下滑看面经。\n\n作为一个双非本的菜菜，可能是有案底吧[牛泪]，有过ACM省银，蓝桥国三，国家奖学金这三个还算是能拿得出手的奖，还有一些天梯赛省三，大床省三这种拿不出手的，学校的名头也不是什么理工类院校，甚至听起来更像唱歌跳舞的艺术类民族院校[笑cry]，在投递简历的时候也是碰了一鼻子（不止一鼻子，一头）的灰，鼠鼠开始也是有点消息闭塞，感觉暑期实习提前两个月四五月份找就差不多，所以在五一之后完成了一个go的项目之后开始投递，然后发现很多大厂的暑期实习已经快结束了，还开着的官网投了一波，也做了不少笔试，都几乎杳无音信,唯一面过的大厂应该也就百度了，实习到了二面，问了很多关于网安的问题，凉了，然后陆续零散的面过一些小公司，上海一天三百的一家开发，后来因为时间原因没去，北京一个月三千多，每个月涨一千五的小公司，北京一家远程实习的创业公司，老板很年轻，同事人也都很好，但没几天我拿到了小米的offer，短期实习了没几天算是被我鸽了吧，心里还挺不好意思的，然后就是拿到了小米sre的实习，收到面试电话的时候，现查了一下什么是SRE[笑cry]，自己还是很想做开发的，但是小米对于当时的我来说，在我的认知里，我觉得算是大厂了（所以到底算不算我也不清楚。。），碰巧女朋友拿到了快手的实习，所以我也就接了面试，没有太多八股，考了一些场景题和一些linux命令。然后就开始了我的实习经历，后续在实习工作中慢慢感觉几乎没什么开发的任务，oncall，点点点，感觉更像一个运维，比较适合储备知识量比较大而又不想高强度研发的人适合干，再加上转正之后开的薪资，低的离谱（没错，就是比你想象的还要低很多），鼠鼠又走进了秋招的历程，有了小米的实习加成，又是在北京，鼠鼠也就一心投大厂（这里的大厂指很多人都知道的公司），陆续面过，好未来，百度（没错又凉了），去哪儿，腾讯云，多益，其中，好未来忘了是一面还是二面凉了，多益当时聊的很好，场景题都答上了，八股项目也没问题也聊了很久，然后一直没消息挂了，百度，感觉像KPI，一个女面试官，像看着提纲一样，一条一条八股问，问题和问题之间也没什么连贯性，有些我深入说了一下也没什么反馈，最后说我基础不扎实....，去哪儿一天速通三面，最后泡池子挂了，腾讯云二面因为太久没用golang，让我用golang现场写项目（我一般都是面向chatgpt编程），太久没默写，挂掉了，以上感觉有几次机会也还是自己没把握住吧，还是自己菜，“菜就多练”，该面的都面了，基本上该投的都投完了，一大堆的投递和笔试也都没接到面，可能双非本杀过人吧，中途鼠鼠签了我mi的两方协议，总得有口饭吃，三方签署截止时间是23年年末，碰巧鼠鼠年末回学校考试，想着的就是如果回学校考试前还没有其他offer就签mi的三方了，（鼠鼠秋招这几个月发现，对于普通人来说，找工作真的很看运气）不知道应该说是命该如此，还是真的就是机缘巧合，在回学校的上一周接到了京东面试（前几天得知导师离职的消息），所以当时心里也有种感觉，就是这次面试一定要过，这次失败也就彻底没机会了，这里简单概括，后文会详更面经，一面八股+项目+编码能力（一个小时左右），二面第一个面试官八股+项目+学校经历，第二个面试官主要问学校经历（因为写了是ACM工作室负责人），问了很多，关于我负责哪些任务，带队参赛怎么培训，如何安排队员负责的侧重点，做项目如何安排分工协商，如果有人不配合怎么办等等很多，实习经历，实习都做了什么，遇到难题怎么办，闯祸的话怎么挽救等等很多吧，面试官说技术问题前面两人都面过了，他就不问了，侧重的都是这种性格和处事方法能力的问题，最后问是哪里人，发现是老乡，还让我如何用简短的几乎话介绍一些家乡，吸引别人前去游玩（这个问题真的给我难住了，因为家乡算是一个不知名的小县城），最后还是想了一些家乡特有的特点概括了两句。三面hr面，主要也是问学校经历，实习经历，学到的内容，如何选取自己的职业发展方向，薪资等问题（这里说了mi不到20k），最后东子给的也不到20k[牛泪]，但算上绩效还是比米多些，整体感觉三面就一面让写了下快排，（真的因为太久没写了，而且完全没复习算法，写了很久，磕磕绊绊的，面试官等不及了，让我换一个写，写了一下log查找有序数组二分），剩下那几面几乎没有卡顿的地方，都聊的很好，hr面完之后我看了下后台的流程代码已经推进到offer状态栏，整体四位面试官感觉人都很好，不会的问题会引导你，让你慢慢理解思考想，也没有生硬的问八股文都是结合项目和结合实习经历问的。从初试当天到收到offer一共九天，最后鼠鼠在回学校的高铁上，收到了谈薪的电话，信号不太好，有些都没听清，说了不给A，鼠鼠也没敢A就接了。然后回学校取三方，回北京和东子签完，以上。总之感觉还是比较坎坷的，因为鼠鼠本人对技术还是比较感兴趣的所以一心投北京互联网企业，并且想去个开发岗，虽然最后是运维开发，但感觉总要强过SRE（问了下，就是开发岗不会有运维任务），但其实鼠鼠现在心里依旧没底，东子前段时间大裁员，没准我的位置就是裁出来的，和鸽的太多才能捞到我的，而且鼠鼠明年得回学校不能提前实习，心里也一直担心东子会不会毁三方或者试用期裁应届生之类的，提离职的时候leader也是劝我好好考虑，因为米子这边部门明确表示过不裁应届生，但想了想还是走吧，一个是岗位一个是薪资，都强于米子，除了稳定这个理由也没有别的理由能让我继续留在米子，组里的同事都很好，对我这个新人也很照顾，再加上米子能和女朋友住一起，东子只能周末夫妻了，所以也犹豫了几天，但最后综合权衡了一下还是签了JD。如果没有被毁约和试用期被裁，这应该也就是鼠鼠最后一次更面经了，也算是给自己的秋招做个总结，这几个月的实习和求职历程，真的让鼠鼠有很多感慨（快送走了小组一半人了）\n\n在时代的洪流面前，个人真的渺小如尘埃，很微不足道，拿不到offer的牛友这真的不是你的错，不要质疑自己，有精力有余力就坚持走自己选的方向至少坚持了你不会后悔，你努力过了，还有春招，还有补录。别灰心，前几个月，鼠鼠也是沮丧的不行，总之，坚持吧，24年第一个工作日，和那些同为应届生在求职之路历经坎坷的牛友们共勉！加油！**\n_永远相信美好的事情即将发生！_**\n\n京东后端开发（运维平台相关python+go）面经\n\n时间有点久，顺序可能记不太清\n\n一面主要深挖项目\n\n自我介绍\n\ngolang的八股，channel，groutine，gmp模型，可能还有但记不太清了，但golang的八股也就这些东西，重点是自己回答的时候能拓展把他们联系起来以及说出和其他语言的区别和优势\n\n深挖项目，这里就是结合我简历上的项目问了很多，我项目中写的几乎问到了为什么用消息队列，分块上传怎么实现，登录权限怎么验证，限流，分布式怎么实现，rpc框架，为什么要用分布式，技术选型，项目的时间大概占到三四十分钟左右，几乎每一个问题，我都会延伸，就是没有面试官问什么我答什么，说出自己的深入理解，就是把我学的都展示出来[笑cry]\n\nlinux命令，这里我又主动提到了我实习遇到的内存泄漏问题如何排查出来的（然后面试官又问我项目有bug怎么排查）\n\n快排（忘了，磕磕绊绊写了好久），二分\n\n手写链表的增删改查，用C结构体写的，把结构体改成类，面试官说是看我编码能力\n\n最后问我python的能力能有c的多少，我说百分之七八十，面试官笑了，说那我就不该说用C应该用python写，我也笑了，哈哈\n\n然后我说了一下自己用python写过的一些小工具，实习中写了很多爬虫自动化的工具，还有个人开发的一个根据企业微信接口实现定期给微信推送消息的脚本，部署在服务器上，会每天早上发天气预报和穿衣提醒，提醒吃饭等等，之前的面试，面试官不问我也没说过[笑cry]，但这次可能真的比较想走吧，所以主动了一些\n\n反问：技术栈，会不会有运维任务\n\n时间一个小时左右\n\n二面\n\n自我介绍\n\n问了下python 的八股，我直接说不会，然后说了一下python现在更多的是写一些工具，没有太深入的去学习\n\ngolang八股，map，slice，指针引用，内存管理相关\n\n项目细节（因为项目是自己亲手一步一步做的，所以几乎没在项目上被难到过）\n\n大概半个多小时\n\n第二位面试官\n\n这位面试官给人感觉听起来就是领导之类的，主要问了一些\n\n校园经历，培训时队员不配合怎么办，做项目任务的分工，学习路线\n\n（感觉像领导者的问题，要不是写着后端开发我可能会以为是选小组长，哈哈哈[笑cry]）\n\n实习经历，遇到难题，闯祸如何解决，职业规划，两句话介绍家乡特色\n\n反问：结果多久能出来\n\n半个多小时\n\n整体二面一个多小时\n\nHR面：\n\n自我介绍，学校经历，手上offer，薪资，为什么没在mi转正，职业规划，还聊了很多但是忘了，我就记得这个面试官总笑[笑cry]\n\n以上，整体没有太多八股，技术方面主要深挖了项目，项目问的很深，从头到尾问遍了，一面技术偏重压力偏大一些，二面和hr面技术没有太多。可能有些忘了，想起来随时补充，最后祝大家考研的都能上岸，找工作的都能拿到满意的offer！2024元旦快乐！\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/571445180465778688?sourceSSR=users",
        "title": "24秋招(2023.8.6)米哈游笔试真题解析",
        "content": "### 1.米小游学英语\n\n**题目描述**\n\n米小游读小学了，学校里新开了英语课。\n\n某一天老师进行了一对一的口语考试，考试内容为复述老师说的话。考试要求每个人一共进行![](https://www.nowcoder.com/equation?tex=t&preview=true)次测试，每次测试中，老师会说一句话，包含![](https://www.nowcoder.com/equation?tex=n&preview=true)个单词，米小游每复述出一个单词，就能够获得一分，但是当分数低于0时，本次测试就会结束，并且该次测试未通过。\n\n米小游英语很差，因此他想知道自己一共能通过多少次测试。\n\n**输入描述**\n\n>\n> 第一行输入一个正整数![](https://www.nowcoder.com/equation?tex=t&preview=true)，代表米小游需要进行的测试数量\n>\n> 接下来的`3*t`行，每3行用于描述一次测试:\n>\n>\n> 第一行输入一个正整数![](https://www.nowcoder.com/equation?tex=n&preview=true)，代表老师说的一句话包含的单词数量。\n>\n>\n> 第二行输入![](https://www.nowcoder.com/equation?tex=n&preview=true)个仅由小写字母组成的字符串，用空格隔开。代表老师说的单词。\n>\n>\n> 第三行输入![](https://www.nowcoder.com/equation?tex=n&preview=true)个仅由小写字母组成的字符串，用空格隔开。代表米小游复述的话。\n>\n>\n> ![](https://www.nowcoder.com/equation?tex=1%5Cle%20t%20%5Cle%2010%2C1%5Cle%20n%20%5Cle%20100&preview=true)\n>\n> 单词的长度均不超过10。\n\n**输出描述**\n\n> 一个整数，代表米小游最终通过了多少次测试。\n\n**样例**\n\n**输入**\n\n    \n    \n    3\n    2\n    hello hello\n    hello hello\n    3\n    how are you\n    hwo are you\n    4\n    how old are you\n    how old are yuo\n    \n    \n\n**输出**\n\n    \n    \n    2\n    \n\n**题解：模拟**\n\n维护一个变量`score`和`cnt`表示米小游每次答题的分数和能通过多少次测试，如果某一轮测试中某一时刻的`score`的值<0，则直接跳出当前循环，如果最终有![](https://www.nowcoder.com/equation?tex=score%5Cge%200&preview=true)，则`cnt`计数+1。\n\n**复杂度分析**\n\n> 时间复杂度：![](https://www.nowcoder.com/equation?tex=O\\(n*t*10\\)&preview=true)\n>\n> 空间复杂度：![](https://www.nowcoder.com/equation?tex=O\\(n\\)&preview=true)\n\n**C++**\n\n    \n    \n    #include <bits/stdc++.h>\n    using namespace std;\n    typedef pair<int,int>PII;\n    #define x first\n    #define y second\n    typedef long long ll;\n    const int N=2E5+10,mod=1e9+7;\n    int n,m;\n    string w[N],t[N];\n    int main(){\n        cin>>n;\n        int cnt=0;\n        for(int i=0;i<n;i++){\n            cin>>m;\n            for(int i=0;i<m;i++){\n                cin>>w[i];\n            }\n            for(int i=0;i<m;i++){\n                cin>>t[i];\n            }\n            int score=0;\n            for(int i=0;i<m;i++){\n                if(w[i]==t[i])score++;\n                else score--;\n                if(score<0){\n                    break;\n                }\n            }\n            if(score>=0){\n                cnt++;\n            }\n        }\n        cout<<cnt<<endl;\n        return 0;\n    }\n    \n\n**Java**\n\n    \n    \n    import java.util.*;\n    \n    public class Main {\n    \n        public static void main(String[] args) {\n            Scanner sc = new Scanner(System.in);\n            int n = sc.nextInt();\n            int res = n;\n            while (n -- > 0) {\n                int len = sc.nextInt();\n                sc.nextLine();\n                String[] s1 = sc.nextLine().split(\" \");\n                String[] s2 = sc.nextLine().split(\" \");\n                int count = 0;\n                for (int i = 0; i < len; i++) {\n                    if (s1[i].equals(s2[i])) {\n                        count++;\n                    } else {\n                        count--;\n                    }\n                    if (count < 0) {\n                        res--;\n                        break;\n                    }\n                }\n            }\n            System.out.println(res);\n        }\n    }\n    \n    \n\n**Python**\n\n    \n    \n    t = eval(input())\n    final = 0\n    for _ in range(t):\n        num = int(input())\n        s1 = input().split()\n        s2 = input().split()\n        score = 0\n        for j in range(num):\n            if s1[j] == s2[j]:\n                score +=1\n            else:\n                score -=1\n            if score < 0:\n                break\n        if score >= 0:\n            final += 1\n    print(final)\n    \n    \n\n### 2.希尔割草\n\n**题目描述**\n\n希尔最近沉迷于一款割草游戏。所谓割草游戏，并不是割草模拟器，而是指一款击杀敌人快，很容易一次性就击杀大量敌人的游戏。\n\n希尔每放一个大范围aoe技能下去，就能看见屏幕上一大片的敌人消失，非常解压。\n\n这天，希尔又在玩这款割草游戏了，他看着面前的n*个敌人，每个敌人都有![](https://www.nowcoder.com/equation?tex=a_i&preview=true)的血，但是突然发现他的技能只能给一个敌人造成1点伤害了。但好在希尔所使用的角色点了天赋，**开局时给所有敌人添加debuff，当一名敌人血量降到一半及以下时，就会给所有敌人造成1点伤害**(这个debuff触发一次后消失)。希尔想知道，他最少需要多少次攻击才能击杀所有敌人。\n\n**输入描述**\n\n>\n> 第一行输入一个正整数![](https://www.nowcoder.com/equation?tex=n&preview=true)，代表敌人的最大数量\n>\n>\n> 第二行输入![](https://www.nowcoder.com/equation?tex=n&preview=true)个正整数![](https://www.nowcoder.com/equation?tex=a_i&preview=true)，代表每个敌人的血量\n>\n>\n> ![](https://www.nowcoder.com/equation?tex=1%5Cle%20n%5Cle%2010%5E5%2C1%5Cle%20a_i%20%5Cle%2010%5E9&preview=true)\n\n**输出描述**\n\n> 一个正整数，代表希尔攻击的最小次数。\n\n**样例**\n\n**输入**\n\n    \n    \n    2\n    6 8\n    \n\n**输出**\n\n    \n    \n    10\n    \n\n**样例说明**\n\n    \n    \n    希尔打第一个敌人3次，触发天赋，每个敌人剩余2，7血。接下来，希尔打第二个敌人3次，触发天赋，每个敌人剩余1，3血。希尔无法再触发天赋了，因此还要攻击4次，总共是10次。\n    \n\n**题解：贪心+排序**\n\n为了尽可能减少攻击次数，我们肯定是想把天赋效果尽可能发挥满，也就是说，**能被天赋aoe效果击败的怪物，我们就不主动攻击他** 。\n\n什么怪物必须要攻击呢，显然，天赋最多只能触发![](https://www.nowcoder.com/equation?tex=n&preview=true)次，如果一个怪物的血量![](https://www.nowcoder.com/equation?tex=%5Cge%20n&preview=true)，那么一定是要对他进行攻击的。\n\n此外，对于血量更多的一些怪物，即使我们把它留到最后再去攻击（触发完其他所有怪物的aoe效果之后），它本身还是不会触发aoe效果，因此，我们需要将他们的aoe优先触发，这个血量阈值是2n。\n\n剩余的怪物，先触发血量少的怪物的aoe肯定会优于先触发血量多的情况，因为先触发血量多的可能会把血量少的打死，导致aoe伤害浪费，进而导致总攻击次数增多。\n\n所以我们先将怪物按血量排序，然后计算血量大于2n的怪物的需要手动攻击的攻击次数，同时记录aoe的触发次数`cnt`，再依次从小到大依次处理\n\n当我们判断第![](https://www.nowcoder.com/equation?tex=i&preview=true)个敌人时，如果该敌人被天赋攻击`cnt`次后**不能触发天赋**\n，我们就要打到他触发天赋(血量少的要比血量多的先触发天赋，所以这里一定要打)，如果可以触发就省去这一步，之后还要减去后面`n-cnt`个敌人天赋触发扣的血，敌人剩余的血量就是我们额外要攻击的次数，进行累加即可。\n\n**复杂度分析**\n\n> 时间复杂度：![](https://www.nowcoder.com/equation?tex=O\\(nlogn\\)&preview=true)\n>\n> 空间复杂度：![](https://www.nowcoder.com/equation?tex=O\\(n\\)&preview=true)\n\n**C++**\n\n    \n    \n    #include <iostream>\n    #include <vector>\n    #include <algorithm>\n    using namespace std;\n    \n    int main() {\n        int n;\n        cin >> n; // 输入n\n        vector<int> msters;\n        for (int i = 0; i < n; i++) {\n            int mster;\n            cin >> mster; // 输入怪物的血量\n            msters.push_back(mster);\n        }\n        sort(msters.begin(), msters.end()); // 对怪物血量进行排序\n        \n        int cnt = 0; // 记录已经触发的aoe次数\n        int ans = 0; // 记录攻击总次数\n        while (!msters.empty() && msters.back() >= 2 * n) {\n            ans += msters.back() - n; // 实际攻击时将接受剩余aoe的血量预留下来\n            cnt++; // 触发的aoe次数+1\n            msters.pop_back(); // 移除血量大于等于2n的怪物\n        }\n        \n        for (int i = 0; i < msters.size(); i++) {\n            int msterhp = msters[i];\n            int nowhp = msterhp - cnt; // 当前怪物接受完之前的aoe后的剩余血量\n            \n            if (nowhp > msterhp / 2) {\n                ans += nowhp - msterhp / 2; // 如果当前敌人没有触发aoe，攻击他直到触发他的aoe\n                nowhp = msterhp / 2;\n            }\n            \n            if (nowhp - (n - cnt) > 0) {\n                ans += nowhp - (n - cnt); // 计算当前敌人需要的额外攻击次数\n            }\n            \n            cnt++; // 触发的aoe次数+1\n        }\n        \n        cout << ans << endl; // 输出攻击总次数\n        return 0;\n    }\n    \n    \n\n**Java**\n\n    \n    \n    import java.util.Arrays;\n    import java.util.Scanner;\n    \n    public class Main {\n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            int n = scanner.nextInt(); // 输入n\n            int[] msters = new int[n];\n            for (int i = 0; i < n; i++) {\n                msters[i] = scanner.nextInt(); // 输入怪物的血量\n            }\n            Arrays.sort(msters); // 对怪物血量进行排序\n            \n            int cnt = 0; // 记录已经触发的aoe次数\n            int ans = 0; // 记录攻击总次数\n            while (msters.length > 0 && msters[msters.length - 1] >= 2 * n) {\n                ans += msters[msters.length - 1] - n; // 实际攻击时将接受剩余aoe的血量预留下来\n                cnt++; // 触发的aoe次数+1\n                msters = Arrays.copyOf(msters, msters.length - 1); // 移除血量大于等于2n的怪物\n            }\n            \n            for (int msterhp : msters) {\n                int nowhp = msterhp - cnt; // 当前怪物接受完之前的aoe后的剩余血量\n                \n                if (nowhp > msterhp / 2) {\n                    ans += nowhp - msterhp / 2; // 如果当前敌人没有触发aoe，攻击他直到触发他的aoe\n                    nowhp = msterhp / 2;\n                }\n                \n                if (nowhp - (n - cnt) > 0) {\n                    ans += nowhp - (n - cnt); // 计算当前敌人需要的额外攻击次数\n                }\n                \n                cnt++; // 触发的aoe次数+1\n            }\n            \n            System.out.println(ans); // 输出攻击总次数\n        }\n    }\n    \n    \n\n**Python**\n\n    \n    \n    n = int(input())\n    msters = list(map(int, input().split()))\n    msters.sort()\n    cnt = 0\n    ans = 0\n    while msters and msters[-1] >= 2*n:        #先处理血量大于2*n的怪物\n        ans += msters.pop() - n            #实际攻击时将接受剩余aoe的血量预留下来，实际攻击次数就相当于接受完n次aoe后的血量\n        cnt += 1                    #记录已经触发的aoe次数\n    for msterhp in msters:        #再依次从小到大取数\n        nowhp = msterhp - cnt            #当前怪物接受完之前的aoe后的剩余血量\n        if nowhp > msterhp // 2:        #如果当前敌人没有触发aoe，就攻击他直到触发他的aoe\n            ans += nowhp - msterhp//2\n            nowhp = msterhp//2\n        if nowhp - (n-cnt) > 0:    #再计算当前敌人需要的攻击次数\n            ans += nowhp - (n-cnt)\n        cnt += 1        #记录的aoe次数+1\n    print(ans)\n    \n    \n\n### 3.莫娜施法\n\n**题目描述**\n\n莫娜是一名远近闻名的魔法师。\n\n这天他受邀来到了一个国家，来帮这个国家的国王解决一个问题。这个国家的国王年轻时曾有一颗非常美丽的树，但是国王却不小心惹怒了一个十分邪恶的黑魔法师，于是黑魔法师施法，让这棵树变得十分丑陋。现在，这棵树一共有![](https://www.nowcoder.com/equation?tex=n&preview=true)个节点，根节点为1号节点，其深度为1。每个节点都被黑魔法师随机施加了一个丑陋值，丑陋值越大，越影响这棵树的美观度，影响值为该节点的深度乘其丑陋值。\n\n国王苦苦寻找了半辈子解决方案，让无数魔法师尝试过，但都没办法将树变回原样。长时间受黑魔法影响，这棵树再也无法变为原样了。终于，国王找到了莫娜，希望莫娜能**尽可能地将树的丑陋值减少**\n，并承诺，减少了多少丑陋值，就给莫娜多少钱。\n\n莫娜看了看树，发现受黑魔法影响，只能裁剪树的一部分将其嫁接到另一个节点上。莫娜想挣尽可能多的钱，因此他想知道能将树的丑陋值降到的最小值是多少？\n\n**注：只能裁剪一次。**\n\n**输入描述**\n\n>\n> 第一行输入一个整数![](https://www.nowcoder.com/equation?tex=n\\(1%5Cle%20n%20%5Cle%2010%5E5\\)&preview=true)表示的大小\n>\n>\n> 第二行输入![](https://www.nowcoder.com/equation?tex=n&preview=true)个整数![](https://www.nowcoder.com/equation?tex=a\\(1%5Cle%20a_i%5Cle%2010%5E8\\)&preview=true)表示每个节点的丑陋值\n>\n>\n> 接下来![](https://www.nowcoder.com/equation?tex=n-1&preview=true)行，每行输入两个整数![](https://www.nowcoder.com/equation?tex=u%2Cv\\(1%5Cle%20u%2Cv%20%5Cle%20n\\)&preview=true)，表示树上的边\n\n**输出描述**\n\n> 输出一个整数表示最小的丑陋值\n\n**样例**\n\n**输入**\n\n    \n    \n    4\n    3 2 1 4\n    1 2\n    1 3\n    3 4\n    \n\n**输出**\n\n    \n    \n    17\n    \n\n**题解：树形DP**\n\n定义![](https://www.nowcoder.com/equation?tex=sum%5Bi%5D&preview=true)为以![](https://www.nowcoder.com/equation?tex=i&preview=true)为根节点的子树的权值和，![](https://www.nowcoder.com/equation?tex=d%5Bi%5D&preview=true)为![](https://www.nowcoder.com/equation?tex=i&preview=true)节点的深度，![](https://www.nowcoder.com/equation?tex=f%5Bi%5D&preview=true)为以![](https://www.nowcoder.com/equation?tex=i&preview=true)为根节点的子树的丑陋值和，我们可以从根节点1开始，**跑一遍DFS**\n，来计算上述的值。\n\n然后我们可以考虑裁剪第![](https://www.nowcoder.com/equation?tex=i\\(2%5Cle%20i%20%5Cle%20n\\)&preview=true)个节点，贪心的考虑，一定是把当前的节点，嫁接到根节点的位置上，那么，其实改变的丑陋值其实就是以![](https://www.nowcoder.com/equation?tex=i&preview=true)为根节点的子树的丑陋值对应的部分。\n\n没裁剪之前这一部分的值为![](https://www.nowcoder.com/equation?tex=d%5Bi%5D*sum%5Bi%5D&preview=true)\n\n裁剪并嫁接后的这一部分的值为![](https://www.nowcoder.com/equation?tex=2*sum%5Bi%5D&preview=true)\n\n对应的差值![](https://www.nowcoder.com/equation?tex=diff%3D\\(d%5Bi%5D-2\\)*sum%5Bi%5D&preview=true)\n\n**复杂度分析**\n\n> 时间复杂度：![](https://www.nowcoder.com/equation?tex=O\\(n\\)&preview=true)\n>\n> 空间复杂度：![](https://www.nowcoder.com/equation?tex=O\\(n\\)&preview=true)\n\n**C++**\n\n    \n    \n    #include <bits/stdc++.h>\n    using namespace std;\n    typedef pair<int,int>PII;\n    #define x first\n    #define y second\n    typedef long long ll;\n    const int N=2E5+10,mod=1e9+7;\n    int n,m;\n    ll f[N],w[N],d[N],sum[N];\n    vector<int>g[N];\n    vector<ll> dfs(int u,int fa,int depth){\n        d[u]=depth;\n        sum[u]=w[u];\n        f[u]+=1ll*w[u]*d[u];\n        for(int &x:g[u]){\n            if(x==fa)continue;\n            auto t=dfs(x,u,depth+1);\n            f[u]+=t[0];sum[u]+=t[1];\n        }\n        return {f[u],sum[u]};\n    }\n    int main(){\n        cin>>n;\n        for(int i=1;i<=n;i++)cin>>w[i];\n        for(int i=1;i<n;i++){\n            int a,b;\n            cin>>a>>b;\n            g[a].push_back(b);\n            g[b].push_back(a);\n        }\n        dfs(1,0,1);\n        ll res=f[1];\n        for(int i=2;i<=n;i++){  //考虑替换第i个节点\n            if(d[i]<=2)continue;\n            ll down=1ll*(d[i]-2)*sum[i];\n            res=min(res,f[1]-down);\n        }\n        cout<<res<<endl;\n        return 0;\n    }\n    \n\n**Java**\n\n    \n    \n    import java.util.*;\n    \n    public class Main {\n        static final int N = 200010;\n        static final int mod = (int)1e9 + 7;\n        static int n;\n        static long[] f = new long[N], w = new long[N], d = new long[N], sum = new long[N];\n        static List<Integer>[] g = new ArrayList[N];\n    \n        static long[] dfs(int u, int fa, int depth) {\n            d[u] = depth;\n            sum[u] = w[u];\n            f[u] += 1L * w[u] * d[u];\n            for (int x : g[u]) {\n                if (x == fa) continue;\n                long[] t = dfs(x, u, depth + 1);\n                f[u] += t[0];\n                sum[u] += t[1];\n            }\n            return new long[]{f[u], sum[u]};\n        }\n    \n        public static void main(String[] args) {\n            Scanner sc = new Scanner(System.in);\n            n = sc.nextInt();\n            for (int i = 1; i <= n; i++) {\n                w[i] = sc.nextLong();\n                g[i] = new ArrayList<>();\n            }\n            for (int i = 1; i < n; i++) {\n                int a = sc.nextInt();\n                int b = sc.nextInt();\n                g[a].add(b);\n                g[b].add(a);\n            }\n            dfs(1, 0, 1);\n            long res = f[1];\n            for (int i = 2; i <= n; i++) {\n                if (d[i] <= 2) continue;\n                long down = 1L * (d[i] - 2) * sum[i];\n                res = Math.min(res, f[1] - down);\n            }\n            System.out.println(res);\n        }\n    }\n    \n\n**Python**\n\n    \n    \n    from collections import defaultdict\n    \n    N = 200010\n    mod = int(1e9) + 7\n    n = 0\n    f = [0] * N\n    w = [0] * N\n    d = [0] * N\n    sum = [0] * N\n    g = defaultdict(list)\n    \n    def dfs(u, fa, depth):\n        d[u] = depth\n        sum[u] = w[u]\n        f[u] += 1 * w[u] * d[u]\n        for x in g[u]:\n            if x == fa:\n                continue\n            t = dfs(x, u, depth + 1)\n            f[u] += t[0]\n            sum[u] += t[1]\n        return f[u], sum[u]\n    \n    n = int(input())\n    w=[0]+list(map(int,input().split()))\n    for i in range(1, n):\n        a, b = map(int, input().split())\n        g[a].append(b)\n        g[b].append(a)\n    dfs(1, 0, 1)\n    res = f[1]\n    for i in range(2, n + 1):\n        if d[i] <= 2:\n            continue\n        down = 1 * (d[i] - 2) * sum[i]\n        res = min(res, f[1] - down)\n    print(res)\n    \n\n以上内容均来自[笔试刷题指南](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxuq7bkgch1.feishu.cn%2Fdocx%2FBodwdmrbnojrdlxDmYLc6vzsnxe)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/571171535541604352?sourceSSR=users",
        "title": "12.30 右岸物联 - 感知世界 Java实习",
        "content": "# 12.30 右岸物联 - 感知世界 Java实习\n\n自我介绍\n\n## Java\n\n说说方法重写和方法重载有什么区别\n\n## 数据库\n\n介绍MySQL中锁、索引、事务之间的联系\n\n说一下你用Redis实现了什么优化功能\n\n## 项目\n\n说一下你的前后端项目是怎么部署的\n\n## 对面试官提问\n\n# 总结\n\n这次面试的公司规模比较小，我去时一个工作室的人实在不多，面试的流程也比较简单，很快面完就回去了，所以这次面经写的内容也很少\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/571444644081311744?sourceSSR=users",
        "title": "24暑期实习(2023.4.15)米哈游笔试真题解析",
        "content": "### T1 关于3\n\n**题目内容**\n\n在这个古老的民族中，数学不仅是一门学科，更是一种信仰和文化。他们相信，数字是宇宙中最基本的构成元素，任何事物的本质都可以用数字来描述和解释。\n\n因此，这个民族对数字的研究非常深入。他们探索各种数学问题，包括数论、几何、代数等等，不断推进数学领域的发展。\n\n其中一个有趣的问题是如何用若干个不相等的 3\n的幂次方的和或差来表示任何正整数。这个问题引起了这个民族数学家们的极大兴趣，经过长期的研究和探索，他们最终得出了结论：**任何正整数都可以用若干个不相等的\n3 的幂次方的和或差表示** 。\n\n这个发现深深地影响了这个民族的文化和信仰，成为他们数学研究和文化传承中的重要组成部分。为了纪念这个发现，这个民族经常使用 3\n的幂次方作为他们文化的象征，并且在重要的节日和庆典中经常使用这个数字来表示祝福和祈愿。\n\n今天，你有机会帮助这个民族解决一个实际的问题：**给定一个正整数，你需要找到一种由若干个不相等的 3\n的幂次方的和或差表示的方式，并按照每一项从大到小的顺序输出** 。\n\n**输入描述**\n\n>\n> 一个正整数![](https://www.nowcoder.com/equation?tex=x\\(1%5Cle%20x%20%5Cle%2010%5E9\\)&preview=true)\n\n**输出描述**\n\n> 一个表达式，最终的答案必须等于![](https://www.nowcoder.com/equation?tex=x&preview=true)\n> 。**表达式的每一项必须是 3的幂，且不能有两项相同。**\n>\n> 例如， 18 必须输出为 27−9 而不能是 9+9 。\n\n**样例**\n\n**输入**\n\n    \n    \n    30\n    \n\n**输出**\n\n    \n    \n    27+3\n    \n\n**题解：三进制+递归拆解**\n\n对于一个数字`x`，它一定可以表示为若干个2的整数幂的和，比如![](https://www.nowcoder.com/equation?tex=7%3D2%5E2%2B2%5E1%2B2%5E0&preview=true)，但是，它不一定能表示为若干个3的整数幂的和，比如![](https://www.nowcoder.com/equation?tex=30%3D3%5E3%2B3%5E1&preview=true)，这个是可以表示成若干个3的整数幂的和的，但是对于![](https://www.nowcoder.com/equation?tex=2&preview=true)这个数字来说，它不能被表示为若干个3的整数幂的和，但是可以被表示为![](https://www.nowcoder.com/equation?tex=26%3D3%5E3-3%5E0&preview=true)\n\n那么我们分析一下：什么样的数字可以被表示为若干个3的整数幂的和，我们设`i`为3的整数幂的最高次幂，那么**它可以表示的最大数字不超过**![](https://www.nowcoder.com/equation?tex=3%5E0%2B3%5E1%2B...%2B3%5Ei%3D%5Cfrac%7B3%5E%7Bi%2B1%7D-1%7D%7B2%7D&preview=true)\n\n因此，对于在该范围内的数字，是可以用若干个3的整数幂的和表示的，我们取![](https://www.nowcoder.com/equation?tex=i%3Dlog_3\\(x\\)&preview=true)，那如果有![](https://www.nowcoder.com/equation?tex=x%5Cge%20%5Cfrac%7B3%5E%7Bi%2B1%7D-1%7D%7B2%7D&preview=true)，则我们需要向`i+1`借一位，然后让![](https://www.nowcoder.com/equation?tex=x%3Dx-3%5E%7Bi%2B1%7D&preview=true)，然后再递归处理`x`，注意递归处理时，需要对`x`取绝对值，然后后面所得到的幂次也需要变换符号，比如加号变成减号，或者减号变成加号。\n\n**复杂度分析**\n\n> 时间复杂度：`O(logn)`\n>\n> 空间复杂度：`O(1)`\n\n**C++**\n\n    \n    \n    #include <bits/stdc++.h>\n    using namespace std;\n    typedef pair<int,int>PII;\n    #define x first\n    #define y second\n    typedef long long ll;\n    const int N=1E5+10;\n    int n;\n    vector<int>nums;\n    ll pow(int a,int b)\n    {\n        ll res=1,t=a;\n        while(b)\n        {\n            if(b&1)res*=t;\n            t*=t;\n            b>>=1;\n        }\n        return res;\n    }\n    void get_val(int x)\n    {\n        int t=1;\n        while(x>1)\n        {\n            int p=log(x)/log(3);\n            if((pow(3,p+1)-1)/2<x)   //不能由1 3 ... 3^p 表示 需要向上借位\n            {\n                nums.push_back(pow(3,p+1)*t);\n                t*=-1;\n                x=pow(3,p+1)-x;\n            }\n            else\n            {\n                nums.push_back(pow(3,p)*t);\n                x-=pow(3,p);\n            }\n        }\n        if(x)nums.push_back(x*t);\n    }\n    int main()\n    {\n        // 1+3+...+3^n=(3^(n+1)-1)/2\n        cin>>n;\n        get_val(n);\n        bool flag=true;\n        for(int &x:nums)\n        {\n            if(flag)\n            {\n                cout<<x;\n                flag=false;\n            }\n            else\n            {\n                if(x>0)cout<<\"+\";\n                cout<<x;\n            }\n        }\n        return 0;\n    }\n    \n\n**Java**\n\n    \n    \n    import java.util.*;\n    \n    public class Main {\n        static int n;\n        static List<Integer> nums = new ArrayList<>();\n    \n        static long pow(int a, int b) {\n            long res = 1, t = a;\n            while (b > 0) {\n                if ((b & 1) == 1) res *= t;\n                t *= t;\n                b >>= 1;\n            }\n            return res;\n        }\n    \n        static void get_val(int x) {\n            int t = 1;\n            while (x > 1) {\n                int p = (int) (Math.log(x) / Math.log(3));\n                if ((pow(3, p + 1) - 1) / 2 < x) {\n                    nums.add((int) pow(3, p + 1) * t);\n                    t *= -1;\n                    x = (int) pow(3, p + 1) - x;\n                } else {\n                    nums.add((int) pow(3, p) * t);\n                    x -= pow(3, p);\n                }\n            }\n            if (x != 0) nums.add(x * t);\n        }\n    \n        public static void main(String[] args) {\n            Scanner sc = new Scanner(System.in);\n            n = sc.nextInt();\n            get_val(n);\n            boolean flag = true;\n            for (int x : nums) {\n                if (flag) {\n                    System.out.print(x);\n                    flag = false;\n                } else {\n                    if (x > 0) System.out.print(\"+\");\n                    System.out.print(x);\n                }\n            }\n        }\n    }\n    \n\n**Python3**\n\n    \n    \n    import math\n    \n    def pow(a, b):\n        res, t = 1, a\n        while b:\n            if b & 1:\n                res *= t\n            t *= t\n            b >>= 1\n        return res\n    \n    def get_val(x):\n        t = 1\n        nums = []\n        while x > 1:\n            p = int(math.log(x) / math.log(3))\n            if (pow(3, p + 1) - 1) / 2 < x:\n                nums.append(pow(3, p + 1) * t)\n                t *= -1\n                x = pow(3, p + 1) - x\n            else:\n                nums.append(pow(3, p) * t)\n                x -= pow(3, p)\n        if x:\n            nums.append(x * t)\n        return nums\n    \n    n = int(input())\n    nums = get_val(n)\n    flag = True\n    for x in nums:\n        if flag:\n            print(x, end='')\n            flag = False\n        else:\n            if x > 0:\n                print('+', end='')\n            print(x, end='')\n    \n\n### T2 a的组合方式\n\n**题目描述**\n\n在音乐创作过程中，有一种常见的技巧叫做“和声”。和声是指通过组合多个音符的声音来产生更加丰富的音乐效果。在和声中，相邻的音符通常被组合成和弦，而和弦的构成方式与音符的间隔密切相关。\n\n假设在一首音乐作品中，有一段旋律由\n![](https://www.nowcoder.com/equation?tex=n&preview=true)个音符组成，每个音符的音高由一个**正整数表示**\n。作曲家希望为这段旋律添加一些和声，以产生更加丰富的音乐效果。为了实现这个目标，他们想要找到一组和弦，使得这组和弦的构成方式与旋律的音符间隔完全匹配。\n\n为了帮助作曲家实现这个目标，你需要编写一个程序来计算出可能的音符数组\n![](https://www.nowcoder.com/equation?tex=a&preview=true)的组合方式数目。给定一个长度为![](https://www.nowcoder.com/equation?tex=n-1&preview=true)的和弦数组\n![](https://www.nowcoder.com/equation?tex=b&preview=true)，你的任务是**计算出可能的音符数组![](https://www.nowcoder.com/equation?tex=a&preview=true)\n的组合方式数目**。其中，和弦数组 ![](https://www.nowcoder.com/equation?tex=b&preview=true)\n中的每个元素\n![](https://www.nowcoder.com/equation?tex=b%5Bi%5D%3Da%5Bi%5D%2Ba%5Bi%2B1%5D&preview=true)\n\n作曲家们知道，在音乐中，和弦的构成方式是非常丰富多样的。因此，他们希望通过这个程序来快速地计算出所有可能的音符数组\n![](https://www.nowcoder.com/equation?tex=a&preview=true) 的组合方式数目，以便在创作过程中进行参考\n\n**输入描述**\n\n> 第一行输出为一个整数\n> ![](https://www.nowcoder.com/equation?tex=n\\(1%5Cle%20n%20%5Cle%2010%5E5\\)&preview=true)。\n>\n> 第二行输出为 ![](https://www.nowcoder.com/equation?tex=n-1&preview=true)个整数，第\n> ![](https://www.nowcoder.com/equation?tex=i&preview=true)个整数为![](https://www.nowcoder.com/equation?tex=b_i\\(1%5Cle%20b_i%5Cle%2010%5E9\\)&preview=true)\n\n**输出描述**\n\n> 输出为一个整数，表示数组![](https://www.nowcoder.com/equation?tex=a&preview=true)有多少种可能\n\n**样例**\n\n**输入**\n\n    \n    \n    3\n    2 2\n    \n\n**输出**\n\n    \n    \n    0\n    \n\n**样例说明**\n\n> a,b之间的关系，且a必须为正整数\n\n**题解：思维题**\n\n![](https://www.nowcoder.com/equation?tex=b_1%3Da_1%2Ba_2&preview=true)\n\n![](https://www.nowcoder.com/equation?tex=b_2%3Da_2%2Ba_3&preview=true)\n\n![](https://www.nowcoder.com/equation?tex=b_3%3Da_3%2Ba_4&preview=true)\n\n...\n\n可以得到：\n\n![](https://www.nowcoder.com/equation?tex=a_2%3Db_1-a_1&preview=true)\n\n![](https://www.nowcoder.com/equation?tex=a_3%3Db_2-b_1%2Ba_1&preview=true)\n\n...\n\n已知所有的![](https://www.nowcoder.com/equation?tex=b_i&preview=true)，因此所有![](https://www.nowcoder.com/equation?tex=a_i&preview=true)的可能其实就是取决于![](https://www.nowcoder.com/equation?tex=a_1&preview=true)可以取的值的个数\n\n根据所有的![](https://www.nowcoder.com/equation?tex=a_i%3E0&preview=true)可以不断地去计算![](https://www.nowcoder.com/equation?tex=a_1&preview=true)取值的上界和下界，然后一边读取![](https://www.nowcoder.com/equation?tex=b_i&preview=true)，一边更新上下界即可\n\n**复杂度分析**\n\n> 时间复杂度：![](https://www.nowcoder.com/equation?tex=O\\(n\\)&preview=true)\n>\n> 空间复杂度：![](https://www.nowcoder.com/equation?tex=O\\(n\\)&preview=true)\n\n**C++**\n\n    \n    \n    #include <algorithm>\n    #include <climits>\n    #include <iostream>\n    \n    using namespace std;\n    \n    int main()\n    {\n        int n = 0;\n        cin >> n;\n        long long upper = LONG_MAX, lower = 0;\n        long long bSum = 0;\n        for (int i = 1; i < n; ++i)\n        {\n            int bi = 0;\n            cin >> bi;\n            if (i & 1)\n            {\n                bSum += bi;\n                upper = min(upper, bSum);\n            }\n            else\n            {\n                bSum -= bi;\n                lower = max(lower, bSum);\n            }\n        }\n        // 如果lower >= upper - 1, 输出0.\n        long long answer = max(0ll, upper - lower - 1);\n        cout << answer << endl;\n        return 0;\n    }\n    \n    \n\n**Java**\n\n    \n    \n    import java.util.Scanner;\n    \n    public class Main {\n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            int n = scanner.nextInt();\n            long upper = Long.MAX_VALUE, lower = 0;\n            long bSum = 0;\n            for (int i = 1; i < n; ++i) {\n                int bi = scanner.nextInt();\n                if ((i & 1) == 1) {\n                    bSum += bi;\n                    upper = Math.min(upper, bSum);\n                } else {\n                    bSum -= bi;\n                    lower = Math.max(lower, bSum);\n                }\n            }\n            // 如果lower >= upper - 1, 输出0.\n            long answer = Math.max(0, upper - lower - 1);\n            System.out.println(answer);\n        }\n    }\n    \n\n**Python**\n\n    \n    \n    n = int(input())\n    upper = float('inf')\n    lower = 0\n    bSum = 0\n    for i in range(1, n):\n        bi = int(input())\n        if i % 2 == 1:\n            bSum += bi\n            upper = min(upper, bSum)\n        else:\n            bSum -= bi\n            lower = max(lower, bSum)\n    # 如果lower >= upper - 1, 输出0.\n    answer = max(0, upper - lower - 1)\n    print(answer)\n    \n\n### T3 奇妙糖果\n\n**题目内容**\n\n在一个神奇的糖果工厂中，有一种特殊的糖果叫做“奇妙糖果”。这种糖果非常受欢迎，因为它的口感和味道都非常好。\n\n奇妙糖果的制作非常复杂，制造过程中要求每种原料的出现次数必须是![](https://www.nowcoder.com/equation?tex=k&preview=true)的倍数，其中\n![](https://www.nowcoder.com/equation?tex=k&preview=true) 是一个给定的正整数。\n\n在制造奇妙糖果的过程中，制造商们发现，他们可以通过选择不同的原料配方来制造出不同的口感和味道的糖果。他们想要快速计算出可以制造的所有糖果的数量，以便在生产计划中进行参考。\n\n为了实现这个目标，他们需要编写一个程序来计算出可以制造的所有奇妙糖果的数量。\n\n给定 ![](https://www.nowcoder.com/equation?tex=n&preview=true) 个原料和正整数\n![](https://www.nowcoder.com/equation?tex=k&preview=true)，以及每个原料的种类![](https://www.nowcoder.com/equation?tex=a_i&preview=true)\n，你的任务是计算出可以制造的所有的奇妙糖果的数量。\n\n注意，这里的“奇妙糖果”是指**使用![](https://www.nowcoder.com/equation?tex=n&preview=true)\n个原料的任意非空子序列制造出的糖果，其中每种原料的出现次数都是\n![](https://www.nowcoder.com/equation?tex=k&preview=true)的倍数**。\n\n子序列定义是数组中选择若干个元素按照原顺序组成的新数组。\n\n**输入描述**\n\n> 第一行输出为两个整数\n> ![](https://www.nowcoder.com/equation?tex=n\\(1%5Cle%20n%5Cle%2050\\)&preview=true)和![](https://www.nowcoder.com/equation?tex=k\\(1%5Cle%20k%20%5Cle%2050\\)&preview=true)\n> ，表示原料的个数。\n>\n> 第二行输出为![](https://www.nowcoder.com/equation?tex=n&preview=true)个整数，第\n> ![](https://www.nowcoder.com/equation?tex=i&preview=true) 个整数为\n> ![](https://www.nowcoder.com/equation?tex=a_i\\(1%5Cle%20a_i%5Cle%2050\\)&preview=true)，表示该原料的种类的编号\n\n**输出描述**\n\n> 输出为一个整数，表示有多少使用\n> ![](https://www.nowcoder.com/equation?tex=n&preview=true)个原料的任意非空子序列制造出的糖果，其中每种原料的出现次数都是![](https://www.nowcoder.com/equation?tex=k&preview=true)的倍数。\n\n**样例**\n\n**输入**\n\n    \n    \n    4 2\n    1 2 1 2\n    \n\n**输出**\n\n    \n    \n    3\n    \n\n**说明** 三种方案分别为：{1,1}, {2,2}, {1,2,1,2}\n\n**题解：组合数学计数**\n\n每个糖果的数量必须是![](https://www.nowcoder.com/equation?tex=k&preview=true)的倍数 即为\n![](https://www.nowcoder.com/equation?tex=0%2Ck%2C2k%20...%20nk&preview=true)\n\n因此考虑**枚举每种糖果的方案数** 然后基于**乘法原理** 累乘即可\n\n对于第![](https://www.nowcoder.com/equation?tex=i&preview=true)种糖果![](https://www.nowcoder.com/equation?tex=a_i&preview=true)\n对应的答案应该是![](https://www.nowcoder.com/equation?tex=C\\(a_i%2C0\\)%2BC\\(a_i%2Ck\\)%2BC\\(a_i%2C2k\\)%2B...&preview=true)\n\n注意 **最终答案需要-1(因为不能一个糖果都不选)**\n\n因为本题数据量不大，可以直接**预处理组合数计算即可**\n（如果本题数据范围为![](https://www.nowcoder.com/equation?tex=10%5E5&preview=true)，对于C++和Java选手则需要使用乘法逆元处理）\n\n**复杂度分析**\n\n> 时间复杂度:![](https://www.nowcoder.com/equation?tex=O\\(n%5E2\\)&preview=true)\n>\n> 空间复杂度：![](https://www.nowcoder.com/equation?tex=O\\(n\\)&preview=true)\n\n**C++**\n\n    \n    \n    #include <bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    const int N=55;\n    ll n,w[N],f[N][N],k;\n    unordered_map<int,int>cnts;\n    void init()  \n    {\n        for(int i=0;i<N;i++)\n        {\n            for(int j=0;j<=i;j++)\n            {\n                if(!j)f[i][j]=1;\n                else f[i][j]=(f[i-1][j]+f[i-1][j-1]);\n            }\n            \n        }\n    }\n    int main()\n    {\n        cin>>n>>k;\n        init();\n        for(int i=0;i<n;i++)\n        {\n            int x;\n            cin>>x;\n            cnts[x]++;\n        }\n        ll res=1;\n        for(auto &[u,v]:cnts)\n        {\n            if(v<k)continue;\n            ll s=0;\n            for(int i=0;i<=v;i+=k)s+=f[v][i];\n            res*=s;\n        }\n        res--;  //去掉空集\n        cout<<res<<endl;\n        return 0;\n    }\n    \n    \n\n**Java**\n\n    \n    \n    import java.util.*;\n    \n    public class Main {\n        static final int N = 55;\n        static long[][] f = new long[N][N];\n        static Map<Integer, Integer> cnts = new HashMap<>();\n    \n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            int n = scanner.nextInt();\n            int k = scanner.nextInt();\n            init();\n            for (int i = 0; i < n; i++) {\n                int x = scanner.nextInt();\n                cnts.put(x, cnts.getOrDefault(x, 0) + 1);\n            }\n            long res = 1;\n            for (Map.Entry<Integer, Integer> entry : cnts.entrySet()) {\n                int v = entry.getValue();\n                if (v < k) continue;\n                long s = 0;\n                for (int i = 0; i <= v; i += k) {\n                    s += f[v][i];\n                }\n                res *= s;\n            }\n            res--;  // Remove the empty set\n            System.out.println(res);\n        }\n    \n        static void init() {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j <= i; j++) {\n                    if (j == 0) {\n                        f[i][j] = 1;\n                    } else {\n                        f[i][j] = f[i - 1][j] + f[i - 1][j - 1];\n                    }\n                }\n            }\n        }\n    }\n    \n\n**Python**\n\n    \n    \n    from collections import defaultdict\n    import math\n    n , k = list(map(int , input().split()))\n    a = list(map(int , input().split()))\n    cnt = defaultdict(int)\n    for x in a:\n    \tcnt[x] += 1\n    ans = 1\n    # 枚举 每个数\n    for x in cnt.keys():\n    \tt = 0\n        # 枚举次数\n    \tfor y in range(0 , cnt[x] + 1 , k):\n            # 求组合数\n    \t\tt += math.comb(cnt[x] , y)\n    \tans *= t\n    \n    if ans == 0:\n    \tprint(ans)\n    else:\n    \tprint(ans - 1)\n    \n    \n\n以上内容均来自[笔试刷题指南](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxuq7bkgch1.feishu.cn%2Fdocx%2FBodwdmrbnojrdlxDmYLc6vzsnxe)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/571444080782184448?sourceSSR=users",
        "title": "24秋招(2023.9.24)米哈游笔试真题解析",
        "content": "整体的难度不是特别大，T1是一个签到题，直接枚举即可，T2是经典概率DP问题，T3又是一个数学题，考虑贡献法来统计权值，计算每个元素对结果产生的贡献\n\n### T1\n\n**题目描述**\n\n对于一个数组![](https://www.nowcoder.com/equation?tex=c&preview=true)，定义![](https://www.nowcoder.com/equation?tex=f\\(c\\)&preview=true)为![](https://www.nowcoder.com/equation?tex=c&preview=true)数组所有元素的总和。\n现在给定两个长度为![](https://www.nowcoder.com/equation?tex=n&preview=true)的数组![](https://www.nowcoder.com/equation?tex=a%2Cb&preview=true)，请你恰好删除一个数组![](https://www.nowcoder.com/equation?tex=a&preview=true)的元素或者一个数组![](https://www.nowcoder.com/equation?tex=b&preview=true)的元素，使得![](https://www.nowcoder.com/equation?tex=f\\(a\\)&preview=true)异或![](https://www.nowcoder.com/equation?tex=f\\(b\\)&preview=true)最大\n\n**输入格式**\n\n> 第一行输入一个整数![](https://www.nowcoder.com/equation?tex=n&preview=true)\n>\n>\n> 第二行输入![](https://www.nowcoder.com/equation?tex=n&preview=true)个整数![](https://www.nowcoder.com/equation?tex=a_i&preview=true)\n>\n>\n> 第三行输入![](https://www.nowcoder.com/equation?tex=n&preview=true)个整数![](https://www.nowcoder.com/equation?tex=b_i&preview=true)\n>\n>\n> ![](https://www.nowcoder.com/equation?tex=1%5Cle%20n%2Ca_i%2Cb_i%20%5Cle%2010%5E5&preview=true)\n\n**输出描述**\n\n> 输出最大的异或和。\n\n**样例**\n\n**输入**\n\n    \n    \n    3\n    1 2 3\n    3 2 1\n    \n\n**输出**\n\n    \n    \n    5\n    \n\n**说明**\n\n> 数组a数组中的3\n\n**题解**\n：签到题，枚举删除![](https://www.nowcoder.com/equation?tex=a&preview=true)数组或![](https://www.nowcoder.com/equation?tex=b&preview=true)数组中的某一个数即可\n\n**C++**\n\n    \n    \n    #include <bits/stdc++.h>\n    using namespace std;\n    const int N = 5E5 + 10,mod=1e9+7;\n    typedef long long ll;\n    ll n,a[N],b[N];\n    int main() {\n        cin>>n;\n        ll s1=0,s2=0;\n        for(int i=0;i<n;i++){\n            cin>>a[i];\n            s1+=a[i];\n        }\n        for(int i=0;i<n;i++){\n            cin>>b[i];\n            s2+=b[i];\n        }\n        ll res=0;\n        for(int i=0;i<n;i++){\n            res=max({res,s1^(s2-b[i]),(s1-a[i])^s2});\n        }\n        cout<<res<<endl;\n        return 0;\n    }\n    \n\n**Python**\n\n    \n    \n    N = 500010\n    mod = int(1e9) + 7\n    a = [0] * N\n    b = [0] * N\n    \n    n = int(input())\n    s1 = s2 = 0\n    a=list(map(int,input().split()))\n    b=list(map(int,input().split()))\n    for i in range(n):\n        s1+=a[i]\n        s2+=b[i]\n    res = 0\n    for i in range(n):\n        res = max(res, max(s1 ^ (s2 - b[i]), (s1 - a[i]) ^ s2))\n    print(res)\n    \n\n### T2\n\n**题目描述**\n\n米小游都快保底了还没抽到希儿，好生气哦!只能打会活动再拿点水晶了。\n米小游和世界第一可爱的魔法少女![](https://www.nowcoder.com/equation?tex=TeRiRi&preview=true)正在打BOSS，BOSS当BOSS血量小于等于0时，BOSS死亡。![](https://www.nowcoder.com/equation?tex=TeRiRi&preview=true)的血量为![](https://www.nowcoder.com/equation?tex=h&preview=true)，有一套牌，在一轮中，她会按顺序一张一张的将卡牌打出，套牌中有两种卡牌:\n\n1.时来运转，获得![](https://www.nowcoder.com/equation?tex=x&preview=true)个幸运币\n\n2.**幸运一掷**\n造成![](https://www.nowcoder.com/equation?tex=x&preview=true)点伤害，并投掷所有幸运币，造成等于所有幸运币掷出的点数之和的伤害\n\n幸运币可以等概率的投掷出1~6之间的点数。米小游想知道，![](https://www.nowcoder.com/equation?tex=TeRiRi&preview=true)的套牌在一轮内击杀BOSS的概率\n\n**输入格式**\n\n>\n> 第一行输入两个整数![](https://www.nowcoder.com/equation?tex=n\\(1%3Cn%3C100\\)%2Ch\\(1%3C%3C10%5E9\\)&preview=true)，分别表示卡牌张数和BOSS血量。\n> 接下来![](https://www.nowcoder.com/equation?tex=n&preview=true)行每行首先输入两个整数![](https://www.nowcoder.com/equation?tex=t\\(1%5Cle%20t%5Cle%202\\)%2Cx\\(1%5Cle%20x%5Cle%2010\\)&preview=true)，![](https://www.nowcoder.com/equation?tex=t&preview=true)为1表示卡牌为时来运转，![](https://www.nowcoder.com/equation?tex=t&preview=true)为2表示卡牌为幸运一掷。\n\n**输出格式**\n\n>\n> 输出一个实数表示答案，你的答案与标准答案的误差不超过![](https://www.nowcoder.com/equation?tex=10%5E%7B-4%7D&preview=true)都被认为时正确答案。\n\n**样例**\n\n**输入**\n\n    \n    \n    2 5\n    1 1\n    2 1\n    \n\n**输出**\n\n    \n    \n    0.5\n    \n\n**说明**\n\n> 幸运币掷出4及以上的概率为0.5，再加上1点固定伤害，即可击杀BOSS。\n\n**题解：期望DP**\n\n这里有一个细节就是，**需要使用第二种卡牌的时候，收集到的硬币才会被打出**\n，因此需要记录打出的硬币数，然后并把怪物的血量扣除固定值![](https://www.nowcoder.com/equation?tex=x&preview=true)的伤害\n\n定义![](https://www.nowcoder.com/equation?tex=f%5Bi%5D%5Bj%5D&preview=true)为投掷前![](https://www.nowcoder.com/equation?tex=i&preview=true)次\n点数总和为![](https://www.nowcoder.com/equation?tex=j&preview=true)的概率\n\n最终首先判断投掷的次数![](https://www.nowcoder.com/equation?tex=num*6&preview=true)是否小于![](https://www.nowcoder.com/equation?tex=h&preview=true)\n\n不小于的话，就把**对应的概率之和累加**\n\n![](https://www.nowcoder.com/equation?tex=f%5Bi%5D%5Bj%5D%3D%5Csum_%7Bk%20%3D%20j-6%7D%5E%7Bk%20%3D%20j-1%7D%20f%5Bi-1%5D%5Bk%5D&preview=true)\n\n**C++**\n\n    \n    \n    #include <bits/stdc++.h>\n    using namespace std;\n    typedef long long ll;\n    const int N=1010,M=6010;\n    int n,t,h,x;\n    double f[N][M];  //投掷前i次 点数总和为j的概率\n    int main() {\n        int cnt=0,num=0;  //硬币数量\n        cin>>n>>h;\n        for(int i=0;i<n;i++){\n            cin>>t>>x;\n            if(t==1){\n                cnt+=x;\n            }\n            else{\n                h-=x;\n                num+=cnt;\n                cnt=0;\n            }\n        }\n        f[0][0]=1.0;\n        for(int i=1;i<=num;i++){\n            for(int j=i;j<=num*6;j++){\n                for(int k=1;k<=6;k++){\n                    if(j>=k){\n                        f[i][j]+=f[i-1][j-k]*1.0/6;\n                    }\n                }\n            }\n        }\n        double res=0.0;\n        if(h<=num*6){\n            for(int i=h;i<=num*6;i++){\n                res+=f[num][i];\n            }\n        }\n        cout<<res<<endl;\n        return 0;\n    }\n    \n\n**Java**\n\n    \n    \n    import java.util.*;\n    \n    public class Main {\n        static final int N = 1010;\n        static final int M = 6010;\n        static int n, t, h, x;\n        static double[][] f = new double[N][M];  // 投掷前 i 次，点数总和为 j 的概率\n    \n        public static void main(String[] args) {\n            Scanner sc = new Scanner(System.in);\n            int cnt = 0, num = 0;  // 硬币数量\n            n = sc.nextInt();\n            h = sc.nextInt();\n            for (int i = 0; i < n; i++) {\n                t = sc.nextInt();\n                x = sc.nextInt();\n                if (t == 1) {\n                    cnt += x;\n                } else {\n                    h -= x;\n                    num += cnt;\n                    cnt = 0;\n                }\n            }\n            f[0][0] = 1.0;\n            for (int i = 1; i <= num; i++) {\n                for (int j = i; j <= num * 6; j++) {\n                    for (int k = 1; k <= 6; k++) {\n                        if (j >= k) {\n                            f[i][j] += f[i - 1][j - k] * 1.0 / 6;\n                        }\n                    }\n                }\n            }\n            double res = 0.0;\n            if (h <= num * 6) {\n                for (int i = h; i <= num * 6; i++) {\n                    res += f[num][i];\n                }\n            }\n            System.out.printf(\"%.4f\\n\", res);\n        }\n    }\n    \n\n**Python**\n\n    \n    \n    N = 1010\n    M = 6010\n    f = [[0.0 for _ in range(M)] for _ in range(N)]  # 投掷前 i 次，点数总和为 j 的概率\n    \n    n, h = map(int, input().split())\n    cnt = num = 0  # 硬币数量\n    for _ in range(n):\n        t, x = map(int, input().split())\n        if t == 1:\n            cnt += x\n        else:\n            h -= x\n            num += cnt\n            cnt = 0\n    f[0][0] = 1.0\n    for i in range(1, num + 1):\n        for j in range(i, num * 6 + 1):\n            for k in range(1, 7):\n                if j >= k:\n                    f[i][j] += f[i - 1][j - k] * 1.0 / 6\n    res = 0.0\n    if h <= num * 6:\n        for i in range(h, num * 6 + 1):\n            res += f[num][i]\n    print(\"%.4f\" % res)\n    \n\n### T3\n\n**题目描述**\n\n米小游拿到了一个数组![](https://www.nowcoder.com/equation?tex=a&preview=true)，她用这个数组构造一个新数组![](https://www.nowcoder.com/equation?tex=b&preview=true)，其中![](https://www.nowcoder.com/equation?tex=a_i&preview=true)代表![](https://www.nowcoder.com/equation?tex=b&preview=true)数组中有![](https://www.nowcoder.com/equation?tex=a_i&preview=true)个![](https://www.nowcoder.com/equation?tex=i&preview=true)。例如，若![](https://www.nowcoder.com/equation?tex=a%3D%5B2%2C3%2C1%5D&preview=true)，那么![](https://www.nowcoder.com/equation?tex=b%3D%5B1%2C1%2C2%2C2%2C2%2C3%5D&preview=true)，因为a1\n=\n2，代表![](https://www.nowcoder.com/equation?tex=b&preview=true)数组中有2个1;![](https://www.nowcoder.com/equation?tex=a_2%3D3&preview=true)，代表![](https://www.nowcoder.com/equation?tex=b&preview=true)数组中有3个2，![](https://www.nowcoder.com/equation?tex=a_3%3D1&preview=true)，代表![](https://www.nowcoder.com/equation?tex=b&preview=true)数组中有1个3。\n现在给定![](https://www.nowcoder.com/equation?tex=a&preview=true)数组，你需要帮米哈游求出![](https://www.nowcoder.com/equation?tex=b&preview=true)数组中所有连续子数组的极差之和。由于答案可能过大，请对![](https://www.nowcoder.com/equation?tex=10%5E9%2B7&preview=true)取模。数组的极差指最大值减去最小值。\n\n**输入格式**\n\n>\n> 第一行输入一个正整数![](https://www.nowcoder.com/equation?tex=n&preview=true)，代表![](https://www.nowcoder.com/equation?tex=a&preview=true)数组的元素数量\n>\n>\n> 第二行输入![](https://www.nowcoder.com/equation?tex=n&preview=true)个正整数![](https://www.nowcoder.com/equation?tex=a_i&preview=true)，代表![](https://www.nowcoder.com/equation?tex=a&preview=true)数组的元素。\n>\n>\n> ![](https://www.nowcoder.com/equation?tex=1%5Cle%20n%5Cle%2010%5E5&preview=true)\n>\n>\n> ![](https://www.nowcoder.com/equation?tex=1%20%5Cle%20a_i%5Cle%2010%5E9&preview=true)\n\n**输出格式**\n\n>\n> 一个整数，代表数组中所有区间的极差之和，对![](https://www.nowcoder.com/equation?tex=10%5E9%2B7&preview=true)取模的值。\n\n**样例**\n\n**输入**\n\n    \n    \n    2\n    2 1\n    \n\n**输出**\n\n    \n    \n    2\n    \n\n**说明**\n\n> a=[2,1]时，b数组为[1,1,2]。\n>\n> 此时b数组共有6个连续子数组:\n>\n> [1]的极差为0\n>\n> [1]的极差为0\n>\n> [2]的极差为0\n>\n> [1,1]的极差为0\n>\n> [1,2]的极差为1\n>\n> [1,1,2]的极差为1\n>\n> 因此答案是0+0+0+0+1+1=2\n\n**题解** ：**贡献法计数+前缀和**\n\n考虑第![](https://www.nowcoder.com/equation?tex=i&preview=true)个元素对结果的贡献，选择第![](https://www.nowcoder.com/equation?tex=i&preview=true)个元素对结果的贡献\n![](https://www.nowcoder.com/equation?tex=b%5Bi%5D*\\(b%5Bi%2B1%5D*1%2Bb%5Bi%2B2%5D*2%2B...%2Bb%5Bk%5D*\\(k-i\\)\\)&preview=true)\n\n如果是选择第![](https://www.nowcoder.com/equation?tex=i%2B1&preview=true)个元素，对结果的贡献为![](https://www.nowcoder.com/equation?tex=b%5Bi%2B1%5D*\\(b%5Bi%2B2%5D*1%2Bb%5Bi%2B3%5D*2%2B...%2Bb%5Bk%5D*\\(k-i-1\\)\\)&preview=true)\n\n右边的差值其实就是![](https://www.nowcoder.com/equation?tex=b%5Bi%2B1%5D%2Bb%5Bi%2B2%5D%2B...%2Bb%5Bk%5D&preview=true)\n\n因此可以预处理一个**后缀和数组** 来去一遍遍历，一遍计算，当然，也可以不使用后缀和数组，维护两个变量即可，如下代码中的`sum`和`s`所示\n\n**C++**\n\n    \n    \n    #include <bits/stdc++.h>\n    using namespace std;\n    const int N = 5E5 + 10,mod=1e9+7;\n    typedef long long ll;\n    ll n,a[N];\n    int main() {\n        cin>>n;\n        for(int i=1;i<=n;i++)cin>>a[i];\n        ll res=0,sum=0,s=0;\n        for(int i=2;i<=n;i++){\n            sum+=1ll*a[i]*(i-1);\n            s+=a[i];\n        }\n        for(int i=1;i<n;i++){  //考虑选择a[i]对结果的贡献 a[i]*(a[i+1]*1+a[i+2]*2+...+a[k]*(k-i)\n            ll cur=1ll*a[i]*sum;\n            res=(res+cur)%mod;\n            sum-=s;\n            s-=a[i+1];\n        }\n        cout<<res<<endl;\n        return 0;\n    }\n    \n\n**Java**\n\n    \n    \n    import java.util.Arrays;\n    import java.util.Scanner;\n    \n    public class Main {\n        public static void main(String[] argv) {\n            Scanner in = new Scanner(System.in);\n            int n = in.nextInt();\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = in.nextInt();\n            }\n            final int mod = 1000000007;\n            long[] preSum = new long[n];\n            for (int i = 0; i < n; i++) {\n                preSum[i] = i == 0 ? arr[0] : preSum[i-1]+arr[i];\n            }\n            long sum = 0;\n            for (int i = n-1; i >= 0; i--) {\n                sum += 1l * arr[i] * i;\n                sum %= mod;\n            }\n            long res = 0;\n            for (int i = 0; i < n; i++) {\n                res += 1l * arr[i] * sum;\n                res %= mod;\n                sum -= preSum[n-1] - preSum[i];\n                sum = (sum + mod) % mod;\n            }\n            System.out.println(res);\n    \n        }\n    \n    }\n    \n\n**Python**\n\n    \n    \n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    mod = 1000000007\n    preSum = [0] * n\n    for i in range(n):\n        preSum[i] = arr[i] if i == 0 else preSum[i-1] + arr[i]\n    \n    sum_val = 0\n    for i in range(n-1, -1, -1):\n        sum_val += 1 * arr[i] * i\n        sum_val %= mod\n    \n    res = 0\n    for i in range(n):\n        res += 1 * arr[i] * sum_val\n        res %= mod\n        sum_val -= preSum[n-1] - preSum[i]\n        sum_val = (sum_val + mod) % mod\n    \n    print(res)\n    \n\n以上内容均来自[笔试刷题指南](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxuq7bkgch1.feishu.cn%2Fdocx%2FBodwdmrbnojrdlxDmYLc6vzsnxe)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/571166679107960832?sourceSSR=users",
        "title": "12.29 Cider一面 Java后端实习生",
        "content": "# 12.29 Cider一面 Java后端实习生\n\n自我介绍\n\n## 项目\n\n介绍自己熟悉的一段业务经历，主要负责什么，又达成了什么效果\n\n你业务中的数据主要是干什么的？\n\n## 技术\n\n### Java\n\n说说Java语言的优势与劣势\n\n说说Java中的垃圾回收，具体是怎么做的？\n\nJava中的垃圾回收的第一步是要做什么？\n\nJava中的垃圾回收是怎么识别哪些对象是垃圾的？\n\nJava中的垃圾回收是怎么找到哪些对象是被引用的？\n\n分代回收为什么要对对象进行分代而不是全部一起回收？\n\n介绍常用的垃圾回收器\n\n介绍Java8默认使用的垃圾回收器\n\n介绍java中的四种引用类型\n\n介绍Java中的线程池\n\n介绍Java中线程池的参数的作用，它们什么时候会生效又有什么作用\n\n### 计算机网络\n\n使用浏览器访问一个URL会经历什么哪些过程？\n\n介绍DNS服务器\n\n介绍http和https协议的区别\n\n非对称加密是用来做什么？对称加密又是用来做什么的？\n\n对称加密和非对称加密谁传输效率比较快？\n\n### 数据库\n\n介绍MySQL8的新特性\n\nMySQL的索引有几种类型？\n\nMySQL中的默认索引是什么？\n\nMySQL中有哪些锁？\n\nMysql中什么时候使用表锁，什么时候使用行锁？\n\n分库分表能加快你查询数据的速度吗？\n\n### 框架\n\nSpring有什么好处？\n\n依赖注入的最大作用是什么？\n\n依赖注入是怎么实现的？\n\n## 场景\n\n假如你数据库中有100万条短信要如何做才能令其尽快地取出来并发送给用户？\n\n## 算法\n\n判断回文链表\n\n## 向面试官提问\n\n# 总结\n\n我前面发挥不错，但是后面有关于MySQL和场景题的发挥比较糟糕，但是总体来说自我感觉还算良好。面试官人很好，面试过程很愉快甚至还有说有笑\n\n最后许愿能过一面\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/571442775107895296?sourceSSR=users",
        "title": "24秋招(2023.8.13)米哈游笔试真题解析",
        "content": "### 1.棋盘\n\n**题目内容**\n\n塔子哥有一个`n*m`的棋盘，一次移动可以选择上下左右四个方向移动一次，不同于普通棋盘，这个棋盘是循环的。\n\n即 ![](https://www.nowcoder.com/equation?tex=\\(x%2Cm\\)&preview=true) 和\n![](https://www.nowcoder.com/equation?tex=\\(x%2C1\\)&preview=true)\n两个点可以一步到达，其中![](https://www.nowcoder.com/equation?tex=1%5Cle%20x%20%5Cle%20n&preview=true)。同样的，\n![](https://www.nowcoder.com/equation?tex=\\(n%2Cy\\)&preview=true)和\n![](https://www.nowcoder.com/equation?tex=\\(1%2Cy\\)&preview=true)\n两个点也可以一步到达，其中\n![](https://www.nowcoder.com/equation?tex=1%5Cle%20y%20%5Cle%20m&preview=true)。\n\n现在塔子哥需要从 A先走到 B 点，再从 B 点走到 C点，问最小移动次数是多少。\n\n**输入描述**\n\n> 第一行两个整数，![](https://www.nowcoder.com/equation?tex=n&preview=true)和\n> ![](https://www.nowcoder.com/equation?tex=m&preview=true)。\n>\n> 接下来三行，第一行是点 A\n> 的坐标![](https://www.nowcoder.com/equation?tex=\\(x_A%2Cy_A\\)&preview=true)，第二行是点B\n> 的坐标![](https://www.nowcoder.com/equation?tex=\\(x_B%2Cy_B\\)&preview=true)\n> ，第三行是点 C\n> 的坐标![](https://www.nowcoder.com/equation?tex=\\(x_C%2Cy_C\\)&preview=true)\n>\n>\n> ![](https://www.nowcoder.com/equation?tex=1%5Cle%20n%2Cm%20%5Cle%2010%5E9%2C1%5Cle%20x_A%2Cx_B%2Cx_C%5Cle%20n%2C1%5Cle%20y_A%2Cy_B%2Cy_C%5Cle%20m&preview=true)\n\n**输出描述**\n\n输出从 A 到 B ，再从 B到 C 的最小移动次数\n\n**样例**\n\n**输入**\n\n    \n    \n    4 4\n    1 2\n    1 3\n    1 4\n    \n\n**输出**\n\n    \n    \n    2\n    \n\n**题解：模拟**\n\n考虑任意点![](https://www.nowcoder.com/equation?tex=\\(a%2Cb\\)&preview=true)到![](https://www.nowcoder.com/equation?tex=\\(c%2Cd\\)&preview=true)的**最小移动距离**\n\n首先，我们可以考虑从![](https://www.nowcoder.com/equation?tex=a&preview=true)到![](https://www.nowcoder.com/equation?tex=c&preview=true)的移动距离\n\n  * **方式1** ：直接到达：![](https://www.nowcoder.com/equation?tex=dist%3Dabs\\(a-c\\)&preview=true)\n  * **方式2** ：先走到![](https://www.nowcoder.com/equation?tex=n&preview=true)，再由![](https://www.nowcoder.com/equation?tex=n&preview=true)走到1，再由1走到![](https://www.nowcoder.com/equation?tex=c&preview=true)，![](https://www.nowcoder.com/equation?tex=dist%3Dn-abs\\(a-c\\)&preview=true)\n\n两种方式的移动取最小值，![](https://www.nowcoder.com/equation?tex=dist%3Dmin\\(abs\\(a-c\\)%2Cn-\nabs\\(a-c\\)\\)&preview=true)\n\n因此![](https://www.nowcoder.com/equation?tex=\\(a%2Cb\\)&preview=true)到![](https://www.nowcoder.com/equation?tex=\\(c%2Cd\\)&preview=true)的**最小移动距离**![](https://www.nowcoder.com/equation?tex=dist%3Dmin\\(abs\\(a-c\\)%2Cn-\nabs\\(a-c\\)\\)%2Bmin\\(abs\\(b-d\\)%2Cm-abs\\(b-d\\)\\)&preview=true)\n\n按照上述公式模拟即可\n\n**复杂度分析**\n\n> 时间复杂度：`O(1)`\n>\n> 空间复杂度：`O(1)`\n\n**C++**\n\n    \n    \n    #include <bits/stdc++.h>\n    using namespace std;\n    \n    typedef pair<int, int> PII;\n    \n    int main()\n    {\n        int n, m;\n        cin >> n >> m;\n    \n        PII a, b, c;\n        cin >> a.first >> a.second;\n        cin >> b.first >> b.second;\n        cin >> c.first >> c.second;\n    \n        long long ans = 0;\n        // 从 a 到 b 的 x 轴\n        ans += min(abs(a.first - b.first), n - abs(a.first - b.first));\n        // 从 a 到 b 的 y 轴\n        ans += min(abs(a.second - b.second), m - abs(a.second - b.second));\n        // 从 b 到 c 的 x 轴\n        ans += min(abs(b.first - c.first), n - abs(b.first - c.first));\n        // 从 b 到 c 的 y 轴\n        ans += min(abs(b.second - c.second), m - abs(b.second - c.second));\n    \n        cout << ans << \"\\n\";\n        return 0;\n    }\n    \n    \n\n**Java**\n\n    \n    \n    import java.util.Scanner;\n    \n    public class Main {\n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            int n = scanner.nextInt();\n            int m = scanner.nextInt();\n    \n            int[][] points = new int[3][2];\n            for (int i = 0; i < 3; i++) {\n                points[i][0] = scanner.nextInt();\n                points[i][1] = scanner.nextInt();\n            }\n    \n            long ans = 0;\n            // 从 a 到 b 的 x 轴\n            ans += Math.min(Math.abs(points[0][0] - points[1][0]), n - Math.abs(points[0][0] - points[1][0]));\n            // 从 a 到 b 的 y 轴\n            ans += Math.min(Math.abs(points[0][1] - points[1][1]), m - Math.abs(points[0][1] - points[1][1]));\n            // 从 b 到 c 的 x 轴\n            ans += Math.min(Math.abs(points[1][0] - points[2][0]), n - Math.abs(points[1][0] - points[2][0]));\n            // 从 b 到 c 的 y 轴\n            ans += Math.min(Math.abs(points[1][1] - points[2][1]), m - Math.abs(points[1][1] - points[2][1]));\n    \n            System.out.println(ans);\n        }\n    }\n    \n    \n\n**Python**\n\n    \n    \n    n, m = map(int, input().split())\n    \n    points = []\n    for _ in range(3):\n        x, y = map(int, input().split())\n        points.append((x, y))\n    \n    ans = 0\n    # 从 a 到 b 的 x 轴\n    ans += min(abs(points[0][0] - points[1][0]), n - abs(points[0][0] - points[1][0]))\n    # 从 a 到 b 的 y 轴\n    ans += min(abs(points[0][1] - points[1][1]), m - abs(points[0][1] - points[1][1]))\n    # 从 b 到 c 的 x 轴\n    ans += min(abs(points[1][0] - points[2][0]), n - abs(points[1][0] - points[2][0]))\n    # 从 b 到 c 的 y 轴\n    ans += min(abs(points[1][1] - points[2][1]), m - abs(points[1][1] - points[2][1]))\n    \n    print(ans)\n    \n    \n\n### 2.有根树的节点个数\n\n**题目内容**\n\n塔子哥有一个 n 个节点的树，树根编号为 1 。\n\n塔子哥**可以在叶子节点上添加一个新的儿子节点** ，添加后，添加的节点变成了新的叶子节点。\n\n若干次操作后，塔子哥想问你**距离树根不超过k** 的节点最多可以有多少个。\n\n**输入描述**\n\n> 第一行，一个正整数n 表示树中节点个数，k 表示不超过树根的距离，\n>\n> 接下来 n-1行，每行输入两个整数 u和v ，表示节点u和v之间有一条边\n>\n>\n> ![](https://www.nowcoder.com/equation?tex=1%5Cle%20n%20%5Cle%2010%5E5%2C1%5Cle%20k%20%5Cle%2010%5E9%2C1%5Cle%20u%2Cv%20%5Cle%20n&preview=true)\n\n**输出描述**\n\n> 一个整数，表示若干次操作后距离树根不超过k的节点最大数量。\n\n**样例**\n\n**输入**\n\n    \n    \n    4 2\n    1 2\n    1 3\n    1 4\n    \n\n**输出**\n\n    \n    \n    7\n    \n\n**样例解释**\n\n    \n    \n    本身有4个节点到根节点的距离不超过k(1,2,3,4)\n    叶子节点是(2,3,4) 还可以再添加一个节点\n    因此总共的数量为4+3=7\n    \n\n**题解：DFS+贡献法计数**\n\n考虑每一个节点对答案的贡献：如果当前节点距离根节点的距离`d`有![](https://www.nowcoder.com/equation?tex=d%20%5Cle%20k&preview=true)，则答案+1\n\n**此外，如果当前节点还是叶子节点**\n，则说明还可以再叶子结点下添加![](https://www.nowcoder.com/equation?tex=k-d&preview=true)个点，这些点可以构成一条链。\n\n**根据上述方式统计计数即可** ，注意本题题目给的是无向边，需要建两条有向边。\n\n**复杂度分析**\n\n> 时间复杂度：`O(n)`\n>\n> 空间复杂度：`O(1)`\n\n**C++**\n\n    \n    \n    #include <bits/stdc++.h>\n    using namespace std;\n    int main()\n    {\n        int n, k;\n        cin >> n >> k;   \n        // 建图\n        vector<vector<int>> g(n);\n        for (int i = 1; i < n; ++i) {\n            int u, v;\n            cin >> u >> v;\n            u--; v--;\n            g[u].emplace_back(v);\n            g[v].emplace_back(u);\n        }\n        const int INF = 0x3f3f3f3f;\n        long long ans = 0;\n        vector<int> dist(n, INF);\n        // 计算1号点到每个点的距离，1号点到自己的距离为 0\n        dist[0] = 0;\n        function<void(int,int)> dfs = [&](int u, int fa) {\n            // 如果1号点到u+1点的距离 <= k，则答案加1\n            if (dist[u] <= k) {\n                ans += 1;\n            }\n    \n            // 如果1号点到叶子的距离 < k，则还可以再这个叶子下加 k - dist[u] 个\n            if (u != 0 && g[u].size() == 1 && dist[u] < k) {\n                ans += k - dist[u];\n            }\n    \n            // 继续遍历子树 v \n            for (int v: g[u]) {\n                if (v == fa) continue;\n                dist[v] = dist[u] + 1;\n                dfs(v, u);\n            }\n        };\n        \n        dfs(0, -1);\n    \n        cout << ans << \"\\n\";\n    \n        return 0;\n    }\n    \n\n**Java**\n\n    \n    \n    import java.util.ArrayList;\n    import java.util.List;\n    import java.util.Scanner;\n    \n    public class Main {\n        static List<List<Integer>> g;\n        static int[] dist;\n        static int n, k;\n        static long ans;\n    \n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            n = scanner.nextInt();\n            k = scanner.nextInt();\n            \n            // 建图\n            g = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                g.add(new ArrayList<>());\n            }\n    \n            for (int i = 1; i < n; i++) {\n                int u = scanner.nextInt() - 1;\n                int v = scanner.nextInt() - 1;\n                g.get(u).add(v);\n                g.get(v).add(u);\n            }\n    \n            final int INF = 0x3f3f3f3f;\n    \n            ans = 0;\n            dist = new int[n];\n            for (int i = 0; i < n; i++) {\n                dist[i] = INF;\n            }\n            // 计算1号点到每个点的距离，1号点到自己的距离为 0\n            dist[0] = 0;\n    \n            dfs(0, -1);\n    \n            System.out.println(ans);\n        }\n    \n        static void dfs(int u, int fa) {\n            // 如果1号点到u+1点的距离 <= k，则答案加1\n            if (dist[u] <= k) {\n                ans++;\n            }\n            // 如果1号点到叶子的距离 < k，则还可以再这个叶子下加 k - dist[u] 个\n            if (u != 0 && g.get(u).size() == 1 && dist[u] < k) {\n                ans += k - dist[u];\n            }\n            // 继续遍历子树 v \n            for (int v : g.get(u)) {\n                if (v == fa) {\n                    continue;\n                }\n                dist[v] = dist[u] + 1;\n                dfs(v, u);\n            }\n        }\n    }\n    \n\n**Python3**\n\n    \n    \n    def dfs(u, fa):\n        global ans\n        # 如果1号点到u+1点的距离 <= k，则答案加1\n        if dist[u] <= k:\n            ans += 1\n        # 如果1号点到叶子的距离 < k，则还可以再这个叶子下加 k - dist[u] 个\n        if u != 0 and len(g[u]) == 1 and dist[u] < k:\n            ans += k - dist[u]\n        # 继续遍历子树 v \n        for v in g[u]:\n            if v == fa:\n                continue\n            dist[v] = dist[u] + 1\n            dfs(v, u)\n    \n    \n    n, k = map(int, input().split())\n    \n    # 建图\n    g = [[] for _ in range(n)]\n    for _ in range(1, n):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n    \n    INF = int(1e9)\n    \n    ans = 0\n    dist = [INF] * n\n    # 计算1号点到每个点的距离，1号点到自己的距离为 0\n    dist[0] = 0\n    \n    dfs(0, -1)\n    \n    print(ans)\n    \n\n### 3.原神抽卡\n\n小米很喜欢在原神中抽卡，而且他只抽活动池。\n\n活动池的抽卡有三种结果：非五星角色，五星限定角色，五星常驻角色。\n\n抽到五星常驻角色和五星限定角色的概率均为![](https://www.nowcoder.com/equation?tex=%5Cfrac%7Bp%7D%7B2%7D&preview=true)，抽到非五星角色的概率为![](https://www.nowcoder.com/equation?tex=1-p&preview=true)\n\n**如果抽到了五星常驻角色，则之后的抽卡结果将发生变化**\n，变为![](https://www.nowcoder.com/equation?tex=p&preview=true)的概率抽到五星限定角色，![](https://www.nowcoder.com/equation?tex=1-p&preview=true)的概率抽到非五星卡。\n\n**如果连续89抽都没有抽到五星角色，则第90抽必定抽到一个五星限定角色或者五星常驻角色**\n\n给定一个概率![](https://www.nowcoder.com/equation?tex=p&preview=true)，请你求出小米抽到五星限定角色的期望次数是多少？\n\n**输入格式**\n\n>\n> 一个小数![](https://www.nowcoder.com/equation?tex=p&preview=true)表示抽卡概率，![](https://www.nowcoder.com/equation?tex=0%3Cp%3C1&preview=true)\n\n**输出格式**\n\n>\n> 一个小数，表示抽到五星限定角色的抽卡次数期望。你的答案和正确答案的误差不超过![](https://www.nowcoder.com/equation?tex=10%5E%7B-6%7D&preview=true)即视为正确\n\n**样例**\n\n**输入**\n\n    \n    \n    0.001\n    \n\n**输出**\n\n    \n    \n    129.1649522\n    \n\n**题解：期望DP**\n\n我们可以发现，抽到第一次五星角色有50%的概率是限定五星角色，抽到第二次五星角色（如果第一次歪了）100%概率是限定五星角色，那么我们设第一次抽到五星角色为![](https://www.nowcoder.com/equation?tex=P&preview=true),第二次同理可得，也为![](https://www.nowcoder.com/equation?tex=P&preview=true)，那么整体的抽到五星限定角色的概率就是![](https://www.nowcoder.com/equation?tex=P*0.5%2BP*1%3D1.5P&preview=true)\n\n定义![](https://www.nowcoder.com/equation?tex=dp%5Bi%5D&preview=true)为第![](https://www.nowcoder.com/equation?tex=i&preview=true)次抽到五星角色的概率，第![](https://www.nowcoder.com/equation?tex=i&preview=true)次抽中，说明前![](https://www.nowcoder.com/equation?tex=i-1&preview=true)次均没有抽中，因此**状态转移方程为**![](https://www.nowcoder.com/equation?tex=dp%5Bi%5D%3D\\(1-%0A%5Csum_%7Bj%3D1%7D%5E%7Bi-1%7Ddp%5Bj%5D%20%0A%20\\)*p&preview=true)\n\n期望就是概率乘权值![](https://www.nowcoder.com/equation?tex=E%3D%5Csum%20i*dp%5Bi%5D&preview=true)\n\n代码中可以使用前缀和优化，即可把![](https://www.nowcoder.com/equation?tex=dp%5Bi%5D&preview=true)变为![](https://www.nowcoder.com/equation?tex=%5Csum_%7Bj%3D1%7D%5E%7Bi%7Ddp%5Bj%5D%20&preview=true)\n\n**C++**\n\n    \n    \n    #include <iostream>\n    using namespace std;\n    double dp[91];\n    \n    int main() {\n        double p;\n        cin >> p;\n    \n        double cnt = 0; //记录总期望次数\n    \n        for (int i = 1; i < 90; i++) {\n            dp[i] = (1 - dp[i - 1]) * p;\n            cnt += dp[i] * i;\n            dp[i] += dp[i - 1]; // 前缀和\n        }\n    \n        cnt += 90 * (1 - dp[89]); // i = 90时特殊处理\n        cout << fixed;\n        cout.precision(7);\n        cout << cnt * 1.5 << \"\\n\";\n    \n        return 0;\n    }\n    \n\n**Java**\n\n    \n    \n    import java.util.*;\n    \n    public class Main {\n        public static void main(String[] args) {\n            Scanner sc = new Scanner(System.in);\n            double p = sc.nextDouble();\n            double[] dp = new double[91];\n            double cnt = 0;\t\t//记录总期望次数\n            for(int i = 1 ; i < 90 ; i++) {\n                dp[i] = (1-dp[i-1]) * p;\n                cnt += dp[i] * i;\n                dp[i] += dp[i-1];\t\t//前缀和\n            }\n            cnt += 90 * (1-dp[89]);\t\t//i=90时特殊处理\n            System.out.printf(\"%.7f\\n\", cnt *1.5);\n        }\n    }\n    \n    \n    \n\n**Python**\n\n    \n    \n    p = float(input())\n    \n    dp = [0] * 91\n    cnt = 0 # 记录总期望次数\n    \n    for i in range(1, 90):\n        dp[i] = (1 - dp[i - 1]) * p\n        cnt += dp[i] * i\n        dp[i] += dp[i - 1]  # 前缀和\n    \n    cnt += 90 * (1 - dp[89])  # i=90时特殊处理\n    \n    print(f\"{cnt * 1.5:.7f}\")\n    \n    \n\n以上内容均来自[笔试刷题指南](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxuq7bkgch1.feishu.cn%2Fdocx%2FBodwdmrbnojrdlxDmYLc6vzsnxe)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570938306280652800?sourceSSR=users",
        "title": "滴滴面经（附答案）",
        "content": "这是一位牛友面试滴滴的题目，本篇文章尝试回答一下，如有错误，欢迎大家留言指正\n\n原面经链接：[https://www.nowcoder.com/discuss/482240892393226240?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F482240892393226240%3FsourceSSR%3Dusers)\n\n一面，40min\n\n**1.Java 有什么集合，说详细一些，每个集合有什么实现类** ？\n\n**2.HashMap 和 ConcurrentHashMap 区别** ？\n\n答：HashMap底层是数组+链表存储数据（Java8后链表长度大于一定值，链表会转化为红黑树），当存放键值对（key,\nvalue）时，首先对key计算哈希值，来确定键值对在数据中的存放位置，如果不同的key的hash值相同，则会发生哈希冲突，HashMap通过链地址法来解决哈希冲突；当HashMap中的元素数量达到数组大小与加载因子（默认大小0.75）乘积时，HashMap会尽心扩容，扩容会新建一个新的数组，新数组为旧数组大小的2倍（注：扩容涉及到元素的重新分配，相对比较耗费性能）；HashMap不是线程安全的，多线程环境下有可能会出现线程安全问题；HashMap中允许null作为键和值\n\nConcurrentHashMap底层也是采用数组+链表/红黑树的结构存储数据，但是它采用了分段锁技术，即将数据分为多个段，每个段独立加锁，当某个线程访问一个段时，不会阻塞其它段的访问，极大的提高的并发访问的效率。在Java8之后，ConcurrentHashMap放弃了段的概念，而是进一步降低了锁的粒度，通过synchronized\n+CAS来保证线程安全；ConcurrentHashMap与HashMap解决哈希冲突以及扩容的原理均类似；ConcurrentHashMap中null不允许作为键和值\n\n**3.线程和进程的区别** ？\n\n答：根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位\n\n内核通过进程表项（PCB）来描述进程，操作系统内核通过一个双向链表来管理PCB，比如进程创建时，将该进程的PCB添加到双向链表中；当进程销毁时，将该进程的PCB从双向链表中删除。\n\n每一个进程会有自己独立的虚拟地址空间，也就是说有自己的一个页表，创建进程时，加载器会将可执行文件映射到该虚拟地址空间；当CPU访问虚拟地址，如果页表未命中，也就是说该虚拟页还没有缓存到物理内存中，它就会触发一个缺页异常。\n\n进程有自己独立的虚拟地址空间，同时进程切换时，不仅需要切换寄存器、堆栈，还需要进行虚拟地址空间的切换，切换代价比较大；而线程共享进程的地址空间，切换时进需要切换寄存器和栈，切换代价比较小\n\n**4.多线程了解吗，线程池了解吗** ？\n\n答：多线程的目的是为了最大限度利用CPU资源，通过多线程可以同时执行多个任务，但是线程的频繁创建和销毁会十分浪费性能，于是可以通过线程池来解决这一问题，Java中可以通过new\nThreadPoolExecutor()或者Executors.newFixedThreadPool()来创建线程池，线程池有几大核心参数：\n\na. 核心线程数corePoolSize：线程池中始终存在的线程数，即使线程处于空闲状态，也不会被被回收\n\nb. 最大线程数maximumPoolSize: 线程池中允许存在的最大线程数\n\nc. 工作队列WorkQueue：用于存放待处理任务的阻塞队列\n\nd. 线程工厂ThreadFactory: 用于创建新线程的工厂，可以通过这个参数来定义如何创建新线程（比如定义线程的名字等）\n\ne. 拒绝策略：当工作队列满了之后，且线程已经达到了线程池最大线程数目，线程池会采用拒绝策略来处理新的任务\n\n注：当核心线程无法处理提交的任务时，会暂时将任务存放到任务队列中，如果任务队列已满，则会创建线程（直至最大线程数目），如果已经达到了最大线程限制，提交到线程池的任务依旧在增多，则通过设置的拒绝策略来对后续提交的任务进行处理。\n\n**5.数据库事务了解吗，索引了解吗**\n\n答：数据库事务指对数据库的一系列操作，要么全部成功，要么全部不执行。事务需要满足四个基本原则即：ACID原则\n\na. 原子性：事务中的所有操作要么全部成功，要么全部不执行。如果在事务执行过程中出现故障，则会回滚已经执行的操作\n\nb.一致性：事务开始之前和事务执行完之后，数据库中的数据需符合预设的规则，保证数据的正确性。比如账户A有400元，账户B有400元，现在账户A向账户B转账200元，那么转账这个操作就是一个事务，这个是事务执行前后，均需要满足账户A+账户B的总金额为800，这便是一致性\n\nc.隔离性：数据库运行多个事务同时对数据进行读写和修改，隔离性可以防止多个事务并发执行时而导致的数据不一致，事务隔离主要分为读未提交、读已提交、可重复读、串行化\n\nd.持久性：事务处理结束后，对数据的修改就是永久的，即使系统故障也不会丢失\n\n**6.聚簇索引和非聚簇索引了解吗** ？\n\n答：在MySQL中通常使用B+树作为索引的存储结构，对于聚簇索引：B+树的非叶子节点中仅存放主键值，而叶子节点中存放主键值和数据，其中叶子节点之间通过双向链表连接，便于范围查询，叶子节点内部的数据通过链表连接，支持二分查找\n\n非聚簇索引：与聚簇索引的区别在于叶子节点中不存放数据，而是存储主键值，因此如果要通过非聚簇索引查找数据（非主键），需要先找到主键，然后再去聚簇索引中根据主键查询数据，成为“回表”\n\n**7.Redis 缓存穿透怎么回事，怎么解决**\n\n答：缓存穿透指查询的数据既不在缓存中，也不在数据库中，这样由于在缓存中取不到数据，每次均会去数据库中查询，对数据库造成很大的压力。解决方法:\n\na. 布隆过滤器：使用布隆过滤器可以判断一个数据是否存在，这样如果对于数据库中不存在元素可以直接通过布隆过滤器直接判断，从而避免访问数据库\n\nb.缓存空对象：第一次访问时，没有相应的数据，可以直接在redis中缓存一个空结果，这样后续的请求便可以被redis拦截了\n\n二面，40min\n\n**1.Redis 分布式怎么做，知道哨兵吗**?\n\n答：redis一个集群通常有多个节点组成，这些节点中有的是主节点，而有的是主节点的备份（又称从节点），以此保证主节点挂了之后，依旧有从节点可以代替主节点提供服务（故障转移），其中只有主节点可以接收写命令和读命令，而从节点仅能接收读命令。在redis中考虑到单个节点未必能存储整个数据集合，同时为了进一步提高应对高流量的读写的能力，redis通过“分片”的方式保存数据，即：将整个数据集合分为16384个slot，redis集群中的每个节点拥有其中一部分slot（并且每个slot均有备份），这样redis便打造成了高扩展性高可用的分布式系统了\n\n至于哨兵集群主要用来感知Redis的节点是否在线，比如某个主节点突然挂掉，需要按照一定的规则选举某个从节点成为主节点（一般是选举拥有最新数据副本的从节点成为主节点），如果长时间没有主节点，会影响客户端的写入命令执行（毕竟redis中只有主节点可以接收写命令）\n\n[https://mp.weixin.qq.com/s?__biz=MzIxMzg5ODIxMA==&mid=2247483763&idx=1&sn=949177d06b56d73c3d3bb70bcc0cae2d&chksm=97ae87fea0d90ee89d3a0b9322979838bfb3a045d2e5fcbf0ce85ba783cc28ace3aae6441e03&token=880968211&lang=zh_CN#rd](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzIxMzg5ODIxMA%3D%3D%26mid%3D2247483763%26idx%3D1%26sn%3D949177d06b56d73c3d3bb70bcc0cae2d%26chksm%3D97ae87fea0d90ee89d3a0b9322979838bfb3a045d2e5fcbf0ce85ba783cc28ace3aae6441e03%26token%3D880968211%26lang%3Dzh_CN%23rd)\n\n**2.线程和进程的区别** ？见上述回答\n\n**3.线程之间怎么共享资源** （我说的是 volatile 修饰变量）\n\n答：个人感觉这里应该是回答如何进行线程同步吧或者说线程之间共享资源，如何保证线程安全性\n\na.Synchronized关键字：可以用于修饰变量和代码块，保证同一时刻仅有一个线程可以获取锁并执行同步代码\n\nb.Lock锁：java并发库中提供了更加灵活的锁机制，如ReentantLock\n\nc.ThreadLocal：ThreadLoacal变量为每个线程创建一个副本，每个线程只能访问自己的副本，从而避免了线程安全问题\n\nd.使用并发容器：Java并发库提供了一些线程安全的容器，比如ConcurrentHashMap、CopyOnWriteArrayList等\n\n4.ThreadLocal 了解吗，怎么修改和获取数据，底层原理看过吗？\n\n答：ThreadLocal主要通过set(), get()方法来设置，获取数据\n\n    \n    \n    ThreadLocal<String> threadLocal = new ThreadLocal<>();\n    thradLocal.set(\"hello, world\");\n    String value = threadLocal.get();\n    \n\n在讨论ThreadLocal\n之前，我们需要明白Thread类中有个ThreadLocalMap变量，键值为ThreadLocal类，值为真正的局部变量。ThreadLocal的底层是一个哈希映射，即ThreadLocal.ThreadLocalMap\n\n**5.数据库索引了解吗**\n\n答：数据库索引是数据库用于提高查询速度的数据结构，可以把它类比成一本书的目录。索引主要分为主键索引，唯一索引，联合索引，普通索引等，从实现结构上又可以分为B-\nTree索引，B+Tree索引、Hash索引等。切记虽然索引可以提高查询速度，但是索引也占据存储空间，所以要合理的设计索引。\n\n**6.数据库分库分表了解吗，只分库不分表可以吗，只分表不分库可以吗** （没回答出来）\n\n答：数据库的分库分表是为了解决单一数据库无法承受过大的数据量以及访问压力，通过将数据分散到多个数据库或者表中，提高系统额扩展性和性能。\n\n只分库不分表可以，即将数据分散到多个数据库中，但每个数据库的表结构均相同，可以**有效的分散数据库的访问压力** 。\n\n只分表不分库也可以，即将一个大表的数据分散到多个小表中，但是所有的表均在一个数据库中，可以减少单表数据量，提高查询速度。\n\n两种方式各有优缺点，只分库不分表，解决单一数据库压力过大的问题，但是如果表的数据量过大，依旧影响查询效率\n\n只分表不分库，可以解决单表数据量过大的问题，但是如果数据库访问压力大，那么性能依旧会受到影响。\n\n**8.限流了解吗（不了解，面试官给我说这个很常用，而且解决方案很成熟，让我了解一下** ）\n\n答：限流主要用于保护系统在高流量下的稳定性，当系统达到一定阈值时，限流策略就会生效，超过限制的请求将会被拒绝，防止系统因为过载而崩溃。\n\n谷歌有非常成熟的限流方案，GuavaRateLimiter，基于令牌桶算法实现，内置两种模式应对不同的限流场景，分别是突发模式和预热模式。核心算法便是令牌桶，桶内令牌的数量以固定的速度增长，每个请求都需要从令牌桶中获取令牌才能被放行，否则就会被拒绝，这样只需要设定令牌生成的速度，便能控制限流阈值。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570800703602491392?sourceSSR=users",
        "title": "星环科技 一二面",
        "content": "**星环科技的hr和面试官应该是我国内面试中遇到最好的了... 秋招面过星环的同学最后虽然去阿里云了，但对星环还是挺推荐的，挺看好公司业务和工作氛围。**\n\n# 一面\n\n面试前看牛客相关面经都问了很多数据库相关的问题，所以面试前两天都在看MySQL八股，结果面试的时候一个没问。。。\n\n  1. 自我介绍+实习项目介绍；\n  2. 开源小项目的PR介绍；\n  3. 了解星环是做什么的吗？\n  4. 现在是想尝试一下数据库内核开发吗？\n  5. 实习过程中遇到过什么问题，怎么解决的呢？\n  6. 实习中用到的技术，你是怎么学习的呢？\n  7. 用过C++吗？（之前刷题用过stl，现在转python了\n  8. 聊一下你对CAP的理解；\n  9. 聊一下对数据库分层的理解；\n  10. 一道算法题，lc114，将二叉树转成链表；\n\n反问就是问了一下面试官的组具体是做什么，什么契机接触数据库开发的，组里技术栈是什么，是否要求候选人有C++背景啥的。\n\n# 二面\n\n又是看了一天MySQL八股但一点没问的一场面试。面试官是美硕，精神状态有点像我实习组里的同事。\n\n就聊了一下实习项目，实习感受，为什么回国。闲聊了一下读研的生活，然后介绍了一下自己组负责的业务。\n\n最后我问了一下团队规模、工作氛围之类的。我以为后面还会有八股或算法题，结果说完暂时没有其他问题，面试官就说今天就到这了，他也没有别的问的了。\n\n面完hr就问我倾向于一面二面哪个面试官的组，说后续就剩补个笔试测评，具体想去哪个组可以之后再定。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570653319803183104?sourceSSR=users",
        "title": "字节懂车帝 IOS端开发 转正实习 25届 面经",
        "content": "### 比较之前\n\n  * 优化了自我介绍。\n  * 重新复习了一遍知识总结。\n  * 重新总结了自己的算法思维。\n  * 合理地调整了自己的心情和未来规划。\n\n### TimeLine\n\n\\--12/21投简历--12/22约面试--12/29一面--01/02已终止--\n\n### 一面 1h\n\n![](https://uploadfiles.nowcoder.com/compress/mw1000/images/20231230/468686332_1703926232126/EBDDD7E76ED426DCC0174EBE3AD7B7B8)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570630791479263232?sourceSSR=users",
        "title": "2024年算法工程师烂大街的面试问题",
        "content": "1、xgboost和lgbm的区别是什么？\n\n特征浮点分箱为直方图加速。\n\n2、kmeans的算法原理是什么？\n\n任取几个点作为聚类中心；迭代n轮：先给每个点找距离最近的中心，然后将中心作为变量，优化目标函数（mse），中心位置和每个样本所属类别交替迭代。\n\n3、DBScan和层次聚类的原理是什么？\n\n4、transformer的原理是什么？\n\n5、大模型微调的流程是什么？\n\n6、lora和stable diffusion怎么用？\n\n7、NLP大模型怎么开发？\n\n8、系统辨识的算法有哪些?\n\n9、快速排序怎么写？非递归形式怎么写?\n\n10、怎么判定一个点在多边形内部？\n\n射线法\n\n11、C+=的静态链接和动态链接是什么？\n\n12、你的论文写得是什么？\n\n13、\n\n  \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570625289164787712?sourceSSR=users",
        "title": "2024秋招，TCL测试开发工程师全流程回顾",
        "content": "###\n\n前言\n\n大家好，今天回顾一下我在2024秋招中参加的TCL面试全流程，希望能帮助到有需要的人\n\n###\n\n时间线\n\n8月30日，人才测评\n\n9月6日，线上英文笔试\n\n第一家考英文笔试的，虽然我六级过了，但是很突然没咋准备，据说分数很低....后面面试面试官也针对这个问题让我用英语回答技术问题\n\n9月12日专业笔试\n\n10月19日调剂base地\n\n10月31日技术面\n\n因为时间隔得比较久，简历更新忘记同步了，面试官问的还是之前的内容\n\n没有自我介绍先是两三个生活问题，让我放松项目介绍解决什么问题有什么亮点竞赛组队负责工作蒙特卡洛树极大极小值算法发现的bug，怎么解决的遇到的困难求职日常安排工作中，发现刚发布的版本有bug怎么解决？测试要做哪些工作？展示一下你的博客内容（屏幕共享）怎么制作好一篇博客，从哪些方面考虑？学生工作负责哪些内容？有什么困难？怎么解决？专利做过吗？得过什么奖学金？TCP和UDP的区别OSI七层模型介绍5G和4G的区别反问（业务）\n\n11月7日hr面，当场oc\n\n11月10日录用测评\n\n###\n\n面试内容\n\n1\\. 没有自我介绍\n\n2\\. 先是两三个生活问题，让我放松\n\n3\\. 项目介绍\n\n4\\. 解决什么问题\n\n5\\. 有什么亮点\n\n6\\. 竞赛组队\n\n7\\. 负责工作\n\n8\\. 博弈算法\n\n9\\. 项目中发现的bug\n\n10\\. 怎么解决遇到的困难\n\n11\\. 求职期间日常时间安排\n\n12\\. 工作中，发现刚发布的版本有bug怎么解决？ 复现-评估紧急程度-需要人力资源-无法快速解决就回滚\n\n13\\. 测试要做哪些工作？\n\n14\\. 展示一下你的博客内容（屏幕共享）\n\n15\\. 怎么制作好一篇博客，从哪些方面考虑？ 技术-热点-时间-质量-解决了什么问题？-帮助了哪些人？\n\n16\\. 学生工作负责哪些内容？\n\n17\\. 有什么困难？怎么解决？\n\n18\\. 专利做过吗？\n\n19\\. 得过什么奖学金？\n\n20\\. TCP和UDP的区别 安全-消耗-建立连接-应用场景-面向目标\n\n21\\. OSI七层模型介绍 应用层-传输层-会话层-数据链路层-物理层\n\n22\\. 5G和4G的区别 协议方面\n\n23\\. 反问（业务）\n\n###\n\n总结\n\n面试体验还可以，但当时的楼主还是菜鸟，很多问题回答的不够准确，感谢那位面试官，让我成长了很多\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570609822169661440?sourceSSR=users",
        "title": "滴滴开奖",
        "content": "最后一个池子泡出来了[牛泪]，原先的部门是小桔能源，后面被两轮车捞起来了，给了一个白菜。分享一下面经。\n\n## 20230920 滴滴一面\n\n1.讲一下毕设，毕设中的创新点是什么？\n\n2.在实习中最大的收获是什么？\n\n3.讲一下在阿里用过的AOne有什么缺陷，该怎么优化？封网结束后，服务部署频率过高的问题该怎么处理呢？从技术和需求的角度去讲。\n\n4.如何避免数据重复？\n\n## 20230926 滴滴 二面\n\n1.实习项目的介绍\n\n2.kakfa的作用\n\n3.如果有10亿条数据，该如何找到中位数呢？\n\n4.如果数据是动态的该怎么找到中位数呢？如何找到最大的100个数呢？\n\n5.如何设计缓存\n\n  * 性能\n  * 扩展性\n  * 持久化\n\n6.redis单纯的set和get的数据结构是什么？\n\n## 20231020 滴滴三面\n\n1.介绍实习的主要工作内容\n\n2.介绍实习项目与datax的不同点\n\n3.介绍一下MySQL索引\n\n4.为什么MySQL索引用b+树\n\n5.Redis 持久化方式有哪些\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570583271776550912?sourceSSR=users",
        "title": "睿智合创 实习",
        "content": "1.用过线程池吗\n\n2.countdownlatch底层原理\n\n2.线程池的核心线程数和最大线程数怎么安排\n\n4.cpu如果使用率高达95%以上可能是什么问题导致的\n\n5.如果一个接口的响应速度是3秒,你可以从那些地方优化\n\n6.你的gateway和openfeign做过那些配置\n\n7为什么要做熔断,hystrix的线程池隔离和信号量隔离的区别\n\n8.你在实习时的主要收获有什么\n\n9.你在实习时遇到什么难题吗\n\n10.实习时的导师安排是什么样的\n\n反问....\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570624394746232832?sourceSSR=users",
        "title": "24秋招实习，初创公司测试开发实习生面经",
        "content": "## 前言\n\n记录一下23年11月初面试一家初创公司的测开实习生的技术问题\n\n## 过程\n\n  1. 自我介绍\n  2. 项目中用到的测试工具\n  3. 登录注册测试用例设计\n  4. 了解的测试方法和工具\n  5. selenium定位元素方法\n  6. 同名字段如何区分\n  7. pytest和Unittest区别\n  8. 接口测试怎么做\n  9. Jmeter了解吗，接口测试、性能测试、压力测试\n  10. get和post的区别，安全性、大小\n  11. cookie和session的区别，存储位置、安全性，他们通过篡改cookie做本地多分支部署\n  12. 压力测试了解，工具？\n  13. 反问，业务\n  14. 工作（保障产品按照文档和UI稿的内容、解决线上问题、推进工作、每周迭代、黑盒测试、部署、把握上线时间）\n  15. 测试环境部署，Jenkins，CI部署\n  16. 技术栈：web自动化+pytest+allure，PO设计模式\n  17. 测试需要写代码吗？自动化、性能、接口测试\n  18. 对产品的建议\n\n### 二面技术主管\n\n  1. 自我介绍\n  2. 数据库底层结构，我记得是红黑树，直接开始讲结构，他提醒我不要瞎说\n  3. 更新操作\n  4. 大学里哪门课学的最好，介绍一下\n  5. 常见数据结构\n  6. 设计铅笔测试用例\n  7. 做学生工作负责过哪些内容？\n  8. 组织过哪些活动？\n  9. 怎么组织一个活动？\n  10. 把控哪些关键？\n  11. 怎么分配人员工作？\n  12. 工作的意义？\n  13. 举行会议的意义？\n  14. 认为大多数人做学生工作的目的？\n  15. 面对下属摸鱼你会怎么做？\n  16. 反问\n  17. 公司业务\n  18. 业务流程 需求文档-需求评审（逻辑、业务合理性）-开发（研发方案）-测试（测试用例）-三方评审-测试-产品、UIreview-回归-灰度-生产\n  19. 测试push开发，和产品讨论解决问题，推进进度\n  20. 测付费墙、付费流程\n  21. 做测试实习的目的，想要获得什么？\n\n## 总结\n\n很好的一家公司，可惜中道崩殂，资金方跑路了，已经结束啦\n\n**欢迎点赞、收藏、评论，it's important for me.**\n\n**欢迎点赞、收藏、评论，it's important for me.**\n\n**欢迎点赞、收藏、评论，it's important for me.**\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570338561602457600?sourceSSR=users",
        "title": "面试题解析|宝洁八大问-领导力",
        "content": "🍬题目：举例说明，你在一项团队活动中如何采取主动性，并且起到领导者的作用，最终获得你所希望的结果。\n\n  \n\n🌰关键词：领导作用&获得结果\n\n  \n\n🧃提示：需要讲清楚我们作为主动推进事情的领导者，一共做了一些什么事情，并且达到了什么结果，并将实际结果与预期进行比较。\n\n  \n\n🍙讲述逻辑：\n\n1.团队活动是什么？\n\n2.你如何成为了领导者的角色以及你做了哪些事情（这里需要稍微详细一点，并且需要分点展开，让面试官对你的步骤有直观的了解）\n\n3.通过你的推进，事情有了什么结果，以及和预期结果对比，做得更好的地方。\n\n  \n\n🥠宝洁八大问作为非常经典的问题合集，能够很好的帮助大家总结自己的个人经历，建议每一位候选人在求职前都可以深入学习了解下宝洁八大问的回答技巧。如果有疑问，可以后台私信详细咨询。\n\n  \n\n🥜面试稳稳赢系列会主要和大家共同讨论面试题目的拆解，站在HR的视角带你看透面试问题的本质。欢迎持续关注，另外同时有简历稳稳赢，求职稳稳赢等更多板块，欢迎大家来我的主页，学习以及讨论相关话题。🫘🫖🍻🥂\n![vuwegliOR8nYyB98rKW3auFJWnMC6zbU.jpg](https://uploadfiles.nowcoder.com/images/20231229/722513612_1703851273839/8E1B1A91AF29FA8F035FDF0C19F5F151)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570615662725402624?sourceSSR=users",
        "title": "2024秋招，顺丰科技测试开发工程师全流程回顾",
        "content": "9月21日测评\n\n10月26日技术一面，本来是11点半开始，我正做另一个笔试呢，突然给我打电话开面\n\n  1. 自我介绍\n  2. 项目经历\n  3. 对测试的认识\n  4. 做过哪些测试工作？\n  5. 项目中的测试点\n  6. 软件测试\n  7. 硬件测试\n  8. 算法测试\n  9. 日常安排\n  10. 团队合作怎么开展？\n  11. 反问\n\n15分钟结束，一开始以为KPI，结果给过了\n\n10月31日技术二面\n\n记录在这里了[https://www.nowcoder.com/discuss/548819022180114432?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F548819022180114432%3FsourceSSR%3Dusers)\n\n11月1日hr面，都是常见问题，主要介绍了一下升职空间\n\n11月9日oc\n\n11月10日拒了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570322739882459136?sourceSSR=users",
        "title": "快手电商数分日常实习（已OC）",
        "content": "![](https://uploadfiles.nowcoder.com/message_images/20231229/994633469_1703847471826/discuss_1703847470963.jpeg)![](https://uploadfiles.nowcoder.com/message_images/20231229/994633469_1703847479482/discuss_1703847478534.jpeg)![](https://uploadfiles.nowcoder.com/message_images/20231229/994633469_1703847486288/discuss_1703847485438.jpeg)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570319107262877696?sourceSSR=users",
        "title": "美团——商业分析实习，一面凉经",
        "content": "问题：\n\n简历中体现商业分析的案例\n\n交通指标，可以改善的策略\n\n时间序列分析，预测\n\n指标下降，供给侧和需求侧两方面拆分\n\n两道sql题\n\n自己的优缺点\n\n项目中的挑战\n\n对特价团购有没有什么了解\n\n最差的一次面试体验，被面试官鸽了两次，白熬夜准备[牛泪]\n\n感觉商业分析师最重要的还是业务理解吧，准备的数分理论都没问到[尴尬]\n\n面试后自我感觉良好，被面试官夸了两次，结果第二天就被挂了[发火]\n\n每次现场手撕代码就会大脑一片空白，但是其实题目很简单，可能还是要多练习[摸鱼中]\n\n拜拜了，团子[发火][发火][发火]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570612932766171136?sourceSSR=users",
        "title": "2024秋招，建信金融科技非功能测试工程师",
        "content": "广州事业群\n\n10月12日专业笔试\n\n10月16日性格测评\n\n10月27日技术一面（两男一女）\n\n  1. 自我介绍\n  2. 挂科？\n  3. 怎么了解到招聘信息\n  4. 期望城市\n  5. 其他offer\n  6. 怎么选择，主要关注哪些方面（环境、业务、发展空间）\n  7. 期望薪资\n  8. 提前入职时间\n  9. 对岗位的认识（非功能测试）\n  10. 为什么报这个岗位\n  11. 除了工作之外做些什么，业余爱好（篮球、电竞、AIGC）\n  12. 对于北上广选择的想法（向往广东文化）\n  13. 项目经历，主要承担的职责\n  14. 比赛结果\n  15. 说会通知结果，也没通知\n\n像极了KPI\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570276367334477824?sourceSSR=users",
        "title": "百度实习面经，瑟瑟发抖...",
        "content": "![](https://git.acwing.com/Hasity/interview_hunter/-/raw/master/2024/image/%E7%99%BE%E5%BA%A6%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F.JPG)\n\n## 1 内存分区，进程内存映象，linux内存模型\n\n  1. **内存分区（Memory Partitioning）** ： 内存分区是指将计算机的物理内存划分成不同的区域，每个区域用于存储不同类型的数据。常见的内存分区包括：\n\n     * **代码段（Code Segment）** ：存储程序的执行代码。\n     * **数据段（Data Segment）** ：存储全局变量等数据。\n     * **堆（Heap）** ：用于动态分配内存，由程序员进行手动管理。\n     * **栈（Stack）** ：用于存储函数调用的局部变量、函数参数等。\n  2. **进程内存映像（Process Memory Image）** ： 进程内存映像是指一个运行的进程在内存中的布局和组织。它包括以下部分：\n\n     * **代码段** ：存储进程的执行代码。\n     * **数据段** ：包括初始化的全局变量和静态变量。\n     * **堆** ：用于动态分配内存，比如通过`malloc`和`free`。\n     * **栈** ：存储函数调用的局部变量、函数参数等。\n\n进程内存映像使得操作系统能够有效地管理多个进程，并确保它们之间不会相互干扰。\n\n  3. **Linux内存模型** ： Linux操作系统采用了分页机制来管理内存，其中有两个关键概念：\n\n     * **虚拟内存（Virtual Memory）** ：允许程序使用比实际物理内存更大的地址空间。这使得每个进程都有独立的地址空间，提高了系统的稳定性和安全性。\n\n     * **分页（Paging）** ：将物理内存划分成大小固定的页面，与虚拟内存中的页面相对应。当一个程序需要访问某个页面时，操作系统将其加载到物理内存中。这有助于提高内存的利用率和管理效率。\n\n>\n> **[面经专栏直通车](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fcreation%2Fmanager%2FcolumnDetail%2F0xKkDM)**\n\n>\n> **[面经专栏下载](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgit.acwing.com%2Flicw%2F24_job_hunter)**\n\n## 2 堆是谁来分配\n\n在大多数编程语言中，堆内存的分配和释放通常是由程序员手动管理的，而不是由编程语言或操作系统自动处理。\n\n  1. **手动管理（Manual Management）** ：\n\n     * 在C语言中，通过使用`malloc`函数来动态分配堆内存，而使用`free`函数来释放已分配的内存。\n     * 在C++中，可以使用`new`运算符来分配堆内存，而使用`delete`运算符来释放内存。\n  2. **自动管理（Automatic Management）** ：\n\n     * 有一些编程语言提供自动内存管理，例如Java、C#和Python。在这些语言中，垃圾回收器（Garbage Collector）负责自动识别不再被程序使用的内存，并释放它们，包括堆中的内存。\n\n在手动管理的情况下，程序员负责确保正确地分配和释放内存，以避免内存泄漏（内存未释放）或悬挂指针（引用已释放的内存）等问题。在自动管理的情况下，垃圾回收器会自动处理内存的分配和释放，减轻了程序员的负担，但也可能引入一些性能开销。\n\n总体而言，堆内存的分配和释放取决于编程语言和程序员的选择。\n\n## 3 开发时碰到内存溢出，内存泄露\n\n**处理内存溢出** ：\n\n  1. **检查算法和数据结构** ：\n\n     * 优化算法和数据结构，确保它们在处理大数据量时具有良好的性能。\n  2. **释放不必要的资源** ：\n\n     * 在使用完资源后及时释放，包括文件句柄、网络连接等。\n  3. **增加堆栈大小** ：\n\n     * 对于一些递归或深度调用的情况，可能需要增加堆栈大小。\n  4. **使用内存池** ：\n\n     * 对于频繁的内存分配和释放，考虑使用内存池，减少内存碎片化。\n  5. **分析内存使用情况** ：\n\n     * 使用工具分析内存使用情况，例如内存分析器，以找出哪些部分占用了大量内存。\n\n**处理内存泄漏：**\n\n  1. **使用内存分析工具** ：\n\n     * 使用专业的内存分析工具，例如Valgrind（对C/C++很有用）或内存分析器，来检测和报告内存泄漏。\n  2. **代码审查** ：\n\n     * 定期进行代码审查，特别关注内存分配和释放的代码块，确保它们的使用是正确的。\n  3. **使用智能指针** ：\n\n     * 对于支持智能指针的语言，使用它们可以减少手动内存管理的错误。\n  4. **确保资源释放** ：\n\n     * 在对象生命周期结束时，确保释放与之关联的资源，包括关闭文件、释放网络连接等。\n  5. **编写单元测试** ：\n\n     * 编写测试用例，特别是针对内存管理的测试，以及时捕捉潜在的问题。\n  6. **日志和监控** ：\n\n     * 在应用程序中实施日志和监控机制，以及时发现和诊断内存泄漏问题。\n  7. **定期性能优化** ：\n\n     * 定期进行性能优化，包括内存方面的优化，以确保应用程序在长时间运行后不会因为内存泄漏而出现问题。\n\n## 4 了解过检测内存泄露的工具或是方法\n\n检测内存泄漏的工具和方法有很多，具体的选择通常取决于你所使用的编程语言和开发环境。以下是一些常见的工具和方法：\n\n**内存分析工具** ：\n\n  1. **Valgrind（C/C++）** ：\n\n     * Valgrind是一个强大的工具，可用于检测内存泄漏、不初始化的内存访问等问题。它能够在运行时对程序进行详细的内存分析。\n  2. **AddressSanitizer（C/C++）** ：\n\n     * AddressSanitizer是GCC和Clang的一个特性，用于检测内存错误，包括内存泄漏、访问已释放内存等。\n  3. **LeakSanitizer（C/C++）** ：\n\n     * LeakSanitizer是GCC和Clang的另一个特性，专门用于检测内存泄漏。\n  4. **Dr. Memory（Windows，C/C++）** ：\n\n     * Dr. Memory是一款用于检测内存泄漏和内存错误的工具，特别适用于Windows环境。\n  5. **Heap Profiler（Java）** ：\n\n     * Java有内置的Heap Profiler，可以用于分析Java应用程序的内存使用情况，包括泄漏检测。\n\n**日志和手动检查** ：\n\n  1. **内存日志** ：\n\n     * 在代码中插入日志语句，记录内存分配和释放的信息，以便分析程序的内存使用情况。\n  2. **手动检查** ：\n\n     * 定期审查代码，特别关注内存分配和释放的地方，确保资源的正确释放。\n\n**静态代码分析工具** ：\n\n  1. **Clang Static Analyzer** ：\n\n     * Clang Static Analyzer是一个用于静态代码分析的工具，可以帮助检测代码中的潜在问题，包括内存泄漏。\n  2. **Coverity** ：\n\n     * Coverity是一种商业静态代码分析工具，可以帮助发现和修复各种代码缺陷，包括内存泄漏。\n\n**运行时检测** ：\n\n  1. **自定义检测机制** ：\n\n     * 在代码中插入特殊的标记或计数，以便在运行时检测内存泄漏。\n  2. **使用内存管理库** ：\n\n     * 一些编程语言或框架提供了内置的内存管理库，可以用于检测内存泄漏，例如C++中的`_CrtDumpMemoryLeaks`。\n\n## 5 extern c语法，具体什么作用\n\n`extern \"C\"` 是一种 C++ 中的语法特性，用于在 C++ 代码中声明使用 C 语言编写的函数或变量。它告诉编译器按照 C\n语言的方式进行名称修饰和链接。\n\n在 C++ 中，默认情况下，函数和变量的名称会经过名称修饰（name mangling）以支持函数重载和其他 C++ 特性。而在 C\n语言中，不进行名称修饰。\n\n使用 `extern \"C\"` 可以使 C++ 代码与 C 代码进行混合编译和链接，解决了在 C++ 中调用 C 函数或变量时名称不匹配的问题。\n\n**用法示例** ：\n\n  1. 函数声明：\n\n假设有一个 C 语言的头文件 `example.h`：\n\n    \n    \n    // example.h\n    #ifdef __cplusplus\n    extern \"C\" {\n    #endif\n    \n    void c_function(); // C 函数声明\n    \n    #ifdef __cplusplus\n    }\n    #endif\n    \n\n在 C++ 中的源文件中可以这样使用：\n\n    \n    \n    // cpp_file.cpp\n    #include \"example.h\"\n    \n    int main() {\n        c_function(); // 可以在 C++ 代码中调用 C 函数\n        return 0;\n    }\n    \n\n**变量声明：**\n\n    \n    \n    // example.h\n    #ifdef __cplusplus\n    extern \"C\" {\n    #endif\n    \n    extern int c_variable; // C 变量声明\n    \n    #ifdef __cplusplus\n    }\n    #endif\n    \n\n在 C++ 中的源文件中可以这样使用：\n\n    \n    \n    // cpp_file.cpp\n    #include \"example.h\"\n    \n    int main() {\n        int value = c_variable; // 可以在 C++ 代码中使用 C 变量\n        return 0;\n    }\n    \n\n使用 `extern \"C\"` 时需要注意以下几点：\n\n  * `extern \"C\"` 应该用于 C++ 代码中，通过 `#ifdef __cplusplus` 来确保只在 C++ 环境下进行声明。\n  * `extern \"C\"` 的作用是告诉编译器使用 C 语言的命名和链接规则，因此在 `{}` 内部的函数和变量会按照 C 的方式进行处理。\n  * 使用 `extern \"C\"` 不会改变函数的实际实现，只是改变了函数的名称在符号表中的表示方式。\n\n## 6 进程几种状态，切换的时机；interruptible和uninterrupted状态\n\n在操作系统中，一个进程可以处于多个状态之一，而进程的状态转换是由操作系统内核根据进程执行的情况来管理的。以下是常见的进程状态以及状态之间的切换时机：\n\n**进程的几种状态：**\n\n  1. **运行（Running）** ：\n\n     * 进程占用 CPU 运行，是当前正在执行的进程。\n  2. **就绪（Ready）** ：\n\n     * 进程已经准备好运行，但由于其他进程正在执行，它暂时无法获得 CPU 时间。\n  3. **阻塞（Blocked）** （也称为等待或睡眠）：\n\n     * 进程暂时不能执行，因为它正在等待某个事件的发生，例如等待用户输入或等待磁盘I/O完成。\n\n**进程状态之间的切换时机：**\n\n  1. **创建（Creation）** ：\n\n     * 进程被创建时，处于创建状态。\n  2. **就绪和运行状态切换** ：\n\n     * 进程在就绪状态等待 CPU 时间，当操作系统调度它时，切换到运行状态。\n  3. **运行和阻塞状态切换** ：\n\n     * 进程在执行过程中可能遇到需要等待的事件，例如等待I/O操作完成，此时它从运行状态切换到阻塞状态。\n  4. **阻塞和就绪状态切换** ：\n\n     * 当某个等待的事件发生，阻塞的进程切换回就绪状态，等待CPU的调度。\n  5. **运行和终止状态切换** ：\n\n     * 进程执行完毕或发生致命错误时，从运行状态切换到终止状态。\n\n**interruptible 和 uninterruptible 状态：**\n\n  1. **interruptible 状态** ：\n\n     * 进程处于可以被中断的状态。在等待某些事件（如I/O操作）时，进程可能处于interruptible状态，这表示它可以被操作系统中断，从而响应其他事件。\n  2. **uninterruptible 状态** ：\n\n     * 进程处于无法被中断的状态。在某些情况下，例如正在等待磁盘I/O完成时，进程可能处于uninterruptible状态，这表示它不能被中断，必须等待事件完成才能继续执行。\n\n这两种状态的选择通常取决于进程等待的事件的性质。例如，对于磁盘I/O，可能会选择uninterruptible状态，因为中断可能导致数据不一致。而对于网络I/O，可能选择interruptible状态，以便更及时地响应其他事件。\n\n## 7 进程和线程区别\n\n进程（Process）和线程（Thread）是操作系统中用于执行程序的两个基本的执行单位，它们之间有一些关键的区别：\n\n  1. **定义** ：\n\n  * **进程** ：是一个独立的执行单元，有自己的地址空间、数据栈，以及其他系统资源（文件描述符、信号处理等）。进程之间相互独立，通信需要使用进程间通信（IPC）机制。\n\n  * **线程** ：是进程的一部分，共享进程的地址空间和其他资源，但拥有独立的执行栈。线程之间更容易共享数据和通信，因为它们共享相同的地址空间。\n\n  2. **资源开销** ：\n\n  * **进程** ：相对较大的资源开销，每个进程都有独立的内存空间、文件描述符等。\n\n  * **线程** ：较小的资源开销，因为它们共享相同的资源。\n\n  3. **通信** ：\n\n  * **进程** ：通信需要使用IPC机制，如管道、消息队列、共享内存等。\n\n  * **线程** ：通信更容易，因为它们共享相同的地址空间。\n\n  4. **独立性** ：\n\n  * **进程** ：相对独立，一个进程的崩溃通常不会影响其他进程。\n\n  * **线程** ：一个线程的崩溃可能导致整个进程的崩溃，因为它们共享相同的地址空间和资源。\n\n  5. 创建和销毁：\n\n  * **进程** ：相对较慢，涉及到分配独立的地址空间、资源初始化等。\n\n  * **线程** ：相对较快，因为它们共享相同的资源，创建和销毁的开销较小。\n\n  6. 安全性：\n\n  * **进程** ：由于进程有独立的地址空间，一个进程的错误通常不会直接影响其他进程。\n\n  * **线程** ：由于共享相同的地址空间，一个线程的错误可能会影响其他线程。\n\n  7. **适用场景：**\n\n  * **进程** ：适用于多核心系统，能够实现真正的并行计算。\n\n  * **线程** ：适用于需要共享数据和通信的任务，因为线程可以更方便地共享相同的地址空间。\n\n## 8 内存管理的buddy，伙伴系统\n\nBuddy系统是一种内存管理的算法，常用于管理动态分配的内存块。它主要用于解决内存碎片化的问题，提高内存利用率。Buddy系统基于二叉树的概念，将内存分割为大小为2的幂的块，这些块的大小就像一对伙伴。\n\n下面是Buddy系统的基本原理和操作：\n\n  1. **内存分配** ：\n\n  2. 初始时，整个可用内存看作是一个大小为2的幂的块。\n\n  3. 当需要分配一块大小为2^k的内存时，系统在2^k的空闲块链表中查找可用块。如果找到，则分配该块；否则，向上合并块，直到找到合适大小的块。\n\n  4. **内存释放** ：\n\n  5. 当一块内存释放时，将其加入到对应大小的空闲块链表。\n\n  6. 检查其伙伴块是否也是空闲的，如果是，就合并这两个块，并将合并后的块加入到上一级的空闲块链表中。这一过程一直持续，直到合并到最大块或者找到一个非空闲的块。\n\n  7. **优点** ：\n\n  * 解决了内存碎片问题，因为大小为2的幂的块容易合并和分割。\n  * 分配和释放操作的时间复杂度为O(1)。\n\n  4. **缺点** ：\n\n  * 内存浪费：由于每个块的大小必须是2的幂，因此可能出现一些内存浪费。\n  * 外部碎片：释放的内存块可能不能直接合并到相邻的块中，导致外部碎片。\n\n  5. **应用场景** ：\n\n  * 适用于需要频繁分配和释放小块内存的场景，例如操作系统中的内核内存管理。\n  * 不适用于大对象的分配，因为可能导致较大的内存浪费。\n\n## 9 CFS，和O(1)对比，结合实例说了一下\n\nCFS（Completely Fair Scheduler）和O(1)调度器是Linux内核中用于进程调度的两种不同的调度算法。\n\nO(1)调度器：\n\nO(1)调度器是早期Linux内核中使用的一种调度算法，它的设计目标是使调度的时间复杂度保持为O(1)。这是通过维护一个任务数组和一个就绪队列实现的，通过简单的数据结构，O(1)调度器可以在常数时间内找到下一个要执行的任务。\n\n**实例：**\n\n    \n    \n    #include <linux/sched.h>\n    \n    void some_function(void) {\n        while (1) {\n            // 进行一些工作\n            schedule();  // 使用O(1)调度器进行进程切换\n        }\n    }\n    \n\n在上述示例中，`schedule()`\n函数用于调用O(1)调度器进行任务切换。O(1)调度器在实时性能方面表现较好，但在处理大量任务时，可能导致某些任务饥饿。\n\nCFS调度器：\n\nCFS调度器是Linux内核中较新的调度算法，引入了红黑树的概念，通过对任务运行时间的虚拟时钟进行动态的调整，实现对任务的公平调度。CFS调度器的设计目标是提供更好的公平性和负载均衡。\n\n**实例：**\n\n    \n    \n    #include <linux/sched.h>\n    \n    void some_function(void) {\n        while (1) {\n            // 进行一些工作\n            schedule();  // 使用CFS调度器进行进程切换\n        }\n    }\n    \n\n在这个示例中，`schedule()` 调用用于调用CFS调度器进行任务切换。CFS调度器会根据任务的虚拟运行时间来选择下一个要运行的任务，以实现公平性。\n\n对比：\n\n  1. **时间复杂度** ：\n\n     * O(1)调度器的时间复杂度为O(1)。\n     * CFS调度器的时间复杂度相对较高，但它更注重于提供公平性和负载均衡。\n  2. **公平性** ：\n\n     * O(1)调度器可能在任务的公平性方面表现较差，容易导致某些任务长时间无法获得CPU时间。\n     * CFS调度器被设计为更公平，它通过动态调整虚拟运行时间来确保任务相对公平地分享CPU时间。\n  3. **适用场景** ：\n\n     * O(1)调度器适用于需要较低调度延迟的场景。\n     * CFS调度器适用于更注重公平性和负载均衡的场景。\n\n## 10 中断的基本框架，以键盘中断为例\n\n中断是计算机系统中一种异步事件处理的机制，允许系统在执行当前任务的同时响应外部事件。以下是处理中断的基本框架，以键盘中断为例：\n\n  1. **中断发生** ：\n\n  * 用户按下键盘上的某个键触发中断，键盘控制器产生中断请求（IRQ）。\n\n  2. **硬件层处理** ：\n\n  * CPU检测到中断请求，停止当前执行的任务。\n  * CPU保存当前执行任务的上下文（程序计数器、寄存器等）。\n\n  3. **中断向量表** ：\n\n  * 硬件通过中断向量表确定中断的类型和处理程序的入口地址。\n  * 在键盘中断的情况下，中断向量表会指向处理键盘中断的中断服务程序。\n\n  4. **中断服务程序（Interrupt Service Routine，ISR）** ：\n\n  * 控制权转移到相应中断的处理程序。\n  * 在键盘中断的情况下，键盘中断服务程序负责处理键盘输入。\n\n    \n    \n    keyboard_isr:\n        ; 处理键盘中断的汇编代码\n        ; 读取键盘输入，更新相应的数据结构或触发相应的事件\n        ; 恢复寄存器状态等\n    \n        ; 中断服务程序执行完毕后，执行中断返回指令\n        iret\n    \n\n  5. **软件层处理** ：\n\n  * 中断服务程序执行完毕后，CPU从中断返回指令（iret）返回到之前被中断的任务。\n  * 恢复之前保存的任务上下文。\n\n  6. **继续执行任务** ：\n\n  * 控制权返回到之前被中断的任务，任务继续执行。\n\n在这个基本框架下，中断服务程序是中断处理的核心。键盘中断服务程序将负责读取键盘输入、更新相应的数据结构、触发事件等。整个中断处理流程实现了异步事件的响应，使得系统能够在执行任务的同时处理来自外部的事件，提高了系统的响应性。\n\n## 11 IPC\n\nIPC（Inter-Process\nCommunication）是指不同进程之间进行数据交换和通信的机制。在多任务和多进程的操作系统中，不同的进程可能需要互相通信，共享数据或者协同完成某些任务。以下是几种常见的IPC方式：\n\n  1. **管道（Pipe）** ：\n\n  * **描述：** 管道是一种半双工的通信机制，数据流只能单向流动。通常用于具有父子关系的进程之间的通信。\n\n  * **示例：** 在Shell中，通过管道可以将一个进程的输出连接到另一个进程的输入，实现两者之间的通信。\n\n    \n    \n    $ ps aux | grep \"process_name\"\n    \n\n  2. **消息队列（Message Queue）** ：\n\n  * **描述：** 消息队列是一种通过消息进行通信的机制，可以实现进程之间的异步通信。\n\n  * **示例：** 进程A通过消息队列向进程B发送消息，进程B从消息队列中读取消息并作出相应处理。\n\n  3. **共享内存（Shared Memory）** ：\n\n  * **描述：** 共享内存允许多个进程访问同一块物理内存区域，进程可以直接读写这块内存区域。\n\n  * **示例：** 进程A将数据写入共享内存，进程B可以直接从共享内存读取这些数据，实现了高效的进程间通信。\n\n  4. **信号（Signal）** ：\n\n  * **描述：** 信号是一种异步通信方式，用于通知进程发生了某个事件。每个信号都有一个唯一的数字标识，例如SIGINT表示中断信号。\n\n  * **示例：** 进程A通过发送信号SIGUSR1通知进程B执行某个特定操作。\n\n  5. **套接字（Socket）** ：\n\n  * **描述：** 套接字是一种提供网络通信的机制，也可用于同一台主机上不同进程之间的通信。\n\n  * **示例：** 在客户端-服务器模型中，服务器通过套接字监听客户端的连接请求，实现进程之间的通信。\n\n  6. **信号量（Semaphore）** ：\n\n  * **描述：** 信号量是一种用于控制多个进程对共享资源访问的机制，可用于解决进程同步和互斥问题。\n\n  * **示例：** 多个进程需要同时访问一个共享资源时，可以使用信号量来进行同步和协调。\n\n这些IPC机制提供了不同层次的抽象和复杂性，选择合适的IPC方式取决于具体的应用需求和设计考虑。\n\n## 12 linux查看进程状态\n\n在Linux系统中，可以使用一系列命令来查看进程的状态。以下是一些常用的命令：\n\n  1. **ps命令** ：\n\n`ps` 命令用于显示当前运行在系统上的进程。下面是一些常见的用法：\n\n  * 查看所有进程：\n    \n        ps aux\n    \n\n  * 查看指定用户的进程：\n    \n        ps -u username\n    \n\n  2. **top命令** ：\n\n`top` 命令以动态的方式显示系统的活动进程。它提供了一个实时更新的任务列表，并显示各种系统资源使用情况。\n\n    \n    \n    top\n    \n\n  3. **htop命令** ：\n\n`htop` 是 `top` 的一个增强版本，提供了更多的交互式功能和更直观的界面。\n\n    \n    \n    htop\n    \n\n  4. **pgrep命令** ：\n\n`pgrep` 命令用于通过进程名查找进程的PID（进程标识符）。\n\n    \n    \n    pgrep process_name\n    \n\n  5. **pkill命令** ：\n\n`pkill` 命令用于通过进程名终止进程。\n\n    \n    \n    pkill process_name\n    \n\n  6. **kill命令** ：\n\n`kill` 命令用于向指定的进程发送信号，例如终止进程。\n\n    \n    \n    kill -9 PID\n    \n\n以上命令中的 PID 是进程的标识符，可以通过 `ps` 命令或其他进程查看命令获取。\n\n## 13 线上环境服务出现问题怎么检测，挂了怎么拉起，怎么管理\n\n线上环境服务出现问题时，检测、拉起和管理服务都是关键的运维任务。以下是一些建议和常见的做法：\n\n  1. **检测服务问题** ：\n\n  2. **监控系统** ：\n\n     * 使用监控系统实时监测关键指标，如 CPU 使用率、内存使用率、网络流量等。\n     * 设置阈值并配置警报，以便在达到或超过阈值时及时通知运维人员。\n  3. **日志分析** ：\n\n     * 定期分析服务日志，查找异常信息，警报或记录异常情况。\n     * 使用日志聚合工具，如ELK Stack（Elasticsearch、Logstash、Kibana），以更方便地分析和监控日志。\n  4. **心跳检测** ：\n\n     * 实现心跳检测机制，定期向服务发送请求并检查响应，确保服务正常运行。\n  5. **综合健康检查** ：\n\n     * 定期进行综合健康检查，包括服务端口的可用性、依赖服务的连通性等。\n  6. **服务挂了怎么拉起** ：\n\n  7. **自动恢复机制** ：\n\n     * 实现自动恢复机制，例如使用进程管理工具（如systemd、supervisord）监控服务状态，当服务挂掉时自动拉起。\n  8. **容器编排工具** ：\n\n     * 如果使用容器化技术，可使用容器编排工具（如Docker Compose、Kubernetes）来管理服务的自动重启和伸缩。\n  9. **自动扩展** ：\n\n     * 在云环境中，通过自动扩展组件，如Auto Scaling（AWS）、Instance Group（Google Cloud）来动态调整实例数量，确保服务可用性。\n  10. **服务管理** ：\n\n  11. **版本控制** ：\n\n     * 使用版本控制系统（如Git）来管理服务代码和配置，确保可以回滚到稳定的版本。\n  12. **灰度发布** ：\n\n     * 实施灰度发布策略，逐步将新版本服务引入线上环境，减少潜在问题的影响范围。\n  13. **自动化运维工具** ：\n\n     * 使用自动化运维工具（如Ansible、Chef、Puppet）来部署和管理服务，确保环境一致性。\n  14. **备份与恢复** ：\n\n     * 定期进行数据备份，确保在服务问题导致数据丢失时能够迅速恢复。\n  15. **紧急手动操作** ：\n\n     * 提前定义好应急手动操作流程，以防止自动化机制失效时进行紧急修复。\n\n通过以上措施，可以有效地检测服务问题、自动拉起服务、并管理服务的生命周期，提高服务的可靠性和稳定性。\n\n## 14 git操作\n\nGit 是一分布式版本控制系统，用于跟踪文件的变化和协作开发。以下是一些基本的 Git 操作：\n\n  1. **初始化仓库** ：\n\n    \n    \n    git init\n    \n\n在当前目录下初始化一个新的 Git 仓库。\n\n  2. **克隆仓库** ：\n\n    \n    \n    git clone <repository_url>\n    \n\n从远程仓库克隆一个本地副本。\n\n  3. **添加文件** ：\n\n    \n    \n    git add <filename>\n    \n\n将文件添加到暂存区。\n\n  4. **提交更改** ：\n\n    \n    \n    git commit -m \"Commit message\"\n    \n\n将暂存区的更改提交到本地仓库。\n\n  5. **查看状态** ：\n\n    \n    \n    git status\n    \n\n查看工作区、暂存区和本地仓库的状态。\n\n  6. **查看提交历史** ：\n\n    \n    \n    git log\n    \n\n查看提交历史记录，包括提交者、提交时间和提交信息。\n\n  7. **创建分支** ：\n\n    \n    \n    git branch <branch_name>\n    \n\n创建一个新的分支。\n\n  8. **切换分支** ：\n\n    \n    \n    git checkout <branch_name>\n    \n\n切换到指定分支。\n\n  9. **合并分支** ：\n\n    \n    \n    git merge <branch_name>\n    \n\n将指定分支的更改合并到当前分支。\n\n  10. **远程操作** ：\n\n  * **添加远程仓库** ：\n    \n        git remote add origin <repository_url>\n    \n\n  * **推送到远程仓库** ：\n    \n        git push -u origin <branch_name>\n    \n\n  * **拉取远程仓库的更改** ：\n    \n        git pull origin <branch_name>\n    \n\n  11. **撤销更改** ：\n\n  * **撤销工作区的更改** ：\n    \n        git checkout -- <filename>\n    \n\n  * **撤销暂存区的更改** ：\n    \n        git reset HEAD <filename>\n    \n\n  * **撤销最后一次提交** ：\n    \n        git reset --soft HEAD^\n    \n\n  12. **标签操作** ：\n\n  * **创建标签** ：\n    \n        git tag -a <tag_name> -m \"Tag message\"\n    \n\n  * **推送标签到远程仓库** ：\n    \n        git push origin --tags\n    \n\n这些是 Git 的一些基本操作，涵盖了从初始化仓库到推送到远程仓库的基本流程。在实际使用中，你可能还会遇到其他一些高级的 Git 操作，如\nrebase、stash、cherry-pick 等，具体使用取决于项目的需求和团队的工作流程。\n\n## 15 虚拟化设备\n\n虚拟化设备是指通过虚拟化技术模拟或抽象的硬件设备，使得多个虚拟机（VM）能够在同一物理主机上并发运行，各自拥有自己独立的虚拟硬件资源。这种虚拟化的方式使得多个操作系统和应用程序能够在一个物理主机上同时运行，而不需要物理硬件的完全隔离。\n\n以下是一些常见的虚拟化设备：\n\n  1. **虚拟中央处理单元（Virtual CPU，vCPU）：** 每个虚拟机都分配有一个或多个虚拟 CPU，这些虚拟 CPU 由宿主机的物理 CPU 进行调度和执行。\n\n  2. **虚拟内存（Virtual Memory）：** 虚拟机使用虚拟内存来管理其内存空间，而实际的物理内存由宿主机管理。\n\n  3. **虚拟磁盘（Virtual Disk）：** 虚拟机使用虚拟磁盘来存储其操作系统和应用程序，这些虚拟磁盘可能是文件（如VMDK、VHD）或者直接访问物理存储设备。\n\n  4. **虚拟网络适配器（Virtual Network Adapter）：** 虚拟机通过虚拟网络适配器与物理网络通信，这样可以使得虚拟机之间和虚拟机与宿主机进行网络通信。\n\n  5. **虚拟图形处理单元（Virtual GPU，vGPU）：** 允许虚拟机共享物理主机的图形处理能力。\n\n  6. **虚拟输入/输出设备（Virtual I/O Devices）：** 包括键盘、鼠标、打印机等，使得虚拟机可以与这些虚拟设备进行交互。\n\n虚拟化设备的出现使得资源可以更加灵活地分配和共享，提高了硬件的利用率，并简化了系统管理。主流的虚拟化平台包括VMware、Microsoft\nHyper-V、KVM（Kernel-based Virtual\nMachine）等。这些平台提供了完整的虚拟化解决方案，包括虚拟化设备的模拟、管理、监控等功能。\n\n![alt](https://git.acwing.com/Hasity/interview_hunter/-/raw/master/2024/image/%E7%99%BE%E5%BA%A6%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F2.JPG)\n\n我的公众号：Hasity学不会\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570208375632400384?sourceSSR=users",
        "title": "字节 秋招 国际电商 后端开发 一二面（凉经）",
        "content": "## 一面 11.8（54min）\n\n  * 自我介绍\n  * 项目背景\n  * Netty响应式模型，网络IO模型\n  * epoll性能为什么好\n  * epoll的e是什么意思\n  * BIO AIO区别\n  * 挑一个项目聊一下\n  * 秒杀怎么做的\n  * 从用户点击抢购，整个完成流程说一下\n  * 怎么优化秒杀系统，让服务端不需要处理太多无效的请求\n  * Go、Java的特点 \n    * 它们在运行层面有什么差别\n    * 它们是面向对象还是面向过程\n  * 线程池参数，工作过程\n  * 你平常用哪个线程池，和别的有什么区别\n  * 死锁是怎么产生的，构造一个场景\n  * 死锁产生条件\n  * 怎么解决死锁、避免死锁\n  * http https区别\n  * http解决了tcp的什么问题\n  * 粘包拆包\n  * 滑动窗口解决了什么问题\n  * 滑动窗口会变大变小吗\n  * 网络突然来了很大的流量，是怎么防止拥堵的\n  * 手撕 \n    * 力扣 79. 单词搜索 \n      * 变形一下，可以走到重复的位置\n      * 详细的讨论了一下这道题的时空间复杂度，面试官还挺认可的。\n  * 反问\n\n## 二面 11.13（1h）\n\n  * 排序算法\n  * 讲一下归并排序\n  * 归并排序都用在哪些场景\n  * 讲一下快排\n  * 快排是怎么确定区间的\n  * 快排时间复杂度 \n    * ![](https://www.nowcoder.com/equation?tex=O\\(NlogN\\)&preview=true)、![](https://www.nowcoder.com/equation?tex=O\\(N%5E2\\)&preview=true) 分别是什么情况下会出现\n  * 还有更快的排序算法吗\n  * 给你全中国的年龄，14亿人按照年龄排序，用什么排序算法\n  * 建堆时间复杂度\n  * 堆中插入元素的时间复杂度\n  * 建堆后，输出这个堆的时间复杂度\n  * 手撕：三个升序数组 找第K小的值（要求 空间复杂度![](https://www.nowcoder.com/equation?tex=O\\(1\\)&preview=true)）\n  * 无反问，直接结束了，压力很大的说了句拜拜，排序答的实在是太烂了..\n\n> 二面很离谱，上来没自我介绍直接开始究极拷打排序算法；算法题其实挺简单的，但空间复杂度要求\n> ![](https://www.nowcoder.com/equation?tex=O\\(1\\)&preview=true)\n> 就一直卡住了，最后在面试官提醒下做出来了。\n\n> 第二天感谢信。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570195967857664000?sourceSSR=users",
        "title": "灵蔓科技 一面",
        "content": "水\n\n上来一道sql，两道算法，一道智商题\n\n![](https://uploadfiles.nowcoder.com/images/20231229/307430694_1703816928540/2A6F2C9093C7F3D02DDCFD24E53F505F)\n\n![](https://uploadfiles.nowcoder.com/images/20231229/307430694_1703816939017/C47C7CA7596AFC0BD57C2B9E9F0F3453)\n\n![](https://uploadfiles.nowcoder.com/images/20231229/307430694_1703816948962/0500CC8D727E1D506507F4B5D21438EC)\n\n![](https://uploadfiles.nowcoder.com/images/20231229/307430694_1703816962965/37450FF27938B2B0874271CCD62EEE27)\n\n这玩意没想着还能还回来，弱智了...\n\n后面就一直在看项目，访问控制，ORM，表结构，导入导出。项目难点也没问...\n\n二面完被我追问，说是外包。拜拜...\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570195022386135040?sourceSSR=users",
        "title": "Funplus引擎开发实习二面（已OC）",
        "content": "书接上文，二面整体难度高出一面许多，面试官考察了很多关于数学原理上的东西，拷打c++的时候也问的比较深。而且感觉面试官更多的是想看你知其然后知不知其所以然，所以光看面经其实完全应付不了，当时被拷打的汗流浃背了。\n\n二面 12.26 （50min）\n\nc++:\n\n1\\. 智能指针，讲讲unique_ptr，性能如何，如何实现，有哪些注意点\n\n2\\. shared_ptr和weak_ptr，线程安全，weak_ptr如何做到破坏循环引用，为什么不用裸指针代替weak_ptr（问的很深）\n\n3\\. 智能指针和裸指针的比较，谁更快。问了很多次，寄完了\n\n4\\. 说说std::move和std::forward，有性能开销吗，为什么？\n\n5\\. push_back和emplace_back区别，传递参数有什么区别？（估计是想问几种情况下这两个东西的区别）\n\n图形学：\n\n1\\. PBD相关，浮点误差的积累问题，PBD和XPBD的区别，XPBD能解决PBD的哪些问题？\n\n2\\. 说说物质点法的模拟，p2g和g2p，优势与劣势，具体写的时候有没有遇到？\n\n3\\. 具体讲讲雪的模拟，能不能做刚体的模拟？\n\n4\\. SVD分解（被拷打麻了），为什么要SVD分解，SVD分解怎么做的，数学原理？\n\n5\\. 讲讲CUDA SPH，具体说一说neighbor searching\n\n6\\. 你认为游戏中做实时的SPH流体模拟需要注意什么，怎么做？\n\n7\\. 多重网格法（硬着头皮讲的，当时已经被拷打麻了）\n\n每个问题都问的比较深，汗流浃背了，很多时候都磕磕绊绊的。不过面试官非常好，一直在引导。\n\n第二天约hr面，已OC\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570187104718749696?sourceSSR=users",
        "title": "会议室占用时间段 - 华为OD统一考试",
        "content": "> OD统一考试\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n现有若干个会议，所有会议共享一个会议室，用数组表示各个会议的开始时间和结束时间，\n\n格式为: [[会议1开始时间，会议1结束时间]，[会议2开始时间，会议2结束时间]] 请计算会议室占用时间段。\n\n## 输入描述\n\n[[会议1开始时间，会议1结束时间]，[会议2开始时间，会议2结束时间] ]\n\n> **备注** :\n>\n> 会议个数范围: [1,100]\n>\n> 会议室时间段: [1,24]\n\n## 输出描述\n\n输出格式预输入一致,具体请看用例。\n\n[[会议开始时间，会议结束时间]，[会议开始时间，会议结束时间]\n\n## 示例1\n\n    \n    \n    输入:\n    [[1,4], [2,5],[7,9], [14,18]]\n    \n    输出:\n    [[1,5], [7,9],[14,18]]\n    \n    说明:\n    时间段[1,4]和[2,5]重叠，合并为[1,5]\n    \n\n## 示例2\n\n    \n    \n    输入:\n    [[1 ,4],[4,5]]\n    \n    输出:\n    [[1,5]]\n    \n\n**说明**\n\n> 此题为核心编码模式，非ACM模式。\n\n## 题解\n\n> 排序 + 模拟\n>\n> 如果我们按照区间的左端点排序，那么在排完序的列表中，可以合并的区间一定是连续的。\n>\n> **算法描述**\n>\n> 我们用数组 merged 存储最终的答案。\n>\n> 首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间：\n>\n> 如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾；\n>\n> 否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。\n\n### Java\n\n    \n    \n    /**\n     * @author code5bug\n     */\n    class Solution {\n        public int[][] merge(int[][] roomTimes) {\n            if (roomTimes.length == 0) {\n                return new int[0][2];\n            }\n            Arrays.sort(roomTimes, new Comparator<int[]>() {\n                public int compare(int[] time1, int[] time2) {\n                    return time1[0] - time2[0];\n                }\n            });\n            List<int[]> merged = n\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570181709656854528?sourceSSR=users",
        "title": "百词斩日常实习面经（oc）",
        "content": "百词斩一面：\n\n项目：\n\n扫码登录怎么做的\n\n富文本编辑器\n\n防抖节流\n\n图片懒加载\n\n八股：\n\n说一下this？\n\n深拷贝和浅拷贝？\n\njs的基本数据类型和复杂数据类型？存在哪里？（堆 栈）\n\n协商缓存和强缓存？\n\nCookie和session区别？setCookie？\n\nReact的hooks介绍？\n\nReact的fiber？\n\nReact的setState的同步和异步？批量更新？\n\ndisplay有哪些可选属性？介绍flex？\n\nposition的relative是相对于什么？fixed是相对于什么？\n\n介绍一下链表？\n\n百词斩二面\n\n项目中遇到印象最深收获最多的？iframe原理？\n\njwt和Cookie区别？为什么用jwt？项目中token过期是怎么监听的？用户输入密码错误的话怎么感知？\n\n怎么封装axios？\n\n说说HTTP协议？由哪些组成？请求头有哪些内容？Http常见状态码？\n\nHTTPS和HTTP区别？讲一讲过程？ssl证书最重要的是什么？\n\n协商缓存和强缓存？ETAG是什么？\n\n部署的时候的方式？如果用户正在使用的话应该用什么方式？\n\nTCP协议的安全性如何实现的？它和HTTP协议有什么关系？\n\n讲一讲IP协议？\n\nGET和POST区别？讲一讲PUT和DELETE？\n\n实现一个元素居中？\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570096504870805504?sourceSSR=users",
        "title": "B站微服务开发-一面挂经",
        "content": "面试官人挺好的，聊的也挺愉快，最后聊到Github开源，还给我show了一下自己的Github主页和现在组里开源的kratos微服务框架。\n\n  1. 自我介绍+实习项目+开源贡献介绍；\n  2. 开源贡献的项目是解决什么问题的？\n  3. 实习做的k8s，那说一下k8s的核心组件；\n  4. k8s资源调度如何实现的？（预选+排序\n  5. etcd或master挂了，影响k8s已有服务吗？\n  6. 知道etcd的实现原理吗？\n  7. 再介绍一下实习项目，根据项目里的内容问了些问题；\n  8. 实习用的Postgres，那你说一下mysql和Postgres的区别吧；（不知道，没了解过Postgres跟mysql的区别，国内八股都是mysql的\n  9. mysql的索引怎么实现的；\n  10. http协议有哪些，1.0, 1.x, 2.0, 3.0都有什么区别；\n  11. 如果用QUIC的话，我从wifi切换到5g，网络会有什么变化吗？\n  12. Redis有哪些数据类型；\n  13. zset的底层数据结构是什么；string的数据结构是什么；\n  14. golang或Java写一个生产者消费者模型；\n\n反问：\n\n  1. 岗位叫微服务工程师，具体是做什么呢？部门是做b站的网关服务，提供微服务框架啥的；\n  2. 技术栈是什么？\n  3. 介绍了一下组里开源的kratos框架，还提了面试官自己的Github主页，说以前经常参与开源社区，现在写的少了啥的；\n  4. 新人培养和晋升机制；\n\n21届秋招春招都投过，当时简历都没过，今年简历上多了一年国内大厂全职+一段国外大厂实习，好不容易过了简历而且一面聊的挺好，最后竟然还是挂了，b站是什么招人标准啊...\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570074756708401152?sourceSSR=users",
        "title": "2024 届秋招 Golang 面经",
        "content": "纯面经帖，供后人参考，非经验贴，发完准备卸载牛客安心搞论文。\n\n个人基本情况：\n\n  * BG双非硕（非知名双非）\n  * 混杂型开发：Go/Java + 前端(Vue) + 移动端 (Flutter/Swift) 都有真实项目（或开源项目）\n  * Leetcode 500+ 题\n  * 三段小厂实习，Github 700+ Star，博客访问量 100w+\n  * 国际级、国家级、省级竞赛都有（特等、一等、二等、三等都有）\n\n学校 BG 问题，进面的不多，大多能走完技术面，但是最后不一定能开出来（唉）\n\n  * 部分工资会因为 BG 压薪资，也有不压的。开出来的薪资从 20- 到 50+ 的都有\n\n主要整理一些**知名厂** 。对于一些零零碎碎的中小厂，要么流程很奇怪，要么面试很简单，就不记录了\n\n  * 比如：格力电器、海信、点点互动等\n\n第一个中大厂 offer 是得物，大概在 11 月左右拿到（工资非常香），后面很多中小厂面试就拒了\n\n最后去了百度\n\n# 得物\n\n岗位职责：\n\n参与相关业务开发及维护工作，参与技术方案设计；参与容器化相关开发及维护工作；\n\n参与Golang相关框架及中间件的开发及维护工作；\n\n编写相关业务、技术文档等。\n\n任职要求：\n\n2024届毕业生，本科及以上学历，计算机类、软件类、通信类等相关专业；\n\n扎实的编程基础，至少掌握一门开发语言，熟悉Golang优先；\n\nCET4及以上，能够看懂技术相关的英文文档优先；\n\n有扎实的计算机基础知识功底，掌握常见数据结构和算法；\n\n有Docker、Kubernetes开发或使用经验者优先。\n\n## 笔试 08-23\n\n  * 试卷名称： golang开发工程师\n  * 考试时长： 120 分钟\n  * 开始时间： 2023-08-23 19:00 星期三\n  * 结束时间： 2023-08-23 22:00 星期三\n  * 20选择 + 2编程 + 1问答\n\n编程题：100 + 81\n\n## 一面 08-27\n\n面试官人比较和善，每说几句话都会点头肯定，压力比较小\n\n  * 自我介绍\n  * 浏览器输入 URL 的一个过程\n  * TCP 三次握手，四次握手的过程\n  * TCP 释放连接为什么要等待 2MSL 时间\n  * TCP 如何保证它的数据的顺序性\n  * TCP 进行拥塞控制的手段有哪些\n  * 进程、线程、协程的区别\n  * Golang 的 GMP 调度 \n    * 说下 GMP 的整个过程\n    * M 发生系统调用了 G 和 P 会怎么样\n    * M 系统调用结束以后会怎么样\n  * 介绍一下自己的项目\n  * 介绍一下使用 JWT 进行鉴权的过程\n  * 说一下 Gin 的拦截器的原理\n  * 说一下 Gin 的路由怎么实现的\n  * Gin 的路由使用的数据结构（字典树），介绍一下字典树\n\n## 二面 09-16\n\n一个女面试官，人比较和善 自我介绍 介绍一下项目中的亮点和难点\n\n  * 任务调度器是如何实现的？\n  * 流量控制是如何实现的？\n  * 垃圾邮件的检测是如何做的？\n  * 邮件发送失败会怎么样\n  * 如果发送邮件的过程中突然项目宕机了，重新开始会重新走流程吗？优雅启动 + 优雅重启\n  * .... （一大堆项目追问，具体忘了）\n\nNginx 的反向代理原理是什么？没答出来，说了下应用场景\n\nNginx 的负载均衡方案有哪些？\n\nDocker 相比物理机进行部署有什么好处？\n\nRedis 持久化有几种？\n\nRedis 的主从架构有哪些？\n\n和同事一起解决一个问题，有不同的解决方案会怎么办？\n\n和同事一起完成一个任务，同事能力比较差怎么办？\n\n对未来的职业规划是什么？\n\n## 三面 09-17\n\n主管应该是，压力较大 自我介绍 深挖项目\n\n  * 亮点\n  * 垃圾邮件如果是怎么做的？用的开源项目 rspamd\n  * 有了解过这个开源项目的内部实现吗？无\n  * 邮件任务调度器如何实现的？\n  * 流量控制成怎么做的？超时重发怎么做？\n  * 知道哪些邮件接收协议？\n  * SMTP 细节，除了 SMTP 还知道哪些邮件传输协议？\n  * 怎么判断是不是垃圾邮件？\n  * 有具体的优化前后的数值指标吗？无\n  * ...\n\n说说 Go 新特性 K8S 的架构？\n\n# 360\n\n工作职责\n\n1、负责360搜索旗下多个重点业务的web服务端开发和维护工作\n\n2、负责360搜索新业务方向的web服务端开发工作\n\n3、持续对产出的代码进行优化和升级4、参与需求分析，方案设计，配合业务测试等工作\n\n任职资格\n\n1、计算机相关专业毕业\n\n2、有使用过go或者php做过实际的开发项目经验\n\n3、扎实的算法和数据结构，操作系统的基础知识\n\n4、熟悉linux环境下的开发，熟悉常用的linux命令\n\n5、优秀的学习能力和执行力\n\n笔试 09-23\n\n40 选择 + 2 编程（100 + 80）\n\n## 一面 10-10\n\n都是经典八股\n\n说说 Linux 常用操作，ps 是干嘛的\n\nGo map 为什么是无序的？\n\nMySQL 索引分类，索引的优点和缺点\n\n分库分表\n\nCookie 和 Session 的区别和应用，分布式 Session 的实现\n\nTCP三次握手/四次挥手\n\nRedis 的数据类型及其数据结构，Bitmap 是什么\n\nRedis 的雪崩效应 ，是什么，怎么解决\n\n线程，进程，协程区别\n\n算法：用 Go 手撕快速排序\n\n## 二面 10-16\n\n挖掘项目\n\n## HR 面 11-02\n\n15分钟左右\n\n自我介绍\n\n想从事的技术方向\n\n介绍实习项目，有什么难点\n\n觉得自己在哪些方面有不足\n\n自己的性格和工作风格\n\n哪里人，为什么投北京\n\n目前的秋招进度\n\n期望薪资多少\n\n反问：\n\n  * 工作作息：早9晚6，双休\n  * 技术栈：全部是 Golang\n  * 后续：等通知\n\n# 闪送\n\n【职位描述】\n\n1、参与闪送运力业务线核心模块，如调度、生态等业务相关开发工作；\n\n2、参与闪送运力业务线架构设计和规划，设计合理、扩展性强的系统模型，提升需求迭代速度与系统能力；\n\n3、保障系统稳定性，通过系统设计、编码实现系统自我保护，提升系统可用性及可维护性；\n\n4、确保自身编码能达到高质量交付，且可以协同QA共同改进测试流程，实时优化系统性能，排除线上故障，确保系统稳定；\n\n5、积极主动协调团队成员完成项目，信守承诺，言出必行。\n\n【任职资格】\n\n1、全日制统招本科及以上学历，计算机相关专业；\n\n2、具有扎实的数据结构、操作系统、算法、网络等计算机基础知识；\n\n3、掌握Golang编程语言，掌握面向对象的编程思想，会使用常用的shell命令；\n\n4、熟悉Mysql数据库的基本使用，熟练使用SQL语句，了解数据库索引结构、事务隔离机制、锁等；\n\n5、优秀的逻辑思维能力，善于从复杂系统表象拆解分析问题，有较强解决问题能力；\n\n6、善于交流，有良好的团队合作精神和协调沟通能力，有一定项目推动能力。\n\n具备以下经验者优先：\n\n1、有参加各种计算机竞赛并获奖的经历；\n\n2、有原创的技术博客或者参与过知名的开源项目或者某开源项目作者；\n\n3、有在知名公司核心部门实习经历且实习时间不少于6个月。\n\n## 笔试 10-08\n\n编程题2道：100 + 100\n\n## 一面 10-13\n\n50min，无手撕\n\n项目挖掘 GO：\n\n  * slice 和 array 的区别\n  * map, slice 未初始化，操作会怎么样。发生 panic 应该怎么办\n  * recover 怎么使用的，defer 相比普通的在函数最后执行操作，其优势是什么\n  * channel 相关操作\n  * map 有序无序，为什么？map 是否并发安全？如何保证并发安全？map 并发读写都是不安全的。\n  * 如何控制 GMP 中 M 的数量？(???)\n  * 如何控制 goroutine 的生命周期，channel 的作用，context 的作用\n  * select 如何使用？\n  * new 和 make 的区别？\n\nMySQL 的事务隔离级别，可重复读解决什么，幻读是什么？ MySQL 修改数据库某个表的字段用什么指令？\n\nTCP 三次握手，两次握手会怎么样，TCP 和 UDP 的区别，什么时候用 UDP\n\nRedis 的数据结构有哪些？GEO 怎么用的？\n\nRedis 如何实现分布式锁？\n\nCAP 理论，举个场景，为什么只满足一个就不能满足另外两个\n\nLinux 的常用命令说说\n\ngit 创建分支的指令，git 合并分支的命令，git 如果提交了想撤回使用什么\n\ndocker 容器之间无法访问可能是什么原因\n\n项目中遇到的问题\n\n反问：\n\n  * 语言：Go 和 Java 都有，你面的部门的业务线是 Go\n  * 技术栈：web 框架是自研的\n\n## 二面 10-25\n\n面试官人很好很诚恳，也给出了很多有用的建议\n\n语言层面：\n\n  * Go 和 Java 对比\n  * Go 的并发模型\n  * Go 的错误处理和 Java 的异常处理对比\n  * 设计模式，写开源项目有没有特地用过设计模式\n\n数据库：\n\n  * 跳表的实现原理\n  * Redis 跳表 和 MySQL B+ 树的对比\n  * MySQL 的 MVCC 机制\n  * Redis 的分布式锁\n  * Redis 的分布式锁和 Zookeeper 的分布式锁的区别？（？？？)\n\n其他：\n\n  * 用过哪些消息队列？\n  * 为什么需要消息队列？\n  * 一个完整的链路中，因为消息队列异步的业务，如何做链路追踪？（？？？）\n\n未来的职业规划？\n\n对哪个方面的技术比较感兴趣？\n\n反问：\n\n  * 常用技术栈？\n  * 对应届生的要求？1、耐心 2、保持好奇\n\n## HR面 10-31\n\n基本就是HR面常见问题，聊了40分钟左右，记录几个还有印象的\n\n学业情况都完成了吗？\n\n是哪里人？为什么选择投北京的？\n\n对闪送公司本身和业务的理解？\n\n竞赛经历，挑了个最大的问在其中做了什么，收获了什么？\n\n实习经历？每段实习做什么，收货了什么？\n\n说一说有没有通过自己的逻辑能力来解决某些复杂的系统问题？\n\n认为国内技术最好的互联网公司是哪家？面过吗？自己分析下是为什么挂了？\n\n职业规划？\n\n反问：\n\n  * 闪送就一个业务部门，只是可能会做不同的事情\n  * 闪送的作息相比其他互联网会比较轻松\n\n# 中国移动信息技术中心\n\n任职要求：\n\n1.熟悉掌握Java、Go其中至少一种开发语言，熟练掌握Linux系统；\n\n2.有良好的研究背景和成果，对云计算领域兴趣浓厚；\n\n3.具备创造性思维，对工作充满热情，具备良好的团队合作精神和沟通能力，有良好的文档和PPT撰写能力；\n\n4.熟练使用主流数据库及中间件（Mysql、Redis、Rabbitmq、Kafka、Zookeeper等）；\n\n5.有Kubernetes、Docker、Container等技术相关经验者优先；\n\n工作职责：\n\n1、负责云计算PaaS平台相关模块的研发工作，参与平台架构设计、方案编写等工作；\n\n2、跟踪云计算领域技术发展趋势，推动平台整体架构规划持续演进；参与开源组件架构、源码解读，跟进开 源技术，参与开源组件的定制化开发、改造及优化\n\n3、参与项目管理，协助推进项目设计、建设，确保项目的顺利上线，参与需求分析和沟通工作，协助形成需求设计文档\n\n4、负责平台部分模块的代码修改、设计、研发、持续迭代等自主研发工作；\n\n5、开发技术栈包括但不限于Java、Golang、前端相关语言等；\n\n6、参与DevOps、云原生开发、K8s等关领域的前沿技术研究；\n\n## 笔试 10-28\n\n## 一面 10-19\n\n自我介绍\n\n介绍开源，项目\n\n会参与开源项目吗，一般是个人项目，还是团队项目\n\nPaaS 是什么？\n\n用过哪些 CI/CD 的工具\n\n  * Jekins 的部署流程\n  * 镜像仓库是推送到哪里\n\n用过哪些 NoSQL\n\nMySQL 和 MongoDB 应用场景\n\n【绝杀】如果大厂和我们同时给你发 Offer，会怎么选？\n\n  * 应届生应该会优先选大厂吧【注意以后回这种问题要尽量挖掘该公司，该岗位的优势】\n\n## 二面 11-01\n\n2个面试官轮流问，还有1个应该是HR小姐姐\n\n自我介绍\n\n问开源项目，Star数量，写的哪些项目，为什么写，具体如何实现（拷打项目细节）\n\n问竞赛细节，参加哪些竞赛，有哪些是自发参加的\n\n问实习情况，除了个人项目还有哪些项目，学校里和导师做过科研项目吗\n\n问对 K8S 的了解，有哪些概念和组件，如何编写自动化部署脚本（没研究过，让我说自己的理解）\n\n问是哪里人，为什么选择投北京的\n\n未来三到五年的职业规划\n\n对于团队合作和个人做项目更偏向于哪个\n\n会想要担当团队中的领导人吗\n\n反问：\n\n  * 业务\n  * 技术栈\n  * 流程：就两面，后续等通知\n\n# 金山\n\n## 笔试 09-24\n\n15基础选择题 + 5Go选择题 + 3编程题（100 + 100 + 100）\n\n## 一面 10-18\n\n时长：45 min，项目占一大半时间，八股比较少\n\n自我介绍\n\n项目：\n\n  * 简历上三个项目都问了，还出了很多场景题\n  * 文件存储用的什么？用的 key 是什么？有考虑过相同文件重复的问题吗？\n  * 你的开源项目的出发点是什么？怎么想到这个思路的？项目存在的问题？屏幕共享进行演示和代码讲解\n\n八股：\n\n  * Go GMP 调度机制\n  * Go string 和 []byte 的区别\n  * 操作系统中零拷贝\n  * MySQL InnoDB 的存储结构，B+树\n  * K8S 的金丝雀部署\n\n其他：\n\n  * 实习时项目开发的流程是什么？\n\n反问：\n\n  * 服务端技术栈：主要就是 Go\n  * 流程：两轮面试 + HR\n\n## 二面 10-27\n\n聊项目\n\n# 每日互动\n\n## 一面 10-19\n\n时长：1 小时，无手撕，基本全程项目\n\n自我介绍 屏幕共享，讲解开源项目，讲解博客\n\n  * 开源组件库的实现思路，有没有什么参考\n  * 博客开源项目，有没有什么参考\n  * 权限模块是怎么实现的\n\n用户发现访问速度比较慢，有哪些排查思路（前后端）\n\n负载均衡有哪几种？\n\nWeb 开发需要考虑的安全性有哪些方面\n\nmkdir /a/b/c 爆错，怎么解决？加 -p\n\n对函数式编程有所了解吗\n\nJava 和 Go 的区别\n\n说说你认识的设计模式\n\n说说知道的排序算法\n\n介绍一下 Docker 和 K8S 相关\n\n栈和队列的区别\n\nCSS 垂直居中\n\nNode 了解多少\n\n个人优势和缺点\n\n推荐两本书籍（技术 + 非技术）\n\n一块砖的作用（1分钟）\n\n未来的职业发展方向\n\n反问：\n\n  * 技术栈：后端 Java/Go/Node，前端 Vue\n  * 业务：面向政企\n\n## 二面 10-23\n\n有点偏 HR，都是比较宽泛的技术问题\n\n  * 学校、竞赛问了下\n  * Java 和 Go 的区别\n  * 对全栈的理解，以及为什么当全栈\n  * 用过的语言\n  * 个人性格怎么样，优缺点\n  * 后续职业规划\n\n反问：\n\n  * 公司业务：手机推送 SDK（个推）+ 面向政企提供信息化服务\n  * 公司技术栈：Nodejs 为主，Java\n  * 公司位置：杭州市西湖区\n\n## HR面 10-25\n\n聊天\n\n# 百度\n\n## 一面 12-07\n\n## 二面 12-13\n\n## 三面 12-14\n\n# 字节跳动\n\n## 一战 timeline\n\n### 一面 09-04\n\n1、自我介绍\n\n2、聊项目\n\n3、项目聊的很深，甚至面试官理解业务后还出了针对原项目的场景题\n\n  * 怎么保证发送并发情况下发送多个邮件导致的邮件攻击问题\n  * 如果因为网络问题导致邮件发送失败会怎么处理？（如何知道邮件发送失败了）\n\n4、聊到 Redis，问了些分布式锁相关的问题\n\n  * SETNX 和 SET NX 区别\n  * 如何使用分布式锁解决前面项目中某个问题\n  * 自旋锁的本质是什么？（如何实现的？）\n\n5、聊着聊着聊到 MySQL 慢 SQL 的查询\n\n  * 索引有哪些分类\n  * 聚簇索引和非聚簇索引\n  * 回表是什么\n  * 如何减少回表次数来优化\n  * 如何排查慢 SQL\n  * 如何最直观的查看慢 SQL\n  * EXPLAIN 执行计划要关注的字段\n  * 如果设置了索引速度还是很慢怎么办\n\n6、聊到 MySQL 数据量大的问题\n\n  * MySQL 数据量非常大了以后要怎么做\n  * 分库分表有几种思路\n  * 说说适合你的业务的分库分表方案\n\n算法题：删除链表的倒数第 K 个元素（要求一次遍历，不能使用快慢指针）\n\n  * 递归写完后，还加问了一句，堆和栈的区别是什么？\n\n### 二面 09-18\n\n体验不好\n\n面试官要求手撕一道竞赛题，撕完直接结束了\n\n可以看之前发的动态\n\n## 二战 timeline\n\n### 一面 11-07\n\n### 二面 11-10\n\n### 三面 11-28\n\n### 四面 12-01\n\n# 好未来\n\n## 09-09 一天三面（二面挂）\n\n一面：\n\n  * 说下四次挥手的过程\n  * 为什么需要 2MSL？2MSL 会产生什么问题？\n  * 使用 gorm 遇到过哪些坑 \n    * _更新时用结构体更新，不会更新零值，需要用 map 数组\n    * _time.Time日期格式默认是 ISO 8601 格式，想要更改格式需要自定义时间结构体\n  * MySQL 的事务隔离级别说一下 \n    * 默认隔离级别是什么，解决了幻读吗\n    * 为什么没有完全解决幻读？说个 case\n  * 说一下 Redis 和 Memcached 的区别？\n  * Redis 的 的数据可能会丢失吗？（操作系统层面） \n    * 生成 RDB 文件期间，如果 Redis 奔溃，数据会丢失\n    * RDB 后台进程刷盘，操作系统层面可能会丢失\n    * AOF 默认每秒同步一次文件，这秒内 Reids 奔溃，数据会丢失\n  * Redis 两种持久化方式\n  * Redis 实现排行榜使用什么数据结构？\n  * 说一下对 MySQL 的 事务的理解\n  * 为什么 MySQL 使用 B+ Tree，Redis 使用跳表？\n  * 虚拟内存的作用？\n  * Swap 机制是什么？作用是什么？\n  * 通过 Swap 交换的内存比一般磁盘 IO 更快吗？\n  * 线程、进程、协程的区别？\n  * 协程为什么是 2~4kb？\n\n算法题：\n\n  * 顺时针打印矩阵\n\n二面：（挂了？）\n\n  * 自我介绍\n  * 说说个人项目中的亮点和技术\n  * 说说从新考虑架构和设计项目会怎么设计\n\n# 平安金服\n\n## 一面 11-02\n\n## 二面 忘了\n\n当时晚上 8点左右在跑步，突然接到通知面试，回去随便面了面\n\n# 帷幄匠心\n\n## 09-25 一天三面（二面挂）\n\n一面：\n\n  * 八股 + 简单叙述项目\n  * 跳表的实现原理？查询和新增？\n  * Java 中非线程安全的数据结构\n  * 算法：有效的括号 + 最长回文子串\n\n二面：（挂了）\n\n  * 八股\n  * 算法：无重复的最长子串 + 某个改编题（树相关）\n\n# peropero\n\n小公司，当场表示面试通过，愿意来就发 offer\n\n小厂面试很轻松，聊天局：\n\n  * Go 的垃圾回收和 Java 的 垃圾回收的区别？Java的没背\n  * Go 的 CSP 并发编程介绍一下？\n  * Go 中的内存逃逸现象是什么？\n  * Nginx 的四层负载均衡和七层负载均衡\n  * Redis 的常用数据结构有哪些？\n  * Redis 实现一个同分数按时间戳的功能？\n  * 游戏开发和常规开发的区别？\n  * 未来的职业规划？\n\n下面完全就是聊天了。。。。\n\n公司技术，加班情况 ，业务分布，团队人手\n\n# 中金所\n\n## 一面 10-17\n\n自我介绍\n\n实习项目：\n\n  * 点赞功能如何实现\n  * 监听在线用户如何实现\n  * 实习中负责哪些功能模块\n  * 为什么不留在实习公司\n\nRestful 和 RPC 的区别？\n\n哈夫曼树是如何实现的？（？？早忘了）\n\n用栈如何实现队列？\n\nMySQL 新增一列字段的语句？（具体忘了，只答了用 Alter）\n\n家在哪里？怎么知道我们公司的？\n\n反问：\n\n  * 语言技术栈\n  * 业务是什么\n\n最后：\"感谢你参与今天的面试\"\n\n## 二面 11-7（拒了）\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569999287766061056?sourceSSR=users",
        "title": "滴滴前端实习一面",
        "content": "  1. 自我介绍\n  2. Vue2用的多还是vue3用的多？（都挺熟\n  3. 它两的响应式原理？\n  4. 详细介绍一下Object.defineProperty这个api\n  5. http和https 的区别 (只知道https使用了SSL加密更安全 X\n  6. HTTP缓存\n  7. MVVM模式\n  8. 遍历数组的方法\n  9. map和forEach\n  10. 闭包\n  11. 浏览器的渲染过程 （只答到渲染树那块 X\n  12. 路由有几种模式？（history和hash，详细说了一下实现方式\n  13. 原型和原型链的区别\n  14. react用了多久呢？\n  15. 常用的hooks\n  16. useRef\n  17. 手写：节流防抖、深拷贝、全排列 X\n  18. 反问：\n  19. 相对于其他候选人有哪些方面需要提升？每个人都不一样，你可能很多东西都知道一点但不是太深吧\n  20. 学习前端的建议？每个人都不太一样，找到适合子的方法。\n\n感觉也凉凉，总结下来就是八股背的还是不够细致，然后手写题也练的少了。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/570088113918279680?sourceSSR=users",
        "title": "小米云原生-秋招补录-面经",
        "content": "## 一面\n\n一面面试官感觉精神状态还比较好，问的也比较简单。就是聊了一下实习项目和九月Github一个开源项目提的PR，然后跟我聊了一下组里具体是做什么，问我为什么考虑回国而不是留北美blabla。\n\n然后简单问了几个八股：\n\n  1. java并发了解吗？用过什么并发类吗？（了解过没用过\n  2. 看你之前美团工作的时候用过Elasticsearch，熟悉原理吗？（不熟悉，就是当时有个小需求用了一下\n  3. 看你简历上写了CAP、BASE，说一下你对他们的理解吧。\n  4. 你实习项目里同事做的高可用集群，对应了CAP的什么内容呢，说一下。\n  5. 了解kafka吗？（本科做秒杀项目的时候用过rocketmq，没用过kafka\n  6. 后面好像还有问几个数据库的八股，录音中断没记下来。\n  7. 最后出了道机器人路径的简单dp\n\n刚开始面国内公司，八股准备的不是很足，感谢一面面试官最后还是放我一马。\n\n## 二面\n\n二面面试官好像是部门负责人，挺年轻的，不过感觉有点亚健康。\n\n  1. 自我介绍+聊实习项目；\n  2. 实习公司跟国内公司的区别，实习的时候最大的挑战是什么；\n  3. 参与开源项目的契机是什么；\n  4. 实习中最大的技术收获是什么；\n  5. 想做Infra还是业务；（面云原生团队，我肯定顺着说喜欢Infra\n  6. 有看过分布式的书或公开课吗？（听过6.824啥的，没看过\n  7. 介绍一下分布式锁是做什么的？\n  8. 介绍一下分布式事务是做什么的？\n  9. 了解有哪些限流算法吗；\n  10. 说一下协程跟线程的区别；\n  11. 多个协程修改线程里的一个共享资源，需要加锁吗？\n  12. 现在有一个客户端和服务端，连接后网络超时了，可能是什么原因。（没大get到面试官想问什么，最后问我用没用过socket编程\n  13. GC算法；\n  14. young gc和Full gc的区别；\n  15. 频繁Full gc可能得原因有哪些；\n  16. 了解线程池吗，说一下它的原理；\n  17. 为什么阿里java规范要求我们创建线程池时指定参数，而不是使用默认的线程池类型；\n  18. 两道算法题，一个生成所有合法括号（lc 22）\n\n反问：\n\n  1. 介绍一下部门业务和团队规模；\n  2. 小米的晋升机制，部门上次晋升窗口多少人升职；\n  3. infra团队对校招候选人有什么要求，需要有前面提到的分布式系统的经验吗？\n  4. 面试流程；（还有一轮交叉面，没有hr面\n\n## 三面\n\n三面面试官感觉也是有些亚健康。\n\n  1. 自我介绍+聊实习项目\n  2. 实习公司跟你预想的有什么不一样的地方吗？\n  3. 实习的时候你觉得比较大的挑战是什么？\n  4. 算法题，一道背包问题，写完有点小bug调了一会；\n  5. 设计题，根据ip地址查找对应城市，用二分\n  6. 没问啥八股\n\n聊完反问也没问啥，因为一二面想问的基本都问完了。\n\n过了两天oc了。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569975950658605056?sourceSSR=users",
        "title": "百度-搜索在线架构-实习面经（库存）",
        "content": "## 一面\n\nC++：\n\n  * 介绍一下多态\n  * 虚函数实现原理、优点、缺点（效率和内存）\n\ngdb：\n\n  * 用 gdb 调试过的最复杂的项目、如何调试、用到了哪些指令\n  * 如何处理堆栈中某些函数乱码\n  * 如何观察堆栈中某些函数的某个变量的值是多少\n\nKafka：\n\n  * 介绍一下 Kafka 持久化\n  * Kafka 是基于内存还是磁盘（磁盘）\n  * 为什么 Kafka 基于磁盘性能反而更好\n  * 了解 Kafka 吞吐量是多少吗\n\nNetwork：\n\n  * 建立一个 TCP 连接需要消耗哪些系统资源\n  * 了解 TCP 缓冲区多大吗（一般为几 KB 到几 MB 之间）\n\nOS：\n\n  * 为什么 CPU 要绑在特定的核上（Linux 自己调度不可以吗）\n  * 了解 CPU 多级缓存吗\n  * 为什么缓存序号越小速度越快\n\nperf：\n\n  * perf 底层原理\n  * perf 火焰图中有些函数找不到是什么原因\n\nLeetCode：\n\n  * 将一个 64 位的整数第 m～n 位置为 0（不允许使用循环）\n\nExpand：\n\n  * 虚函数表指针占用几个字节（32 位下占用 4 个字节）\n  * 如何用 gdb 调试多线程服务\n\n## 二面\n\nOS：\n\n  * 堆和栈的区别、优点、缺点（性能角度）\n  * 产生死锁的四个必要条件（互斥、占有并等待、非抢占、循环等待）\n\ngRPC：\n\n  * 介绍一下 protobuf 以及其他竞品\n\nLeetCode：\n\n  * 环形链表（No. 141）并证明有效性\n  * 打家劫舍 II（No. 213）\n  * 多个有序数组求交集（搜索场景：数据量大且稠密程度不同）\n\nDistributed：\n\n  * 一致性哈希算法（场景题）\n\n## 说明\n\n当时面完八月份就去实习了，组长比较喜欢招聪明的实习生，只不过他认为的聪明就是算法题写的很快。组内氛围其他帖子说过，不多赘述了，总的来说人际关系氛围不错，组长很平易近人，但工作氛围个人不适应，感觉很多工作都很难开展。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569994593509376000?sourceSSR=users",
        "title": "得物前端实习一面",
        "content": "  1. 自我介绍\n  2. ES6新特性\n  3. Promise实现原理\n  4. setTimeout如何实现这中功能呢（这里没太听懂面试官的意思\n  5. vue的响应式原理\n  6. vue diff算法\n  7. vue2和vue3的异同点\n  8. 对React的认识\n  9. 使用过哪些hooks\n  10. useEffect和useLayoutEffect有什么区别\n  11. hooks的规则有哪些？ 为什么要这样写？\n  12. 简历中nestjs有项目经验吗？有哪些功能模块功能？\n  13. 角色校验模块有哪核心点呢？\n  14. vue和react哪个更熟悉呢？\n  15. 数组的api？\n  16. js里面空间改变成时间的案例？（没听懂意思，面试官直接过了\n  17. 封装组件需要考量哪些问题呢？（颗粒度，复用性、样式隔离、\n  18. 性能优化？\n  19. 用过Antd吗？（看过一点源码\n  20. 可以实习多久呢？可以不可以随时到岗？\n  21. 反问： 业务：CURD项目 技术栈：React\n\n只面了二十分钟，还是算上自我介绍的时间~~~\n\n25号面的 估计是挂了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569973288428904448?sourceSSR=users",
        "title": "【秋招】数分offer大赏",
        "content": "金九银十铜十一摆烂十二，想想还是给自己秋招画个总结句号\n\n**bg：** 中流985+港三硕，5段非大厂数分实习，无科研无奖\n\n**找工作方向：** 数据分析师/数据挖掘师/产品经理\n\n**timeline：** 8月开始，9月爆满，10月爆满，11月零零散散，12月收尾\n\n**offer：** pingan、蚂蚁金服、PDD、oppo、SF、淘天\n\n数分的薪资基本上比较接近，薪资范围在n*15——(n+5)*15，有烂大白菜也有大sp，越晚拿到的offer薪资越低\n\n工作地点聚集在珠三角和长三角，北京投的最多但是颗粒无收\n\n笔试：\n\n数分的卷子，上知天文下知地理，一般都和软工、算法一起考，出题范围经常远超数分应有的难度和知识库。建议自学部分计算机基础、网络安全、数据结构，同时保证数分体系内的题不会出错\n\n面试：\n\n简历相关必须非常的了解，同时能够有自己的思考深挖背后逻辑以及存在的商业价值，数分目前很看产出和思考\n\n数理基础、统计学概率论、机器学习深度学习、SQLPython，虽然没有手撕代码但是也要做题目讲逻辑\n\n商业逻辑没事多看‘人人都是产品经理’，很多面试题的思路都可以找到，剩下的就是具体问题具体分析\n\n学会包装自己包装项目包装实习，面试面的是基本功更是你的沟通表达能力\n\n态度：\n\n自信强势，虽然本人菜的一笔但是依旧认为面试是需要大胆张口说自己的想法和思路的。害羞或者嘟嘟囔囔很容易被面试官刷下来，一定要带着一副老子就是全世界最牛逼的心态去面试\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569974504026378240?sourceSSR=users",
        "title": "快手-用户增长-秋招面经（库存）",
        "content": "## 一面\n\nC++：\n\n  * 派生类继承基类时、虚函数表内的函数是何时替换的\n  * 指向派生类的基类指针、强转为 `void*` 再转为基类指针、此时调用虚函数会发生什么（正常）\n\nProject：\n\n  * 使用 perf 排查程序性能的高端经历（例如尽量避免使用虚函数、vector 预定空间避免频繁扩容等）\n\nLeetCode：\n\n  * 反转链表 `[l, r]` 区间内的所有节点、返回新链表的头节点\n\n## 二面\n\nC++ & Webserver：\n\n  * 线程池实现步骤\n  * 存放线程执行任务的结构体或者类型是什么（`std::function`）\n  * 线程 A 如何向线程 B 发起异步请求并获取到处理结果、接口是什么\n  * 介绍一下智能指针\n  * 了解哪些设计模式（单例、工厂、建造者）\n  * 泛型编程使用经验\n\nProject：\n\n  * 为什么要使用 cgroup 进行绑核、有没有了解过其他方案（namespace）\n  * C++ 中 CPU 绑核的 API 是什么（`sched_setaffinity`）\n  * 如果车端 CPU 开销超过原有的 11 个核怎么办\n\nScene Questions：\n\n  * 按行和按列遍历二维数组在性能上的差异\n  * 死循环中执行 `i++` 自增操作后睡眠 1ms、CPU 占用是怎么样的\n\nLeetCode：\n\n  * 手撕 shared_ptr\n  * 平衡二叉树（No. 110）\n\n## 后续\n\n九月份面的，当时告知二面通过，会约三面，然后就没有然后了。现在还没挂，就挺搞笑的。\n\n![](https://uploadfiles.nowcoder.com/images/20231228/908639282_1703764508300/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569917525962530816?sourceSSR=users",
        "title": "互联网大厂笔试基础算法-前缀和（一维&二维）算法讲解",
        "content": "前缀和算法作为一种基础算法，在笔试面试中遇到的次数很多，不管是秋招，春招还是暑期实习，因此还是建议大家熟练掌握，学会使用前缀和算法的模版即可~\n\n## 算法讲解\n\n前缀和算法，是用来快速求解数组中某一个区间的区间和的值，如果对于每一个询问，都可以在![](https://www.nowcoder.com/equation?tex=O\\(1\\)&preview=true)的时间复杂度内快速求解，如果使用枚举的思想，则平均复杂度为![](https://www.nowcoder.com/equation?tex=O\\(n\\)&preview=true)，远高于![](https://www.nowcoder.com/equation?tex=O\\(1\\)&preview=true)的复杂度，那么前缀和是如何做到这一点的，其实是通过区间拆分+预处理的思想得到的，预处理的复杂度为![](https://www.nowcoder.com/equation?tex=O\\(n\\)&preview=true)\n\n### 算法步骤\n\n对于给定的一个数组，如下图所示，其中，0~8为数组的下标\n![alt](https://uploadfiles.nowcoder.com/files/20231228/757525878_1703750835429/a1612350-aed7-425a-9637-8dd7eb040ea7.png)\n\n那么，对于数组任意的一个区间范围![](https://www.nowcoder.com/equation?tex=%5Bi%2Cj%5D&preview=true)，如何快速地求解它的区间和？\n\n首先，我们可以看几个例子\n\n![](https://www.nowcoder.com/equation?tex=%5B0%2C2%5D&preview=true)的区间和为![](https://www.nowcoder.com/equation?tex=w%5B0%5D%2Bw%5B1%5D%2Bw%5B2%5D%3D1%2B2%2B4%3D7&preview=true)\n\n![](https://www.nowcoder.com/equation?tex=%5B1%2C3%5D&preview=true)的区间和为![](https://www.nowcoder.com/equation?tex=w%5B1%5D%2Bw%5B2%5D%2Bw%5B3%5D%3D2%2B4%2B5%3D11&preview=true)\n\n我们可以预处理一个前缀和数组![](https://www.nowcoder.com/equation?tex=s&preview=true)，其中![](https://www.nowcoder.com/equation?tex=s%5Bi%5D&preview=true)表示区间![](https://www.nowcoder.com/equation?tex=%5B0%2Ci%5D&preview=true)的区间和，那么我们很容易得出![](https://www.nowcoder.com/equation?tex=s%5Bi%5D&preview=true)的递推式\n\n![](https://www.nowcoder.com/equation?tex=s%5Bi%5D%3Ds%5Bi-1%5D%2Bw%5Bi%5D%2Cs%5B0%5D%3Dw%5B0%5D&preview=true)\n\n根据上述式子，我们可以得到一个前缀和数组，如下图所示\n\n![alt](https://uploadfiles.nowcoder.com/files/20231228/757525878_1703750851704/3bc54f76-811d-4be8-9fbd-\naa5c890cb847.png)\n\n我们知道，对于区间![](https://www.nowcoder.com/equation?tex=%5B0%2Ci%5D&preview=true)的前缀和为![](https://www.nowcoder.com/equation?tex=s%5Bi%5D&preview=true)，区间![](https://www.nowcoder.com/equation?tex=%5B0%2Cj%5D&preview=true)的前缀和为![](https://www.nowcoder.com/equation?tex=s%5Bj%5D&preview=true)，则区间![](https://www.nowcoder.com/equation?tex=%5Bj%2Ci%5D&preview=true)的前缀和为![](https://www.nowcoder.com/equation?tex=s%5Bi%5D-s%5Bj-1%5D&preview=true)，具体计算方式如下：\n\n![](https://www.nowcoder.com/equation?tex=%5Bj%3Ai%5D%E5%8C%BA%E9%97%B4%E5%92%8C%3Dw%5Bi%5D%2Bw%5Bi%2B1%5D%2B...w%5Bj%5D&preview=true)\n\n![](https://www.nowcoder.com/equation?tex=s%5Bi%5D%3Dw%5B0%5D%2Bw%5B1%5D%2B...w%5Bi%5D%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20%5C%20\\(1\\)&preview=true)\n\n![](https://www.nowcoder.com/equation?tex=s%5Bj-1%5D%3Dw%5B0%5D%2Bw%5B1%5D%2B...w%5Bj-1%5D%5C%20%5C%20%5C%20%5C%20\\(2\\)&preview=true)\n\n**根据(1),(2)式子作差可得**\n：![](https://www.nowcoder.com/equation?tex=%5Bj%3Ai%5D%E5%8C%BA%E9%97%B4%E5%92%8C%3Ds%5Bi%5D-s%5Bj-1%5D&preview=true)\n\n因此，我们只需要预处理出前缀和数组，就可以根据上述计算公式，快速地计算出任意一个区间的区间和，在实际笔试或者面试中，**为了减少边界情况的考虑，我们更习惯性地将数组下标设置为从1开始**\n。\n\n### 应用场景\n\n  * **一维前缀和** 主要是用于**快速地求解某一个区间和** ，但是前缀和是**静态的算法** ，就是说这个数组中每一个元素的值不能被修改，如果要一边修改一边动态查询，就需要使用**树状数组** 或者**线段树** 这种数据结构来实现动态查询。\n\n  * 二维前缀和**主要是针对二维场景** ，比如对于一个矩阵，矩阵的长度为![](https://www.nowcoder.com/equation?tex=n&preview=true)，宽度为![](https://www.nowcoder.com/equation?tex=m&preview=true)，它对应有![](https://www.nowcoder.com/equation?tex=n*m&preview=true)个整数点，每一个点对应的权值不同，使用二维前缀和可以快速求出起点为![](https://www.nowcoder.com/equation?tex=\\(x1%2Cy1\\)&preview=true)，终点为![](https://www.nowcoder.com/equation?tex=\\(x2%2Cy2\\)&preview=true)的小矩形的权值和。\n\n**注意** ：本算法一般是基础算法，笔试中**很少会单独考察** ，一般会**结合哈希表，动态规划，贪心等算法考察** 。\n\n## 算法模版\n\n### 一维前缀和模版\n\n**题目描述**\n\n输入一个长度为`n`的整数序列。\n\n接下来再输入`m`个询问，每个询问输入一对`l,r`\n\n对于每个询问，输出原序列中从第`l`个数到第`r`个数的和。\n\n**输入格式**\n\n> 第一行包含两个整数`n`和`m`。\n>\n> 第二行包含`n`个整数，表示整数数列。\n>\n> 接下来`m` 行，每行包含两个整数`l` 和`r`，表示一个询问的区间范围。\n\n**输出格式**\n\n> 共`m`行，每行输出一个询问的结果。\n\n**数据范围**\n\n>\n> ![](https://www.nowcoder.com/equation?tex=1%5Cle%20l%5Cle%20r%5Cle%20n%20&preview=true)\n>\n>\n> ![](https://www.nowcoder.com/equation?tex=1%5Cle%20n%2Cm%20%5Cle%2010%5E5&preview=true)\n>\n>\n> ![](https://www.nowcoder.com/equation?tex=-10%5E3%5Cle%20%E6%95%B0%E5%88%97%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC%20%5Cle%2010%5E3&preview=true)\n\n**输入样例**\n\n    \n    \n    5 3\n    2 1 3 6 4\n    1 2\n    1 3\n    2 4\n    \n\n**输出样例**\n\n    \n    \n    3\n    6\n    10\n    \n\n**题解** ：**前缀和模板题** ，大家直接把这个**板子背过就行** ，笔试中遇到就直接套用即可\n\n  * cpp\n  * java\n  * python\n\n    \n    \n    #include <iostream>\n    using namespace std;\n    const int N = 1e+6 + 10;\n    int a[N], S[N],n,m;\n    int main()\n    {\n        cin>>n>>m;\n        for(int i = 1; i <= n; i++)cin>>a[i];\n        for(int i=1;i<=n;i++)\n        S[i]=S[i-1]+a[i];\n        while (m--)\n        {\n            int l;int r;\n            cin>>l>>r;\n            printf(\"%d\\n\",S[r]-S[l-1]);\n        }\n        return 0;\n    }\n    \n    \n    \n    import java.util.Scanner;\n    \n    public class Main {\n        public static void main(String[] args) {\n            Scanner sc = new Scanner(System.in);\n            int N = 1000005;\n            int[] a = new int[N];\n            int[] S = new int[N];\n    \n            int n = sc.nextInt();\n            int m = sc.nextInt();\n    \n            for (int i = 1; i <= n; i++) {\n                a[i] = sc.nextInt();\n                S[i] = S[i - 1] + a[i];\n            }\n    \n            while (m-- > 0) {\n                int l = sc.nextInt();\n                int r = sc.nextInt();\n                System.out.println(S[r] - S[l - 1]);\n            }\n    \n            sc.close();\n        }\n    }\n    \n    \n    \n    n, m = map(int, input().split())\n    a = [0] * (n + 1)\n    S = [0] * (n + 1)\n    \n    a[1:n + 1] = map(int, input().split())\n    \n    for i in range(1, n + 1):\n        S[i] = S[i - 1] + a[i]\n    \n    for _ in range(m):\n        l, r = map(int, input().split())\n        print(S[r] - S[l - 1])\n    \n\n### 二维前缀和模版\n\n**题目描述**\n\n输入一个 ![](https://www.nowcoder.com/equation?tex=n&preview=true) 行\n![](https://www.nowcoder.com/equation?tex=m&preview=true)列的整数矩阵，再输入![](https://www.nowcoder.com/equation?tex=q&preview=true)\n个询问，每个询问包含四个整数\n![](https://www.nowcoder.com/equation?tex=x1%2Cy1%2Cx2%2Cy2&preview=true)，表示一个子矩阵的左上角坐标和右下角坐标。\n\n对于每个询问输出子矩阵中所有数的和。\n\n**输入格式**\n\n第一行包含三个整数 ![](https://www.nowcoder.com/equation?tex=n%2Cm%2Cq&preview=true)。\n\n接下来\n![](https://www.nowcoder.com/equation?tex=n&preview=true)行，每行包含![](https://www.nowcoder.com/equation?tex=m&preview=true)个整数，表示整数矩阵。\n\n接下来![](https://www.nowcoder.com/equation?tex=q&preview=true)行，每行包含四个整数\n![](https://www.nowcoder.com/equation?tex=x1%2Cy1%2Cx2%2Cy2&preview=true)，表示一组询问。\n\n**输出格式**\n\n共 ![](https://www.nowcoder.com/equation?tex=q&preview=true) 行，每行输出一个询问的结果。\n\n**数据范围**\n\n![](https://www.nowcoder.com/equation?tex=1%5Cle%20n%2Cn%20%5Cle%201000&preview=true)\n\n![](https://www.nowcoder.com/equation?tex=1%5Cle%20q%20%5Cle%202*10%5E5&preview=true)\n\n![](https://www.nowcoder.com/equation?tex=1%5Cle%20x1%5Cle%20x2%5Cle%20n&preview=true)\n\n![](https://www.nowcoder.com/equation?tex=1%5Cle%20y1%20%5Cle%20y2%20%5Cle%20m&preview=true)\n\n![](https://www.nowcoder.com/equation?tex=%E2%88%92100%5Cle%20%E7%9F%A9%E9%98%B5%E5%86%85%E5%85%83%E7%B4%A0%E7%9A%84%5Cle%20100&preview=true)\n\n**输入样例**\n\n    \n    \n    3 4 3\n    1 7 2 4\n    3 6 2 8\n    2 1 2 3\n    1 1 2 2\n    2 1 3 4\n    1 3 3 4\n    \n\n**输出样例**\n\n    \n    \n    17\n    27\n    21\n    \n\n二维前缀和模板题，这里给大家提供多语言版本的代码模版，大家背过就行，笔试的时候直接拿出来用即可。\n\n  * cpp\n  * java\n  * python\n\n    \n    \n    #include <iostream>\n    #include <cstring>\n    #include <algorithm>\n    \n    using namespace std;\n    \n    const int N = 1010;\n    \n    int n, m, q;\n    int a[N][N], s[N][N];\n    \n    int main()\n    {\n        cin >> n >> m >> q;\n    \n        for (int i = 1; i <= n; i ++ )\n            for (int j = 1; j <= m; j ++ )\n                cin >> a[i][j], s[i][j] = s[i][j - 1] + s[i - 1][j] - s[i - 1][j - 1] + a[i][j];\n    \n        while (q -- )\n        {\n            int x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            cout << s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1] << endl;\n        }\n        return 0;\n    }\n    \n    \n    \n    import java.util.Scanner;\n    public class Main{\n        public static void main(String[] args){\n            Scanner scan = new Scanner(System.in);\n            int n = scan.nextInt();\n            int m = scan.nextInt();\n            int q = scan.nextInt();\n            int[][] a = new int[n+1][m+1];\n            int[][] s = new int[n+1][m+1];\n            for(int i = 1 ; i <= n  ; i ++ ){\n                for(int j = 1 ;j <= m ; j ++ ){\n                    a[i][j] = scan.nextInt();\n                }\n            }\n            for(int i = 1 ; i <= n  ; i ++ ){\n                for(int j = 1 ;j <= m ; j ++ ){\n                    s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];\n                }\n            }\n            while(q-->0){\n                int x1 = scan.nextInt();\n                int y1 = scan.nextInt();\n                int x2 = scan.nextInt();\n                int y2 = scan.nextInt();\n                System.out.println(s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1]);\n            }\n        }\n    }\n    \n    \n    \n    N = 1010\n    a = [[0]*N for _ in range(N)]\n    s = [[0]*N for _ in range(N)]\n    \n    n,m,q = map(int,input().split())\n    \n    for i in range(1,n+1):\n        a[i] = [0] + list(map(int,input().split())) + a[m+1:]\n    \n    for i in range(1,n+1):\n        for j in range(1,m+1):\n            s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j]\n    \n    while q:\n        x1,y1,x2,y2 = map(int,input().split())\n        print(s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1])\n        q -= 1\n    \n\n## 算法练习\n\n大家可以使用上述模版完成两道LeetCode的练习题\n\n一维前缀和：[****************************](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fcount-\nvowel-strings-in-ranges%2F)\n\n二维前缀和：[******************************](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fleetcode.cn%2Fproblems%2Frange-\nsum-query-2d-immutable%2Fdescription%2F)\n\n以上内容均来自于[******](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxuq7bkgch1.feishu.cn%2Fdocx%2FBodwdmrbnojrdlxDmYLc6vzsnxe)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569842395701903360?sourceSSR=users",
        "title": "北京某公司（一面1h oc）",
        "content": "  1. 自我介绍\n  2. 问项目\n  3. 对其他语言有了解吗，讲一下go语言\n  4. 面试官是go，让我给他以不懂得角度，讲什么是jvm\n  5. 讲一下进程线程\n  6. jvm的进程线程怎么到操作系统内核的\n  7. 怎么判断一个程序是否是多进程多线程\n  8. 有哪些命令可以查看查看进程和端口\n  9. Redis是单线程吗，IO怎么实现实现，IO多路复用\n  10. 零拷贝，写时复制\n  11. 力扣347，102\n\n说了一下主要的工作内容\n\n忘了录音，有些忘了，全程操作系统，不是太熟悉，给问蒙了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569835572097814528?sourceSSR=users",
        "title": "接上，某中厂二面",
        "content": "  1. 项目中责任链模式具体怎么做的\n  2. 项目中BinLog配合RocketMQ实现缓存一致性具体怎么做的\n  3. 布隆过滤器如何解决缓存穿透的\n  4. 三次握手\n  5. 一道算法：反转链表\n\n半小时技术，十分钟情况交流，面试体验还行，之前hr说二面没技术，搞得我大意了，都答出来了，不过有点磕磕绊绊。希望OC\n\n\\--------------\n\n已过\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569857197140672512?sourceSSR=users",
        "title": "笔试ACM模式图论建图模板（Java&Python&C++）",
        "content": "互联网笔试中图论的题目比例很多，不管是基础的DFS,BFS，还是涉及到一些算法，如拓扑排序，dijkstra等，都离不开图的构建，LeetCode中的二叉树类型的题目，以及图论的题目，都是已经提供好对应的领接表或者领接矩阵，所以对于初学者来说，还是有必要去学习一下图论中的相关知识点，以及如何构建图的关系的。\n\n#### 树\n\n树这个数据结构，相信看过一些后端八股，比如MySQL，Redis，又或者刷过一些数据结构题目的同学，一定对这种结构比较熟悉，树是由![n（n\\\\ge\n1\\)](https://hr.nowcoder.com/equation?tex=n%EF%BC%88n%5Cge%201\\)&preview=true)个有限节点组成一个**具有层次关系的集合**\n。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。\n\n**树有以下特点**\n\n  * 每个节点具有0个或多个子节点\n  * 没有父节点的节点被称为根节点\n  * 每一个非根节点只有一个父节点\n  * 每一个节点及其后代节点整体可以被视为一个树\n\n树中有一类很特殊的树：二叉树，二叉树是一种特殊的树，其中任何一个节点具有的子节点个数不超过2，因此被称为二叉树，如下图所示，就是一个根节点为1的二叉树。1号节点的子节点是2和3,2节点的子节点是4和5，3节点的子节点是6和7。\n\n![](https://uploadfiles.nowcoder.com/images/20231228/757525878_1703735884944/69B05851F2FE58A175066F1E5DA68C38)\n\n#### 图\n\n那么树与图具有什么关系呢？其实树是一种特殊的图，就是**有向无环图** 。\n\n  * 有向，指的是有方向，比如上面这张图，**箭头的方向就表示了其是一个有向图** ，对于二叉树而言，在递归搜索的时候，你可以从父节点搜到子节点，但是你不能从子节点搜索到父节点\n  * 无环，不能自己指向自己（自环），或者由多个节点构成一个环，比如`a->b`,`b->c`,`c->a`，这就构成了一个环，对于树这种数据结构，从根节点出发是自顶向下的，是不会存在环的一个关系的，因此树一定是一种无环图。\n\n![](https://uploadfiles.nowcoder.com/images/20231228/757525878_1703735923225/420D92A1E247C53D80820F445882CE54)\n\n#### 图论基本概念\n\n**入度** ：**指向当前节点的有向边的数量** ，比如有一条a->b的有向边，则节点b的入度为1\n\n**出度** ：**当前节点被指向的有向边的数量** ，比如有一条a->b的有向边，则节点a的出度为1\n\n**注意** ：如果在一个有向图中，一个节点的**入度为0**\n，那么该节点，就是一个没有父节点的根节点。比如**拓扑排序中，起始的入队元素就是入度为0的所有点** 。**邻接矩阵**\n：邻接矩阵是一种常见的图的存储结构，用于表示顶点之间的关系。它使用一个**二维数组来表示图中顶点之间的连接关系**\n，其中数组的行和列分别代表图中的顶点，而数组中的元素表示顶点之间是否有边相连，以及边的权重。如果顶点![i](https://hr.nowcoder.com/equation?tex=i&preview=true)和顶点![j](https://hr.nowcoder.com/equation?tex=j&preview=true)之间有边相连，则邻接矩阵中的元素![A\\[i\\]\\[j\\]为1](https://hr.nowcoder.com/equation?tex=A%5Bi%5D%5Bj%5D%E4%B8%BA1&preview=true)（或边的权重），否则为0。比如有如下无向图\n\n![](https://uploadfiles.nowcoder.com/images/20231228/757525878_1703735949682/B33D0AEDB05DBBE0A43F62D94C9A4ABE)\n\n邻接矩阵表示为：\n\n    \n    \n      0  1  0  1\n      1  0  1  1\n      0  1  0  1\n      1  1  1  0\n    \n\n**邻接表** ：邻接表是另一种常见的图的存储结构，它使用**一个数组和链表来表示图中的顶点和它们的邻接顶点**\n。具体来说，数组中的每个元素代表图中的一个顶点，而每个元素对应的链表存储了与该顶点相邻的顶点。比如有如下无向图\n\n![](https://uploadfiles.nowcoder.com/images/20231228/757525878_1703735965929/B33D0AEDB05DBBE0A43F62D94C9A4ABE)\n\n邻接表表示为：\n\n    \n    \n    1:  2 -> 4  #表示1有2和4与它相连\n    2:  1 -> 3\n    3:  2 -> 4\n    4:  1 -> 3\n    \n    \n\n这篇文章讲解领接表的质量还是相当不错的，可以供大家参考：[领接表讲解](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F618361957)\n\n### 建图模版\n\n笔试中常考的建图，一般都是需要使用**领接表建图**\n\n对于一般的BFS或者DFS来说，很多题目是没有边权这种说法的，那么就可以直接使用下面的点权建图模版建图，如果有边权，则可以使用下面的边权模版建图，如果边权在点上，仍然可以使用下面的边权模版建图。\n\n常用的建图方法主要是有**点权建图**(权值在节点上)，**边权建图**(权值在边上)，还有一种就是使用**离散化建图** （使用哈希表）\n\n#### 领接表点权建图\n\n权值在点上，对应点有权值，对于C++选手来说，可以使用`vector`来优化建图，并维护一个`w`数组来记录点权\n\n**输入样例**\n\n`n`个点，`m`条边，每行输入两个整数`a`，`b`，表示`a->b`连接一条**有向边**\n\n最后一行输入`n`个整数，表示`n`个点的点权\n\n    \n    \n    4 3\n    1 2\n    2 3\n    3 4\n    1 2 3 4\n    \n    \n\n**C++**\n\n    \n    \n    #include <bits/stdc++.h>\n    using namespace std;\n    const int N=1E5+10;\n    vector<int>g[N];  //领接表的vector写法 仅适用于点权建图\n    int w[N];\n    void dfs(int u,int fa) //如果是有向图 就不需要fa这个变量\n    {\n        //do things\n        for(int &x:g[u]) //访问u的所有节点\n        {\n            if(x==fa)continue; //无向边才需要这一句 保证每个节点只会被访问一次(不理解的可以直接背过)\n            dfs(x,u);\n            // do things\n        }\n    }\n    \n    int main(){\n        int n,m;  //n个点,m条边\n        cin>>n>>m;\n        for(int i=0;i<m;i++){\n            int a,b;\n            cin>>a>>b;\n            g[a].push_back(b);  //a->b建立一条边\n        }\n        for(int i=1;i<=n;i++)cin>>w[i];\n        return 0;\n    }\n    \n    \n\n**Java**\n\n    \n    \n    import java.util.Scanner;\n    import java.util.ArrayList;\n    \n    public class Main {\n        static final int N = 100010;\n        static ArrayList<Integer>[] g = new ArrayList[N];\n        static int[] w = new int[N];\n    \n        static void dfs(int u, int fa) {\n            // Do things\n            for (int x : g[u]) {\n                if (x == fa)\n                    continue;\n                dfs(x, u);\n                // Do things\n            }\n        }\n    \n        public static void main(String[] args) {\n            int n, m;\n            Scanner scanner = new Scanner(System.in);\n            n = scanner.nextInt();\n            m = scanner.nextInt();\n    \n            for (int i = 1; i <= n; i++) {\n                g[i] = new ArrayList<>();\n            }\n    \n            for (int i = 0; i < m; i++) {\n                int a, b;\n                a = scanner.nextInt();\n                b = scanner.nextInt();\n                g[a].add(b);  // a->b建立一条边\n            }\n    \n            for (int i = 1; i <= n; i++) {\n                w[i] = scanner.nextInt();\n            }\n        }\n    }\n    \n    \n\n**Python3**\n\n    \n    \n    N = 100010\n    g = [[] for _ in range(N)]\n    w = [0] * N\n    \n    def dfs(u, fa):\n        # Do things\n        for x in g[u]:\n            if x == fa:\n                continue\n            dfs(x, u)\n            # Do things\n    \n    n, m = map(int, input().split())\n    for i in range(m):\n        a, b = map(int, input().split())\n        g[a].append(b)  # a->b建立一条边\n    \n    w[1:] = map(int, input().split())\n    \n    \n\n#### 领接表边权建图\n\n权值在边上，对应点有权值，对于C++选手来说，可以使用`vector`来优化建图，不过需要使用`pair<int,int>`这个类型来分别存储节点和边权\n\n**输入样例**\n\n`n`个点，`m`条边，每行输入三个整数a,b,c 表示`a->b`连接一条边权为`c`的**无向边**\n\n    \n    \n    4 3\n    1 2 3\n    2 3 2\n    3 4 2\n    \n    \n\n**C++**\n\n    \n    \n    #include<bits/stdc++.h>\n    using namespace std;\n    typedef pair<int,int>PII;\n    #define x first\n    #define y second\n    typedef long long ll;\n    const int N=1E5+10;\n    vector<PII>g[N];\n    int n,f[N];\n    void dfs(int u,int fa){\n        for(auto &[x,w]:g[u]){\n            if(x==fa)continue;\n            dfs(x,u);\n            //代码逻辑\n        }\n    }\n    int main(){\n        cin>>n;\n        for(int i=1;i<n;i++){\n            int a,b,c;\n            cin>>a>>b>>c;\n            g[a].push_back({b,c});\n            g[b].push_back({a,c});\n        }\n        return 0;\n    }\n    \n    \n\n**Java**\n\n    \n    \n    import java.util.ArrayList;\n    import java.util.List;\n    import java.util.Scanner;\n    \n    public class Main {\n        static List<int[]>[] g;\n        static int n;\n        static int[] f;\n    \n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            n = scanner.nextInt();\n            g = new ArrayList[n + 1];\n            for (int i = 1; i <= n; i++) {\n                g[i] = new ArrayList<>();\n            }\n            f = new int[n + 1];\n    \n            for (int i = 1; i < n; i++) {\n                int a = scanner.nextInt();\n                int b = scanner.nextInt();\n                int c = scanner.nextInt();\n                g[a].add(new int[]{b, c});\n                g[b].add(new int[]{a, c});\n            }\n        }\n    \n        static void dfs(int u, int fa) {\n            for (int[] pair : g[u]) {\n                int x = pair[0];\n                int w = pair[1];\n                if (x == fa) continue;\n                dfs(x, u);\n                //代码逻辑\n            }\n        }\n    }\n    \n    \n\n**Python3**\n\n    \n    \n    from collections import defaultdict\n    \n    n = int(input())\n    g = defaultdict(list)\n    f = [0] * (n + 1)\n    \n    def dfs(u, fa):\n        global f\n        for x, w in g[u]:\n            if x == fa:\n                continue\n            dfs(x, u)\n            #代码逻辑\n    \n    for _ in range(1, n):\n        a, b, c = map(int, input().split())\n        g[a].append((b, c))\n        g[b].append((a, c))\n    \n    \n\n#### 离散化建图\n\n一般用于点的范围较大(![\\[-10^9,10^9\\]](https://hr.nowcoder.com/equation?tex=%5B-10%5E9%2C10%5E9%5D&preview=true))，或者含有负数的点，一般会使用离散化建图，或者有的不是点，而是**字符串与字符串之间存在相互转换的关系**\n，就可以使用哈希表这种数据结构来实现离散化建图。\n\n**C++**\n\n    \n    \n    #include<bits/stdc++.h>\n    using namespace std;\n    int main() {\n        unordered_map<int, vector<pair<int, int>>> path;\n    \n        // 添加节点 1 到节点 2 的边权为 3\n        path[1].push_back({2, 3});\n    \n        // 遍历节点 1 的所有能到的点和边权\n        int node = 1;\n        for (auto &entry : path[node]) {\n            int target = entry.first;\n            int weight = entry.second;\n            // 进行处理\n            cout << \"From node \" << node << \" to node \" << target << \" with weight \" << weight << endl;\n        }\n    \n        return 0;\n    }\n    \n    \n\n**Java**\n\n    \n    \n    import java.util.*;\n    \n    public class Main {\n        public static void main(String[] args) {\n            int N = 100010;\n            Map<Integer, List<Map.Entry<Integer, Integer>>> path = new HashMap<>();\n            \n            // 添加节点 u 到节点 v 的边权为 w\n            int u = 1, v = 2, w = 3;\n            if (!path.containsKey(u)) {\n                path.put(u, new ArrayList<>());\n            }\n            path.get(u).add(new AbstractMap.SimpleEntry<>(v, w));\n            \n            // 遍历节点 u 的所有能到的点和边权\n            int node = 1;\n            if (path.containsKey(node)) {\n                for (Map.Entry<Integer, Integer> entry : path.get(node)) {\n                    int target = entry.getKey();\n                    int weight = entry.getValue();\n                    // 进行处理\n                }\n            }\n        }\n    }\n    \n    \n\n**Python3**\n\n    \n    \n    from collections import defaultdict\n    \n    n = int(input())\n    g = defaultdict(list)\n    f = [0] * (n + 1)\n    \n    def dfs(u, fa):\n        global f\n        for x, w in g[u]:\n            if x == fa:\n                continue\n            dfs(x, u)\n            #代码逻辑\n    \n    for _ in range(1, n):\n        a, b, c = map(int, input().split())\n        g[a].append((b, c))\n        g[b].append((a, c))\n    \n    \n\n#### 真题讲解\n\n下面讲解一道24秋招米哈游的笔试真题，来为大家去看一下笔试中图论题目是如何考察的，以及遇到这种题目，我们如何去处理。\n\n##### 题目描述\n\n塔子哥有一个 ![n](https://hr.nowcoder.com/equation?tex=n&preview=true) 个节点的树，树根编号为\n![1](https://hr.nowcoder.com/equation?tex=1&preview=true) 。\n\n塔子哥可以在叶子节点上添加一个新的儿子节点，添加后，添加的节点变成了新的叶子节点。\n\n若干次操作后，塔子哥想问你距离树根不超过 ![k](https://hr.nowcoder.com/equation?tex=k&preview=true)\n的节点最多可以有多少个。\n\n##### 输入描述\n\n第一行，一个正整数![n](https://hr.nowcoder.com/equation?tex=n&preview=true)\n表示树中节点个数，![k](https://hr.nowcoder.com/equation?tex=k&preview=true) 表示不超过树根的距离，\n\n接下来 ![n-1](https://hr.nowcoder.com/equation?tex=n-1&preview=true) 行，每行输入两个整数\n![u](https://hr.nowcoder.com/equation?tex=u&preview=true) 和\n![v](https://hr.nowcoder.com/equation?tex=v&preview=true) ，表示节点\n![u](https://hr.nowcoder.com/equation?tex=u&preview=true) 和\n![v](https://hr.nowcoder.com/equation?tex=v&preview=true) 之间有一条边。\n\n![1 \\\\leq n \\\\leq 10^5, 1\\\\leq k\\\\leq 10^9, 1\\\\leq u,v\\\\leq\nn](https://hr.nowcoder.com/equation?tex=1%20%5Cleq%20n%20%5Cleq%2010%5E5%2C%201%5Cleq%20k%5Cleq%2010%5E9%2C%201%5Cleq%20u%2Cv%5Cleq%20n&preview=true)\n\n##### 输出描述\n\n一个整数，表示若干次操作后距离树根不超过 ![k](https://hr.nowcoder.com/equation?tex=k&preview=true)\n的节点最大数量。\n\n##### 样例\n\n**输入**\n\n    \n    \n    4 2\n    1 2\n    1 3\n    1 4\n    \n    \n\n****![](https://uploadfiles.nowcoder.com/images/20231228/757525878_1703736035976/7CC738686830E7E69BE37D351E450820)\n\n**输出**\n\n    \n    \n    7\n    \n\n**说明** 若干次操作后，最终的树如下，此时有\n![7](https://hr.nowcoder.com/equation?tex=7&preview=true) 个点距离\n![1](https://hr.nowcoder.com/equation?tex=1&preview=true) 号点的距离小于等于\n![2](https://hr.nowcoder.com/equation?tex=2&preview=true)\n\n****![](https://uploadfiles.nowcoder.com/images/20231228/757525878_1703736054305/CD3DD123767CF3A98F35AC0C78F172F0)\n\n**思路:树形DFS+贡献法计数**\n考虑每一个节点对答案的贡献：如果当前节点距离根节点的距离d有![d \\\\le k](https://hr.nowcoder.com/equation?tex=d%C2%A0%5Cle%C2%A0k&preview=true)，则答案+1\n\n此外，如果当前节点还是叶子节点，则说明还可以再叶子结点下添加![k-d](https://hr.nowcoder.com/equation?tex=k-d&preview=true)个点，这些点可以构成一条链。\n\n因此，我们只需要对以1号点为根的树进行DFS遍历，在遍历的过程中，可以计算出每一个节点到根节点的距离，然后根据上述的规则进行计算，累加答案即可。\n\n根据上述方式统计计数即可，注意本题题目给的是无向边，需要建两条有向边。\n\n**C++**\n\n    \n    \n    #include <bits/stdc++.h>\n    using namespace std;\n    int main()\n    {\n        int n, k;\n        cin >> n >> k;   \n        // 建图\n        vector<vector<int>> g(n);\n        for (int i = 1; i < n; ++i) {\n            int u, v;\n            cin >> u >> v;\n            u--; v--;\n            g[u].emplace_back(v);\n            g[v].emplace_back(u);\n        }\n        const int INF = 0x3f3f3f3f;\n        long long ans = 0;\n        vector<int> dist(n, INF);\n        // 计算1号点到每个点的距离，1号点到自己的距离为 0\n        dist[0] = 0;\n        function<void(int,int)> dfs = [&](int u, int fa) {\n            // 如果1号点到u+1点的距离 <= k，则答案加1\n            if (dist[u] <= k) {\n                ans += 1;\n            }\n    \n            // 如果1号点到叶子的距离 < k，则还可以再这个叶子下加 k - dist[u] 个\n            if (u != 0 && g[u].size() == 1 && dist[u] < k) {\n                ans += k - dist[u];\n            }\n    \n            // 继续遍历子树 v \n            for (int v: g[u]) {\n                if (v == fa) continue;\n                dist[v] = dist[u] + 1;\n                dfs(v, u);\n            }\n        };\n        \n        dfs(0, -1);\n    \n        cout << ans << \"\\n\";\n    \n        return 0;\n    }\n    \n    \n    \n\n**Java**\n\n    \n    \n    import java.util.ArrayList;\n    import java.util.List;\n    import java.util.Scanner;\n    \n    public class Main {\n        static List<List<Integer>> g;\n        static int[] dist;\n        static int n, k;\n        static long ans;\n    \n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            n = scanner.nextInt();\n            k = scanner.nextInt();\n            \n            // 建图\n            g = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                g.add(new ArrayList<>());\n            }\n    \n            for (int i = 1; i < n; i++) {\n                int u = scanner.nextInt() - 1;\n                int v = scanner.nextInt() - 1;\n                g.get(u).add(v);\n                g.get(v).add(u);\n            }\n    \n            final int INF = 0x3f3f3f3f;\n    \n            ans = 0;\n            dist = new int[n];\n            for (int i = 0; i < n; i++) {\n                dist[i] = INF;\n            }\n            // 计算1号点到每个点的距离，1号点到自己的距离为 0\n            dist[0] = 0;\n    \n            dfs(0, -1);\n    \n            System.out.println(ans);\n        }\n    \n        static void dfs(int u, int fa) {\n            // 如果1号点到u+1点的距离 <= k，则答案加1\n            if (dist[u] <= k) {\n                ans++;\n            }\n            // 如果1号点到叶子的距离 < k，则还可以再这个叶子下加 k - dist[u] 个\n            if (u != 0 && g.get(u).size() == 1 && dist[u] < k) {\n                ans += k - dist[u];\n            }\n            // 继续遍历子树 v \n            for (int v : g.get(u)) {\n                if (v == fa) {\n                    continue;\n                }\n                dist[v] = dist[u] + 1;\n                dfs(v, u);\n            }\n        }\n    }\n    \n\n**Python**\n\n    \n    \n    def dfs(u, fa):\n        global ans\n        # 如果1号点到u+1点的距离 <= k，则答案加1\n        if dist[u] <= k:\n            ans += 1\n        # 如果1号点到叶子的距离 < k，则还可以再这个叶子下加 k - dist[u] 个\n        if u != 0 and len(g[u]) == 1 and dist[u] < k:\n            ans += k - dist[u]\n        # 继续遍历子树 v \n        for v in g[u]:\n            if v == fa:\n                continue\n            dist[v] = dist[u] + 1\n            dfs(v, u)\n    \n    \n    n, k = map(int, input().split())\n    \n    # 建图\n    g = [[] for _ in range(n)]\n    for _ in range(1, n):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        g[u].append(v)\n        g[v].append(u)\n    \n    INF = int(1e9)\n    \n    ans = 0\n    dist = [INF] * n\n    # 计算1号点到每个点的距离，1号点到自己的距离为 0\n    dist[0] = 0\n    dfs(0, -1)\n    print(ans)\n    \n\n**以上内容均来自：**[笔试刷题指南](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxuq7bkgch1.feishu.cn%2Fdocx%2FBodwdmrbnojrdlxDmYLc6vzsnxe)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569819046925836288?sourceSSR=users",
        "title": "平面灯阵中寻找最大正方形边界 -  华为机试真题题解",
        "content": "> 分值： 300分\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n现在有一个二维数组来模拟一个平面灯阵，平面灯阵中每个位置灯处于点亮或熄灭，分别对应数组每个元素取值只能为1或0，现在需要找一个正方形边界，其每条边上的灯都是点亮(对应数组中元素的值为1)的，且该正方形面积最大。\n\n## 输入描述\n\n第一行为灯阵的高度(二维数组的行数)\n\n第二行为灯阵的宽度(二维数组的列数)\n\n紧接着为模拟平台灯阵的二维数组arr\n\n1< arr.length <= 200 1< arr[0].length <= 200\n\n## 输出描述\n\n返回满足条件的面积最大正方形边界信息。返回信息[r,c,w],其中r,c分别代表方阵右下角的行号和列号，w代表正方形的宽度。如果存在多个满足条件的正方形，则返回r最小的，若r相同，返回c最小的正方形。\n\n## 示例1\n\n    \n    \n    输入：\n    4\n    5\n    1 0 0 0 1\n    1 1 1 1 1\n    1 0 1 1 0\n    1 1 1 1 1\n    \n    输出：\n    [3,2,3]\n    \n    解释：\n    满足条件且面积最大的正方形边界，其右下角的顶点为[3,2]，即行号为3，列号为2，其宽度为3，因此返回信息为[3,2,3]。\n    \n\n## 示例2\n\n    \n    \n    输入：\n    3\n    3\n    1 0 0\n    0 1 0\n    0 0 1\n    \n    输出：\n    [0,0,1]\n    \n    解释：\n    满足条件且面积最大的正方形边界有三个。即为[0,0,1]、[1,1,1]、[2,2,1],根据要求，如果满足条件有多个，则返r最小，即为 [0,0,1]。\n    \n\n## 题解\n\n> **动态规划** 的题目\n>\n> ### 解题思路\n>\n> 首先，我们需要计算每个位置的左侧和上侧连续为1的数量，以便在后续判断正方形边界时使用。（在代码实现中使用 row_psum 和 col_psum\n> 来实现）\n>\n> 然后，我们遍历二维数组，对每个点 `(r, c)`，检查以该点为右下角的正方形边界，看是否满足条件。\n>\n> 最终，找到满足条件的最大正方形边界，返回其右下角的行号、列号和边长。\n\n### Java\n\n    \n    \n    import java.util.Scanner;\n    \n    /**\n     * @author code5bug\n     */\n    public class Main {\n        // 检查以（r,c）为正方形，宽度为 w 的正方形边界的灯是否都是点亮的\n        static boolean check(int[][] row_psum, int[][] col_psum, int r, int c, int w) {\n            // 下，右边检查\n            if (row_psum[r][c] < w || col_psum[r][c] < w) return false;\n    \n            // 左、上边检查\n            if (col_psum[r][c - w + 1] < w || row_psum[r - w + 1][c] < w) return false;\n    \n            return true;\n        }\n    \n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            int h = scanner.nextInt();\n            int w = scanner.nextInt();\n    \n            int[][] g = new int[h][w];\n            for (int r = 0; r < h; r++) {\n                for (int c = 0; c < w; c++) {\n                    g[r][c] = scanner.nextInt();\n                }\n            }\n    \n            // row_psum[r][c] 表示 （r,c） 左侧连续 1 的数量\n            int[][] row_psum = new int[h][w];\n            // col_psum[r][c] 表示 （r,c） 上侧连续 1 的数量\n            int[][] col_psum = new int[h][w];\n    \n            for (int r = 0; r < h; r++) {\n                for (int c = 0; c < w; c++) {\n                    if (g[r][c] == 0) continue;\n    \n                    row_psum[r][c] = (c > 0 ? row_psum[r][c - 1] : 0) + 1;\n                    col_psum[r][c] = (r > 0 ? col_psum[r - 1][c] : 0) + 1;\n                }\n            }\n    \n            // [r, c, w]\n            int[] result = new int[3];\n    \n            for (int r = 0; r < h; r++) {\n                for (int c = 0; c < w; c++) {\n                    if (g[r][c] == 0) continue;\n    \n                    for (int width = Math.min(r\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569609455097151488?sourceSSR=users",
        "title": "武汉国响 面经 1h20min",
        "content": "线下面\n\n上来先手撕代码 Leetcode 5 最长回文子串 1115 交替打印FooBar\n\n自我介绍\n\n工作室情况\n\n介绍项目\n\n项目里的人工智能算法怎么做的（别人做的）\n\n项目里的高性能条件查询怎么做的 各级缓存，分页冲突\n\nMybatis有几级缓存？怎么去配二级缓存？\n\n异步数据导出方案 两个分布式锁\n\n导出锁有没有考虑不同用户进行操作时的处理行为 直接在权限方面控制住\n\n项目中线程怎么创建的 @Async 追问：有没有改过？×\n\nJava中创建线程的方式？\n\n线程的生命周期？\n\n项目中可视化用的是什么\n\n前端有没有了解 ×\n\n介绍另一个项目\n\n项目中的图片检测（盆间检测 超绿检测）\n\n项目的图片怎么上传的\n\n讲一下集合框架？\n\n优先队列怎么实现的？×\n\nHashMap数据结构？\n\nConcurrentHashMap怎么保证线程安全？\n\nAQS？\n\n重入的底层原理是什么？\n\nCountDownLatch和CyclicBarrier有什么区别？×\n\n会用其他语言吗\n\n微服务核心组件有哪些？\n\n数据库设计有几大原则？×\n\n设计要考虑什么点？\n\nMysql有哪些引擎？\n\n事物的隔离级别？\n\nMysql默认是哪个？\n\n谈谈MVCC？\n\n怎么进行sql优化？ 建索引，优化sql语句还没了解\n\n索引有哪些类型？\n\nB+树和B树有什么区别？时间复杂度有什么变化？ 答的查询时候的时间复杂度\n\n索引什么时候会失效？×\n\nRedis怎么用的\n\nRedis数据类型？\n\nRedis中Set和ZSet区别？\n\nZSet怎么实现的？×\n\nDocker怎么用的\n\n开发文档怎么写的\n\n（闲聊）\n\nChatGPT怎么用的\n\n自己有没有搭过\n\nPOE前段时间是不是升级了\n\n向量数据库用没用过\n\n平时刷不刷算法\n\n反问：\n\n表现怎么样？\n\n业务做什么？\n\nHR问：\n\n学校生活相关\n\n实习时间安排\n\n薪资\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569589472568901632?sourceSSR=users",
        "title": "新奥 秋招",
        "content": "1.观察者模式,以及一些相关问题\n\n2.hashmap底层,红黑树怎么实现,知道一个hashmap一定存在红黑树(不知道他想说啥)\n\n3.你的redis延迟队列怎么实现的\n\n4.tcp为什么是三次连接\n\n反问\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569537781643411456?sourceSSR=users",
        "title": "杭州小厂二面面经",
        "content": "还有一轮技术面，累[牛泪][牛泪][牛泪]\n\n自我介绍\n\n项目拷打（真的拷打了好久）\n\n非常规八股：\n\n  1. 讲一下MVCC\n  2. 讲一下MySQL索引\n  3. 为什么选择B+树\n  4. 创建索引的命令\n  5. 讲一下HashMap遍历方式\n  6. 写代码实现HashMap遍历 删除指定Value的元素\n  7. 为什么不在迭代器里删除元素\n  8. 单向链表排序（我说的归并）\n  9. 怎么实现归并\n  10. 时间复杂度\n  11. 如果是数组还是这个时间复杂度吗\n  12. 背包问题了解吗\n  13. 讲一下贪心怎么实现\n\n反问：对我们公司有什么想问的吗？\n\n进去实习的话是哪个部门\n\n大数据部门或者数据管理部门\n\n还有一面技术面，许愿能面上，别再为难我了[牛泪]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569539133656334336?sourceSSR=users",
        "title": "炉火科技 实习",
        "content": "1.tcp和udp的区别\n\n2.mysql和redis的区别\n\n3.反射和线程池\n\n4.写sql:建数据库,建表,增删改查数据\n\n5帧同步和状态同步\n\n6.rabittmq的流程\n\n7.用过的设计模式,知道那些设计模式\n\n然后聊了一些有点没的\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569537413912039424?sourceSSR=users",
        "title": "邮储数据中心面经",
        "content": "笔试：10月22号笔试，提前刷刷行测也是有必要的，英语有两篇短文，还有一些英语单选，计算机专业知识考的很少。\n\n一面：11月10号，面试时间比较短，数据中心偏运维，当时问我如何看待DevOps，用过什么自动化运维工具，还有就是论文相关内容，还有简历以及八股相关。大概五分钟。\n\n二面：11月30号，领导面试+人力面试，大概15分钟\n\n有一些简历问题，不太难，只要简历上写的能说上来就可以。\n\n开放性问题：\n\n问我的普通本科和其他同学211、985本有区别吗？\n\n如何做好学校和工作中角色的切换。\n\n对数据中心的理解，说说为什么能胜任这个岗位。\n\n论文的具体的改进，简要说一说？\n\n实习中最大的挑战，挑印象最深的说一下。\n\n实习中主要使用哪些技术栈，以及部署的具体技术。\n\n实习中有没有向其他同事请教问题？\n\n户口需求，工作地点考虑之类问题。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569523451044626432?sourceSSR=users",
        "title": "鹰角 策划 已挂 三面面经",
        "content": "*前脚挂后脚马上发早就盘完的面经！\n\n*深感全网狂搜角的面经和流程然后搜不出来的痛苦，希望能帮到后来人\n\n*希望不算透题，不好的话我就改\n\n个人情况和流程：普通美本文科双专业跳级，10个demo（个人和团队都有，6个是gamejam）两三个小奖，一段小厂文案实习\n\n除了角其他厂统统简历挂，无任何笔/面（好吧虽然角最后也挂了）。秋招，很神奇吧.jpg\n\n10.31投简历-11.9一面-11.21二面-11.30BP面-12.26wx拒\n\n三次都聊到55-60min\n\n一面项目面\n\n*面试官哥哥人很好但是感受到了两个i人的微妙尴尬（乐\n\n1.让我挑个demo介绍，浅挖，再挑一个讲叙事差异\n\n2.游戏经历\n\n3.世界观构建&统筹（？）的理解和工作流（我讲得烂烂的\n\n4.玩过哪些重度RPG游戏（都没玩过，大劣势\n\n5.喜欢的影视和动画\n\n6.个人表达比较强烈，但在比较工业化的流程中有没有什么预期和职业规划，能接受吗\n\n7.反问，面试表现不能问，个人评价不好说，最后我脑子抽抽不知道咋蹦出一句可能我是海猫激推吧，然后听到了面试官礼貌的干笑\n\n二面缘分面（？）\n\n*机缘巧合下面试官玩过还记得我的俩demo，或许因此没聊这块（？）\n\n1.岗位认知规划（答得好模糊所以得到了教导，谁边面试边记笔记啊原来是我\n\n2.挖挖实习\n\n3.工作预期，会遇到的困难什么的\n\n4.挖挖学生工作室经历\n\n5.游戏经历\n\n6.诚实地说了玩得不多，所以问为什么选择游戏为创作载体\n\n7.聊创作动机\n\n8.人生相谈，给我职业规划和心理预期建议\n\n9.反问，但我脑子宕机，痛失良机\n\n三面HRBP面\n\n*面试官姐姐人特热情特好，但是有微妙的跳坑不自知感……\n\n1.挖挖实习\n\n2.感觉实习内容和喜好不同，为什么选这家实习？（因为他们公司照片放了很多猫\n\n3.挖挖学生工作室经历\n\n4.岗位理解和工作预期\n\n5.最难的一次合作\n\n6.秋招怎么选岗位（我：我首先选择鹰角网络 BP姐姐：谢谢\n\n7.毕业前规划\n\n8.大学/国外生活的困难\n\n9.反问，问了新人培训和对我的规划的建议，补充解释为什么我大学创作偏内容产出，赞美了角，问了何时出结果\n\n个人小结：\n\n即使只是短短的面试也能感受到深深的鼓舞和指引，感恩，爱角🌹\n\n感想是找工作的话还是多准备点正经作品集吧，不要像我一样在自己的精神世界果奔然后找工作全靠电波……\n\n被各种拷打后（bu）深刻认识到我的劣势好多，游戏经历少得可怜，没有拆解案没有游戏剧本，心态太任性，还果奔（反而被角捞起来面了试还是很感动的，真是玄妙的校招（？）虽然我现在一个offer没有但是祝大家都有心仪的offer！\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569519288814501888?sourceSSR=users",
        "title": "北京某公司实习",
        "content": "## 一面（12.27）\n\n  1. 自我介绍\n  2. 问项目\n  3. websocket是怎么设计的\n  4. websocket协议的连接过程\n  5. 文件上传怎么实现的\n  6. 这个http服务本身是用了什么容器\n  7. 什么时候触发到controller方法（是发生了1kb就开始还是全部接收到）\n  8. springboot常用的注解有哪些\n  9. 怎么实现在某些组件加载前后打印日志\n  10. 从浏览器输入一个url到显示页面的过程\n  11. https连接建立的过程\n  12. Mysql的存储引擎\n  13. UUID为什么不推荐作为主键\n  14. 最近有学什么新技术吗\n  15. 反问： \n    1. 如果入职，会做什么内容的工作\n    2. 有哪些表现不好的地方\n    3. 一共二面\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569495648014180352?sourceSSR=users",
        "title": "撒上灰又盖上土",
        "content": "百度实习三面\n\n好消息，二面似乎过了，坏消息，三面怎么是hr面\n\n自我介绍（我不知道是hr面，我狂说技术栈，具尬）\n\n##### 实习经历\n\n实习的具体内容\n\n最近又遇到什么困难，是怎么解决的\n\n##### 自己的优缺点\n\n要怎么改正这些缺点，明确目标\n\n对未来规划的安排\n\n自己是怎么学新技术的，自己在技术方面哪里若哪里强\n\n##### 未来方面\n\n来实习希望收获什么，为网盘能做什么（因为好像面的是网盘的部门）\n\n从产品的角度觉得网盘的优缺点。有什么可以优化的（我说没有。。。）\n\n平时有没有接触ai，从哪些途径\n\n还有很多记不清了，主要是我以为是技术面，结果是纯聊天，我开头没反应过来，，，，\n\n##### 反问\n\n觉得在百度工作感觉怎么样\n\n百度现在战略方向是什么\n\n如果可以入职是不是有一个专门的导师带\n\n然后面试官说可能以为过节offer会迟一点，带火有没有这方面的经验，我现在就是急急急，以为最近期末考了，如果能定下来我就租房了，我今天给hr发了个邮件，但是还没回，不太懂啊\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569490567806156800?sourceSSR=users",
        "title": "辉曦智能 NPU算子开发实习生 （12.14）",
        "content": "第一次面试吧，没什么经验，面完没有回复，G\n\n面试时长：1 h\n\n面试内容：\n\n* 项目拷打，面试官对softMax的reduce比较感兴趣（还是比较懂的）\n\n* softmax的reduce部分是如何实现的？\n\n* reduce时做指数运算时是否出现精度丢失问题？如何解决？\n\n  * 如果有reduce项目一定会问的\n\n* 如果指数运算时出现了溢出，如何解决溢出的问题？\n\n  * 溢出的解决办法，可以考虑先把最大值找出来，在算sum时候减去最大值，不确定可不可行，如果大家有更好的理解欢迎留言。\n\n* SIMD和SIMT的区别是什么？SIMD相较于SIMT的优势，为什么大家还会用SIMD？\n\n  * 简单介绍下SIMD和SIMT吧，然后具体SIMD的优势我的理解可能说硬件实现上GPU更加复杂一些，SIMD只是CPU上的一个扩展吧\n\n* 计算机体系结构了解哪些？\n\n  * 简单说说CPU和GPU\n\n* GPU中共享内存中的Bank Conflict如何解决？以及避免发生Bank Conflict的解决方法？\n\n  * padding\n\n* 并行有哪些层次的并行方法？\n\n  * 数据并行\n  * 任务并行\n  * 流水线并行\n\n这是我后来查的，如果大家有补充也欢迎评论区讨论，一起学习\n\n* 循环展开优化的底层实现机制，为什么循环展开会起作用？\n\n  * 较少循环开销\n  * 有利于指令流水线调度\n\n* 手撕矩阵乘，可以用CPP或者CUDA C\n\nCUDA C写核函数没写出来，太菜了，这个还是要多练的\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569477958348316672?sourceSSR=users",
        "title": "浩鲸科技 秋招 Java 一面（已拒二面）",
        "content": "> base南京，国内运营中心资源产品线。\n\n## 一面 10.14（45min）\n\n  * 自我介绍\n  * 项目背景\n  * 项目问题、解决办法\n  * 项目有没有考虑到后面分布式部署的问题\n  * 布隆过滤器的使用场景\n  * Java集合\n  * ArrayList，调用 `add(int index, E element)` 是如何处理的（指定下标）\n  * ArrayList是线程安全的吗\n  * ArrayList在JDK中线程安全的实现\n  * HashTable、ConcurrentHashMap区别\n  * AQS有哪些实现类\n  * synchronized ReentrantLock区别\n  * JVM对synchronized有什么优化\n  * synchronized用在成员方法和静态方法上有什么不同\n  * 线程池参数\n  * 假设我创建了一个线程池，核心线程数是5，最大线程数是10，阻塞队列长度是200，此时添加了200个任务，假设这些任务都比较耗时，短时间内不会出现线程的复用，那么线程池中的最大线程数会是多少\n  * 单例模式，饿汉式懒汉式有什么区别\n  * 索引失效\n  * MySQL隔离级别\n  * 读已提交 可重复读区别\n  * 假设MySQL的隔离级别是可重复读，我在A事务中新插入了一条数据，此时还未提交，在B事务中是否能查到\n  * Redis数据结构\n  * 如果使用Redis来实现一个消息队列，我们可以用哪种数据结构\n  * 怎么用Redis实现到期取消订单的功能\n  * Redis分布式锁\n  * Spring事务失效\n  * 有一个@Transactional的方法，负责处理数据的入库，使用线程池多线程处理，那这个多线程处理的批量入库的方法还有事务管理吗 \n    * 比如线程池有一个线程出现了异常，那其他线程已经入库的数据会回滚吗\n  * MyBatis怎么在查询的时候进行全局配置，带上 `deleted = 0` 的条件\n  * 反问\n  * 问了下预期薪资\n\n> 二面好像就是HR面了，拒了。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569461123993403392?sourceSSR=users",
        "title": "掌握的单词个数 - 华为OD统一考试",
        "content": "> OD统一考试\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n有一个字符串数组 words 和一个字符串 chars。假如可以用 chars 中的字母拼写出 words\n中的某个\"单词\"（字符串)，那么我们就认为你掌握了这个单词。\n\nwords 的字等仅由 a-z 英文小写宁母组成，例如“abc”。\n\nchars 由 a- z 英文小写字母和“?”组成，其中英文“?\"表示万能字符，能够在拼写时当作任意一个英文字母。例如“?\"可以当作\"a\"等字母。\n\n注意: 每次拼写时，chars 中的每个字母和万能字符都只能使用一次。输出词汇表 words 中你掌握的所有单词的个数。没有掌握任何单词，则输出0。\n\n## 输入描述\n\n第一行: 输入数组 words 的个数，记作N。\n\n第二行~第N+1行: 依次输入数组words的每个字符串元素。\n\n第N+2行: 输入字符串 chars\n\n## 输出描述\n\n输出一个整数，表示词汇表 words 中你掌握的单词个数\n\n**备注**\n\n1 <= words.length <= 100\n\n1 <= words[i].length, chars.length <= 100\n\n所有字符串中都仅包含小写英文字母、英文问号\n\n## 示例1\n\n    \n    \n    输入\n    4\n    cat\n    bt\n    hat\n    tree\n    atach??\n    \n    输出\n    3\n    \n    说明:可以掌握的单词 \"cat”、“bt\"和\"hat\"。\n    \n\n## 示例2\n\n    \n    \n    输入\n    3\n    hello\n    world\n    cloud\n    welldonehohneyr\n    \n    输出：\n    2\n    \n    说明:可以掌握的单词 \"hello”、“world\"。\n    \n\n## 示例3\n\n    \n    \n    输入\n    3\n    apple\n    car\n    window\n    welldoneapplec?\n    \n    输出：\n    2\n    \n    说明:可以掌握的单词 \"apple”、“car\"。\n    \n\n## 题解\n\n> 模拟题\n>\n> 通过对单词的每个字符个数进行统计，然后按照题意要求进行模拟，拼写时单词的每个字符都能拼出来则单词可以掌握。\n\n### Java\n\n    \n    \n    import java.util.List;\n    import java.util.Scanner;\n    import java.util.stream.Collectors;\n    import java.util.stream.IntStream;\n    \n    /**\n     * @author code5bug\n     */\n    public class Main {\n    \n        // 统计字符串各字符个数\n        public static int[] counter(String s) {\n            // cnt[26] 表示 '?' 号的个数\n            int[] cnt = new int[27];\n            for (char c : s.toCharArray()) {\n                if (c == '?') cnt[26]++;\n                else cnt[c - 'a']++;\n            }\n            return cnt;\n        }\n    \n        // 检测 source 字符个数能否由 target 拼接而来（target[26] 表示 '?' 的个数）\n        public static boolean canSpell(int[] source, int[] target) {\n            int t = target[26];  // '?' 号个数\n            for (int i = 0; i < 26 && t >= 0; i++) {\n                if (source[i] <= target[i]) continue;\n    \n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569263462161850368?sourceSSR=users",
        "title": "360 Java开发实习二面 2023/12/26",
        "content": "一、介绍滴滴和农行项目\n\n二、八股\n\n1.jvm调优\n\n2.linux抓包\n\n3.分段和分页\n\n4.中断的流程\n\n5.ioc和aop原理\n\n6.es底层原理\n\n7.指令的执行周期\n\n8.https加密流程\n\n9.volatile关键字的原理\n\n10.linux命令\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569253097495601152?sourceSSR=users",
        "title": "阿里健康-小鹿中医 前端实习 一面+二面 面经（已oc）",
        "content": "一面（12.15）：\n\n  * 常用vue指令有哪些√\n  * v-model的原理√\n  * this指向√\n  * http三次握手四次挥手的过程√\n  * new的实现过程√\n  * apply、bind和call的区别√\n  * bind中返回的函数中做了什么（说的有点乱）\n  * 原型和原型链√\n  * 闭包√\n  * 内存泄漏怎么解决√\n  * 垃圾回收机制的方法√\n  * 引用计数法的弊端√\n  * vue-router的原理√\n  * vue的生命周期√\n  * 子组件的数据重新渲染时会触发什么生命周期（不会 猜了一下 面试官说我猜对了hh）\n  * vue2和vue3的响应式原理√\n  * reflect有几个参数×\n  * 大文件切片上传时有没有做断点续传 （没有）\n  * 怎么判断首页有没有白屏（可以找取几个关键点看是否为空）√\n  * 防抖和节流的区别以及适用场景√\n  * 当抢票按钮时用防抖的局限，怎么优化（先触发一次，然后设置定时器，在某段时间内设置按钮禁用）√\n\n二面（12.18）：\n\n  * v8引擎的原理\n  * 有没有了解过热点代码\n  * http1.0和2.0的区别\n  * 错误捕获的方式\n  * 滥用vuex会引起哪些问题\n  * api的二次封装怎么实现的\n  * ts类型校验\n\n当天oc\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569221029822824448?sourceSSR=users",
        "title": "【前端】百度在线面经",
        "content": "2023年最后一波日常实习面经，2024也要继续加油💪 ~\n\n## 一面\n\n时长：45min\n\n  * 有在用 Github 么 ✅\n  * 平时有用到 Nginx 么 ✅\n\n### Vue\n\n  * 场景：input框，下面一个div盒子展示input的value。讲述一下input值改变后，Vue渲染的过程（深入一直聊，一直问）✅\n\n### React\n\n  * 说一下 Ract 中常用的 Hooks ✅\n  * 你说到了useMemo，有哪些应用场景 ✅\n\n### 实习相关\n\n  * 在项目中如何提交 Form 表单，说一下你的工作方案 ✅\n  * 工作中是如何进行 api 请求的 ✅\n\n## 二面\n\n时长：45min\n\n二面面后没及时总结，有些记不清了，主要问了一些 JS 的 this指向 还有一些 ES6 语法知识和计网相关知识。\n\n### TypeScript\n\n  * 实现数组类型，要求数组至少有一个元素 ❌\n\n### 手写题\n\n  * 实现一个自定义定时器，可以传入a，b。第一次执行在 a 秒后，之后执行都是 b 秒后 ✅\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569202378621124608?sourceSSR=users",
        "title": "小红书日常实习前端一面",
        "content": "#\n\n1.http1.0和http2.0的区别\n\n2.多个连接一定比单个连接好吗（因为前面答了多路复用）\n\n3.静态方法，原型方法，实例方法是什么，写一个列子（没写清楚）\n\n5.flex：1是什么的缩写，以及每个属性的意思\n\n4.js的基本数据类型和引用数据类型\n\n5.为什么会将这些数据类型作为引用数据类型，比如一个很长的string，为什么他不是引用数据类型（只想到了储存在堆栈中空间更大，然后方便查找）\n\n6.括号匹配（ac）\n\n7.事件循环题（ac）记不太清楚了，不太难\n\n一共就半个小时，感觉有点kpi\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569249706354737152?sourceSSR=users",
        "title": "蔚来前端实习一面+二面+hr面 面经（已oc）",
        "content": "一面（12.14）：\n\n  * 自我介绍\n  * 怎么接触的前端\n  * display的属性有哪些 √\n  * flex布局里的属性有哪些 √\n  * position的定位有哪些 √\n  * 其中会脱离文档流的定位有哪些 √\n  * 隐藏元素的方法 √\n  * 其中display：none会占据空间吗 √\n  * 实现居中的方法 √\n  * 伪元素有哪些 √\n  * 场景题：用一个div实现一个六边形 √\n  * 重绘和重排 √\n  * 怎么减少重排 √\n  * js数据类型有哪些 √\n  * 判断数据类型的方法有哪些 √\n  * type of 的返回值 √\n  * 数组的方法有哪些 √\n  * 改变数组的方法有哪些 （说错了一个， flat会返回新数组）\n  * 事件循环 √\n  * 宏任务 微任务有哪些 √\n  * nexttick原理（这里答的不是很好，应该是dom节点更新推到下一次事件循环结束，说成数据更新了、、后面问具体场景时也答的不是很好，已经尽量圆了、、、）\n  * 为什么先微后宏 √\n  * 手写深拷贝（一紧张obj[key]写成key了，崩溃）\n  * v-show 和 v-if区别 √\n  * 算法：无重复字符的最长子串 √（这个秒了嘿嘿）\n\n二面（12.15）：\n\n  * css选择器有哪些√\n  * 通配符选择器（忘了*{}的名称叫通配符了）\n  * 优先级是什么√\n  * ==和===的区别√\n  * 0.1+0.2为什么不等于0.3√\n  * 如果是0.01+0.02怎么解决√\n  * let var const的区别√\n  * const一定不能改变吗√\n  * watch和computed的区别√\n  * http请求方法√\n  * get和post的区别√\n  * 有没有用过put（没有）\n  * http和https的区别√\n  * http状态码√\n  * 性能优化可以从哪些方面考虑√\n  * 项目页面设计\n  * 项目的页面量级\n  * 项目路由是怎么配置的\n  * 图片懒加载的实现逻辑\n  * 用vue2和vue3哪个多\n  * 为什么项目选型用的vue2\n  * 算法：输入一个日期，返回它是这一年的第几天（一开始说了先判断闰年巴拉巴拉....后面问我有什么性能更好的方式，引导下说了new date）\n\nhr面（12.19）：\n\n问了到岗时间、可实习时长等。。。\n\nhr面完当天oc 12.25正式发了offer邮件\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569218923665657856?sourceSSR=users",
        "title": "【前端】得物面经",
        "content": "2023年最后一波日常实习面经，冲鸭🦆 ~\n\n## 一面\n\n时长：25min\n\n### 开放题\n\n  * 介绍一个你的项目 ✅\n  * 为什么要搞开源，你的组件库发展方向，跟市面上的比有啥优势 ✅\n\n### 场景题\n\n  * 十万个点线的图，在前端如何实现，有什么思路 ✅\n  * 说了下类似虚拟滚动的方案，类似高德地图的方案\n  * cdn的图片为什么来自不同的域名 ❌\n  * 后来知道是浏览器对同源请求有上限\n\n### 计网\n\n  * HTTP 1~2 的区别 ✅\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569198432242434048?sourceSSR=users",
        "title": "上海人工智能实验室后端开发实习面经（已oc）",
        "content": "# 一面\n\n计算机基础你都学过了是吧，那我就不问了（[黑牛问号]）\n\n谈一谈你对hashmap的理解。\n\nhashmap线程不安全的场景，如何去解决。\n\nconcurrenthashmap在1.6之后做了哪些改进。\n\nhashmap在链表长度为8，数组长度为64时链表转红黑树，为什么设定这两个默认值。\n\nsynchronized 和 Lock的区别。\n\n谈一谈在高并发的情况下，会遇到哪些问题，怎么去解决。\n\n如果从线程池的角度去考虑，那怎么去优化。\n\nJVM中的垃圾回收方式\n\n谈一谈Mysql 中怎么去做性能优化。\n\n如果出现慢查询，你如何去解决。\n\n聚集索引和二级索引的区别\n\nspring 事务，在项目中怎么用的\n\n你在项目中用了哪些redis的数据结构，用redis干了什么。\n\nkafka和elasticsearch在项目中怎么用的，了解工业界的用法吗。\n\n反问\n\n业务（大模型相关的后端开发）\n\n对实习生的要求（掌握java基础，中间件会使用就可以，算法方面不做要求）\n\n建议（可以多看看底层原理，掌握后再去学习微服务和中间件）\n\n一面面试官人挺不错，面试体验也很好，问题也比较简单，全答上来了。\n\n# 二面（交叉面）\n\n我是做算法的，对后端的技术不了解，你后端应该过关了，我就来问问你的算法基础。（直接懵了，一点没复习）\n\n为什么选择 ailab的后端开发实习\n\n你今年保研，你的研究方向是什么呢？（大模型，只能说给自己挖坑了）\n\n谈一谈你对大模型的理解吧（谈不了一点，随意乱说一通）\n\n我现在有很多问答结果，我如何去对这些结果进行排序（按得分进行排序）\n\n那你说说排序的方法（相似度）\n\n相似度怎么计算的（矩阵化后计算）\n\n将文本矩阵化的方法叫什么（忘了，后来才想起来是embedding）\n\n我现在有1万个问答请求，但服务器只能同时容纳1000个请求，你怎么做。\n\n传入后端的问答数据，有不同的格式，如何根据格式进行分类存储，并且要保证数据的有序性。\n\n为什么不去找算法实习呢？（我不去找是因为我不想吗[牛泪]）\n\n反问\n\nailab到底是干嘛的（类似于研究所，既有工程也有科研）\n\nailab的后端开发实习也要求有算法基础吗（有则更好，而且你说以后要研究大模型，我就想听听你的一些算法的知识[牛泪]）\n\n如何去提升算法能力 （打好基础，然后推荐了3本书，让我去看看）\n\n二面面完两小时后约hr面\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569191359660171264?sourceSSR=users",
        "title": "深圳桃李未来面试经验分享！",
        "content": "刚刚结束桃李未来的面试！前来分享一下面试经验和整体的感受！\n\n首先介绍一下我的情况，我是22年应届生，一个排名比较靠后的211院校，之前没有系统的教培经历，面试的岗位是教师岗。\n\n面试前：\n\n我是从boss上投递的简历，这个公司的简历筛选比较快，一般有些公司都是3-5天筛选结束，对于急于换工作的朋友不是特别友好，而这家公司是我上午投递的简历，然后下午就有hr老师联系我了，效率top1。电话沟通主要聊了一些我的个人情况和未来的发展路径，hr老师也讲解了公司的情况以及岗位职责和未来的发展晋升体系是什么样子，大概有30分钟，讲的很细，以至于在结束之后我没有啥问题可以问哈哈。\n\n结束第一轮电话沟通后同样也是反馈很快，大概在下班前就收到了面试的邀约，需要进行试讲，对于0经验的伙伴来说，有点像大学的结课演讲或者像毕业论文的答辩，当然没有那么紧张和严肃，我先是做了个ppt然后根据我应聘的年龄段设计了几个小游戏和互动，因为是在职所以准备的时间也不算特别充裕，熟悉了几遍准备第二天进行试讲。\n\n面试中：\n\n面试开始前还是比较紧张的，但是提前10分钟hr老师会进入会议室和我聊聊天，帮我放松一下紧张的心情，面试的过程中为了保证试讲的流畅性，一些互动环节就变成了自问自答了，其实不和面试官互动反而没那么紧张，试讲结束就进入了问答的环节，感觉这个公司的老师们都很温柔哈哈哈，而且都没有架子，因为给我面试的老师是主管和总监，感觉在沟通的过程中也很亲切，让我觉得这个面试更像是一种聊天的方式进行，之前毕业找工作的时候经历过一些公司的压力面，面试官一直绷着脸很凶的那种，很怕进入那些企业之后也是这样的氛围，但这家公司从面试上确实给了我不同的感受。\n\n面试后：\n\n面试结束之后大概隔了1天左右给的反馈，结果是通过的，但是我以为我会挂掉，因为自己是非师范类院校然后专业也不对口，没想到是通过了，后面沟通了offer和入职的一些事项都是比较满意的，从投递简历到拿到offer1周之内就完成了，对于公司和岗位还有企业文化什么的了解也很透彻了，总的来说这次面试体验很不错。\n\n面试感受：\n\n1、效率高，节奏快，1周拿到offer\n\n2、面试官亲切，hr老师认真负责\n\n3、岗位限制不多，对于跨行业经验少的伙伴很友好\n\n面试经验分享：\n\n1、基础知识不能忘，面试官会根据我的试讲题目问一些基础的理论知识，这些肯定是需要提前复习一下的。\n\n2、制作ppt要用心，因为目前我是在职吗，所以其实准备的时间不算特别多，但还是在ppt的制作中去花费了一定心思的，开头的引入到中间的分析讲解后面的重点总结，把逻辑讲清楚就可以。\n\n3、了解公司和岗位，这个应该算面试前的一些经验，因为在选择跳槽或者就业的时候需要了解这个公司和岗位职责内容，再结合自己的一些规划去分析这个岗位是否适合自己，节省不必要的时间成本，和毁约风险。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569216612738334720?sourceSSR=users",
        "title": "【前端】好未来面经",
        "content": "2023年最后一波日常实习面经，希望大家都能拿到心仪的 offer ~\n\n## 一面\n\n  * 介绍一下你写的觉得自己写的不错的项目 ✅\n\n### CSS\n\n  * CSS三栏布局实现方案（左中右）✅\n\n### 场景题\n\n  * 登录常见的实现方案 ✅\n  * 如何在项目中判断用户是否登录 ✅\n  * 如何检测用户离开/进入当前浏览器界面 ✅\n  * 如何判断文件上传是否完完整 ➖\n  * 如何进行大文件上传 ❌\n  * 从当前项目转换到另一个项目如何保持登录状态 ✅\n\n### 手写题\n\n  * 原生JS写登录界面记录密码输入错误次数并展示 ✅\n  * 冒泡排序（算法基础）✅\n  * 排序链表（leetcode mid）✅\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569183120759468032?sourceSSR=users",
        "title": "同程旅行 秋招 Java 一面",
        "content": "> base北京，主要做国际机票、火车票、结算、分销业务。\n\n## 一面 10.31（35min）\n\n  * 自我介绍\n  * 实习项目\n  * 监控框架 怎么采集数据指标\n  * 针对应用服务器 业务日志的异常怎么采集（flarm有没有看过）\n  * 实习过程中最大收获\n  * 怎么排查线上问题 使用什么工具\n  * 线上OOM了 怎么排查 用什么工具\n  * jstack后我想看一些 BLOCKED 的线程 怎么看\n  * 还用过什么其他的工具\n  * 开源的工具有用过吗 比如阿里的Arthas（第一次听）\n  * Linux命令（全忘完了） \n    * 查看Linux进程号\n    * 怎么杀死进程\n    * 查看服务器端口号\n    * 查看服务器硬盘情况\n    * 有一个Tomcat日志文件，我想统计日志文件里异常出错的Top5\n  * 项目拷打\n  * BitMap底层怎么实现的\n  * BitMap怎么解决误判（这块跟面试官有点歧义）\n  * lua脚本怎么保证原子性\n  * RabbitMQ怎么保证消息的顺序性（从生产者角度、消费者如果产生了消息的乱序 消费端怎么做消息的幂等）\n  * 比如MySQL有两张千万级的表做关联查询，针对MySQL监控有哪些方案，MySQL优化有哪些方案\n  * 千万级的数据量查询，除了MySQL优化，还可以用什么方案\n  * 常用的Java线程池\n  * synchronized和ReentrantLock区别\n  * 无手撕\n  * 现在在家还是在学校，从现在到毕业可以一直出来实习吗\n  * 反问\n\n> 一面过后一直没消息，应该是凉了吧。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569171370458767360?sourceSSR=users",
        "title": "某中厂一面",
        "content": "  1. 讲一讲基本数据类型和包装类型的区别\n  2. int i = 2 ；Integer j = 2; sout(i == j)；是true还是false；\n  3. 碰到场景中ArrayList要排序输出，你怎么做？\n  4. 什么是原子性\n  5. 两个事务，事务更新data1，事务2再更新data2，会发生什么？\n  6. 扯了隔离性啥的一大堆，然后才讲到会等待\n  7. 两个事务，事务更新data1，data3，事务2更新data1，data2，会发生什么？\n  8. rocktmq如何实现的延时消息\n  9. 项目如何解决的消息消费失败以及重复投递\n  10. 消费失败没处理\n  11. 如何实现用户关注功能以及点赞排行榜？\n  12. 讲一讲span和div的区别？\n  13. 随便扯了点（我投递后端开发，你问啥前端，焯）\n  14. mybatisplus中的selectList和selectPage\n  15. 感觉就是一个集合查询，一个分页查询，但是不确定，我说忘了\n  16. 讲一讲ioc和aop\n\n总结：难度较小，两个面试官特别有礼貌，体验不错，不过这段时间浮躁，没看八股了，导致一些基本的都忘了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/569215850159378432?sourceSSR=users",
        "title": "【前端】Momenta面经",
        "content": "2023年最后一波日常实习面经，加油 (ง •_•)ง ~\n\n## 一面\n\n时长：45min +\n\n### Vue\n\n  * Vue2与Vue3的区别 ✅\n  * Vue常用的指令和修饰符 ✅，elementUI Dialog 组件 :visible.sync .sync修饰符的作用 ❌\n  * Vue父子组件通信 ➖\n  * Vue父组件如何调用子组件的方法 $$ref，$emit $on ✅\n  * Vue2中 key 的作用 ✅\n  * Vuex如何现持数据久化 ✅\n  * Vue父子组件生命周期执行顺序 ✅\n\n### JavaScript\n\n  * JS事件循环机制看输出 ✅\n\n### 场景题\n\n  * 如何检测白屏 ✅\n  * 页面发生白屏如何判断哪里出问题 ✅\n  * 首屏优化方案 ✅\n\n### 手写题\n\n  * 红灯每3s亮一次，黄灯每2s亮一次，绿灯每1s亮一次（就是每隔一秒循环输出 绿 红 蓝）✅\n\n## 二面\n\n时长：45min +\n\n### 实习相关\n\n  * 介绍一下你在XX(上一家公司)做了什么 ✅\n  * 对XX(上一家公司)的项目有什么优化和思考 ✅\n\n### HTML\n\n  * HTML和XHTML ❌\n\n### JavaScript\n\n  * 对闭包的理解 ✅\n  * ES6新特性 ✅\n\n### 工程化\n\n  * 介绍一下webpack打包流程 ✅\n  * 怎么理解 Wbpack Loader 与 Plugin ✅\n\n### 微信小程序\n\n  * 微信小程序渲染原理 ❌\n\n### 场景题\n\n  * 项目遇到一个难点怎么解决 ✅\n  * 沟通的解决方案，最后做出来与预想的不一致怎么办 ✅\n\n### 其他\n\n  * 平常有用ChatGPT或者AI编程工具么 ✅\n\n"
    }
]