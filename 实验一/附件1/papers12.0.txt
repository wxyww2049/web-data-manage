[
    {
        "url": "https://www.nowcoder.com/discuss/595541668581879808?sourceSSR=users",
        "title": "QQ后台开发一面凉经",
        "content": "上来做自我介绍，问有哪些后台开发经验，如何理解后台开发。\n\n挑了一个项目简单问问。\n\n问平时用什么语言，选了Go。Go的协程、channel、GMP调度器、多个defer调用顺序、内存逃逸、make和new的区别。\n\n问操作系统，进程线程协程区别、内核态和用户态、虚拟内存、页存替换策略。\n\n问计算机网络，三次握手和四次挥手、http2.0和http1.0的区别。\n\n问平时数据库用的多吧，Redis知道吗。不会，换了MySQL。MySQL的存储引擎区别、聚簇索引和非聚簇索引、创建索引时有什么要注意的、覆盖索引。\n\n问消息队列知道吗，Kafka用过吧，Kafka如何做到高可用、消息可靠传输、什么情况下消息不可靠。\n\n八股问完边找题边让我反问，20min手撕分割回文串。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595400954422280192?sourceSSR=users",
        "title": "朗新科技 一面",
        "content": "时间：2024.1.25\n\n时长：30分钟\n\n1、介绍实习做的项目\n\n2、cookie和session的区别\n\n3、cookie和session在多节点服务器上如何实现共享\n\n4、对于cookie安全问题的解决方法\n\n5、JWT了解过吗？\n\n6、事务的控制方式，事务的传播行为\n\n7、富文本的视频音频上传是怎么做的？\n\n8、有用nginx做过静态代理吗？\n\n9、操作日志记录的方法\n\n10、AOP和IOC的区别\n\n11、微服务之间通信一般用什么实现？为什么使用RPC不使用http请求\n\n12、springcloud 有什么了解的地方？\n\n13、多线程在什么场景下有用到过？怎么处理？\n\n14、介绍一下乐观锁和悲观锁，乐观锁的ABA的问题有没有了解\n\n15、数据库怎么做批量插入？批量插入出现的性能问题如何解决？\n\n16、#{}，${}的区别\n\n17、反问\n\n总结：还是挺有难度的，问的偏项目功能实现，以及日常项目开发中会出现的场景题，暴露出我之前很多没有注意到的地方。遇到这些问题真的不能急，得好好思考了再回答，可以把之前做过的项目出现的类似问题陈述一下。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595394012870184960?sourceSSR=users",
        "title": "机器学习面经",
        "content": "​\n经历了2023年的秋招，现在也已经入职半年了，空闲时间将面试中可能遇到的机器学习问题整理了一下，可能答案也会有错误的，希望大家能指出！另外，不论是实习，还是校招，都祝福大家能够拿到满意的Offer!\n\n机器学习面经系列的其他部分如下所示(这是我在其他地方写的，感兴趣的同学可以点波关注捏)：\n\n[机器学习面经-共13章节](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fmp.csdn.net%2Fmp_blog%2Fmanage%2Farticle%3Fspm%3D1001.2014.3001.5448)\n\n# 1、机器学习模型\n\n## 1.1 有监督学习模型\n\n​![](https://uploadfiles.nowcoder.com/images/20240307/881574605_1709824674301/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n## 1.2 无监督学习模型\n\n​![](https://uploadfiles.nowcoder.com/images/20240307/881574605_1709824691409/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n##  1.3 概率模型\n\n​![](https://uploadfiles.nowcoder.com/images/20240307/881574605_1709824702752/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n## 什么是监督学习？什么是非监督学习？\n\n所有的回归算法和分类算法都属于监督学习。并且明确的给给出初始值，在训练集中有特征和标签，并且通过训练获得一个模型，在面对只有特征而没有标签的数据时，能进行预测。\n\n监督学习：通过已有的一部分输入数据与输出数据之间的对应关系，生成一个函数，将输入映射到合适的输出，例如 分类。\n\n非监督学习：直接对输入数据集进行建模，例如强化学习、K-means 聚类、自编码、受限波尔兹曼机。\n\n半监督学习：综合利用有类标的数据和没有类标的数据，来生成合适的分类函数。\n\n目前最广泛被使用的分类器有人工神经网络、支持向量机、最近邻居法、高斯混合模型、朴素贝叶斯方法、决策树和径向基函数分类。\n\n无监督学习里典型的例子就是聚类了。聚类的目的在于把相似的东西聚在一起，一个聚类算法通常只需要知道如何计算相似度就可以开始工作了。\n\n## 1.5、回归、分类、聚类的区别与联系\n\n​![](https://uploadfiles.nowcoder.com/images/20240307/881574605_1709824716411/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n## 1.6、生成模式 vs 判别模式\n\n生成模型： 由数据学得联合概率分布函数 P（X,Y），求出条件概率分布P(Y|X)的预测模型。\n朴素贝叶斯、隐马尔可夫模型、高斯混合模型、文档主题生成模型（LDA）、限制玻尔兹曼机。 判别式模型： 由数据直接学习决策函数 Y =\nf(X)，或由条件分布概率 P（Y|X）作为预测模型。\nK近邻、SVM、决策树、感知机、线性判别分析（LDA）、线性回归、传统的神经网络、逻辑斯蒂回归、boosting、条件随机场。\n\n# 2、线性模型\n\n## 2.1 线性回归\n\n原理: 用线性函数拟合数据，用 MSE 计算损失，然后用梯度下降法(GD)找到一组使 MSE 最小的权重。\n\n线性回归的推导如下所示：\n\n![](https://uploadfiles.nowcoder.com/images/20240307/881574605_1709824734175/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n### 2.1.1 什么是回归？哪些模型可用于解决回归问题？\n\n  * 指分析因变量和自变量之间关系. \n  * 线性回归: 对异常值非常敏感\n  * 多项式回归: 如果指数选择不当，容易过拟合。 \n  * 岭回归 \n  * Lasso回归\n  * 弹性网络回归\n\n### 2.1.2 线性回归的损失函数为什么是均方差?\n\n![](https://uploadfiles.nowcoder.com/images/20240307/881574605_1709824746728/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n### 2.1.3 什么是线性回归？什么时候使用它？\n\n利用最小二乘函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析.\n\n  * 自变量与因变量呈直线关系; \n  * 因变量符合正态分布; \n  * 因变量数值之间独立; \n  * 方差是否齐性。 \n\n### 2.1.4 什么是梯度下降？SGD的推导？\n\nBGD: 遍历全部数据集计算一次loss函数，然后算函数对各个参数的梯度，更新梯度。\n\n​![](https://uploadfiles.nowcoder.com/images/20240307/881574605_1709824761035/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n![](https://uploadfiles.nowcoder.com/images/20240307/881574605_1709824780154/D2B5CA33BD970F64A6301FA75AE2EB22)\n\nBGD、SGD、MBGD之间的区别​\n\n![](https://uploadfiles.nowcoder.com/images/20240307/881574605_1709824768174/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n### 2.1.5 什么是最小二乘法（最小平方法）？\n\n它通过最小化误差的平方和寻找数据的最佳函数匹配。\n\n### 2.1.6 常见的损失函数有哪些？\n\n  * 0-1损失\n  * 均方差损失(MSE) \n  * 平均绝对误差(MAE) \n  * 分位数损失(Quantile Loss) \n  * 分位数回归可以通过给定不同的分位点，拟合目标值的不同分位数； 实现了分别用不同的系数控制高估和低估的损失，进而实现分位数回归\n  * 交叉熵损失\n  * 合页损失 一种二分类损失函数，SVM的损失函数本质： Hinge Loss + L2 正则化\n\n### 2.1.7 有哪些评估回归模型的指标？\n\n衡量线性回归法最好的指标： R-Squared\n\n![](https://uploadfiles.nowcoder.com/images/20240307/881574605_1709824875347/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n###  什么是正规方程？‍\n\n正规方程组是根据最小二乘法原理得到的关于参数估计值的线性方程组。正规方程是通过求解​编辑来找出使得代价函数最小的参数解出: ​编辑\n\n### 2.1.9 梯度下降法找到的一定是下降最快的方向吗？\n\n不一定，它只是目标函数在当前的点的切平面上下降最快的方向。\n在实际执行期中，牛顿方向（考虑海森矩阵）才一般被认为是下降最快的方向，可以达到超线性的收敛速度。梯度下降类的算法的收敛速度一般是线性甚至次线性的（在某些带复杂约束的问题）。\n\n### 2.1.10 MBGD需要注意什么? 如何选择m？\n\n一般m取2的幂次方能充分利用矩阵运算操作。\n一般会在每次遍历训练数据之前，先对所有的数据进行随机排序，然后在每次迭代时按照顺序挑选m个训练集数据直至遍历完所有的数据。\n\n也称为\"对数几率回归\"。\n\n知识点提炼\n\n  1. 1.分类，经典的二分类算法！\n  2. 2.LR的过程：面对一个回归或者分类问题，建立代价函数，然后通过优化方法迭代求解出最优的模型参数，然后测试验证这个求解的模型的好坏。\n  3. 3.Logistic 回归虽然名字里带“回归”，但是它实际上是一种分类方法，主要用于两分类问题（即输出只有两种，分别代表两个类别）\n  4. 4.回归模型中，y 是一个定性变量，比如 y = 0 或 1，logistic 方法主要应用于研究某些事件发生的概率。\n  5. 5.LR的本质：极大似然估计\n  6. 6.LR的激活函数：Sigmoid\n  7. 7.LR的代价函数：交叉熵\n\n优点：\n\n  * 1.速度快，适合二分类问题\n  * 2.简单易于理解，直接看到各个特征的权重\n  * 3.能容易地更新模型吸收新的数据\n\n缺点：\n\n  * 对数据和场景的适应能力有局限性，不如决策树算法适应性那么强。LR中最核心的概念是 Sigmoid 函数，Sigmoid函数可以看成LR的激活函数。\n  * Regression 常规步骤：\n  * 寻找h函数（即预测函数）\n  * 构造J函数（损失函数）\n  * 想办法（迭代）使得J函数最小并求得回归参数（θ）\n\nLR伪代码：\n\n  * 初始化线性函数参数为1\n  * 构造sigmoid函数\n  * 重复循环I次\n  * 计算数据集梯度\n  * 更新线性函数参数\n  * 确定最终的sigmoid函数\n  * 输入训练（测试）数据集\n  * 运用最终sigmoid函数求解分类的推导\n\n​![](https://uploadfiles.nowcoder.com/images/20240307/881574605_1709824911876/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n### 为什么 LR 要使用 sigmoid 函数？\n\n1.广义模型推导所得 2.满足统计的最大熵模型\n3.性质优秀，方便使用（Sigmoid函数是平滑的，而且任意阶可导，一阶二阶导数可以直接由函数值得到不用进行求导，这在实现中很实用）\n\n## 为什么常常要做特征组合（特征交叉）？\n\n  * LR模型属于线性模型，线性模型不能很好处理非线性特征，特征组合可以引入非线性特征，提升模型的表达能力。\n  * 另外，基本特征可以认为是全局建模，组合特征更加精细，是个性化建模，但对全局建模会对部分样本有偏，\n  * 对每一个样本建模又会导致数据爆炸，过拟合，所以基本特征+特征组合兼顾了全局和个性化。\n\n### 为什么LR比线性回归要好？\n\n  * LR和线性回归首先都是广义的线性回归；其次经典线性模型的优化目标函数是最小二乘，而LR则是似然函数；另外线性回归在整个实数域范围内进行预测，敏感度一致，而分类范围，需要在[0,1]。LR就是一种减小预测范围，将预测值限定为[0,1]间的一种回归模型，因而对于这类问题来说，LR的鲁棒性比线性回归的要好\n\n### 参数求解的优化方法？(机器学习中常用的最优化方法)\n\n梯度下降法，随机梯度下降法，牛顿法，拟牛顿法（LBFGS，BFGS,OWLQN）\n\n目的都是求解某个函数的极小值。\n\n### 工程上，怎么实现LR的并行化？有哪些并行化的工具？\n\n  * LR的并行化最主要的就是对目标函数梯度计算的并行化。\n  * 无损的并行化：算法天然可以并行，并行只是提高了计算的速度和解决问题的规模，但和正常执行的结果是一样的。\n  * 有损的并行化：算法本身不是天然并行的，需要对算法做一些近似来实现并行化，这样并行化之后的双方和正常执行的结果并不一致，但是相似的。\n  * 基于Batch的算法都是可以进行无损的并行化的。而基于SGD的算法都只能进行有损的并行化。\n\n### 如何解决低维不可分问题？\n\n通过特征变换的方式把低维空间转换到高维空间，而在低维空间不可分的数据，到高维空间中线性可分的几率会高一些。\n\n具体方法：核函数，如：高斯核，多项式核等等\n\n### 与最大熵模型MaxEnt的关系?\n\n没有本质区别。LR是最大熵对应类别为二类时的特殊情况，也就是当LR类别扩展到多类别时，就是最大熵模型。\n\n### 为什么 LR 用交叉熵损失而不是平方损失（MSE）？\n\n​\n\n编辑\n\n如果使用均方差作为损失函数，求得的梯度受到sigmoid函数导数的影响；\n\n​编辑求导：​编辑\n\n如果使用交叉熵作为损失函数，没有受到sigmoid函数导数的影响，且真实值与预测值差别越大，梯度越大，更新的速度也就越快。\n\n​编辑求导：​编辑\n\n###\n记忆：mse的导数里面有sigmoid函数的导数，而交叉熵导数里面没有sigmoid函数的导数，sigmoid的导数的最大值为0.25，更新数据时太慢了。\n\n### 能否解决非线性分类问题？\n\n可以，只要使用kernel\ntrick（核技巧）。不过，通常使用的kernel都是隐式的，也就是找不到显式地把数据从低维映射到高维的函数，而只能计算高维空间中数据点的内积。​编辑\n\n### 用什么来评估LR模型？\n\n  * 1.由于LR是用来预测概率的，可以用AUC-ROC曲线以及混淆矩阵来确定其性能。\n  * 2.LR中类似于校正R2 的指标是AIC。AIC是对模型系数数量惩罚模型的拟合度量。因此，更偏爱有最小的AIC的模型。\n\n### 如何解决多分类问题？（OvR vs OvO）\n\n​\n\n编辑\n\n### 在训练的过程当中，如果有很多的特征高度相关或者说有一个特征重复了100遍，会造成怎样的影响？\n\n如果在损失函数最终收敛的情况下，其实就算有很多特征高度相关也不会影响分类器的效果。但是对特征本身来说的话，假设只有一个特征，在不考虑采样的情况下，你现在将它重复100遍。训练以后完以后，数据还是这么多，但是这个特征本身重复了100遍，实质上将原来的特征分成了100份，每一个特征都是原来特征权重值的百分之一。如果在随机采样的情况下，其实训练收敛完以后，还是可以认为这100个特征和原来那一个特征扮演的效果一样，只是可能中间很多特征的值正负相消了。\n\n### 2.2.13 为什么在训练的过程当中将高度相关的特征去掉？\n\n  * 去掉高度相关的特征会让模型的可解释性更好。\n  * 可以大大提高训练的速度。如果模型当中有很多特征高度相关的话，就算损失函数本身收敛了，但实际上参数是没有收敛的，这样会拉低训练的速度。\n  * 其次是特征多了，本身就会增大训练的时间。\n\n今日先更新到这里了，机器学习的总共为12章节，除此之外还有深度学习！等后续一序列更新~​\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595379234793635840?sourceSSR=users",
        "title": "腾讯 WXG 一面G",
        "content": "投的是实习基地，这个基地是只招前端和客户端吧[发火]\n\n纯纯kpi，我项目纯go，云原生方向，wxg C++基础架构，不匹配干嘛要捞我[牛泪]\n\n稍微问了一下项目，问的很少，也不难，20来分钟\n\n云的项目一点没问。。。。\n\n无八股文，直接开始用白板手撕一个数独有多少种解法，lc37的升级版\n\n只会暴力回溯，超时，寄。还是太菜了（应该使用官方的后两种方法，建议大家学习第一个解题：回溯 + 状态压缩（使用\nBitset）的方法，不要使用代码随想录的方法和我一样，会超时！！！）\n\n（吐槽一下，编程平台纯白板，没有任何波浪线提示，打印输出必须程序成功运行才能看到。。。。）\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595373719560753152?sourceSSR=users",
        "title": "商品运营 - 面经 - 天源迪科",
        "content": "**招聘要求：**\n\n![](https://uploadfiles.nowcoder.com/files/20240307/100957974_1709820140705/1684631299819-4eb03d91-7e21-43b6-a3db-c4d9dcf6ba66.png)![](https://uploadfiles.nowcoder.com/files/20240307/100957974_1709820140691/1684631299575-d5066b9d-312d-400f-899f-2bc5f26283e8.gif)\n\n![](https://uploadfiles.nowcoder.com/files/20240307/100957974_1709820140667/1684631299823-86e4f333-5037-4f38-a2e9-d8dc90f18267.png)![](https://uploadfiles.nowcoder.com/files/20240307/100957974_1709820140690/1684631299585-05029324-94b4-49da-8cf3-769f680cc48f.gif)\n\n**投递时间：**\n\n![](https://uploadfiles.nowcoder.com/files/20240307/100957974_1709820140678/1684631299792-8481b6fd-8b65-4233-b510-7bc8c54745b5.png)![](https://uploadfiles.nowcoder.com/files/20240307/100957974_1709820140702/1684631300251-30c43043-03bb-4167-8f4d-4be32bd3a6d6.gif)\n\nA.面试方式：腾讯会议\n\nB.一面流程：\n\n面试官简单自我介绍，介绍了本次面试分为三个部分\n\n**自我介绍：**\n\n**我是---，专业，方向，班内职务，运营经验（详细介绍过程，规模，具体事务，成果，目前情况）**\n\n**目前校内职务，个人爱好，优势：技术，沟通，团队合作（详细介绍）劣势**\n\n这部分略紧张，提前在手机上写了提纲，说的时候依旧吭吃瘪肚。而且给自己挖了不少坑。\n\n**具体提问：**\n\n**1.年级 实习时间 实习时长**\n\n**2.为什么选做商品运营**\n\n自身方向相关\n\n**3.目前正在做的比较有挑战的事情**\n\n手头项目介绍\n\n**4.细问项目中的困难**\n\n回答比较离谱，基本没准备好\n\n**5.困难解决的办法**\n\n未作出完整回答\n\n**6.细问项目中的技术是否会深度学习**\n\n回答只会调参\n\n**7.数据分析会什么技术，有什么成果**\n\n展示了爬虫和Excle看板\n\n**8.结合看板具体提问**\n\n**试分析某月销售数据下降明显原因**\n\n答非所问或回答不完整 面试官做了补充 指导\n\n下降可能会是数据本身的原因，在采集流程，数据整理过程中出现问题\n\n**9.运营经验询问 要求具体介绍**\n\n**运营中出现的问题 具体解决办法是什么**\n\n这点提前预判，但面试官也做了补充，提出了去中心化的解决办法，提升用户交流活跃度\n\n**10.兴趣爱好**\n\n**具体提问 业余兴趣爱好方面的专业性有什么提升方式**\n\n这部分分条回答，自我感觉良好\n\n**11.喜欢看书吗 介绍目前正在看的一本书**\n\n**写一段书评或简短的推荐语推荐给面试官**\n\n借用了名人名言 之后面试官说这部分考察内容运营水平\n\n**12.了解岗位吗 具体说说岗位职责，了解公司吗**\n\n**13.熟悉SQL吗**\n\n**14.熟悉具体的数据分析技术吗？用过哪些技术**\n\n**反问环节:**\n\n提前准备了一些\n\n**1.结合面试情况有哪些提升的点**\n\n需要技术实现的具体成果\n\n**2.公司数据分析方面的岗位有哪些**\n\n**总结：**\n\n**这是本人第一次参见公司面试，第一次写面经，之前对于面试流程也比较了解，略有准备。**\n\n**该岗位要求有数据分析能力，可能会有相关技术的要求，但不是必需，要提前设计好一份具有岗位针对性的自我介绍，面试官大部分问题都是基于个人简介。核心的面试问题是对于异常数据产生原因的分析，以及对于岗位具体职责的了解。**\n\n**由于面试过程中作答属实一般，也没问入职之后的具体工作**\n\n**下次面试加油啦~**\n\n加更：\n\n一面结束三天后HRBP联系说沟通后续安排\n\n通知面试成功，告知公司地址，询问租房打算\n\n之后再次询问实习时长\n\n问我有什么疑问：\n\n问了入职之后安排 前一周培训学习，了解公司文化，适应环境，有导师安排具体业务\n\n问了部门组织情况 是某事业部下属机构\n\n谈薪：先问了我期望薪酬\n\n然后说按招聘要求中的定\n\n填好入职表后发放offer\n\n面试过程比较简单，只有简单的一面，最终也是因为时间不合适，婉拒offer\n\n可能实习比较好找，但愿之后工作顺利~\n\n加油💪啦\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595373046551121920?sourceSSR=users",
        "title": "校招和社招的面试大忌",
        "content": "无论是校招还是社招，除了要有一个充足的准备，对答如流之外，还有一些雷区不得不注意，否则绝对会让你的努力付水东流，一去不复返。\n\n### **尊重他人便是尊重自己**\n\n虽然大家都说技术人不拘小节等等，但是**千万别被误导了。**\n最基础的礼仪还是要有的，毕竟我们还是礼仪之邦。别人可以做不好，咱们要求不了别人，但是一定可以要求自己，**自己做好为首要任务**\n。这些尊重的表现诸如：远程面试开摄像头；现场面试宁可提前也别迟到；面试中回答不卑不亢等。这些看似简单的东西，是给人好印象的前提。不求锦上添花，至少能超过一批不注意的人。\n\n### 正确\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595360965479206912?sourceSSR=users",
        "title": "【大厂面试演练】知道ZooKeeper有什么应用场景吗",
        "content": "![alt](https://uploadfiles.nowcoder.com/images/20240308/300233579_1709878935687/F52EF63178C44CC01836BE6655BF2FD3)\n\n> _面试官：听说你精通ZooKeeper，那我就考考你吧_\n>\n>  \n>\n>\n> _面试官：不用慌尽管说，错了也没关系😊。。。_\n>\n>  \n>\n>\n> 以【**面试官面试** 】的形式来分享技术。**整理分类专栏、首发博客**\n> 在[CSDN](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fhdgaadd)（戳这），本期是《ZooKeeper系列》，期待观众老爷的关注❤️\n\n## 面试官：知道ZooKeeper有什么应用场景吗\n\n嗯嗯，主要有这几种。\n\n  1. 数据发布/订阅。可以用来实现配置中心\n\n  2. 命名服务。类似于UUID，可以生成全局唯一的ID\n\n  3. 集群管理。每一个服务器是一个子节点，可以用来检测到集群中机器的上/下线情况\n\n  4. 分布式锁\n\n>  \n>\n>\n> _面试官思考中…_\n>\n>  \n>\n\n## 面试官：你挑一个你比较熟悉的场景讲讲\n\n嗯嗯好的，那我讲下分布式锁。\n\n是这样的，ZooKeep的获取锁时会在/**exclusive_lock节点** 下创建子节点，如果创建成功则获得锁。如果**失败**\n，则客户端会在该节点注册一个**子节点变更的Watcher监听** 。\n\n同样，释放锁则**删除** 该子节点，此时Watcher监听就会通知客户端可以重新获取了。\n\n![alt](https://uploadfiles.nowcoder.com/images/20240307/300233579_1709817055472/81EF413BE6A7B1A30512A0625BC126C6)\n\n>  \n>\n>\n> _面试官思考中…_\n>\n>  \n>\n\n## 面试官：你说的是排他锁，共享锁呢\n\n好的面试官。共享锁也是类似的场景。\n\n每次**读、写** 请求同样是创建子节点，是一个类似于“/shared_lock/[Hostname]-请求类型-序号”的临时**顺序** 节点。\n\n**接着会获取子节点列表，同时注册Watcher监听** 。\n\n  1. 获取读锁的话，如果前面比自己小的序号**没有写请求** ，则可以读\n  2. 获取写锁的话，只有在自己是**序号最小** 的情况下，才可以读\n\n而共享锁的释放锁和排他锁都是**一样的** 。\n\n![alt](https://uploadfiles.nowcoder.com/images/20240307/300233579_1709817062663/E62B977CACA312DB258D9F727B414F05)\n\n## 面试官：emmmm有没听说过共享锁的羊群效应\n\n噢噢知道的面试官，这个问题主要是出现在**集群规模比较大** 的场景下。\n\n其实共享锁的特别之处，在于每次**读、写** 请求都要**注册Watcher监听来获取子节点列表** ，特别是数量更多的读请求。\n\n子节点列表每次变动都要通知**所有** 的服务器客户端，造成了短时间大量的**事件通知** ，给ZooKeeper带来很大性能消耗。\n\n>  \n>\n>\n> _面试官思考中…_\n>\n>  \n>\n\n## 面试官：那怎么解决呢\n\n我认为要两方面来看吧。\n\n首先我上面说的共享锁实现方式如果在集群不大的情况下是可行的，而且他实现**简单实用** 。而如果在集群规模大的场景下，可以这样**改进** 。\n\n读、写请求首先**获取子节点列表** ，但都**不注册Watcher监听** 。\n\n  * 读请求：**只向** 比自己序号小的最后一个写请求节点注册Watcher监听\n  * 写请求：**只向** 比自己序号小的最后一个节点注册Watcher监听\n\n这样就可以避免羊群效应，主要是**从监听子节点列表，改进为只监听某个子节点** 。\n\n>  \n>\n>\n> _面试官心想，还不错嘛.._\n>\n>  \n>\n\n## 面试官：Kafka应用场景呢，知道Kafka是怎么利用ZooKeeper吗\n\n嗯嗯好的，我了解到的主要有3方面。\n\n  1. 使用ZooKeeper来对所有**Broker服务器、Topic进行管理**\n\nBroker启动后都会到ZooKeeper上创建属于自己的**临时节点** ，其节点路径为/broker/ids/[0…N]，注册Topic节点也是一样。\n\n  2. 另外在Kafka**生产者负载均衡** 方面\n\nKafka消息生产者会通过**监听Broker节点列表** ，负载均衡地分发到某一个Broker。\n\n  3. 而在Kafka**防消费重复消费** 方面\n\n消费者消费消息后，都会在消息分区写入**临时节点** ，代表该消息已消费。\n\n>  \n>\n>\n> _面试官思考中…_\n>\n>  \n>\n\n## 面试官：你刚刚说到Kafka生产者负载均衡，那消费者负载均衡知道吗\n\n哦哦说欠了，消费者负载均衡有两方面。\n\n  * 一方面，每一个消费者服务器都会在ZooKeeper创建**消费者节点** 。当有新消息时，Kafka就可以通过ZooKeeper的**消费者节点列表** 负载均衡地通知某个消费者\n  * 另一方面，Kafa将一个Topic分成了多个分区，多个分区由**不同的Brocker** 处理，这是实现**对Brocker的负载均衡**\n\n![alt](https://uploadfiles.nowcoder.com/images/20240307/300233579_1709817070792/BFAF135CA0568CB5BA2732D375D748EF)\n\n> _面试官抓抓脑袋，继续看你的简历......_\n>\n>  \n>\n>\n> _得想想考点你不懂的😰_\n\n## 未完待续。。。。。。\n\n好了，今天的分享就先到这，我们下期继续。\n\n> **整理分类专栏、首发博客在**\n> ：[CSDN](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fhdgaadd)\n>\n>  \n>\n>\n>\n> [GitHub](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgithub.com%2Fhdgaadd)，你的\n> ⭐️ Star ⭐️，是作者的动力！\n>\n>  \n>\n>\n> **创作不易，不妨点赞、收藏、关注支持一下，各位的支持就是我创作的最大动力** ❤️\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595373595136724992?sourceSSR=users",
        "title": "数据研发 - 一面凉经 - 快手（主站）",
        "content": "**招聘要求：**\n\n![](https://uploadfiles.nowcoder.com/files/20240307/100957974_1709820118846/1703592900483-49265cea-1664-46b0-b89d-b1028ef1c363.png)\n\n**投递时间：**\n\n**2023.12.24 牛客线上寒假实习双选会**\n\n**2023.12.25 下午约面**\n\n**2023.12.26 下午正式面试**\n\nA. 面试方式：轻雀面试（快手旗下面试工具）\n\nB. 一面流程：\n\n面试官全程开启摄像头，介绍面试流程，分为四部分，自我介绍，SQL题目，知识点问答，反问环节\n\n**面试开始：**\n\n**自我介绍：**\n\n**基本上将提前拟好的模板内容完整表述，表达不够流畅，多处停顿，结结巴巴**\n\n目前，在校内，我担任大数据与人工智能创新平台的数据团队负责人，从大一开始，接触到一些大数据方面的基础知识，同时在各类创新创业竞赛中完成数据可视化部分的工作。今年暑期，我在北京天源迪科信息技术有限公司商品销售部下属的智慧化服务中心，担任商品数据运营实习生，主要工作是制作动态看板和数据分析。最近，是在牛客网组织的线上双选会中，看到有这个数据研发的岗位比较匹配，而且快手作为目前流行的短视频和直播APP，有数亿的用户和庞大的数据量，我希望能够进入团队，为快手探索更多的数据价值。\n\n**拷打实习：（完全捏造，一眼露馅）**\n\n  1. **在实习过程中输出的策略会输出到线上么？**\n  2. **你的产出是什么? （纠结的点在于制作的数据看板以及策略没有实际作用于线上或产生实际作用）**\n  3. **如何评估策略是否有效？如何衡量?如何判断能够帮助业务？有怎样的助力？**\n\n回答：遇到过数据来源的问题，进而改变筛选条件\n\n（面试官总结为：上游数据来源加工质量问题）\n\n  1. **那这个看板你更多的是应用于应用层还是配置层，有接触过底层么？从数据采集到数据加工到数据应用这整个的数仓分层的建设，有么？**\n\n回答：没有，当时实习的时候没有\n\n之后做项目时，是有了解过\n\n  1. **那介绍一下你对数据分层的理解和数据分层的作用**\n\n我，结合项目谈一下吧，简单说了说作用，会提升计算效率，逐层筛选，完成数据清洗\n\n分层理解：面试前搜了搜，分五层，基本完整表述\n\n附：Al回答\n\n数据分层是数据仓库设计中一个非常重要的环节，它能够使整个数据体系更容易被理解和使用。在理论上，我们可以把数据仓库分为三个层：数据运营层、数据仓库层和数据产品层。\n\n  * 数据运营层（ODS）：这一层是接近数据源中数据的一层，数据源中的数据经过抽取、清洗、传输后装入本层。这一层面的数据大多是按照源头业务系统的分类方式而分类的。在源数据装入这一层时，会进行去噪、去重、字段命名规范等一系列操作。 \n  * 数据仓库层：这一层存放我们要重点设计的数据仓库中间层数据，也称为细节层。DW层的数据应该是一致的、准确的、干净的数据，即对源系统数据进行了清洗后的数据。 \n\n数据分层的作用主要体现在以下几个方面：\n\n  1. 清晰数据结构：每一个数据分层都有它的作用域和职责，在使用表的时候能更方便的定位和理解。\n  2. 减少重复开发：规范数据分层，开发一些通用的中间层数据，能够减少极大地重复计算。\n  3. 便于维护：通过数据分层，可以更好地进行数据的维护和管理。\n  4. 统一数据口径：通过数据分层，提供统一的数据出口，统一对外输出的数据口径。\n  5. 复杂问题简单化：将一个复杂的任务分解成多个步骤来完成，每一层解决特定的问题。\n\n  1. **有了解过你们数据底层是如何来存储的么？**\n\n回答基本都是Excel表格，也有纯文档形式的\n\n  1. **你目前的数据都在本地，如果从HDFS访问的话，是需要上传，有了解过什么HDFS的文件格式么？常见的文件传输格式有哪些?**\n\n只接触过txt文本格式\n\n  1. **看你简历上也写道Flink，那你有接触过这种实时计算场景么？**\n\n略了解，没有接触过\n\n  1. **那你实习的时候是有写这种SQL是吧？**\n  2. **那我们写一道SQL题吧，窗口函数有了解过吗？目前有一张学生考试成绩表，分别有四个字段，我想统计分年级分科目，每个年级每个科目成绩Top3同学的信息**\n  3. **解释一下SQL执行顺序**\n  4. **你了解过窗口函数么？**\n  5. **有写过其他语言么？写一道算法题吧，给定一个无序数组，求第K大的数，简单说一下sort()内部的一些逻辑，分析时空复杂度**\n  6. **针对本题，有没有相对快排的方式，进行优化？**\n  7. **平时还有什么场景或者机会去了解大数据相关的组件和知识么？**\n\n创新创业项目和大作业\n\n  1. **数据可视化部分你是用一些开源的么，还是怎么实现的?**\n\nPython，帆软相关软件\n\n  1. **有了解过当前比较火的数据处理引擎么？比如MapReduce和Spark，有了解过它们底层的一些原理么？**\n\n接触过MapRuduce\n\n  1. **处理过程中会有一些Key的合并，包括从Map到Reduce这个过程中可能涉及到哪些排序？**\n\n**反问环节：**\n\n**团队主要工作：属于数据平台部，分为几个小团队，对接不同的业务方向，面试岗位属于用户增长方向，数据仓库建设，拉新，留存，活跃等业务行为，业务场景建模，偏离线数据，应用层建模看板或已有核心指标建设**\n\n**项目：项目数据量过小，大数据场景问题无法遇到，从数据采集，分层建模领域应用，涉及主键如何生成，业务库同步，存储方式拓展，再到应用层全链路了解，更多关注在数据领域上的积累。**\n\n**面试总结：**\n\n**SQL + 数据结构 + 八股基础**\n\n**面试前针对公司，岗位，部门寻找面经**\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595358492844634112?sourceSSR=users",
        "title": "杭州新生纪智能科技 测试",
        "content": "一面\n\n自我介绍\n\n前公司项目 担任角色\n\nselenium弊端\n\n目前公司的工作内容\n\n离职原因\n\n二面\n\n自我介绍\n\n工作内容（面试官对大模型很感兴趣，聊了很多）\n\n你的优势\n\n在前公司学习到的事\n\n爬虫问题\n\n工作碰到的困难\n\n薪资期望\n\n反问\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595357169264971776?sourceSSR=users",
        "title": "腾讯实习基地 公众号与小程序 后台开发 一面凉",
        "content": "我是2.28报名实习基地，3.1号面试面完1h挂。\n\n面试官给了个网站有五个题\n\nt1:给n个整数求出两个整数拼成最大数\n\nt2:合并两个有序链表\n\nt3:给定编码过后字符串返回解码字符串,k[s]，表示s重复k次,2<=k<10\n\ninput:3[a2[bc]] output: abcbc abcbc\n\nt4:lc1505 给定一个很大数字，可以相邻位移动最多k次，最后能得到最大整数是多少\n\nt5:二维树状数组模板\n\n写完后开始讲\n\nt2问合并n个有序链表怎么做复杂度多少，用优先队列维护,复杂度size*logn\n\nt4实现的n*n，面试官提示了一下也没想出nlogn做法\n\nt5要我讲二维数组数组实现原理，讲的不是很清楚面试官又给我讲了一下\n\n然后问了下lru-k并发采取的是大锁吗，看过lru-k的论文吗，lru-k在什么情况比lru更好\n\n然后就开始聊天了，最后又问了下io多路复用是什么\n\n面试官很友好，虽然感觉是kpi，但我回答的也很差[牛泪]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595373500014088192?sourceSSR=users",
        "title": "基础数据运营 - 面经 - 自如租房",
        "content": "**招聘要求：**\n\n![](https://uploadfiles.nowcoder.com/files/20240307/100957974_1709820094666/1703831433360-408fc3a6-e03a-446b-b589-cbced0b9ce02.jpeg)\n\n**投递时间：**\n\n2023.12.28 BOSS直聘 联系HR\n\n2023.12.29 面试\n\n**面试流程：**\n\n自我介绍，正常完整表述\n\n**你能介绍一下你的实习经历吗？主要做了哪些工作，得到了哪些结论出来**\n\n**一般Excel有用到过么？一般会使用哪些功能？**\n\n简单的数据筛选，连表查询，Vlookup函数，看板\n\n**有做过海报么？**\n\n做过计划书封面，纳新工作宣传\n\n**做海报是使用的什么工具？**\n\n可画\n\n**有过视频剪辑的经历么？**\n\n**你有什么问题想反问么？**\n\n团队的具体工作\n\n**房屋租赁主要有两个服务对象，租户和业主，客户遗留问题对接，信息搬运，平台互通，数据整理，指标变化原因，输出策略，提醒（海报），好事儿（制作视频），数据分析，形成结论**\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595337842713178112?sourceSSR=users",
        "title": "【腾讯】Java后端面经，范围极广|0306",
        "content": "![](https://git.acwing.com/Hasity/interview_hunter/-/raw/master/2024/image/%E9%9D%A2%E7%BB%8F10%E8%85%BE%E8%AE%AFjava.png)\n\n  1. 括号匹配\n    \n        import java.util.Stack;\n    \n    public class BracketMatching {\n        public static boolean isBracketMatching(String str) {\n            Stack<Character> stack = new Stack<>(); // 创建一个栈用于存储左括号\n    \n            for (int i = 0; i < str.length(); i++) {\n                char ch = str.charAt(i);\n    \n                if (ch == '(' || ch == '[' || ch == '{') { // 如果是左括号，则入栈\n                    stack.push(ch);\n                } else if (ch == ')' || ch == ']' || ch == '}') { // 如果是右括号\n                    if (stack.isEmpty()) { // 如果栈为空，说明没有与之匹配的左括号，返回false\n                        return false;\n                    }\n    \n                    char top = stack.pop(); // 弹出栈顶元素\n    \n                    // 判断右括号与栈顶元素是否匹配\n                    if ((ch == ')' && top != '(') || (ch == ']' && top != '[') || (ch == '}' && top != '{')) {\n                        return false; // 不匹配，返回false\n                    }\n                }\n            }\n    \n            return stack.isEmpty(); // 如果栈为空，说明所有括号都匹配成功，返回true；否则返回false\n        }\n    \n        public static void main(String[] args) {\n            String str1 = \"((()))\";\n            String str2 = \"([{}])\";\n            String str3 = \"({[}])\";\n    \n            System.out.println(isBracketMatching(str1));  // true\n            System.out.println(isBracketMatching(str2));  // true\n            System.out.println(isBracketMatching(str3));  // false\n        }\n    }\n    \n\n>\n> **[面经专栏直通车](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fcreation%2Fmanager%2FcolumnDetail%2F0xKkDM)**\n\n>\n> **[面经专栏下载](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgit.acwing.com%2Flicw%2F24_job_hunter)**\n\n  2. 遍历二叉搜索树\n    \n        // 定义二叉树节点类\n    class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n    \n        public TreeNode(int val) {\n            this.val = val;\n        }\n    }\n    \n    public class BSTTraversal {\n        // 中序遍历二叉搜索树\n        public static void inorderTraversal(TreeNode root) {\n            if (root == null) {\n                return;\n            }\n    \n            inorderTraversal(root.left); // 递归遍历左子树\n            System.out.print(root.val + \" \"); // 输出当前节点的值\n            inorderTraversal(root.right); // 递归遍历右子树\n        }\n    \n        // 前序遍历二叉搜索树\n        public static void preorderTraversal(TreeNode root) {\n            if (root == null) {\n                return;\n            }\n    \n            System.out.print(root.val + \" \"); // 输出当前节点的值\n            preorderTraversal(root.left); // 递归遍历左子树\n            preorderTraversal(root.right); // 递归遍历右子树\n        }\n    \n        // 后序遍历二叉搜索树\n        public static void postorderTraversal(TreeNode root) {\n            if (root == null) {\n                return;\n            }\n    \n            postorderTraversal(root.left); // 递归遍历左子树\n            postorderTraversal(root.right); // 递归遍历右子树\n            System.out.print(root.val + \" \"); // 输出当前节点的值\n        }\n    \n        public static void main(String[] args) {\n            // 构建一个二叉搜索树\n            TreeNode root = new TreeNode(4);\n            root.left = new TreeNode(2);\n            root.right = new TreeNode(6);\n            root.left.left = new TreeNode(1);\n            root.left.right = new TreeNode(3);\n            root.right.left = new TreeNode(5);\n            root.right.right = new TreeNode(7);\n    \n            System.out.print(\"Inorder traversal: \");\n            inorderTraversal(root); // 中序遍历\n            System.out.println();\n    \n            System.out.print(\"Preorder traversal: \");\n            preorderTraversal(root); // 前序遍历\n            System.out.println();\n    \n            System.out.print(\"Postorder traversal: \");\n            postorderTraversal(root); // 后序遍历\n            System.out.println();\n        }\n    }\n    \n    \n\n  3. 给定一组非负整数，求能拼接成的最大整数。\n    \n        import java.util.Arrays;\n    import java.util.Comparator;\n    \n    public class MaxNumber {\n        public static String largestNumber(int[] nums) {\n            // 将整数数组转换为字符串数组\n            String[] strNums = new String[nums.length];\n            for (int i = 0; i < nums.length; i++) {\n                strNums[i] = String.valueOf(nums[i]);\n            }\n    \n            // 自定义比较器，用于比较两个字符串的拼接结果\n            Comparator<String> comparator = new Comparator<String>() {\n                @Override\n                public int compare(String s1, String s2) {\n                    String order1 = s1 + s2;\n                    String order2 = s2 + s1;\n                    return order2.compareTo(order1); // 降序排列\n                }\n            };\n    \n            // 使用自定义比较器对字符串数组进行排序\n            Arrays.sort(strNums, comparator);\n    \n            // 如果排序后的数组第一个元素是0，则直接返回\"0\"\n            if (strNums[0].equals(\"0\")) {\n                return \"0\";\n            }\n    \n            // 拼接排序后的字符串数组\n            StringBuilder sb = new StringBuilder();\n            for (String str : strNums) {\n                sb.append(str);\n            }\n    \n            return sb.toString();\n        }\n    \n        public static void main(String[] args) {\n            int[] nums = {10, 2, 5, 9, 23};\n            String result = largestNumber(nums);\n            System.out.println(\"最大整数：\" + result);\n        }\n    }\n    \n    \n\n  4. Java语言和C语言有哪些区别？\n\n     * 编程范式：C语言是一种过程式编程语言，而Java语言是一种面向对象编程语言。Java语言基于类和对象的概念，支持封装、继承和多态等面向对象的特性。\n     * 内存管理：C语言需要手动管理内存，包括分配和释放内存。而Java语言使用垃圾回收机制，自动管理内存，开发者不需要显式地进行内存管理。\n     * 平台依赖性：C语言是一种编译型语言，编写的程序需要针对特定的操作系统和硬件平台进行编译。而Java语言是一种跨平台的语言，通过Java虚拟机（JVM）实现了平台无关性，Java程序可以在不同的操作系统上运行。\n     * 异常处理：C语言使用错误码来处理异常情况，开发者需要手动检查错误码并进行相应的处理。Java语言引入了异常处理机制，通过try-catch-finally语句块来捕获和处理异常，使得代码更加清晰和可读。\n     * 标准库和生态系统：C语言的标准库相对较小，提供了基本的输入输出、字符串处理等功能。Java语言拥有丰富的标准库和第三方库，提供了大量的API和工具，涵盖了各种领域，方便开发者进行开发。\n     * 编译和执行方式：C语言通过编译器将源代码编译成机器码，然后直接执行。而Java语言通过编译器将源代码编译成字节码，然后在JVM上执行字节码。\n  5. RPC了解吗？\n\nRPC（Remote Procedure Call，远程过程调用）。\n\nRPC是一种通信协议，用于不同计算机之间的远程通信。它允许一个计算机程序调用另一个计算机上的函数或方法，就像调用本地函数一样，隐藏了底层网络通信的细节。\n\n在RPC中，通信的两端分别是客户端和服务器。客户端发起一个远程调用请求，服务器接收请求并执行相应的操作，然后将结果返回给客户端。RPC框架负责处理底层的网络通信、序列化和反序列化等细节，使得远程调用过程对开发者透明。\n\n常见的RPC框架包括Dubbo、gRPC、Thrift等。\n\nRPC的优点包括：\n\n     * 简化分布式系统开发：RPC隐藏了底层通信细节，使得开发者可以像调用本地函数一样调用远程函数，简化了分布式系统的开发。\n     * 提高系统性能：RPC可以将计算任务分布到不同的服务器上，充分利用资源，提高系统的并发性和性能。\n     * 提高系统可扩展性：通过RPC，可以将系统拆分成多个服务，每个服务可以独立部署和扩展，提高系统的可扩展性。\n  6. 介绍常用的Linux命令？\n\n    1. `ls`：列出目录内容。\n    2. `cd`：切换当前工作目录。\n    3. `pwd`：显示当前工作目录的路径。\n    4. `mkdir`：创建新目录。\n    5. `rm`：删除文件或目录。\n    6. `cp`：复制文件或目录。\n    7. `mv`：移动文件或目录，也可用于重命名文件或目录。\n    8. `cat`：显示文件内容。\n    9. `grep`：在文件中搜索指定的模式。\n    10. `chmod`：修改文件或目录的权限。\n  7. Linux中如果出现了CPU满载，如何排查问题？\n\n当Linux系统出现CPU满载的情况时，可以按照以下步骤进行问题排查：\n\n    1. 使用`top`命令查看系统当前的进程和CPU占用情况。按下`Shift + P`按CPU使用率排序进程，观察哪些进程占用了较高的CPU资源。\n    2. 使用`ps`命令结合`top`命令的结果，获取更详细的进程信息。例如，`ps auxf`可以显示所有进程的详细信息，包括进程ID、CPU使用率等。\n    3. 使用`htop`命令代替`top`命令，它提供了更友好的交互式界面，可以更方便地查看和管理进程。\n    4. 使用`pidstat`命令监测特定进程的CPU使用情况。例如，`pidstat -p <进程ID> -u 1`可以每秒钟显示指定进程的CPU使用情况。\n    5. 使用`iotop`命令查看磁盘I/O情况，因为高磁盘I/O可能导致CPU负载升高。\n    6. 使用`sar`命令查看系统的历史性能数据，例如，`sar -u`可以显示CPU使用率的历史数据。\n    7. 使用`strace`命令追踪进程的系统调用，以确定是否有异常的系统调用导致CPU满载。\n    8. 检查系统日志文件，如`/var/log/messages`、`/var/log/syslog`等，查找异常或错误信息。\n    9. 如果有可疑的进程或服务，可以尝试重启它们，或者使用`kill`命令终止它们。\n    10. 如果以上方法无法解决问题，可以考虑使用性能分析工具，如`perf`、`strace`、`gdb`等，对进程进行更深入的分析和调试。\n  8. 介绍一下 堆 这个数据结构？\n\n堆（Heap）是一种特殊的树状数据结构，它满足以下两个主要性质：\n\n    1. 堆是一个完全二叉树（Complete Binary Tree）：除了最底层外，其他层的节点都是满的，且最底层的节点都靠左排列。\n    2. 堆中每个节点的值都必须满足堆的性质：对于最大堆（Max Heap），父节点的值大于或等于其子节点的值；对于最小堆（Min Heap），父节点的值小于或等于其子节点的值。\n\n堆通常用于实现优先队列（Priority Queue）和堆排序（Heap Sort）等算法。\n\n堆可以分为最大堆和最小堆两种类型：\n\n     * 最大堆：父节点的值大于或等于其子节点的值。根节点是堆中的最大值。\n     * 最小堆：父节点的值小于或等于其子节点的值。根节点是堆中的最小值。\n\n堆的主要操作包括插入和删除操作：\n\n     * 插入操作：将一个新元素插入到堆中，保持堆的性质不变。\n     * 删除操作：删除堆中的根节点，并保持堆的性质不变。\n\n堆的插入和删除操作的时间复杂度都是O(log n)，其中n是堆中元素的个数。\n\n堆的应用场景包括：\n\n     * 优先队列：堆可以用于实现高效的优先队列，根据优先级获取最大或最小元素。\n     * 堆排序：堆排序是一种基于堆的排序算法，具有稳定的时间复杂度O(n log n)。\n     * 求Top K问题：通过维护一个大小为K的最小堆或最大堆，可以高效地求解Top K大或Top K小的元素。\n     * 图算法：堆可以用于实现Dijkstra算法、Prim算法等图算法中的优先级队列。\n  9. 动态链接库和静态链接库的区别？\n\n动态链接库（Dynamic Link Library，DLL）和静态链接库（Static Link\nLibrary）是两种常见的库文件形式，它们在链接和加载方式上有以下区别：\n\n    1. 链接方式： \n       * 静态链接库：在编译时将库的代码和应用程序的代码合并成一个可执行文件。链接器将库的代码复制到应用程序中，生成一个独立的可执行文件。应用程序与库的代码是静态链接的关系。\n       * 动态链接库：在编译时只将库的引用信息记录在可执行文件中，而不将库的代码复制到应用程序中。在运行时，操作系统动态加载并链接库的代码，使得多个应用程序可以共享同一个库文件。\n    2. 文件大小： \n       * 静态链接库：库的代码被完整地复制到每个应用程序中，因此每个应用程序都包含了库的完整代码，导致应用程序的文件大小较大。\n       * 动态链接库：多个应用程序可以共享同一个库文件，因此每个应用程序只需要记录库的引用信息，导致应用程序的文件大小较小。\n    3. 内存占用： \n       * 静态链接库：每个应用程序都包含了库的完整代码，因此在内存中会有多份库的代码副本，导致内存占用较高。\n       * 动态链接库：多个应用程序共享同一个库文件，库的代码只需要加载一次，多个应用程序共享同一份库的代码，因此在内存中的占用较少。\n    4. 更新和维护： \n       * 静态链接库：如果库的代码发生更新，需要重新编译和链接应用程序，将新的库代码合并到应用程序中。\n       * 动态链接库：如果库的代码发生更新，只需要替换库文件即可，不需要重新编译和链接应用程序。\n  10. 介绍一下动态规划的思想？上楼梯问题了解吗？用了动态规划和暴力时间复杂度分别是多少？\n\n动态规划（Dynamic\nProgramming）是一种解决多阶段决策问题的优化方法，它将问题分解为多个子问题，并通过保存子问题的解来避免重复计算，从而提高算法的效率。\n\n动态规划的基本思想是：将原问题分解为若干个子问题，先求解子问题的解，然后利用子问题的解构建原问题的解。通过保存子问题的解，避免重复计算，从而减少时间复杂度。\n\n上楼梯问题是动态规划中的一个经典问题。假设有n个台阶，每次可以走1步或2步，问有多少种不同的方式可以爬到楼顶。\n\n使用动态规划解决上楼梯问题的思路如下：\n\n    1. 定义状态：设dp[i]表示爬到第i个台阶的不同方式数。\n    2. 状态转移方程：由于每次可以走1步或2步，所以到达第i个台阶的方式数等于到达第i-1个台阶的方式数加上到达第i-2个台阶的方式数，即dp[i] = dp[i-1] + dp[i-2]。\n    3. 初始条件：dp[0] = 1，dp[1] = 1，表示到达第0个台阶和第1个台阶的方式数都为1。\n    4. 计算顺序：从小到大计算dp[i]，直到计算到dp[n]，即到达第n个台阶的方式数。\n\n使用暴力方法解决上楼梯问题的思路如下：\n\n    1. 枚举所有可能的方式，对于每一种方式，计算到达楼顶的路径数。\n    2. 递归地计算每一种方式的路径数，直到到达楼顶。\n    3. 统计所有方式的路径数之和。\n\n动态规划解决上楼梯问题的时间复杂度为O(n)，因为需要计算从第2个台阶到第n个台阶的方式数，每个台阶只需要计算一次。\n暴力方法解决上楼梯问题的时间复杂度为O(2^n)，因为需要枚举所有可能的方式，每个台阶都有两种选择。\n\n  11. 什么是稳定排序？\n\n稳定排序（Stable\nSorting）是指在排序算法中，如果两个元素的比较结果相等，那么它们在排序后的结果中的相对位置保持不变。换句话说，如果在排序前，元素A在元素B的前面，且A与B的值相等，那么在排序后，A仍然在B的前面。\n\n稳定排序的特点是能够保持相等元素的相对顺序，这在某些应用场景中非常重要。例如，当需要按照多个条件进行排序时，稳定排序可以确保先按照第一个条件排序，再按照第二个条件排序，而不会打乱第一个条件的顺序。\n\n常见的稳定排序算法有冒泡排序、插入排序、归并排序和基数排序等。这些算法在排序过程中会考虑元素的相对位置，以保持排序的稳定性。\n\n相对应的，非稳定排序（Unstable\nSorting）是指在排序算法中，如果两个元素的比较结果相等，它们在排序后的结果中的相对位置可能会发生变化。非稳定排序算法在排序过程中可能会打乱相等元素的相对顺序。\n\n在选择排序算法时，如果需要保持相等元素的相对顺序，就应选择稳定排序算法。否则，如果相等元素的相对顺序不重要，可以选择非稳定排序算法，它们通常具有更高的性能。\n\n  12. 图片分片上传的逻辑是什么？\n\n图片分片上传是一种将大文件分割成多个小片段进行上传的策略，以提高上传效率和稳定性。其基本逻辑如下：\n\n    1. 客户端将待上传的图片文件进行分片切割，将文件分割成多个固定大小的片段（chunk）。\n    2. 客户端按照一定的顺序将这些分片依次上传到服务器端。可以使用HTTP协议的POST请求或其他上传协议进行分片上传。\n    3. 服务器端接收到每个分片后，将其暂存到临时存储区，通常是磁盘或内存。\n    4. 当所有分片都上传完成后，服务器端根据上传的顺序将这些分片进行合并，还原成完整的图片文件。\n    5. 完整的图片文件可以进行进一步的处理，如存储到数据库或文件系统中，或进行其他业务逻辑操作。\n\n在图片分片上传的过程中，还需要考虑以下几个方面的逻辑：\n\n     * 分片大小：需要根据实际情况确定每个分片的大小，通常根据网络环境和服务器性能进行调整，以保证上传效率和稳定性。\n     * 分片顺序：客户端需要按照一定的顺序上传分片，通常是从第一个分片开始，依次上传到最后一个分片。\n     * 分片校验：客户端可以对每个分片进行校验，例如计算分片的哈希值，以确保分片的完整性和准确性。\n     * 断点续传：如果上传过程中出现网络中断或其他异常情况，客户端可以记录已上传的分片信息，下次继续上传时可以从断点处继续上传，以实现断点续传的功能。\n\n通过图片分片上传的方式，可以有效地处理大文件的上传，提高上传效率和稳定性，并且可以灵活控制上传过程，适应不同的网络环境和服务器条件。\n\n  13. 如何用消息队列做削峰填谷的？\n\n使用消息队列可以有效地实现削峰填谷的目标，具体的实现方式如下：\n\n    1. 创建消息队列：选择合适的消息队列系统，如RabbitMQ、Kafka等，并创建相应的消息队列。\n    2. 发送消息：将需要处理的任务或请求转化为消息，并发送到消息队列中。这些消息可以包含任务的相关信息，如任务类型、参数等。\n    3. 消费消息：编写消费者程序，从消息队列中获取消息，并进行相应的处理。消费者可以根据业务需求进行扩展，可以是单个消费者或多个消费者。\n    4. 控制消费速率：通过控制消费者的数量和处理速度，来控制任务的处理速度。可以动态调整消费者的数量，根据实际情况增加或减少消费者的数量。\n    5. 峰值处理：当任务量激增时，消息队列可以暂时存储大量的消息，而不会导致系统负载过高。消费者按照自身的处理能力逐步消费消息，避免了系统的峰值压力。\n    6. 谷值填充：当任务量减少时，消息队列中的消息可以被逐步消费，保证系统的资源得到充分利用，避免了资源的浪费。\n    7. 异步处理：通过消息队列的异步特性，可以将任务的处理与请求的接收解耦。请求可以快速响应，而任务的处理可以在后台进行，提高系统的响应速度和吞吐量。\n\n通过使用消息队列进行削峰填谷，可以平滑处理系统的高峰期和低谷期，提高系统的稳定性和可伸缩性。同时，消息队列还可以提供消息持久化、消息重试等功能，增加系统的可靠性和容错性。\n\n[出处：Zyccccccc\n](https://www.nowcoder.com/feed/main/detail/77469efca8c2414f8443f73bffb8af9a?sourceSSR=users)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595373357910994944?sourceSSR=users",
        "title": "后端开发（Java） - 一面凉经 - 美团（通讯研发）",
        "content": "**投递时间：**\n\n**2024.1.2中午约面 （简单沟通能否接受上海办公）**\n\n**2024.1.3下午面试**\n\n**面试流程：**\n\n**面试连接：牛客网**\n\n**简单做下自我介绍**\n\n**你的这个实习经历主要是做后端Java开发么？**\n\n略微涉及Python 主要是数据分析和策略输出\n\n**接触过Java么？**\n\n接触过一些语法基础和面向对象\n\n**问一些计算机基础吧，网络的七层模型你还有印象么？**\n\n没，物理层做一些基础硬件通信，传输层有TCP/IP\n\n  1. **物理层（Physical Layer）：**\n  2. **数据链路层（Data Link Layer）：**\n  3. **网络层（Network Layer）：**\n  4. **传输层（Transport Layer）：**\n  5. **会话层（Session Layer）：**\n  6. **表示层（Presentation Layer）：**\n  7. **应用层（Application Layer）：**\n\n**TCP协议和UDP协议的区别，讲一讲**\n\n  1. **连接性:**\n  2. **可靠性:**\n  3. **数据流控制:**\n  4. **头部开销:**\n  5. **适用场景:**\n\n**数据结构相关的话，数组链表有了解过么？**\n\n**链表没有了解过么？**\n\n**你觉得数组和链表有什么区别么？**\n\n  1. **存储方式:**\n  2. **大小固定性:**\n  3. **随机访问效率:**\n  4. **插入和删除效率:**\n  5. **空间复杂度:**\n\n**红黑树有了解过么？**\n\n**MySQL底层是使用什么来存储？**\n\nb+树\n\n**b+树有什么特点？这个有了解过么？**\n\n  1. **平衡性:**\n  2. **多路搜索:**\n  3. **叶子节点顺序访问:**\n  4. **非叶子节点不存储数据:**\n  5. **所有叶子节点都在同一层:**\n  6. **适用于外存储器:**\n  7. **适用于范围查询:**\n\n**数据库的特性**\n\n  1. **数据共享:**\n  2. **数据独立性:**\n  3. **数据一致性:**\n  4. **数据持久性:**\n  5. **数据完整性:**\n  6. **数据安全性:**\n  7. **并发控制:**\n  8. **事务管理:**\n  9. **查询语言:**\n  10. **备份和恢复:**\n  11. **数据模型:**\n  12. **可扩展性:**\n\n**比如SQL可以有哪些优化？**\n\n  1. **合理使用索引:**\n  2. **谨慎使用通配符:**\n  3. **适当使用JOIN:**\n  4. **使用EXISTS替代IN:**\n  5. *_避免使用SELECT :_\n  6. **分页查询优化:**\n  7. **使用合适的数据类型:**\n  8. **定期统计和重建索引:**\n  9. **使用存储过程:**\n  10. **使用连接池:**\n  11. **考虑分区表:**\n  12. **数据库服务器参数调优:**\n\n**那你怎么知道它提升的效率怎么样？**\n\n  1. **执行计划分析:**\n  2. **性能测试:**\n  3. **使用数据库性能监控工具:**\n  4. **Query Profiling:**\n  5. **压力测试:**\n  6. **监测变更前后的系统性能:**\n  7. **使用统计信息:**\n  8. **反馈用户体验:**\n\n**redis你有用过吗？**\n\n没有\n\n**那spring？啊哦对，你没用过Java，算了**\n\n**那我们简单来做一道题目吧，语言可切换成你熟悉的**\n\n**牛客 - 中等 - 重排链表**\n\n不会，没思路\n\n**题目的意思是，第一步要找到链表的中间节点，有思路么？**\n\n没有\n\n**你有什么想阐述的么？**\n\n没\n\n**反问环节：**\n\n**我想问一些问题，首先是团队的工作**\n\n美团门店相关，搜门店时有一些标签和电话的漏掉，做一些维护\n\n**学习相关：**\n\nSpring相关 + 基础技术栈\n\n**面试总结：**\n\n**实习一面：基础数据结构 + 八股（计算机网络 + 数据库）**\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595373195289440256?sourceSSR=users",
        "title": "数据开发 - 面经（已OC） - 北京中海通",
        "content": "![](https://uploadfiles.nowcoder.com/files/20240307/100957974_1709820008683/1704447097691-ef05bf28-d4f3-4ea4-843d-7745dee4fd19.png)\n\n**投递流程：**\n\n**2023.12.28 Boss 打招呼**\n\n**2024.1.3 约面**\n\n**2024.1.4 上午面试 （手机端腾讯会议）**\n\n**2024.1.5 上午 通知面试通过**\n\n**腾讯会议手机端无法和录影机同时运行，录音无效，之后注意使用电脑面试**\n\n**面试流程：首先自我介绍，介绍实习工作，SQL使用过哪些聚合函数**\n\n**SQL相关问题，语法基础，优化方法**\n\n**一道基础SQL题目**\n\n**可以实习多久，最快到岗时间是？**\n\n**反问环节：**\n\n部门主要工作：使用自研BI软件制作可视化大屏和报表，SQL书写，后期设计数据挖掘\n\n**面试总结：**\n\n**注意录音，SQL基础**\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595372896696975360?sourceSSR=users",
        "title": "Python实习生（自动化测试脚本开发） TCL",
        "content": "**JD：**\n\n![](https://uploadfiles.nowcoder.com/files/20240307/100957974_1709819915311/1704510494174-80aa60bc-2d0c-4cf0-af16-297946c00099.png)\n\n**招聘流程：**\n\n**2024.1.3 Boss直聘 沟通**\n\n**2024.1.4 约面**\n\n**2024.1.6 上午面试**\n\n**面试流程：**\n\n**上来第一步，直接问Python基础语法，讲一下基础的数据类型**\n\n就记得元组和字典\n\n**分别具体说一下元组和字典**\n\n**流程控制语句有哪些？**\n\n**for循环具体讲讲**\n\n**Python库有用过哪些？具体说说**\n\n爬虫，可视化，词云图（这部分回答的不是很全面）\n\n**Linux有用过吗？**\n\n分布式，大数据开发\n\n**git有用过吗，主要做哪方面？**\n\n**可以讲一下项目经历吗？**\n\n**你在项目中承担哪些工作和任务呢？**\n\n**就是会有写一些需求分析和项目背景是吧？**\n\n**讲一下你在项目中遇到的挑战和成果？**\n\n**有什么想反问的？**\n\n主要工作：工程效能部，集成开发，容器化\n\n入职培训\n\n你打算考研吗？\n\n**作为本地人您为什么会选择广东？**\n\n**以前来过广东？**\n\n**可以随时到岗是吗？**\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595372574347935744?sourceSSR=users",
        "title": "Java后端 - 一面凉经 - 得物（国际电商）",
        "content": "**招聘流程：**\n\n**2024.1.5 HR邮件沟通**\n\n**2024.1.7 上午面试**\n\n**面试流程：**\n\n**简单自我介绍**\n\n简单问实习工作\n\n**介绍目前Java项目**\n\n**如何在项目中处理并发问题**\n\n**讲讲并发编程**\n\n**如何使用锁**\n\n**问什么like查询慢**\n\n**explain具体讲讲**\n\n**加索引为什么会变快**\n\n**索引是什么数据结构**\n\n**b树和b+树的区别**\n\n**讲讲Java虚拟机**\n\n**虚拟机内存如何分配**\n\n**Java对象的生命周期**\n\n**谈谈职业规划**\n\n**为这个岗位或者工作做过哪些努力**\n\n**打算考研吗**\n\n**有什么反问的？**\n\n团队或者部门主要工作\n\n**海外进出口，台湾日本**\n\n**技术主Java，spring全家桶**\n\n项目相关\n\n**面试主要看基础知识深入了解，深入掌握技术**\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595372380118159360?sourceSSR=users",
        "title": "数据开发 - 面经 - 来未来（医疗大数据）",
        "content": "2024.1.9 面试\n\nBoss直聘沟通\n\n**公司要求驻场开发，接受加班，接受出差**\n\n**你是25届是吧？能在六个月左右是吗？目前在校吗？**\n\n**后续有什么规划？**\n\n**你怎么理解数据开发这个岗位的？**\n\n**讲讲简历上这两个项目？是你在学校做的是吧？**\n\n**项目你是全程参与是吧？**\n\n**聊天这个项目的数据源是哪里来的呀？**\n\n**项目整体是落在HDFS上是吧？**\n\n**单一架构，嗷，然后可视化，是哇？**\n\n**下一个电商项目介绍一下？**\n\n**数据来源讲讲？**\n\n**那意思是已经讲，非结构化数据已经转换成结构化数据了是哇？**\n\n**进入MYSQL中数据量有多少？**\n\n**数据拉取的工具是什么？**\n\n**MySQL增删改查了解不？**\n\n**接触过数仓分层没？具体讲讲**\n\n**你认为分层的优势是什么？**\n\n**有没有接触过其他的数据库？或者其他体系？**\n\n**讲一下用户日志分析的特定维度**\n\n**那么产出的一些指标呢？有哪些？**\n\n**项目面向一些案例化的群体是吧？**\n\n**维度考核的指标是什么？**\n\n**那你怎样保证数据一致性和完整性的校验?**\n\n**校园经历也是Hadoop这一套？**\n\n**你实习为什么做了3个月？**\n\n**实习经历的收获介绍一下**\n\n**实习过程中对你帮助比较大的点**\n\n**你认为实习经历和项目经历的区别**\n\n**处理数据过程中有没有什么比较困难的点，简单介绍一个**\n\n**你之前直接对接过客户吗？**\n\n**你对我们公司有过了解吗？**\n\n**出差有什么问题？**\n\n**多久能到岗呀？**\n\n**有什么反问的？**\n\n团队和主要工作？\n\n**为医院做数据治理，院内数据抽取分析，数仓模型开发，数据展示**\n\n数据量级？\n\n**亿级**\n\n前期偏向离线还是实时？\n\n**都有，根据业务场景会具体细分**\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595372003821928448?sourceSSR=users",
        "title": "数据分析 - 面经 - 联蔚数科",
        "content": "2024.1.9 面试\n\nBoss直聘沟通\n\n**先简单做下自我介绍吧**\n\n**你项目中设计的技术选型，你都有使用过是吗？**\n\n**这个项目的团队规模介绍一下**\n\n**在数据部分，详细讲一下主要工作，在数据采集，处理等方面**\n\n**这些工具是学校教的呢？还是自学**\n\n**目前居住地**\n\n**工作地点能接受吗**\n\n**对加班怎么看？**\n\n**你个人的发展方向**\n\n**反问环节:**\n\n**团队或者部门的主要工作**\n\n**具体技术和工具**\n\nHive 可视化看板 埋点工具 数据查询\n\n**数据量**\n\n上亿，需要对接沟通\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595371801119641600?sourceSSR=users",
        "title": "数据分析 - 面经 - 灵狐科技",
        "content": "2024.1.9 面试\n\nBoss直聘沟通\n\n**请就以往工作经历做一下自我介绍**\n\n**详细说一下电商平台这个项目**\n\n**说一下对数据分析岗位的理解，在公司中有怎样的作用**\n\n**讲一下你专业技能，性格契合岗位的点**\n\n**讲一下可以提升或者欠缺的点**\n\n**你有对数据分析领域哪方面感兴趣？**\n\n**或者想深入了解的**\n\n**预计到岗时间，实习时长**\n\n**学校还有事情吗？**\n\n**面试官具体介绍公司**\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595327272756809728?sourceSSR=users",
        "title": "iOS客户端社招两年工程师面试",
        "content": "Minimax一面\n\n  1. static是什么，和class有什么不同？ 答：声明一个静态属性或者函数，我们常常使用值类型的static修饰符。下面就是一个结构体的例子： struct Sun { static func illuminate() {} } 对类来说,使用static 或者class修饰符，都是可以的。它们使用后的效果是一样的，但是本质上是不同的。能解释一下为什么不同吗？ 答案： static修饰的属性或者修饰的函数都不可以重写。但是使用class修饰符，你可以重写属性或者函数。 当static在类中应用的时候，static就成为class final的一个别名。\n  2. Class 和 Struct 的区别\n\n  * 类是引用类型, 结构体为值类型\n  * 结构体不可以继承\n  * 值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝\n  * 引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝\n\n  1. 三个线程异步执行，想要获取三个线程的结果再执行下一段代码，该怎么办？ 用DISPATCHQUEUE\n  2. 三种闭包\n  3. 逃逸闭包，尾随闭包，自动闭包 当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。当你定义接受闭包作为参数的函数时，你可以在参数名之前标注 @escaping，用来指明这个闭包是允许“逃逸”出这个函数的。非逃逸闭包、逃逸闭包，一般都是当做参数传递给函数非逃逸闭包:闭包调用发生在函数结束前，闭包调用在函数作用域内逃逸闭包:闭包有可能在函数结束后调用，闭包调用逃离了函数的作用域，需要通过@escaping声明 尾随闭包是最后一个闭包，可以自动类型推断\n  4. 如何解决循环引用？ weak 和 unkowned 的引入是为了解决由 strong 带来的循环引用问题。简单来说，就是当两个对象互相有一个强指向去指向对方，这样导致两个对象在内存中无法释放。\n  5. weak和unknowned的区别？ weak 和 unowned 的使用场景有如下差别：\n\n  * 当访问对象时该对象可能已经被释放了，则用 weak。比如 delegate 的修饰。\n  * 当访问对象确定不可能被释放，则用 unowned。比如 self 的引用。\n  * 实际上为了安全起见，很多公司规定任何时候都使用 weak 去修饰。 挂了，方向不符合，给了一道括号匹配代码题简单做做\n\n收集iOS题8. Flutter iOS的app\nframework怎么瘦身，做了哪些（二进制瘦身，还是资源删减，是业务还是flutter层）？Flutter iOS的app\nframework瘦身可以从以下几个方面进行：\n\n  1. 二进制瘦身：通过移除未使用的代码和库，减小二进制文件的大小。可以使用Xcode的Build Settings中的Strip Linked Product选项来开启二进制瘦身。\n  2. 资源删减：检查项目中的图像、音频和其他资源文件，移除未使用或不必要的资源。可以使用Xcode的Images.xcassets来管理和优化图像资源。\n  3. Dart和Flutter层瘦身：在Dart和Flutter代码中，移除未使用的类、函数和方法，以及不必要的依赖包。可以使用Dart的pubspec.yaml文件来管理和优化依赖包。\n  4. 使用Flutter的Tree Shaking特性：在编译时，Flutter会自动移除未使用的代码，从而减小最终的二进制文件大小。确保在编译时开启Tree Shaking功能。\n  5. 使用Flutter的Code Splitting特性：将应用程序拆分成多个模块，按需加载，从而减小初始安装包的大小。可以使用Flutter的--split-debug-info=<path>命令来实现代码拆分。\n  6. 使用Flutter的懒加载特性：在需要时才加载某些资源，从而减小应用程序的内存占用。可以使用Flutter的Future.delayed方法来实现懒加载。\n  7. 优化网络请求：减少不必要的网络请求，合并多个请求为一个请求，从而减小应用程序的数据流量。可以使用Flutter的http库来实现网络请求的优化。\n  8. 使用Flutter的缓存策略：合理使用缓存，避免重复加载相同的资源，从而减小应用程序的数据流量。可以使用Flutter的ImageCache类来实现图像资源的缓存。 总之，Flutter iOS的app framework瘦身需要从多个方面进行优化，包括二进制瘦身、资源删减、代码优化等，以减小应用程序的大小和内存占用。\n  9. Flutter渲染树（三个树）介绍和原理 Flutter的渲染树包括Widget、Element和RenderObject这三个树形结构，它们共同完成UI的构建和渲染工作。具体介绍如下：\n  10. Widget树：\n\n  * Widget是Flutter用户界面的不可变描述。它们是UI组件的配置数据结构，描述了UI的部分内容。\n  * Widget树是由Widget对象构成的层次结构，它定义了应用程序的用户界面。\n  * Flutter页面由各种Widget组合而成，每个Widget都是不可变的，即它的所有属性都必须为final类型。\n\n  1. Element树：\n\n  * Element是Widget的一个实例化对象，它通过Widget的createElement()方法创建，并保存了上下文信息。\n  * Element作为Widget树和RenderObject树之间的桥梁，持有对应的Widget和RenderObject的引用，并负责配置Widget在视图树中的位置。\n\n  1. RenderObject树：\n\n  * RenderObject用于应用界面的布局和绘制，它包含了元素的大小、布局等信息。\n  * RenderObject树是实际执行布局和绘制操作的结构，它根据Widget的属性进行layout和绘制。\n\n三棵树的协同工作原理：\n\n  * 当应用程序启动时，Flutter会首先构建Widget树，然后遍历这个树，为每个Widget创建对应的Element对象，形成Element树。\n  * 接着，Flutter会调用每个Element的createRenderObject()方法来创建相应的RenderObject，从而形成RenderObject树。\n  * 在UI更新过程中，如果Widget的配置发生变化，Flutter会比较新的Widget树与旧的Widget树，并通过Element树高效地确定哪些RenderObject需要更新，以最小化渲染工作量。 总的来说，这种设计使得Flutter能够有效地管理和更新UI，同时保持高性能的渲染过程。\n\n腾讯一面10. 定义值类型和引用类型Swift有三种声明类型的方式：class，struct和enum。\n它们可以分为值类型（struct和enum）和引用类型（class）。 它们在内存中的存储方式不同决定它们之间的区别：\n\n  * 值类型存储在栈区。 每个值类型变量都有其自己的数据副本，并且对一个变量的操作不会影响另一个变量。\n  * 引用类型存储在其他位置（堆区），我们在内存中有一个指向该位置的引用。 引用类型的变量可以指向相同类型的数据。 因此，对一个变量进行的操作会影响另一变量所指向的数据。\n\n  1. Swift中字典的存储方式 有一个唯一的键值对，存储在哈希表当中，其中如果产生冲突，采用的是开放定址法(+1） https://juejin.cn/post/6932770154619076621\n  2. http1.0和http2.0的区别 HTTP1.0和HTTP2.0在连接方式、多路复用、头部压缩以及服务器推送方面存在明显区别。具体来说： 支持长连接\n  3. 连接方式：在HTTP1.0中，浏览器与服务器之间只保持短暂的连接，每次请求都需要建立一个新的TCP连接。而HTTP2.0基于SPDY协议，使用了二进制分帧机制，允许在一个单一的TCP连接上进行多路复用，即可以同时处理多个请求和响应，减少了因多次建立连接而产生的延迟和开销。\n  4. 多路复用：HTTP1.0的请求是串行的，一个请求完成才能发送下一个请求，这导致了队头阻塞问题。而HTTP2.0通过多路复用技术解决了这一问题，可以并行地传输多个请求和响应，提高了页面加载速度。\n  5. 头部压缩：HTTP2.0支持头部压缩，能够减少请求和响应头部的大小，进一步节省带宽，加快数据传输速度。而HTTP1.0不支持头部压缩。\n  6. 服务器推送：HTTP2.0引入了服务器推送（Server Push）特性，使得服务器可以在客户端需要之前就主动发送数据，进一步提高了效率。HTTP1.0则没有这个功能。\n\n总的来说，HTTP2.0相比HTTP1.0在连接方式等方面都有显著的提升。这些改进使得HTTP2.0在现代网络应用中更为高效和实用。13.\nHTTPS是通过TLS/SSL协议实现加密的。\n\n首先，客户端和服务器进行握手，期间会交换支持的加密算法、协议版本等信息。然后，服务器会发送自己的数字证书给客户端，以证明自己的身份。这个证书通常由权威的证书颁发机构签发。\n\n接下来是密钥交换阶段，客户端和服务器协商生成一个对称密钥，即\"对话密钥\"。这个密钥将用于后续的所有加密通信。在非对称加密中，服务器还会发送一个公钥给客户端，客户端使用这个公钥加密\"预主秘钥\"（Pre-\nMaster Secret），然后发送给服务器。服务器使用私钥解密得到预主秘钥，双方基于此计算出相同的对话密钥。\n\n最后，使用对话密钥对传输的数据进行加密和解密。因为对话密钥是对称的，所以加解密速度快，适合大量数据的加密传输。同时，TLS/SSL协议还保证了数据的完整性和防篡改性。\n\n总的来说，HTTPS通过TLS/SSL协议实现了数据传输的加密，确保了网络通信的安全性。\n\n  1. Swift的编译流程Swift的编译流程主要包括以下几个步骤：\n  2. 源代码编写：开发者使用Swift语言编写源代码，这些源代码文件通常以.swift为扩展名。\n  3. 编译成中间表示（IR）：Swift编译器首先将Swift源代码编译成一种称为中间表示（Intermediate Representation，简称IR）的形式。IR是一种与平台无关的表示形式，它包含了源代码的抽象语法树（AST）和一些优化信息。\n  4. 优化：在生成IR之后，编译器会进行一系列的优化工作，以提高代码的执行效率。这些优化可能包括去除未使用的代码、内联函数调用、循环展开等。\n  5. 生成目标代码：优化后的IR会被进一步编译成目标平台的机器代码。这个过程可能会涉及到不同的后端编译器，取决于目标平台是iOS、macOS、Linux还是其他系统。\n  6. 链接：如果项目中包含了多个编译单元或者使用了第三方库，编译器还需要将这些部分链接起来，形成最终的可执行文件。\n  7. 调试信息生成：为了能够在后续的调试过程中使用，编译器还会生成调试信息。这通常需要在编译时加上特定的参数，如-g参数，以便在目标文件中包含必要的调试信息。\n  8. 运行或打包：最后，编译完成的可执行文件可以直接运行，或者根据需要进行打包，以便于分发或部署。\n\n总的来说，整个编译流程确保了Swift代码能够被高效地转换成可以在特定平台上运行的机器代码，同时提供了必要的调试支持。Swift的设计还注重内存安全性和原生错误处理，以提高应用的稳定性和安全性。15.\n在Swift编程语言中，线程锁的实现方式是什么？请详细描述其工作原理和使用方法。在Swift编程语言中，线程锁可以通过多种方式实现，包括互斥锁（Mutex）、递归锁、读写锁以及使用DispatchQueue**等。\n线程锁的工作原理主要是通过**\n控制对共享资源的访问来实现线程同步**。当一个线程获得锁时，它会阻止其他线程访问被锁定的代码区域或资源，直到该线程释放锁为止。这样可以防止多个线程同时修改同一份数据，从而避免数据竞争和不一致的问题。\n\n要在Swift中使用线程锁，首先需要选择合适的锁类型。例如，如果需要保护的代码区域允许递归调用，那么应该选择递归锁。如果多个线程只需要读取共享数据而不进行写入，那么可以使用读写锁来提高效率。具体操作如下：\n\n  * 互斥锁（Mutex）：可以使用pthread_mutex_t类型的互斥锁，它在锁定时会阻塞当前线程，直到锁被释放。这种锁适用于保护临界区的代码，确保同一时间只有一个线程可以执行这部分代码。\n  * 递归锁：Swift中的NSLock类可以实现简单的互斥锁，但它不是递归的。如果需要递归锁，可以考虑使用NSRecursiveLock类。\n  * 读写锁：可以使用pthread_rwlock_t类型的读写锁，它允许多个读线程同时访问，但在写线程获取锁时会阻止其他所有线程的访问。\n  * DispatchQueue：可以使用GCD提供的DispatchQueue来实现同步。通过创建串行队列，可以确保任务按顺序执行，从而避免竞争条件。此外，还可以使用dispatch_barrier_async函数在并行队列中创建屏障，以实现读写锁的功能。 总的来说，在使用线程锁时，需要注意正确配对加锁和解锁操作，并且确保加锁和解锁操作在同一个线程中进行。错误的使用线程锁可能导致死锁或线程阻塞等问题，因此在使用时应谨慎并遵循最佳实践。\n\n  1. guard和if的区别 综上所述，虽然guard和if在功能上相似，但guard提供了一种更为优雅和简洁的方式来处理条件判断，尤其是在需要早期退出和处理Optional类型时。使用guard可以帮助编写更加清晰、易于维护的代码。\n  2. 怎么检测野指针？\n  3. 优先级反转的情况遇到过吗，怎么解决 挂了，考的排列组合题和环大小找到环题\n\n小红书一面17. 主线程里加入三个串行线程会有什么影响？18. 串行队列和并行队列的区别19.\n并发和并行的区别并发和并行是两种不同的任务执行方式，它们在概念上有所区别。以下是具体分析：\n\n  * 并行（Parallelism）：并行是指多个任务在同一时刻被多个执行单元同时处理。这通常需要多核处理器或多处理器系统来实现真正的同步执行。在并行处理中，每个任务都独立于其他任务运行，并且可以同时利用不同的CPU核心或处理器资源。\n  * 并发（Concurrency）：并发是指多个任务交替执行，但给人的感觉好像是同时进行的。并发主要是通过任务调度来实现的，即操作系统快速地在不同任务之间切换，使得每个任务都有机会执行。并发可以在单核处理器上实现，因为虽然任一时刻只有一个任务在执行，但通过快速切换，可以有效地模拟出多个任务同时运行的效果。 总的来说，并行关注的是任务的物理执行，而并发关注的是任务的逻辑调度。两者都是操作系统中重要的概念，用于提高系统资源的利用率和提升用户体验。\n\n  1. block、代理和闭包的特性，区别\n  2. ARC具体会在什么时候运行 编译和运行的时候\n  3. 串行队列和同步队列会创造新的线程吗 队列（Queue）本身通常不直接创建线程，而是依赖于派发队列（Dispatch Queue）或线程池来管理和调度任务的执行。当将任务添加到队列中时，底层的派发机制会决定是否创建新的线程来处理这些任务。\n\n在并行队列（Parallel\nQueue）中，系统会根据可用资源和负载情况自动创建和管理线程。当你将任务添加到并行队列时，如果当前有可用的线程，系统会立即分配一个线程来执行该任务。如果没有可用的线程，系统可能会创建新的线程来处理任务。\n\n在串行队列（Serial\nQueue）中，由于任务是按顺序逐个执行的，因此通常不需要创建多个线程。系统会按照任务添加到队列的顺序，逐一在单个线程上执行这些任务。\n\n在某些情况下，你可以自己创建和管理线程，然后将任务分派到特定的队列中。但这通常需要更细致的控制，并需要手动处理线程生命周期和同步问题。\n\n总的来说，队列本身并不直接创建线程，而是由底层的派发机制根据任务的性质和队列的类型来决定何时以及如何创建线程来处理任务。23. Property\nwarpperhttps://juejin.cn/post/6844904018121064456#%E6%A6%82%E8%A7%8824.\nOC/Swift的宏区别25. 函数的具体存储和定义和使用（内存上）26. Swift的类型安全主要体现在哪些方面？27.\n尽管Swift是类型安全，但线程仍然存在崩溃现象，请描述线程可能崩溃的场景尽管Swift是类型安全的语言，但线程崩溃仍然可能发生。以下是一些可能导致线程崩溃的场景：\n\n  * 死锁：当两个或多个线程相互等待对方释放资源，导致彼此都无法继续执行时，就会发生死锁。这通常发生在多个线程访问共享资源时，没有正确的同步机制。\n  * 数据竞争：当多个线程同时访问和修改同一个数据时，可能会导致数据不一致和其他未定义的行为。Swift的内存模型并不能完全保证原子操作的线程安全性，因此需要使用适当的同步机制来避免数据竞争。\n  * 栈溢出：每个线程都有自己独立的栈空间，用于存储局部变量和函数调用信息。如果栈空间不足，会导致栈溢出，进而引发线程崩溃。\n  * 信号处理：当线程接收到某些特定的信号（如段错误、浮点异常等）时，如果没有正确处理这些信号，就可能导致线程崩溃。\n  * 内存泄漏：虽然Swift使用自动引用计数（ARC）进行内存管理，但在某些情况下，循环强引用或不正确的使用unowned和weak关键字可能导致内存泄漏，最终导致线程崩溃。\n  * 非法指令：如果线程执行了非法指令（如除以零、访问无效的内存地址等），会导致线程崩溃。\n  * 资源耗尽：当线程消耗的资源超过系统限制（如打开的文件描述符数量、虚拟内存大小等）时，也可能导致线程崩溃。 总的来说，线程崩溃通常是由于多线程编程中的同步问题、资源管理不当或非法操作等原因导致的。为了避免线程崩溃，需要在编程时充分考虑线程安全性、正确使用同步机制、合理管理资源以及处理异常情况。\n\n  1. Swift是静态语言，在编译的时候就能指定指向函数的指针了吗？ 考的encodeString字符串转码：ABC3[d] -> ABCddd 二面 工程题目：一个疯子和很多乘客一起选择飞机的座位，座位优先级为靠门靠前靠窗，疯子可以随便选座位，提供飞机的座位图和乘客的长度和疯子在乘客的位置，请设计一个工程，返回最后选完的座位图\n\nrequire和便捷哪个是横向是上向可选类型是引用传递还是值传递离屏渲染iosproperty\nwrapper（属性包装器）是一种用于扩展类、结构体和枚举类型的功能。它允许您为属性添加额外的行为，例如计算属性、观察者、键值编码等。要使用\nproperty wrapper，您需要创建一个带有 @propertyWrapper 注解的结构体。这个结构体需要实现一个名为 wrappedValue\n的可变或不可变属性，以及一些可选的初始化方法和属性观察者。下面是一个简单的 property wrapper 示例：\n\nOmi顶对科技面试28. Swift的类型安全主要体现在哪些方面？闭包是如何实现的。内存上是如何传递的\n\n阿里三面大数用链表形式相加\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595321928303296512?sourceSSR=users",
        "title": "腾讯初试",
        "content": "面试凉凉预料之中，虽然是非技术，不过我觉得也可以分享给大家讨论一下\n\n内容运营面试经过\n\n1.上来不是自我介绍，是拉家常，hr是我的学长22届的，跟我说是自家人，就不怎么紧张了\n\n2.自我介绍\n\n3.问为什么不从事机械专业的工作，想来互联网\n\n4.介绍我在我的4份实习中的主要工作内容\n\n5.在这些实习中学到了什么\n\n6.你觉得你有什么优点\n\n7.为什么想做内容运营\n\n8.你认为的内容运营是什么？\n\n9.你的文案能力如何？有没有什么代表？能不能现场写/说一段\n\n10.我都用过腾讯哪些产品\n\n11.你用过的这些产品中哪个最好\n\n12.这款产品和某某产品（竞品）对比如何？\n\n13.对工作地点接受吗？\n\n反问\n\n如果我万分有幸的入职的话，我会涉及到哪个事业群的业务\n\n针对我刚刚的表述，对我有什么建议吗？\n\n最后我的学长告诉我几率渺茫，再加上我的专业是机械不是互联网本专业，做好凉的准备\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595309241158684672?sourceSSR=users",
        "title": "百度-后端面经（二面）",
        "content": "百度-后端面经（二面）- 50分钟  \n岗位：百度-AI创新产品部_后端研发实习  \n忘记开录制了，尽力回忆的😥😥😥  \n  \n1\\. 介绍实习的项目，一些细节的问题。问得很细，还提了一些异常情况怎么处理  \n2\\. go的GC  \n3\\. Mysql查询优化  \n4\\. 限流、熔断怎么做  \n5\\. 平时有用过的Go框架，他们的区别  \n  \n题：有几个队列，每个队列有一些数，顺序从队列从取数。如果这个数之前没取过，就把这个数放入结果集里。  \n输入: [[2 3, 6], [1, 3, 5, 8], [1, 6, 7]]  \n输出:[2, 1, 3, 6, 5, 7, 8]  \n  \n闲聊：  \n上一次在百度网盘的工作内容，为什么辞职，入职后的工作内容，实习时间。  \n  \n2024-03-12更新:    已g。  \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595299704028614656?sourceSSR=users",
        "title": "终于轮到哥们发面经了",
        "content": "# 背景介绍:\n\n先说一下学历背景：某不知名乡下双一流，软件工程专业本科。\n\n但是一直以来都想干游戏设计师，学软件是想作为一个跳板罢了（我才不会说是因为高考没考上树莓）。\n\n主攻游戏系统。手上有几个项目，但成绩也说不上好，最大的优势可能就是起步早以及懂技术。\n\n23年底至今一直在投，过程相当曲折，风雨飘摇兮，魂安何方。\n\n（想到哪写到哪）\n\n23年底:\n\n# funplus:\n\n简历投递后无消息。\n\n# 沐瞳科技:\n\nhr问对技术策划有没有兴趣，答曰也行，而后无消息。\n\n# **杭州炎魂：**\n\n投递半个月后收到笔试。\n\n##  _炎魂笔试_\n\n炎魂的笔试有文案，关卡系统三个方向，为期一个星期。不过可惜的是我收到笔试时大限已经过去了三天，题目有一定难度，也很有挑战，写得很爽。\n\n##  _炎魂hr电话面：_\n\n大概一周后收到hr电话，是个声音很好听的小姐姐，问了问项目细节和为什么要做策划，之后预约一面。\n\n##  _炎魂一面：_\n\n面试细节记不清了，不过面我的貌似是项目主策，面试压力很大。从聊天中大概知道是个格斗游戏大神。\n\n问我最近在玩什么游戏，答JRPG和ARPG，问具体的游戏，当时在玩破晓传说于是答了破晓传说。\n\n又问玩不玩格斗游戏，答不怎么玩，试了试真人快打便浅尝辄止。\n\n问有没有注意到ARPG和格斗游戏在战斗设计上的区别，答对格斗游戏印象不深，请求提示。提示后回答的应该还行，毕竟当时注意到面试官频频点头。\n\n而后问了问自己的一些项目细节以及为啥想做策划，又问了为啥想做系统策划不想做战斗策划，让我区分二者的差异，不过当时对策划这个职位的具体工作内容和能力要求不大清楚，所以答的非常不好\nps：现在也不是很清楚\n\n然后面试官叫我等一下，一分钟后，来了第二个面试官，看起来至少是个制作人。\n\n第二个面试官非常详细的问了很多自己项目的设计细节。并问了我的职业规划，同时给了很多建议，非常支持我找实习，并让我对策划实际工作和理想的差异做好心理准备，受益匪浅。\n\n最后也问了我想做什么项目，并给出了炎魂当时的几个项目，包括已经上线的和在研的。当时坚持自己想做在研项目，现在想想挺蠢的，如果不这么坚持可能就放我进忍三项目组了，毕竟自身能力距离去做在研还远远不够，忍三做做活动看看文档也能学到不少东西。\n\n一周后收到二面通知，炎魂在研项目组。\n\n##  _炎魂二面:_\n\n二面面试官是炎魂在研项目主策，非常随和，但是貌似始终对不上电波。\n\n主要就我的游戏经历进行了提问，问了问各个JRPG之间的差异以及觉得P5设计较好的点，当时没有意识到面试官想让我谈P5的社区设计，于是答了战斗系统，并且答得很不好。\n\n整体没聊多久，最后得知是个经验模拟派对项目，立刻知道自己寄了。\n\n果不其然，一周后得知面试挂了。[笑cry]\n\n## 总结：\n\n炎魂的流程应该是相当严格的，简历筛一批，笔试筛一批，hr电话又筛一批，之后才能面到，而且一面压力相当大，感觉能进去的都不简单。\n\n不过这里不得不说，炎魂的笔试和面试体验都相当好，光是和面试官聊聊就能有不少的收获。而且我一月底也在炎魂参加了ggj，hr小姐姐非常可爱且平易近人，对这个公司的印象极佳。[赞]\n\n24年初\n\n# **北京点点互动**\n\n也是BOSS直聘投的，简历过了之后hr来约了一面。\n\n##  _点点互动一面：_\n\n首先自我介绍。\n\n之后主要就自己的项目进行了细节上的提问。也问了问我玩不玩模拟经营，答城市天际线。而后问我能不能接受模拟经营，答现阶段什么类型都接受。之后就直接进入反问环节了。\n\n面试感觉非常宽松，虽然前后也有半个小时但没有聊其他游戏和我对其他游戏的理解，有点奇怪。\n\n几天后收到hr通知，说面试过了，商定了入职和薪资细节，等待offer流程。\n\n之后我自己在学校这边做了很多去实习的请假和准备。并四处查询资料，做北京租房功课。\n\n2月9日（大年三十）晚，hr通知老板要大推，不招新人[黑牛问号]（严重怀疑说辞真实性），总之就是毁oc了，于是原定大年初五飞往北京的计划取消，老老实实回到学校。\n\n## 总结\n\n点点互动的面试流程给我的感觉相当奇怪，一个是面试标准非常低，没问什么细节，而且居然只要面一次。另一个是口头offer发了了两周后，大年三十晚上告诉我没了，感觉非常离谱。\n\n还好我当时还在老家农村，要是再晚几天人就到北京准备上班了。如果我到北京挑好房签了租金再得知这个消息，那我对这家公司的印象得是负分。（问问如果遇到这种情况能拿赔偿吗）\n\n# **腾讯:**\n\n2月底，在腾讯泡了许久池子的我突然收到群面通知。\n\n## 腾讯群面:\n\n群面体验相当糟糕，题目是和社交派对相关的分析以及基于某个游戏提个创新方案。可惜自己不怎么玩派对游戏。\n\n题目还是其次，群面体验最糟糕的地方在于，一群队友虽然学历履历比你高，但是个个抢着出头，丝毫不注意时间，比如在自我介绍阶段大讲自己的光辉履历。我自己自我介绍大概二十多秒，但是十个人自我介绍总共花了将近十分钟。。。。[笑cry]\n\n由于计时者的发言根本止不住队友讨论的热情，所以整个讨论过程都是不可控且混乱的，前期我还参与讨论，中后期直接开摆，知道大概率全队都寄了。\n\n次日查看进度，全队寄没寄不清楚，反正我是寄了。\n\n## 总结\n\n给个忠告，群面大家是来合作的，不要想着抢风头。中心放在问题讨论上，然后要严格计时。群面的题目其实不难，难的是十个人如何默契的正常讨论。毕竟那么点时间你能讨论出个啥。\n\n# 莉莉丝:\n\n莉莉丝我最开始投的是系统策划，但是hr电话告诉我系统策划是留给24届的，于是给我安排了第二天的slg日常实习战斗策划的面试。\n\n当时不清楚slg的战斗策划要干嘛，于是熬夜体验了多款slg手游并做了战斗拆解（不过后面面试中并没有用上）\n\n次日\n\n## 莉莉丝一面:\n\n自我介绍。\n\n问项目细节，这次不同于之前的面试，问的相当有水平，问到了自己的很多盲点。在这方面交流了很久。\n\n而后交流了一下游戏经历，很尴尬地发现面试官玩的我不玩（或者买不起），我玩的面试官还没玩。\n\n而后面试官看我对p5有一定理解，在给我介绍了星轨和八方旅人战斗系统的前提下（这两款我还没来得及玩），问我p5，星轨，八方旅人在战斗系统设计上的差异。\n\n我思考了两分钟后进行了回答，不过感觉自己答的中规中矩，毕竟后两者是真没深度体验过。\n\n之后又进行了一番游戏经历交流，发现我玩过黑魂，体验过只狼，于是询问我二者的设计差异。以及觉得黑魂中体验的核心是什么。\n\n当时在黑魂上答的还可以，只狼上就不行了，于是面试官问我只狼打到了哪里，**答曰蝴蝶夫人和鬼邢部**\n，估计把面试官干无语了。（黑魂3二周目，但是只狼只在舍友电脑上体验过。。。）\n\n于是又问玩不玩法环，答曰买不起。\n\n最后面试官思索了一会儿，问了问黑魂中设计单向门的原因以及其使用频繁的原因。思考了一分钟后对设计原因做出了回答，但是使用频繁的原因则没有思路，遂作罢，进入反问环节。\n\n一面持续了差不多一个小时，问到了很多盲点，并发现自己游戏的方向确实太窄了，数量也不足，而且新游戏玩得太少（主要是缺钱），导致面试时容易出现面试官不知道聊啥的尴尬情况。除此之外，面试时有点紧张，导致一些话说得前言不搭后语，思路也不够清晰，思考不到位，一些平时能正常运作的思维模式给丢了个七七八八，所以自我感觉整了个烂活。\n\n不过整体来说面试体验相当好，毕竟确实挖掘出了自己的不足，自身确实学到了很多。这就值当了。\n\n面完后觉得自己应该差不多寄了，想着收获不少也无所谓，没想到三日后收到二面邀请。\n\n## 莉莉丝二面:\n\n二面的是主策。\n\n自我介绍。\n\n问我玩不玩手游，答曰否。\n\n就我的项目进行了讨论。\n\n问了问p5最吸引我的是什么。刚好在做炎魂笔试题的时候详细拆解了p5，所以自我感觉答得还行。\n\n问我有没有在玩p3r，答曰在高强度游玩。于是问了一些在社群设计上的区别，以及觉得哪个设计更好。自我感觉答得也还行\n\n而后问我有没有关注p5x，答曰有但不多。让我分析将p5改成手游要着注意什么，以及怎么改。这个问题有点难到我，因为我几乎不玩手游。所以答的并不理想。\n\n而后问p5和其他jrpg在战斗设计上的区别，以及觉得p5的战斗有什么缺陷。感觉自己答的时候思考还是不够充分，可能是其他回合制jrpg玩的太少了，除了p3，p4g，p3r就只有勇者斗恶龙了。所以只能拿DQ11S的战斗系统和P5作对比。\n\n而后聊了聊自己的职业规划后进入反问。\n\n## 总结\n\n二面相比于一面，时间短了一些，问的基本上是我有过一些研究的地方，所以除了手游部分外，没有太多卡壳的地方。二面面试官提醒我系统策划需要进行更广泛的游戏游玩，这也确实是我想成为系统策划的道路上的一大障碍。相比于在某一类游戏深研，提升游戏的广度更是我当下应该做的，最起码目前市面上比较火的游戏还是很有必要去进行完善体验的。所谓大范围要广，一方面要精。\n\n整体下来莉莉丝的面试体验也是极好的，面试官会先做自我介绍再请你自我介绍，让你对他们的项目有个了解[赞]。而且在你好像有思路但不多的时候会给予一些提示，有时候一些轻微的点拨总是能拨开面试者思考的迷雾。\n\n莉莉丝后续:\n\n莉莉丝已挂，看了一下日常实习岗位也消失了。\n\n估计一方面更多地资源要给暑期实习，另一方面自己在二面时在手游部分回答不佳吧。接下来准备再观望一下暑期和下半年的实习机会，游戏方面补充补充手游端游类型的游玩经历。然后有比赛或gamejam的话也都去参加，希望未来顺利吧。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595293773639237632?sourceSSR=users",
        "title": "小鹅通前端实习一面",
        "content": "1.自我介绍，如何接触的前端，公司在深圳，为什么会来深圳实习\n\n2.什么是bfc\n\n3.粘性定位的原理是什么\n\n4.如何判断变量是不是一个数组\n\n5.如何浅拷贝数组\n\n6.new Set()方法的作用是什么，new Set([{a:'1'},{a:'1'}])的返回值是什么\n\n7.nexttick的原理\n\n8.微任务和宏任务\n\n9.讲讲vite打包工具的构建流程（不太了解[牛泪]）\n\n10.如果遇到用户反馈页面的性能比较差，我们需要做一个分析然后做迭代优化，你该怎么做这个事情\n\n反问\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595291569515671552?sourceSSR=users",
        "title": "腾讯 pcg 后台实习 二面凉经",
        "content": "  1. 自我介绍\n  2. 面试官介绍部门\n  3. 撕项目主要问了lru-k算法，内存池实现，内存池还问我有没有了解比较出名的实现(没有)\n  4. 八股 内存对齐 继承和包含的区别 unordered_map rehash过程，c++ stl中有没有线程安全的容器，互斥锁 自旋锁 读写锁 条件变量 简单实现无锁队列 如何查看一个程序的调用堆栈(gdb),如何不通过gdb查看(不知道),gdb用法，linux用过什么命令，查询网络状态的有什么，查询磁盘空间的命令\n  5. 问我实习时间，能不能996，有没有过996\n  6. 反问\n\n全长50min左右，无代码题，回答了大概90%左右的问题，还是秒挂[牛泪]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595286208343805952?sourceSSR=users",
        "title": "B站测开 一面面经 （已挂）",
        "content": "简易版抖音是如何实现的？实现具体有什么功能？里面有没有服务数据的交互？你的接口是怎么设计的？你是如何学习的？\n\n请说出go和python语言的区别？\n\n手撕：快排找到第k个数 以及力扣387\n\n数据结构里面有哪些数据结构类型？请说出各自的特点？\n\n如果有非常乱序的数组，你会选择什么排序算法？\n\n请说一下tcp三次握手？\n\ntcp和udp的区别？\n\ntcp是如何保证可靠传输的？\n\nudp和tcp常用的协议有哪些？\n\nhttp和https的区别？\n\n在浏览器输入一个url，一直到显示到你屏幕上的全过程？\n\nHTTP协议有哪些请求类型？\n\nget和post的区别？\n\nhttp的响应码\n\n数据库：\n\n什么是关系型数据库，什么是非关系型数据库？\n\n说一下mysql和redis各自的功能和区别？\n\nmysql的增删改查的关键字？\n\n写一个查询成绩表中姓陈，成绩在90分以上的同学\n\n索引是什么？什么场景会使用索引？\n\n聊天：\n\n最近阅读的一本书？有没有读后感分享？\n\n你说你基于技术驱动，请你举例说明？\n\n有用chatgpt搭建站点吗？\n\n对测试开发岗位的认知？\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595283224071344128?sourceSSR=users",
        "title": "海康威视笔试凉经（供大家参考）",
        "content": "## 选择/多选（就记得这么多了）\n\n#### 线程同步机制\n\n下面是几种常见的线程同步的方式：\n\n  1. **互斥锁(Mutex)** ：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。\n  2. **读写锁（Read-Write Lock）** ：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。\n  3. **信号量(Semaphore)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。\n  4. **屏障（Barrier）** ：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都到达屏障后，它们才会一起继续执行。比如 Java 中的 CyclicBarrier 是这种机制。\n  5. **事件(Event)** :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作\n\n#### Mybatis当中的￥{} 和 # {}\n\n**#{}方式能够很大程度防止sql注入(安全)，${}方式无法防止Sql注入**\n\n在JDBC能使用占位符的地方,最好优先使用#{}\n\n在JDBC不支持使用占位符的地方,就只能使用${}，典型情况就是 **动态参数**\n\n#{}实现的是向prepareStatement中的预处理语句中设置参数值，sql语句中#{}表示一个占位符即?\n\n#### TCP协议\n\n#### lambda表达式的使用规则\n\n#### 异常是不是对象？\n\n#### PreparedStatement和Statement的区别\n\n  1. **Statement** ：\n  2. **PreparedStatement** ：\n\n#### SpringBoot读取配置文件的注解\n\n@PropertySource,@Value,@Environment,@ConfigurationProperties\n\n#### newInstance属于哪个类\n\n#### Java窗口函数关键字\n\n窗口函数是 SQL 中一类特别的函数。和聚合函数相似，窗口函数的输入也是多行记录。不 同的是，聚合函数的作用于由 GROUP BY\n子句聚合的组，而窗口函数则作用于一个窗口， 这里，窗口是由一个 OVER 子句 定义的多行记录。聚合函数对其所作用的每一组记录输\n出一条结果，而窗口函数对其所作用的窗口中的每一行记录输出一条结果。一些聚合函 数，如 sum, max, min, avg,count\n等也可以当作窗口函数使用\n\n#### 1.聚合窗口函数\n\n许多常见的聚合函数也可以作为窗口函数使用，包括AVG()、SUM()、COUNT()、MAX()以及MIN()等函数。\n\n#### 2.排名窗口函数\n\n排名窗口函数用于对数据进行分组排名，包括ROW_NUMBER()、RANK()、DENSE_RANK()、PERCENT_RANK()、CUME_DIST()以及NTILE()等函数。\n\n#### 3.取值窗口函数\n\n取值窗口函数用于返回指定位置上的数据行，包括FIRST_VALUE()、LAST_VALUE()、LAG()、LEAD()、NTH_VALUE()等函数\n\n#### WEB输出值不完全可能会造成哪些漏洞？\n\n跨站脚本攻击（XSS）、跨站请求伪造（CSRF）、SQL注入、HTTP响应拆分、信息泄露、文件包含漏洞；\n\n## 编程题\n\ntable(date, user_id, time) (20230101, 1 , 2023-1-01 9-01- 00 00 00)\n\n找出各个用户一周的活跃天数：\n\n    \n    \n    SELECT user_id, COUNT(DISTINCT DATE_FORMAT(time, '%Y-%m-%d')) AS active_days\n    FROM table\n    WHERE time >= DATE_SUB(CURDATE(), INTERVAL 1 WEEK)\n    GROUP BY user_id;\n    \n\n请 使用模板方法设计模式实现下面场景：\n\nA：巡查机房各服务器状态是否存在正常/异常\n\nB：巡查班级同学的出勤 远程视频检查\n\n完成后均需提交结果\n\n    \n    \n    abstract class InspectionTemplate {\n        // 模板方法，定义了巡查的算法框架\n        public final void inspect() {\n            startInspection(); // 具体步骤1\n            checkStatus();     // 具体步骤2\n            submitResult();    // 具体步骤3\n        }\n    \n        // 具体步骤1：开始巡查\n        protected abstract void startInspection();\n    \n        // 具体步骤2：检查状态\n        protected abstract void checkStatus();\n    \n        // 具体步骤3：提交结果\n        protected abstract void submitResult();\n    }\n    \n    class ServerInspection extends InspectionTemplate {\n        // 具体实现步骤1：开始巡查服务器\n        @Override\n        protected void startInspection() {\n            System.out.println(\"开始巡查服务器状态...\");\n        }\n    \n        // 具体实现步骤2：检查服务器状态\n        @Override\n        protected void checkStatus() {\n            System.out.println(\"检查服务器状态是否正常/异常...\");\n            // 具体的检查逻辑\n        }\n    \n        // 具体实现步骤3：提交服务器巡查结果\n        @Override\n        protected void submitResult() {\n            System.out.println(\"提交服务器巡查结果...\");\n            // 具体的提交逻辑\n        }\n    }\n    \n    class ClassAttendanceInspection extends InspectionTemplate {\n        // 具体实现步骤1：开始巡查班级出勤\n        @Override\n        protected void startInspection() {\n            System.out.println(\"开始巡查班级同学的出勤...\");\n        }\n    \n        // 具体实现步骤2：远程视频检查\n        @Override\n        protected void checkStatus() {\n            System.out.println(\"远程视频检查同学的出勤情况...\");\n            // 具体的检查逻辑\n        }\n    \n        // 具体实现步骤3：提交出勤巡查结果\n        @Override\n        protected void submitResult() {\n            System.out.println(\"提交出勤巡查结果...\");\n            // 具体的提交逻辑\n        }\n    }\n    \n    public class TemplateMethodPatternExample {\n        public static void main(String[] args) {\n            // 巡查服务器状态\n            InspectionTemplate serverInspection = new ServerInspection();\n            serverInspection.inspect();\n    \n            System.out.println();\n    \n            // 巡查班级出勤\n            InspectionTemplate classAttendanceInspection = new ClassAttendanceInspection();\n            classAttendanceInspection.inspect();\n        }\n    }\n    \n\n三数之和\n\n    \n    \n    public class threeSum {\n    \n        public static void main(String[] args) {\n            int[] array = new int[]  {-1, 0, 1, 2, -1, -4};\n    \n            for (int i =0 ; i < threesum(array).size(); i++) {\n                System.out.println(threesum(array).get(i));\n            }\n        }\n        public static List<List<Integer>> threesum(int[] numbers) {\n            // 1、首先对数组进行排序\n            List<List<Integer>> result = new ArrayList<List<Integer>>();\n            Arrays.sort(numbers);\n            // 2、对数据进行遍历\n            for (int i = 0; i < numbers.length; i++) {\n                // 因为是排好序的数组，所以i的值必须是小于0的\n                if (numbers[i] > 0) {\n                    return result;\n                }\n                // 跳过重复值\n                if(i > 0 && numbers[i-1] == numbers[i]) {\n                    continue;\n                }\n                // 设定双指针\n                int a = i + 1;\n                int b = numbers.length - 1;\n                while(a < b) {\n                    if (numbers[i] + numbers[a] + numbers[b] < 0) {\n                        a++;\n                    }else if (numbers[i] + numbers[a] + numbers[b] > 0) {\n                        b--;\n                    } else {\n                        List<Integer> list = new ArrayList<>();\n                        list.add(numbers[i]);\n                        list.add(numbers[a]);\n                        list.add(numbers[b]);\n                        result.add(list);\n    \n                        while(a < b && numbers[a + 1] == numbers[a]) a++;\n                        while(a < b && numbers[b - 1] == numbers[b]) b--;\n    \n                        a++;\n                        b--;\n                    }\n    \n                }\n            }\n            return result;\n        }\n    }\n    \n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595243509733478400?sourceSSR=users",
        "title": "腾讯一面(凉",
        "content": "  1. 自我介绍\n  2. 3个项目细问\n  3. ThreadLocal 什么情况内存泄漏\n  4. spring AOP实现原理 ( 忘记详细解释下jdk代理和 cglib了,只说了下流程)\n  5. 单例模式的好处\n  6. redis内存结构 \n  7. redis key删除策略\n  8. 缓存雪崩,解决\n  9. mysql 为什么选用b+\n  10. 查询优化\n  11. 联合索引, 覆盖索引\n  12. 解释一下间隙锁\n  13. Jvm 永久代存的内容\n  14. springboot 如何做到启动的时候注入一些bean\n  15. springboot 默认的包扫描路径?\n  16. TCP 为什么需要4次挥手\n  17. java.util.concurrent 包下了解哪些\n  18. 无手撕\n\n只记得这么多了..\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595216866339991552?sourceSSR=users",
        "title": "#排队干饭#acwing#复旦大学机试",
        "content": "提示：本代码并未通过极限情况下的测试用例（10000个数据），因为vector申请的内存空间过大，其他使用数组的题解均有这种情况\n\n链接[https://www.acwing.com/problem/content/description/5063/](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.acwing.com%2Fproblem%2Fcontent%2Fdescription%2F5063%2F)\n\n    \n    \n    #include <iostream>\n    #include <cstdio>\n    #include <vector>\n    \n    using namespace std;\n    \n    int main(){\n        int n;\n        int ai,bi,ti;\n        vector<int> veca,vecb,vect;//到达时间，等待时间，打饭时间\n        int cur_time;//记录当前时间\n        scanf(\"%d\",&n);\n        while(scanf(\"%d%d%d\",&ai,&ti,&bi)!=EOF){\n            veca.push_back(ai);\n            vect.push_back(ti);\n            vecb.push_back(bi);\n        }\n        cur_time=veca[0];\n        for(int i=0;i<n;i++){\n            if(cur_time<=veca[i]) cur_time=veca[i];\n            if(cur_time<=veca[i]+vecb[i]){ //下个同学可以打饭\n                printf(\"%d \",cur_time);\n                cur_time+=vect[i];\n            }\n            else {\n                printf(\"-1 \");\n            }\n        }\n        return 0;\n    }\n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595204788212477952?sourceSSR=users",
        "title": "海康威视前端实习一面",
        "content": "前天约的面好像是\n\n30min，忘记录音了，没有手撕，回忆一下记得的\n\n1.自我介绍，问技术栈\n\n2.设备声音点有问题非常小没怎么听清，交涉了好几分钟听明白大概问的是跨域解决和webpack中proxy配置，答得不好\n\n3.有没有手写过页面，讲讲。怎么用浮动实现导航栏的布局\n\n4.有没有手写过动画，讲讲\n\n5.vue组件间的通信方式\n\n6.vue的hook和react的hook的区别\n\n7.有没有搭建过静态网站，想问有没有用过vitepress\n\n大概是这些，八股挺少的\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595239229605593088?sourceSSR=users",
        "title": "腾讯 一面(凉",
        "content": "刚面完的时候忘记写了,有点忘记了.\n\n上来先手撕4道题\n\n  1. 拼接url\n  2. 链表, 如果后面存在比这个节点大的数字则删除该节点\n  3. 快照数组\n  4. 红眼睛蓝眼睛\n  5. 写完后, 说思路, 聊优化\n  6. 项目\n  7. 如何使用redis\n  8. redis 内存模型 ( 0.0 答成面向用户的数据结构的底层实现了, 感觉应该回答jemolloc 和 hashtable结构的)\n  9. docker实现原理\n  10. docker资源隔离如何实现的\n  11. docker底层还记得什么不\n  12. 反问\n\n大概就记得这么多了..\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595200806660354048?sourceSSR=users",
        "title": "大智慧前端一面",
        "content": "自我介绍\n\n1 上来拷打项目\n\n2 vuex存储位置，vuex为什么比storage好\n\n3 token存储位置\n\n4 动态路由实现，按钮权限\n\n5 按钮的隐藏怎么实现的，几种方式，v-if,v-show的区别\n\n6 css八股，position，选择器优先级等等\n\n7 js为什么是弱类型，删除数组第一个元素方法，判断数据类型方法\n\n8 验证码是干什么的\n\n反问公司做什么？ 大数据\n\n感觉没什么意思，不是很想继续面了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595027462489198592?sourceSSR=users",
        "title": "腾讯-IEG游戏数据-一面凉经复盘",
        "content": "## 算法\n\n排序有哪些\n\n❌手撕归并排序 : `错误原因：死在二分递归的边界上，必须要[l,r]`\n\n  * 我错误使用 [l,r），然后递归传入[ l,mid ) ,[ mid+1,r)\n  * 注意最好[l,r]且 每次mergeSort传入[l,mid] [mid+1,r]\n  * 同样合并有序数组中：i=l，j=mid+1，然后保证 i <=mid j<=r\n\n## 八股\n\n无\n\n## web项目\n\n### ❌JWT令牌的原理 ：\n\n`答：token的原理 + jwt生成头部、载荷、签名，客户端保存到本地,发送http请求时头部携带`\n\n首先了解JWT、cookies、session、token有什么区别？\n\n  * `cookies`的作用是：`让服务器在一段时间内认识你`或`保存你本地的信息`。发送请求时浏览器自动添加到http的cookies字段上。方便服务端识别并保存客户端的信息\n  * `session`：`服务端创建并维护的一个会话状态`，服务器创建连接后将其保存到本地，然后session通过cookies，第二次根据cookies中的session找原本的session信息\n  * `token`：为了`减轻服务端的存储和查询数据库压力`，服务端接收到客户端的登录消息后，签名并加密后返回密文，以后客户端的访问都在http请求头带上token，然后服务端解密算法就可以识别用户。\n  * `JWT`：`一种JSON格式的token`，同样是服务端签名加密后返回，客户端下一次发送的请求头带上，服务端解密后获取到用户信息，不需要收到用户信息后查找数据库来鉴权\n\n接着可以解答上面的问题：\n\n  * JWT在服务端是怎么生成的？根据登录信息，生成`头部（token的类型和加密算法`），`载荷（用户发送的登录身份信息）`，`数字签名（用来验证完整性和真实性）`\n  * JWT在客户端是怎么存储的？ `存在浏览器中（localStorage`，不清理再打开还有），存在`会话中（sessionStorage`，关闭当前页面就没了），`cookies（带在http报文中`每次自动发送）\n\n参考：\n\n> [还分不清\n> Cookie、Session、Token、JWT？](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F164696755)\n\n## 数据库内核\n\n### ⭕数据库持久性怎么实现？\n\n`日志记录，持久化，备份和恢复`\n\n### ⭕数据库日志的异步刷盘怎么实现？\n\n  * `日志写缓冲区`：日志先写入logBuffer中，然后满了以后成批刷入，减少IO消耗\n  * `原本的同步刷新是怎样的？`当发起写入操作时，当前线程执行刷入磁盘操作，将logBuffer中数据刷入到磁盘，直到刷入成功才返回并执行后序操作\n  * `刷新缓冲区flushBuffer`：从logBuffer复制到flushBuffer中就认为已经刷新了，等待刷新线程刷入磁盘\n  * `后台刷新线程`：缓冲区满以后 或者 定期 启动刷新线程，复制logBuffer到flushBuffer并刷入磁盘\n  * `异步是怎么实现的？`当发起刷入操作，直接刷入数据到内存中的flushBuffer，然后直接返回成功并做后序的操作，等待后台异步地线程将flushBuffer中的日志刷入磁盘\n\n### ❌异步刷盘后持久性还能实现吗？\n\n`答：不能，因为异步刷盘不能保证数据不丢失`\n\n  * 问题1：并发写入日志后出现刷新的情况怎么解决？`flush线程开始任务前对logBuffer互斥访问`\n  * 问题2：当复制到flushBuffer后还没刷入时发生了崩溃，能保持一致性吗？ `不能，因为是对logBuffer拷贝到内存中的flushBuffer，还未刷入时断电会丢失这部分数据，因此异步刷盘获得高性能的代价是丢失持久性`\n  * Mysql中也是根据场景，在commit或者abort时设置类似fsync的方式保证同步刷盘一定落盘成功，或者为了高性能采用异步刷盘后台线程1s刷新一次\n\n参考：\n\n> [掌握异步日志：解锁日志系统的效率和性能\n> ](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F663979637)[MySQL数据和日志的刷盘机制以及双一配置\n> ](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjuejin.cn%2Fpost%2F7126357291456004110)\n\n## OS\n\n### ⭕fork() 的原理，哪里体现了fork分配资源？\n\n`复制堆栈段，数据段，栈段等内存布局，但是代码段是映射的父进程的代码段以节省空间`\n\n### ⭕fork()是把进程从1个变成2个，那么最初的进程是从哪里来的？\n\n`系统启动时先加载内核，然后通过引导程序启动初始进程init或者叫systemd进程，是整个进程树的根节点`\n\n### ⭕启动进程是用户态还是内核态？\n\n`systemd进程是内核直接创建的，因此是内核态进程`\n\n### ⭕进程和线程的关系和区别\n\n  * `进程是资源分配的基本单位，有独立的内存空间，创建和切换的开销比较大`\n  * `线程是CPU调度的基本单位，线程是轻量级的进程，只有独立的一组寄存器,PC和栈以及ThreadLocal这样的本地存储，因此创建和切换开销更小`\n\n### ❌进程是通过fork创建的，linux下线程是怎么创建的?\n\n要了解并区分内核态和用户态线程\n\n  * `用户态线程的创建`：用户空间的线程库pthread负责管理，内核实际上是看不见的，可以看见并操作的最小粒度是进程\n  * `内核态创建线程`：系统调用clone，由内核直接负责创建、调度、资源分配\n\n参考：\n\n>\n> [linux：线程的3种实现方式（内核级，用户级和混合型）](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F111553897)\n>\n>\n> [Linux下调用pthread库创建的线程是属于用户级线程还是内核级线程？](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F35128513%2Fanswer%2F2891244832)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595237652211707904?sourceSSR=users",
        "title": "美团日常实习一面面经(凉凉)",
        "content": "  1. 自我介绍\n  2. 项目难点\n  3. 实习收获\n  4. 代码(简单题)\n  5. 浏览器输入url到业务程序过程,业务程序具体是如何收到这个请求的\n  6. spring mvc 流程\n  7. 如何理解mvc这个设计模式\n  8. 如何理解ioc di\n  9. synchronize 和 lock的区别\n  10. G1流程\n  11. G1和CMS有什么不同\n  12. mysql 索引结构\n  13. 解释一下B+的数据结构\n  14. 解释一下联合索引的结构\n  15. 如何优化慢sql\n  16. 介绍一下redis \n  17. go 和 java的区别\n  18. 设计题: 一条请求需要经过很多个系统, 如何收集这条请求的日志.\n  19. 这么设计对业务有侵入, 怎么可以无侵入\n  20. 反问\n\n0.0 面试官好评, 但是我太菜了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595026376453795840?sourceSSR=users",
        "title": "京东零售 Java后端实习面经",
        "content": "# 常规\n\n自我介绍\n\n## 八股\n\n面向对象\n\n继承\n\n访问修饰符的作用\n\n基本数据类型\n\nint 和 long 的区别\n\nint 和 Integer 的区别\n\n重载和重写的区别\n\n常见集合\n\nhashmap 底层实现\n\n反射的概念\n\n反射的实现\n\nAOP\n\n动态代理的两种方式\n\nJava 内存区域\n\n垃圾收集算法\n\n抛出异常和捕获异常\n\ntry、catch 的过程\n\nMySQL 和 redis 的区别\n\nredis 应用\n\nredis 实现分布式锁\n\n缓存雪崩、缓存击穿\n\n缓存击穿解决方法\n\n布隆过滤器\n\nspringmvc 作用\n\nIDEA 查找一个类，全文查找\n\ngit 常用命令\n\nhttp1.0/1.1/2/0 的区别\n\n反问\n\n面试官没开摄像头，不知道是不是kpi\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595022573885280256?sourceSSR=users",
        "title": "3.5袋鼠云前端开发工程师二面",
        "content": "二面很快 大概20分钟\n\n1.自我介绍\n\n2.问简历项目的人员分配\n\n3.讲讲浏览器缓存和CDN加速\n\n4.第一个项目中主要负责哪些部分\n\n5.与后端交互的时候如何进行参数和接口的定义的\n\n6.项目中觉得有什么做的好的地方（介绍了自适应的实现）\n\n7.项目中有没有遇到什么难点\n\n8.如何学习新技能和解决遇到的问题\n\n9.假如说现在给一个比较复杂的页面设计和功能需求，该如何去设计和考虑\n\n10.如何封装组件\n\n11.你的优点和缺点\n\n12.谈谈对数据结构的了解\n\n13.手写冒泡排序\n\n14.反问环节\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595020644220243968?sourceSSR=users",
        "title": "base上海 哔哩哔哩 前端实习面经",
        "content": "投递渠道：BOSS\n\n时间线\n\n  * 2024-02-20 投递简历\n  * 2024-02-23 一面\n  * 2024-02-27 二面\n\n**一面**\n\n  1. 为什么离职\n  2. 如何学习前端的\n  3. TypeScript 常见的工具函数\n  4. flex 布局常用属性\n  5. 如何理解 Promise, 有哪些常见的方法\n  6. 原型与原型链的理解\n  7. npm 版本 `^` 与 `~` 的区别: 前者兼容大版本, 后者兼容次版本\n  8. npm 三位数版本号的含义: breaking change, feature, bug fix\n  9. package-lock.json 的作用以及安装顺序: 如果与 package.json 冲突, 以 package.json 为准\n  10. 跨域问题与解决方案\n  11. rem 理解\n  12. iframe 的作用与使用场景, 如何与父级通信, 如果遇到跨域问题如何解决\n  13. 普通函数与箭头函数的区别, 箭头函数的 this 指向\n  14. 对于闭包的理解\n  15. 实习业务介绍\n  16. 项目难点\n  17. 项目中遇到的性能优化是如何做的\n  18. 前端性能优化有哪些方向\n  19. 竞态问题如何解决, 点击 TabA, 数据未返回又点击 TabB, 数据返回了, 如何保证数据的正确性\n  20. 浏览器缓存\n  21. 如何实现七天免登陆\n\n**二面**\n\n  1. 实习工作内容描述, 如何进行性能优化\n  2. 怎么从 vue 转到 react 的？\n  3. 介绍青训营项目\n  4. 青训项目：npm 安装机制\n  5. CSS：position 有哪些值, 分别代表什么意思, 分别相对于谁定位\n  6. CSS: 如何实现一个正方形\n  7. 手写代码, 原生实现一个点击 tab 切换的效果\n  8. 事件委托与 react 中的事件机制\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595019718096896000?sourceSSR=users",
        "title": "面试安全工程师被问的问题，回答的吞吞吐吐的",
        "content": "本人第一次面试，好多没有答上来，感觉应该过不了，面试问题供大家参考\n\n实习岗位是：安全工程师\n\n面试问题如下:\n\n1.做一下自我介绍：\n\n2.安全技术，主要掌握哪一些技能 一些渗透工具的使用\n\n比如burpsuite、sqlmap、nmap、nessus、awvs等工具，top10漏洞\n\n3.讲一下你最熟悉的两种漏\n\nsql注入和xss，SQL注入的原理和sqlmap的使用以及xss的原理\n\n4.加入说我们一个网站存在sql注入漏洞，在linux服务器上，网站语言是php，后端的数据库是mysql的，MySQL不对外访问。在这些前提下获取这个网站的webshell有哪几条攻击路径？\n\n写一句话木马用中国蚁剑进行连接\n\n5.同第4问接着问，写shell用到的函数有哪些\n\n用到 into outfile ，select 一句话木马 into out file 文件名，用sqlmap反弹shell\n\n6.除了用sqlmap反弹shell以外，还有其他的方式获取webshell吗？\n\n暂时没有了解\n\n7.在学习过程中有没有一次成功的渗透，这次渗透精力让你印象很深刻？\n\n综合渗透的实验，前期就是信息收集，用nmap扫描开放的端口，开放了80端口，访问该ip，发现是drupal框架，用metasploit搜索drupal漏洞，配置好相关攻击载荷。成功攻击，进入后渗透阶段。查看配置文件，发现存在MySQL数据库，明文获取了用户名和密码，用反弹shell登录MySQL\n查看users 获取网站的用户名和密码，发现密码是加密的，我们重新创建一个管理员账户和密码，然后用该账号成功登录。\n\n8.有没有提交过一些 src 提交过一些信息，信息泄露漏洞，文件上传漏洞\n\n9.提交的哪一个src\n\n教育src\n\n10.参加的广西教育系统攻防演习，是代替学校吗，你们组拿了多少分，总共学校拿了多少分？你打了多少分，你们组打了多少分？你是怎么打到的？\n\n11.网安实训是一个什么项目 那上面是一个靶场环境，让我们用自己的方式获取flag\n\n12.平时用的最多的是哪一款工具？\n\nburpsuite，经常抓包，发到各个模块进行尝试，暴力破解，重放模块，加解密模块，抓取返回包\n\n13.讲一下 tcp 的三次握手的过程\n\n客户端向服务端请求，服务端再返回给客服端.......\n\n14.tcp的连接断开的过程\n\n四次挥手， 服务器返回一个值给客户端，客户端收到值也会向服务器确认是否断开，就是来回确认的过程.....\n\n15.nmap常用的参数有哪些，每个参数都是什么意思？\n\n-sV 扫描存活主机的 -o主机操作系统识别\n\n16.nmap总共有几种扫描形式？\n\n分为全扫描和半扫描，半扫描不容易被发现\n\n17.python的话，我看你简历上面写的比较多，你用python写过的最复杂的程序是什么？\n\n写了一个病毒木马，实现监控屏幕，获取cmd命令行\n\n18.你常用的python的库有哪些？正则是哪一个库？发起http请求、发起tcp请求是哪一个库？\n\n不记得\n\n19.操作系统要列出文件下的子路径，用的哪一个库的哪一个函数？\n\n然后是自己问对方的\n\n对方薪资如何、工作内容、工作地点、实习期间有培训什么的吗、待遇怎么样........[喝可乐][喝可乐][喝可乐]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595019425548349440?sourceSSR=users",
        "title": "3.6辛米尔面试面经",
        "content": "面试时长 一小时30分钟，面试官人特别好，很有意思，问的问题很深入，整体面试氛围非常好\n\n0.自我介绍\n\n1.为什么选择他们公司\n\n2.介绍我的github，以及自述文件的实现\n\n3.讲讲自己这个人的优势\n\n4.讲讲项目中比较满意的地方\n\n5.介绍吉首大学...\n\n6.如何实现一个柔性布局目标： 总容器为 .box，内分左右两个子容器，其中 .left 为左侧子容器，要求宽固定为 400 像素；\n.right为右侧，占用其余宽度；\n\n  * 追问：介绍一下flex\n  * 追问：讲一下flex的三个参数分别是什么\n  * 追问：我需要左右按比例伸缩，左占 1 份，右占2分，如何实现\n  * 追问：父容器 1000 ；左、右的 basis 都是 200 。在上一问的基础上，左右呈现的是多宽\n\n7.讲讲Sass ，Sass 变量，@mixin\n\n8.@import 与 @use 的区别\n\n9.原生css\n\n10.如何创建css的私有变量和共有变量\n\n11.ElementPlus中是否注意到过--开头的属性，是什么意思（考察自定义css变量）\n\n12.css中的var()函数\n\n.my-box1 {\n\n\\--my-pane-text-color: #f69;\n\nborder-color: var(--my-pane-text-color, #333);\n\n}\n\n13.Bash 与 PowerShell 语言，用过哪些命令行，并介绍他们的作用\n\n14.谈谈对 Promise 的理解（延申讲解了awaitasync）\n\n15.一个 Promise 的 catch 之后 then ?是否会继续执行\n\n16.promise的相关函数\n\n17.TypedArray Blob 和 ArrayBuffer ，TypedArray，Uint16Array\n\n18.DataView数据窥窗，使用DataView 操纵 ArrayBuffer\n\n19.是否自行发布过npm包\n\n20.代码开发时封装过什么组件，怎么封装的，有什么内容\n\n21.当多个组件需要互相之间共享数据时，该如何实现（答了vuex和pinia，父传子和子传父）\n\n22.如果父组件想传递数据给孙子组件如何实现\n\n面试官提出了provide 与 inject 配合，祖先 provide 数据。任何子孙都可以 inject 同名数据。\n\n23.是否使用过Canvas ，如何使用的，用来做了些什么，有哪些相关的绘图库\n\n24.是否了解Konva\n\n25.是否了解Threejs\n\n26.谈谈animation.css，css动画，相关属性\n\n27.是否了解TypeScript\n\n28.谈谈ESLint的使用和经历\n\n29.介绍一下闭包是什么，使用场景\n\n30.词法作用域\n\n31.是否接触过后端开发\n\n32.是否会在leetcode上刷题\n\n33.在开发过程中更喜欢哪个部分\n\n33.反问\n\n  * 面试流程\n  * 实习生接触到的业务\n  * 薪资，房补，餐补之类的\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595017778558451712?sourceSSR=users",
        "title": "base北京 微软 前端实习面经",
        "content": "投递渠道： 牛客网友内推\n\n时间线\n\n  * 2024-02-21 一面\n  * 2024-02-26 二面\n  * 2024-02-27 三面\n\n**一面**\n\n  1. 自我介绍与实习经历\n  2. 学业相关\n  3. 算法：反转链表\n  4. 算法：求一个数开方后的整数部分\n\n**二面**\n\n  1. 实习工作内容, 如何完善前端开发规范的\n  2. for...in 与 for...of 的区别\n  3. async/await 的理解\n  4. 是否了解 AST ? 是否了解 ESLint 的原理\n\n看代码说结果：\n\n  1. 具名导入与默认导出\n\n    \n    \n    // utils.js\n    const sum = (a, b) => a + b;\n    export default sum;\n    export function minus(a, b) {\n      return a - b;\n    }\n    \n    // index.js\n    import * as sum from \"./utils\";\n    // 如何调用相关函数\n    // sum.default(1, 2)\n    // sum.minus(1, 2)\n    \n\n  2. var / let / const 的变量提升\n\n> let 与 const 都存在变量提升, 提升到块级作用域顶部, 但同时也存在暂时性死区的概念\n\n  3. 给函数的属性赋值是否会报错\n\n    \n    \n    function fn() {}\n    fn.name = \"fn\";\n    \n\n**算法题** ：给定一个数字, 你可以将该数字中的任意一种数字替换为另一种数字, 例如你可以将该数中的所有 0 替换为 1.\n你只能将一种数字替换为另一种数字, 请问通过该替换操作能得到的最大值与最小值之差为多少？\n\n**三面**\n\n  1. 自我介绍与实习经历\n  2. 是否了解过性能优化, 有哪些方式\n  3. 原生实现 tooltip\n  4. CSS 如何绘制一个三角形\n  5. 算法：手写堆排序\n  6. 算法：lc 168. Excel 表列名称\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595012903405666304?sourceSSR=users",
        "title": "腾讯AI面试",
        "content": "1．说一说进程调度算法有哪些\n\n进程调度算法是操作系统中用于决定哪个进程可以获得 CPU 时间片的一种机制。常见的进程调度算法有以下几种：\n\n先来先服务（FCFS）：按照进程到达的先后顺序，依次分配 CPU 时间片给每个进程，直到该进程执行完毕。\n\n短作业优先（SJF）：按照进程需要的 CPU 时间长度，优先分配时间片给需要时间较短的进程，以最大化 CPU 利用率。\n\n优先级调度（Priority）：为每个进程赋予一个优先级，按照优先级从高到低的顺序分配时间片。\n\n时间片轮转（RR）：将 CPU 时间划分成固定大小的时间片，每个进程都被分配一个时间片，若在该时间片内未完成执行，则该进程被放入队列末尾，等待下一轮调度。\n\n多级反馈队列调度（MFQ）：将进程按优先级划分成多个队列，并且每个队列有自己的时间片大小。新来的进程被放入第一级队列，若在该队列中未能及时完成，则被移动至下一级队列。\n\n2．UDP（用户数据报协议）是什么？\n\nUDP是轻量级，无连接，相对可靠，不保证数据传输到达效果的传输层协议\n\n3．HTTPS协议中间人攻击是什么？\n\nHTTPS协议中间人攻击是一种攻击方式，攻击者在通信双方之间插入自己的身份，以窃取或篡改通信内容。\n\n4．TCP协议的流量控制和拥塞控制\n\nTCP的流量控制是基于窗口机制实现的：\n\n在建立连接时，\n发送方和接收方都会建立一个缓存区，在两端进行通信时，数据包头部会有一个窗口字段，标识了接收端剩余的缓存空间。发送方根据窗口字段的值去判断发送数据的大小，从而避免了缓存溢出。\n\nTCP拥塞控制包含：\n\n慢启动、拥塞避免、快重传、快恢复\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595019292337291264?sourceSSR=users",
        "title": "3.5小鹅通面经",
        "content": "1.自我介绍\n\n2.你的博客产出些什么内容\n\n3.你一般学习是通过哪些途径学习\n\n4.你认为你哪个项目做的最好\n\n5.介绍项目业务作用功能\n\n6.项目中的识别简历内容如何用大模型算法实现的7.项目中身份校验是怎么做的\n\n8.token如何携带到服务端中的\n\n9.cookie，session，localstory\n\n10.批量上传文件的整个流程 从获取文件到上传到服务端\n\n11.如何保证文件上传是完整的，md5如何进行校验\n\n12.断点续传\n\n13.异步处理 awaitasync promise 区别 方法 使用场景等 问的很深入\n\n14.节流和防抖 使用场景\n\n15.优化搜索和自动保存：使用限流和防抖技术，减少请求发送频率，优化搜索和文章自动保存功能，避免非必要的请求。这一点的解释。\n\n16.css有哪些动画类型\n\n17.flex有哪些属性\n\n18.性格\n\n19.平时参加的活动，爱好\n\n20.沟通协同问题如何解决\n\n21.项目中遇到困难如何解决\n\n22.反问\n\n  * 面试流程\n  * 公司技术栈\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595016933301374976?sourceSSR=users",
        "title": "base深圳 冰智科技 前端实习面经",
        "content": "投递渠道：BOSS\n\n时间线\n\n  * 2024-02-16 打招呼投简历\n  * 2024-02-18 一面\n  * 2024-02-24 二面\n\n**一面**\n\n  1. 自我介绍与实习经历介绍\n  2. Vue3 生命周期\n  3. v-if 与 v-show 的区别\n  4. 什么是虚拟 DOM\n  5. useState 和 useEffect 如何使用\n  6. React 中 state 与 props 有什么区别（通常 state 的改变由网络请求或者用户操作引起，props 由父组件传递）\n  7. key 的作用\n  8. 实习：如何进行项目规范搭建\n  9. 实习：如何进行性能优化\n  10. 项目：介绍一下项目中如何使用 rollup 的\n  11. 手写代码：现场其一个 react 项目并实现一个 TodoList\n\n**二面**\n\n  1. 垂直居中的几种方式\n  2. flex 布局的几个属性及其含义\n  3. 0.1 + 0.2 为什么不等于 0.3\n  4. 如何理解闭包, 闭包的使用场景\n  5. 什么是宏任务和微任务\n  6. 事件循环机制, 并看代码说结果\n  7. cookie , LocalStorage, SessionStorage 的区别\n  8. http 状态码\n  9. 由 304 状态码引发浏览器缓存机制, 协商缓存与强缓存\n  10. 哪些资源需要进行 CDN 加速\n  11. React 中为什么 hooks 不能在条件语句中使用?\n  12. useEffect 使用场景, dependencies 的作用, 返回值的作用\n  13. React 父子组件通信的方式\n  14. Vuex 的使用场景与基本原理\n  15. Vuex 状态变更如何引起视图更新, 原理是什么\n  16. 虚拟 DOM\n  17. webpack 中的 loader 与 plugin 的区别\n  18. sourceMap 的作用\n  19. 打包方面的性能优化\n  20. 最近做的项目中遇到的难点, 如何解决的\n  21. 青训营项目\n  22. 算法：二叉树的层序遍历\n  23. 反问, 提升空间： 工程化与框架原理\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595019157263925248?sourceSSR=users",
        "title": "3.5袋鼠云前端开发工程师面经",
        "content": "1.自我介绍\n\n2.js的基本数据类型\n\n3.let和const之间的区别\n\n4.js作用域\n\n5.异步问题，await和async，promise\n\nawaitasync和promise之间的区别\n\npromise有几种状态\n\npromise如何捕获异常，promise的事件监听\n\n6.react的掌握程度\n\n7.vue的响应式变量如何声明\n\n8.ref和reactive之间的区别\n\n9.子组件去调用父组件的变量如何操作\n\n10.react的函数式组件，如何使用函数式组件将输入框\n\n11.浏览器缓存原理，协商缓存和强制缓存，还延申讲了cookie，session和localstory\n\n12.伪数组，封装手写列表组件，封装注意点，key\n\n13.手写分页组件\n\n14.数组功底\n\n15.反问环节\n\n  * 自我介绍听感\n  * 面试流程\n  * 公司业务技术栈\n\n16.到岗时间\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595012238226837504?sourceSSR=users",
        "title": "0306腾讯客户端开发实习一面凉经",
        "content": "投的后端开发没人捞，最后被游戏发行部门的客户端开发捞走了\n\n紧紧张张准备了两天cpp，结果面试官估计觉得问我熟悉的python能答出来，整的我们俩都挺尴尬\n\n自我介绍，做的项目是go的论坛后台开发，客户端不感兴趣就没细问\n\n- 语言\n\nPython GIL，generator（说不了解就结束了）\n\n- 数据结构\n\n了解链表吗，描述链表的数据结构和插入的操作\n\n说下哈希表\n\n- 计网\n\nTCP和UDP有什么区别\n\n说下https建立连接的过程\n\n- 操作系统\n\n了解进程和线程之间区别是什么\n\n- 手撕\n\n删除链表的倒数第k个节点（太久没写链表没搞定边界一直ac不了）\n\nide实现生产者消费者队列（压根没记go怎么开多线程和time库计时，直接跟面试官说要不结束了）\n\n一小时左右就被挂了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595005830605410304?sourceSSR=users",
        "title": "wxg一面",
        "content": "  * 三道算法题 贪心 双指针 dp 写完讲思路\n  * 聊项目\n  * 为什么做这个项目\n  * 怎么去学习用到的知识\n  * 进程通信的方式\n  * 什么时候用进程 什么时候线程\n  * http请求 \n  * tcp协议 \n  * 为什么四次挥手\n  * 第二个fin不传会怎样 \n  * 最后一个ack不传会怎么样\n  * 最近学的技术\n  * 为什么学MySQL 讲讲底层\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595018775875862528?sourceSSR=users",
        "title": "人生中第一次面试！袋鼠云nodejs岗",
        "content": "3.4袋鼠云nodejs岗面经 2h03min\n\n1.自我介绍\n\n2.拷打项目，一个一个拷打\n\n● 第一个系统 oss对象存储平台\n\n1.讲讲做的是个什么业务\n\n2 .这里的对象存储具体值得是什么\n\n3.有没有真的实现OSS对象存储\n\n4.项目技术上遇到了什么困难怎么解决的\n\n5.讲讲文件上传分片上传断点续传等；\n\n6.现在回过头看觉得这个项目有什么缺点和改进的点；\n\n● 第二个项目 面对hr的简历分析系统；\n\n1.介绍这个系统的业务；\n\n2.讲讲流程管理模块\n\n3.讲讲数据大屏(开了屏幕共享对着项目截图讲)\n\n4.打开项目框架怎么构思的。\n\n● 第三个项目：\n\n预科志愿分流系统：问了vuex在项目中的运用\n\n● 项目都要求运行展示了，看了代码细节\n\n3.用过哪些js函数库（axios，jquery）\n\n4.了解哪些项目开发设计中的一些规范\n\n5.数据库中事务的四大特性（原子性，隔离性，持久性，还有个一致性忘了）\n\n6.问是否了解redis（没有，过了）\n\n7.问了解哪些数据结构（答了栈，队列，链表，树，图，堆）\n\n8.问数组和链表的区别（答了，数组内存连续，大小固定，延申讲了数组的扩容原理是创建一个更大空间的数组将原数据移动进去；链表内存分散，不固定；讲了数组删除和添加需要进行挪动，但链表只需要改变指针指向更加灵活；）\n\n9.接着上一问，问了数组和链表读取数据的区别（答了数组通过下标直接读取，而链表需要遍历到目标数据上）\n\n10.问了系统中内存为什么能够随机访问（没答出来）\n\n11.列举一下线程的同步方式（只讲了互斥锁和信号量）\n\n12.讲讲JS的事件循环\n\n13.给了一道题目要求输出结果（当时一紧张不记得怎么去看了，明明前几天刚复习过，一紧张嘴巴乱讲话把settmeout说成了是微任务。说明还没理解透彻，没回答正确，但在hr的提示下梳理好了思路）\n\nsetTimeout(() => {\n\nconsole.log('1')\n\nPromise.resolve(2).then(val => {\n\nconsole.log(val)\n\n})\n\n}, 0)\n\nsetTimeout(() => {\n\nconsole.log('3')\n\n}, 0)\n\nPromise.resolve(4).then(val => {\n\nconsole.log(val)\n\n})\n\nPromise.resolve(5).then(val => {\n\nconsole.log(val)\n\n})\n\nconsole.log('6')\n\n答案是645123\n\n14.问什么是完全二叉树\n\n15.场景题：在一个音乐播放软件中，需要实现统计有多少个用户播放过某一首歌\n\n（一开始说了一个很基础的实现，就是点击播放时将用户id和歌曲id存到数据库中，如何通过sql语句去重查询\n\n然后要我写出查询的sql语句，写出来了，一不小心把count写成了sum😅，hr提醒了我，我才反应过来服了）\n\n后面在hr的提示说第一种方法的问题是数据量太大，所以你需要思考如何压缩需要存储的数据量\n\n然后就说了另一种实现方法，就是设置一个标识属性标志用户是否播放过该首歌，如果播放过就不需要重复存储数据。\n\n后面问有没有更好的实现方法，后面想着是不是用哈希表，但是刚想说，hr就说没事这个问题先过了\n\n16：讲讲osi七层模型，并讲讲每一层的作用和涉及的协议\n\n物理层：（答：和选用什么物理传输介质相关，比如光纤电缆之类的，协议不知道没说）\n\n数据连路层（答：主要作用是校验错误，提供可靠传输，协议忘了没说）\n\n网络层（答：最经典的就是IP协议，在网络中传输包，其中还涉及到路由器转发之类的）\n\n传输层（答：经典协议TCP和UDP分别表示可靠传输协议和不可靠传输协议，作用没讲清楚，磕绊了半天说是负责端到端是数据传输）\n\n会话层\n\n表示层（答：不太记得会话层和表示层的作用了）\n\n应用层（答：主要就是和用户的一些交互比如页面显示之类的，设计HTTP等协议）\n\n17.浏览器输入url到展示之间发生了什么\n\n这个问题比较幸运，面试前半个小时刚给朋友讲了一遍这个过程。\n\n先是回答：浏览器先解析URL，然后将域名转化为IP，转化IP过程要先查看缓存是否存在，没有就要进行DNS查询\n\n这里hr问：是哪里的缓存（回答了浏览器的缓存）\n\n然后继续说：得到了IP之后就要进行三次握手建立客户端与服务端之间的TCP连接\n\n然后继续说：接下来就是客户端向服务端发起请求，这里我延申讲解了协商缓存和强制缓存，巴拉巴拉然后客户端获取到数据了\n\n然后继续说：客户端获取数据之后要进行渲染，渲染的过程就是先解析html生成dom树，再解析css样式表获得css样式树，然后结合他们俩生成渲染树，然后根据渲染树进行布局和绘制，将页面显示在屏幕上。\n\n18.场景题：实现一个二维码的扫码登录。是否有做过这个业务，如果没有的话，从技术员的角度想想如何实现。\n\n先思考了一下，想到了之前做的业务里有登录注册时发送验证码的业务，然后感觉应该原理差不多，试着讲了\n\n回答：没有做过二维码的业务，但是我觉得应该和我之前做的验证码验证的差不多的原理，因为验证码和二维码的一个主要应用场景就是验证身份。我当时写验证码时，是先在服务端生成一串数字，然后通过邮箱等方式发送给客户，如果客户输入的验证码传个后端进行校验成功就可以成功登录。然后二维码的话，因为我们常识知道扫描二维码之后是会解析出一些数据的，这就包含比如说身份数据之类的。我觉得二维码可能就是也是服务端先通过一些第三方库生成二维码图像以及一个类似于标识符的东西，然后客户扫码之后就能解析出一些内容，服务端再进行校验就可以了。\n\n然后说完，hr补充问题，说，你这还没有讲完呀，我们需要的是一个完整的流程，服务端校验之后要怎么让客户端知道验证成功了然后继续下一步操作呢？\n\nhr这句话提示了我，我在思考的时候就想起了前几天刚复习的websocket，然后回答：这里的话是需要服务端给客户端一个响应告知验证成功的，然后这里因为axios的功能呢（胡说八道什么呜呜），服务器没办法主动向客户端发送响应，所以需要用到websocket来实现主动向客户端发送验证结果的请求。\n\n这里提到了websocket，hr就说可以过了这道题\n\n19.在业务中如何获得客户端的真实ip\n\n这个我不知道，但是提出了基于这个问题自己的思考，讲了在获取过程中要考虑到一个安全性的问题，比如说可能会接收到假的ip地址之类的。\n\n然后hr说服务端在接受了数据并进行处理之后通常是要发出一个响应的，如果这个ip是假的，服务端就发不出去，所以几乎不需要考虑这个问题。然后hr说，在你现在比如说你是在学校吗，你所在的校园网，你自己其实并没有一个完全属于你自己的ip地址，那么如果说我们在一个假想的完美环境下，客户端和服务端都在公网中有ip地址，请问我的服务端能够获取到客户端的ip地址吗？\n\n我回答说可以的，因为他们都在公网中可以查询到。\n\n然后hr提示我说还记得ip的报文结构吗？\n\n我说我不太记得了，只记得有源IP地址和目的IP地址之类的。\n\n然后hr说对呀，所以说ip报文数据中存储了源IP地址肯定是能获取到的对吧。（这里才恍然大悟\n刚才没想清楚，还是计算机网络忘了很多东西，需要加强），然后给我讲了一下如果如果源ip地址是假的会怎么样。\n\n这里我脑子有点混乱没讲上来，这个问题就过了。\n\n20.问了一下是否了解nat（没有）\n\n21.好像还问了啥 忘记录音了！！忘记了\n\n21.说明公司是不支持远程办公的，问我这边情况如何？\n\n我说之前学长学姐也有大三直接出去实习的，学校的课程只需要完成作业就行。\n\n22.反问环节\n\n● 问了后面的面试流程是什么样的 /还有一轮技术面和hr面\n\n● 问了公司是否是全栈；/否\n\n忘记录音了，还有一些问题不记得了，后面想起来再补充\n\n补充\n\n● 还问了最近在学习些什么新东西\n\n答的nginx和docker，但是是最近刚开始入门的，所以后面说讲讲docker的时候没讲什么\n\n● 还问了是否了解面向对象编程\n\n我回答了java的面向对象编程原理，讲解了封装继承多态\n\n● 还问了是否学习了typescript\n\n回答没有学，但是正计划学了\n\n● 问学习了设计模式之后对你有什么帮助吗\n\n举例了vue的双向数据绑定中观察者模式的运用\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595005204454453248?sourceSSR=users",
        "title": "腾讯实基一面 项目部分面经（挂）",
        "content": "​分享出来积攒福气。\n\n写这篇文章是为了记录我面试pcg时平时没有留意或者钻研的地方。\n\n面试是根据项目问的问题：\n\n### 为什么采用jwt存储token？\n\n我的项目是微服务项目，里面部署了资源服务和认证服务，这里选择jwt作为token一方面是可以存储用户的信息，可以将用户身份信息存储在令牌中，用户认证通过后认证服务颁发令牌给用户，用户将令牌存储在客户端，去访问应用服务时携带令牌去访问，服务端从jwt解析出用户信息。也就是所说的无状态认证。如果是session认证的话存储在服务端会加大服务端的压力，不适合运用于分布式系统。\n\n​​​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709731965625/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n总结来说就是：灵活性，一致性，故障发生的可用性，以及多平台维护的代价。\n\n另一个目的也就是去实行资源的自认证，每次经过网关的时候，就判断令牌的有效性。以此来决定是否可以访问该资源。\n\n### jwt存储信息都存储在哪里，关键信息存储在里面么？\n\njwt的组成部分一般为三部分，头部，负载，和签名部分。我存储的信息一般放置于负载部分，当然，肯定是不建议将密码等私密信息存储在里面的。\n\nspring security是如何和jwt进行结合的呢？\n\n#### 换句话说，如何设置springsecurity的令牌？\n\n这里我之前都是知道怎么去运用，并没有去看过源码，只知道这么配置一下就好了。但项目被拷打了，问了我意想不到的地方，但还是要好好去琢磨琢磨。\n\n首先我们看令牌的配置在哪里\n\n    \n    \n    AuthorizationServerConfigurerAdapter这个类\n    ClientDetailsServiceConfigurer客户端详情的配置\n    AuthorizationServerSecurityConfigurer安全配置,谁能允许通过\n    \n\n![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732031037/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n说白了这三个配置都是需要你去实现的。但是我们这里只讲令牌。\n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732036677/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n这个bean是我们自己配置的，定义了bean并指定了名字。\n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732041459/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n配置一个TokenConfig\n\n定义令牌服务：\n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732046352/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n可以看到这两个bean的名字是一样的。refreshToken解决的其实是令牌的续期问题。当jwt令牌快过期时使用刷新令牌可以再次生成jwt令牌。\n\n### jwt的加密方式是什么？\n\n可以知道，jwt的整体可以用HMAC算法或使用RSA的公钥/私钥对来签名。我们的整理就是\n\n> HMACSHA256(\n>\n> base64UrlEncode(header) + \".\" +\n>\n> base64UrlEncode(payload),\n>\n> secret)\n\n这样的结构。使用base64编码对header和payload两个部分进行编码，再和secret一起加密。\n\nbase64：在参数传输的过程中经常遇到的一种情况：使用全英文的没问题，但一旦涉及到中文就会出现乱码情况。与此类似，网络上传输的字符并不全是可打印的字符，比如二进制文件、图片等。Base64的出现就是为了解决此问题，它是基于64个可打印的字符来表示二进制的数据的一种方法。\n但是原理我个人认为看一遍就好了，不用去死记硬背。\n\n### 数据库里的密码是明文存储的吗？前后端密码验证时如何比对的？\n\n这个是我自己思考的问题，也是我重新看代码的时候看的。\n\n说到这里，我们不妨从头开始顺一下spring security自带的流程。\n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732058055/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n我们输入的密码一般是变成表单提交，那么它会被封装到AUthentication里。\n\n我们可以看到这里的调用关系AuthenticationManager调用DaoAuthenticationProvider，而DaoAuthenticationProvider里的UserDetailsService里又会调用loadUserByUsername来获取用户的信息，并将获取到的用户信息以springsecurity里的Userdetail方式返回。注意这里通过PasswordEncoder的**BCryptPasswordEncoder方式，这个是暗文存储。我觉得可以记一下这个加密方式，因为被问了，我就没记住这个，因为我觉得这个不是重点但还真问了。**\n\n#### **BCryptPasswordEncoder**\n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732070995/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n配置这个来决定security框架自身的密码比对。密码的形式，这个是自带的！！\n\n当然也可以手动的自行配置，不用框架自带的 UserDetailsService也就是可以重写loadUserByUsername方法和比对方式。\n\n这里就会发现，encode里竟然发现了salt字样，没错，**BCryptPasswordEncoder里面自带加盐操作，如果你不指定，那么他会按照自己的配置的一些值来给你加盐。**\n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732077079/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n获取盐代码：\n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732082331/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n加密算法：\n\n通过输入密码和根据密码特点获得的盐来进行加密\n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732094204/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n    \n    \n    random.nextBytes(rnd);\n    \n\n因为每次的 salt 不同，因此每次的 hash 也不同。这样就可以使得相同的 明文 生成不同的 密文\n\n那么如果这个数据库中的密码，我们是通过**BCryptPasswordEncoder加密的存储在数据库当然中的。我们应该如何进行比较用户输入的是否正确呢？因为用户输入的密码也不是暗文的啊。**\n\n#### 那么怎么知道用户输入的密码和数据库中的密码是否一致呢？\n\n这里还是要看**BCryptPasswordEncoder的源码**\n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732104884/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732110660/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732115627/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n继续跟踪hashpw这个方法，我们会发现和加密时候的方法hashpw是一样的。\n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732119410/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n我们会发现，这个方法会将自己定义的盐取出来，并且base64解码，最后和我们的密码加密一下，然后和之前的数据库的暗文进行对比。\n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732125448/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n### 是否了解加盐，如何加盐，加盐的意义是什么？\n\n个人理解我觉得可以和jwt的secret部分做类比。都是通过添加随机的一部分。安全的提高就是：随机数+混入形式。\n\n>\n> 密码加盐里包含随机值和加密方式。随机值是随机产生的，并且以随机的方式混在原始密码里面，然后按照加密方式生成一串字符串保存在服务器。换言之，这个是单向的，电脑也不知道客户的原始密码，即使知道加密方式，反向推出的加密前的字符串也是真正密码与随机值混合后的结果，从而无法解析用户的真正密码。那么是如何验证密码的呢？当你再次输入密码，会以相同的加盐方式生成字符串，如果和之前的一致，则通过。而其它用户无法获得这种加密方式：即生成哪些随机数，以什么方式混入进去，自然就很安全。\n\n如何生成随机字符串？\n\n可以使用org.apache.commons.lang包下有一个RandomStringUtils类，其中有一个randomAlphanumeric(int\nlength)函数，可以随机生成一个长度为length的字符串。\n\n    \n    \n    RandomStringUtils.randomAlphanumeric(10);\n    \n\n加盐的意义用gpt解释的来看吧。\n\n###\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732138612/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n### 前后端密码验证的时候是如何比对的？\n\n### jwt的密钥存储在哪里？\n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732149274/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n这里附属上gpt\n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732152834/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n### jwt的负载部分内容是从哪获得的？\n\n这个也是自己的思考，其实我也好奇为什么这么设置就可以改变jwt里负载的内容。\n\n这个还得跟踪spring security里代码\n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732165520/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n点击一下\n\n    \n    \n    JwtAccessTokenConverter \n    \n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732173019/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n我们可一看到这个里面实现了两个类，我们可以通过tokenenhance里的enhance编写自己的enhance方法来增强扩展这个token信息。当然这里要看的是AccessTokenConverter\n\n一直好奇这里的负载信息哪来的，这就有个信息提取方法\n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732181896/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732188344/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732192939/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n终于看到了这个username\n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732198534/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n这里其实也就是我们在返回userdetail信息里的username\n\n​![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732205676/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n而extractAutentication里的其他信息我画红色的也来自于我们的客户端配置\n\n    \n    \n      public void configure(ClientDetailsServiceConfigurer clients)\n              throws Exception {\n            clients.inMemory()\n                    .withClient()// client_id\n                    .secret()//客户端密钥\n                    .resourceIds()//资源列表\n                    .authorizedGrantTypes()// 该client允许的授权类型\n                    .scopes()// 允许的授权范围\n                    .autoApprove()//false跳转到授权页面\n                    //客户端接收授权码的重定向地址\n                    .redirectUris()\n       ;\n      }\n    \n\n​最终解析我们的jwt令牌，里面的负载部分就会如上述形式呈现。\n\n在这个user_name里面\n\n![](https://uploadfiles.nowcoder.com/images/20240306/488747170_1709732258402/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/595004729831280640?sourceSSR=users",
        "title": "小黑盒hr面 oc",
        "content": "  * 个人情况\n  * 转正意向\n  * 随便聊聊\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594987393896202240?sourceSSR=users",
        "title": "今日份",
        "content": "作业帮春招面试-武汉\n\n一面\n\n 项目十分钟左右 主要还是看题说输出，类似笔试一样，具体题忘了，考察知识点有promise，this指向，变量提升等\n\n二面\n\n几乎跟牛客上一个牛友的一摸一样，感谢那位牛友，就不过多复述了。二面已过，下周hr面。 有秋招进作业帮的好兄弟或者大佬们来谈谈武汉的作业帮可以进吗？！！！\n\n 虾皮笔试\n\n10单选+5多选+3算法\n\n算法：0+88%+80%\n\n 第一个算法题让我算两个日期之间的工作时间，无语，写一半不想写了 后面的基本暴力+一点优化，不想动脑子了。\n\n毕设已经让我抓狂了，心累，呜呜呜，太难了。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594976984019587072?sourceSSR=users",
        "title": "3.6衡泰笔试记录",
        "content": "记录自己不会的题目\n\n  1. jdbcTemplate使用的设计模式。\n  2. 模板方法。\n  3. SQL数据类型转换的关键字。\n  4. cast、convert\n  5. X锁，S锁。\n  6. S锁(共享锁),加锁后其他事物仍然可以对该数据加S锁；\n  7. X锁(排他锁），加锁后其他事物不可以对该数据加锁;\n  8. ORM框架。\n\nORM（Object-Relational\nMapping）框架是一类用于在关系数据库和对象编程语言之间进行桥接的软件。它们允许开发者在编程语言中使用对象的方式来操作数据库中的数据，而不需要直接编写SQL语句。ORM框架通常提供以下功能：\n\n数据库抽象：将数据库表映射成编程语言中的类，数据库表的每行记录映射为类的实例，表的列映射为实例的属性。\n\n数据查询：提供方法和接口进行数据查询，使用类似于编程语言本身的语法，这些查询最终被转换为SQL语句并在数据库中执行。\n\n数据持久化：允许开发者创建、修改对象，这些更改会自动转换为数据库的INSERT、UPDATE或DELETE操作。\n\n事务管理：简化了事务的处理，ORM框架通常提供简单的方法来处理数据库事务。\n\n缓存：提高效率通过缓存常用数据而减少数据库访问次数。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594976493990678528?sourceSSR=users",
        "title": "字节跳动 商业化后端一面",
        "content": "问的都比较基础\n\n介绍一下实习\n\n介绍一下项目\n\n分片机制、路由表讲一下\n\n怎么实现缓存一致性的（binlog）\n\nredis怎么做的流量控制\n\n数据库相关八股轰炸（b,b+树、索引、怎么走索引、回表查询、输入一条语句有哪些流程）\n\n网络tcp相关八股\n\nhttp协议栈\n\n。。。。。。。。。。。\n\n一道shell命令题目，统计日志信息\n\n一道算法题mid难度 力扣43（答主没ac。。。写的很混乱）\n\n总结：项目、八股的问题都中规中矩，没有继续追问到底\n\n但是答主算法题没写对，思路很混乱，写了一堆bug，面试不在状态\n\n估计挂了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594972893423874048?sourceSSR=users",
        "title": "华为OD面经-- python开发，已offer",
        "content": "今天可乐姐来分享一篇面经！大家码住～\n\n时间线：\n\n2月19日 机考-2月20 综测-2月21-22沟通产品线需求-2月23 HR面-2月24技1/25技2- 2月26主管面-3月4日offer\n\n机试：\n\n题目1：\n\n第一步必须为第一个元素 且步长小于n/2\n\n之后每一步走对应数字的长度 求刚好走到数组尾部需要的最小步数\n\n输入\n\n7 5 9 4 2 6 8 3 5 4 3 9\n\n输出\n\n2\n\n题目2：\n\n字符串s 首尾连成环形 请在环中找出'o'字符出现偶数次的最长子字符串长度\n\n输入\n\nalolobo\n\n输出\n\n6\n\n题目3：\n\n机房n*m的矩阵 1表示有服务器 0表示没有 若两台服务器位于同一行或同一列 则认为他们可以组成局域网 求最大局域网个数\n\n输入\n\n2 2\n\n1 0\n\n1 1\n\n输出\n\n3\n\n输入\n\n3 3\n\n1 0 1\n\n1 1 0\n\n1 1 1\n\n输出\n\n6\n\nHR面：聊了一下简历跟考研，没啥好说的\n\n一面：\n\n简历项目 +Python基础\n\n手撕：\n\nN个特性 M个测试用例 优先级大的先执行 优先级相等则用例ID小的先执行\n\n输入\n\n5 3 N个特性 M个测试用例\n\n1\n\n3\n\n5\n\n2\n\n4\n\n1 2 3\n\n2 4 5\n\n5\n\n输出\n\n1\n\n2\n\n3\n\n二面：\n\n记不清了 也是简历相关 python基础\n\n手撕：\n\n编写一个算法来判断一个数 n 是不是快乐数。\n\n「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到\n1。如果 可以变为 1，那么这个数就是快乐数。\n\n如果 n 是快乐数就返回 True ；不是，则返回 False 。\n\n示例：\n\n输入：19\n\n输出：true\n\n解释：\n\n1^2 + 9^2 = 82\n\n8^2 + 2^2 = 68\n\n6^2 + 8^2 = 100\n\n1^2 + 0^2 + 0^2 = 1\n\n主管面：\n\n聊天 谈对奋斗文化的理解\n\n为什么回成都等等\n\n整体感想：挺流畅的，没有想象中的难，也可能是前期可乐姐说服我先不着急笔试，她说先刷好题最重要，前期刷题扎实，加上她不仅发了机考复习资料给我，也指导了我面试该从哪些方面入手准备，不催机考。所以前期1月份的时候我都是在刷题，背八股，没有动力了就找她聊聊部门的一些情况，就最后选了自己最感兴趣的方向。反正找工作告一段落，谢谢可乐姐就帮忙写了一下面经，大家有想走OD流程可以投递给可乐姐V：offerchaojiduo，全国base地都可以的，23届的不要怕自己没有项目经验，其实面试过程中没在意项目，主要还是八股跟手撕代码的\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594957238192672768?sourceSSR=users",
        "title": "玄武科技面经-Java实习",
        "content": "# 技术面\n\n## Java\n\n  * 在哪写地方使用过lambda\n  * map转集合实现方式\n  * jvm的内存结构\n  * 垃圾回收算法\n  * 为什么要分年轻代老年代\n\n## Redis\n\n  * Redis的底层数据结构\n  * Redisson分布式锁和自己实现的相比有什么优点\n  * 缓存和数据库数据如何保证一致性\n\n## Spring\n\n  * Spring常见注解\n  * SpringBoot的启动流程，自动配置\n  * SpringCloud里面的sentinel有什么用\n\n## 其他\n\n  * RocketMQ和RabbitMQ的特点\n  * 网络怎么分层\n  * http和https有什么区别\n\n## 项目\n\n  * 项目没有怎么问，问了我从网上找的这些开源项目是怎么去学习的；然后问了其中遇到过哪些问题。\n\n## 总结\n\n感觉大体上都是常见的八股，然后面试官是根据简历上面写得内容来面的，一边看简历一边问，感觉也没有问的很深，我回答问题后没有怎么追问。\n\n时间大概面了30分钟\n\n## hr面\n\n技术面后接着hr面\n\n  * 问我有没有选择考研，为什么不选择考研\n  * 因为专业是和人工智能相关的，所以还问了我觉得开发难还是那些算法难\n  * 平时的话是怎么学习的\n\n其他忘记了。。。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594955075668234240?sourceSSR=users",
        "title": "货拉拉 数据仓库实习生",
        "content": "由于已经离职了，就发一下面经把\n\n一面\n\n* 自我介绍\n* 项目\n* 数仓怎么分层 \n* 数据倾斜怎么处理\n* join优化\n* 实时数仓和离线数仓的定位\n* 能实习多久\n* 反问\n* 数据量多少进去干什么工作对我的建议\n\n  * 进去主要负责什么\n\n二面\n\n* 说一下MR的执行流程\n* 内部表和外部表的区别\n\n其他记不太清了，主要是一些基本的数仓八股文\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594935481876361216?sourceSSR=users",
        "title": "小扇和小船的数字游戏 - 华为OD统一考试（C卷）",
        "content": "> OD统一考试（C卷）\n>\n> 分值： 200分\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n小扇和小船今天又玩起来了数字游戏，\n\n小船给小扇一个正整数 n（1 ≤ n ≤ 1e9），小扇需要找到一个比 n 大的数字 m，使得 m 和 n 对应的二进制中 1 的个数要相同，如：\n\n    \n    \n    4对应二进制100\n    \n    8对应二进制1000\n    \n    其中1的个数都为1个\n    \n\n现在求 m 的最小值。\n\n## 输入描述\n\n输入一个正整数 n（1 ≤ n ≤ 1e9）\n\n## 输出描述\n\n输出一个正整数 m\n\n## 示例1\n\n    \n    \n    输入：\n    2\n    \n    输出：\n    4\n    \n    说明：\n    2的二进制10，\n    4的二进制位100，\n    1的个数相同，且4是满足条件的最小数\n    \n\n## 示例2\n\n    \n    \n    输入：\n    7\n    \n    输出：\n    11\n    \n    说明：\n    7的二进制111，\n    11的二进制位1011，\n    1的个数相同，且11是满足条件的最小数\n    \n\n## 题解\n\n> #### 题解分析\n>\n> 这道题目要求找到一个比给定的正整数 n 大的数字 m，使得它们的二进制表示中 1 的个数相同。本质上，题目要求在二进制表示中，找到一个比 n\n> 大的具有相同数量的 1 的数。\n>\n> 给出的解法是使用贪心算法。首先，将 n 转换为二进制表示，然后通过贪心地找到可以将某个 0 变成 1 的位置，使得数字变大，同时保持 1\n> 的个数不变。最后输出这个结果。\n>\n> #### 解题思路\n>\n>   1. 将给定的十进制数 n 转换为二进制表示，并在末尾添加一个 0。\n>   2. 使用贪心算法找到可以将某个 0 变成 1 的位置的索引 idx。\n>   3. 调整 idx 位 0 变成 1，同时调整 idx 前的位，使得低位为 1，高位为 0，且二进制中 1 的个数不变。\n>   4. 输出调整后的结果。\n>\n\n### Java\n\n    \n    \n    import java.util.Scanner;\n    import java.util.ArrayList;\n    /**\n     * @author code5bug\n     */\n    public class Main {\n        public static void main(String[] args) {\n            Scanner in = new Scanner(System.in);\n            int n = in.nextInt();\n            System.out.println(solve(n));\n        }\n    \n        // 解决问题的函数\n        public static int solve(int n) {\n            ArrayList<Integer> bs = new ArrayList<>();\n            // 转换为二进制\n            while (n > 0) {\n                bs.add(n % 2);\n                n /= 2;\n            }\n            // 在列表末尾添加一个 0，以便处理\n            bs.add(0);\n    \n            // 贪心的寻找可以将 0 变成 1 的地方的索引 idx（使得数字变大）\n            // idx 满足低位存在 1 且 bs.get(idx) == 0\n            int idx = 0, oneCnt = 0;\n            for (; idx < bs.size(); idx++) {\n                if (oneCnt > 0 && bs.get(idx) == 0) {\n                    break;\n                }\n                oneCnt += bs.get(idx);\n          \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594933542606442496?sourceSSR=users",
        "title": "腾讯IEG部门  前端日常实习一面3.6",
        "content": "![](https://uploadfiles.nowcoder.com/images/20240306/335948961_1709714130777/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n投了好久好久了，去年就已经投了，一直没结果。结果前几天起床收到邮件参加面试，其实心里第一反应是刷kpi？因为看到好多面经都是一下就挂了。。\n\n面试官叫我把摄像头开开，自己又不开，**能不能来点尊重人的面试官。。听声音估计二十多岁，全程都是敷衍漫不经心\n\n上来自我介绍然后问了些无关紧要的题，就让我做三道算法题（其实已经感觉是kpi了，因为面了那么多家第一次见不问前端知识直接做算法题的。。。我在写的途中甚至怀疑我是不是面试错了，面的不是前端岗。。）\n\n  * 算法题不难，第一道算法题是将两个有序数组合并为一个有序数组，leetcode上应该有，用了时间复杂度和空间复杂度都是O(n+m)的方式完成，然后人家问我思路，其实就是双指针+循环，结果人家问我有没有什么改进办法，****我想不到，时间复杂度想五分钟想不到更低的，人家问我空间复杂度有没有更低的，我想了一会弄了十分钟结果是错的哈哈，人家又说给我五分钟再想一下，随便弄了下跟人家讲了下思路，跳过。\n\n我非常怀疑，人家在我写的时候，闭着麦玩手机，我写完之后叫他都没反应还要多叫几次，而且就问我，你有什么改进办法有什么思路，好的你写吧，然后继续闭麦，严重怀疑是kpi，不给个引导随便弄弄，行你厉害\n\n  * 第二题也不难，是leetcode中的最大子数组，用for循环和常熟就能在时间复杂度O(n)和空间复杂度O(1)的情况下完成，人家又问下我思路就跳过\n  * 第三题是让我创建二叉排序树。。。写一个构造函数。。。我不会。。。数据结构用c学的而且已经学了一年半了忘光了。。\n  * 后面看我简历问了我防抖节流，问我怎么实现，我就说用定时器settimeout实现，问我还有别的实现方法吗我说我不知道。。\n  * 然后又问了其它无关紧要的问题，问我能实习多久什么什么之类的\n  * 最后是反问，我问他有什么需要改进的他说我还可以，然后我问了个我非常疑惑的就是，我面试的前端，为什么不问我三件套计网浏览器那些知识而是上来就是三道算法题，他说这是因为业务中真正会用到的，他说那些计网vue浏览器等等知识都是死记硬背。。。好吧fine我无话可说，仁者见仁智者见智吧\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594926008772378624?sourceSSR=users",
        "title": "京东机器学习一二面",
        "content": "一面：  \n没开摄像头，平台在joymeeting  \n首先自我介绍，然后开始提问  \n介绍项目(三个项目第一个第三个都被问了)  \n介绍博弈论中的Q Learning算法  \n机器学习八股：决策树，过拟合，XGB  \n因为提了bagging还被问了随机森林  \n询问工作地是否合适，有无offer  \ncoding:快速排序(测试用例超时，面试官陪我改了十分钟代码[尴尬][尴尬]，貌似他也看不出来哪里有问题[黑牛问号])  \n  \n二面：(感觉答的不是特别好)  \n摄像头开了一眼，估计是要跟照片对比一下确认是苯人  \n自我介绍，无coding  \n问两篇待发表论文：具体工作，有无创新点  \n问深度学习：  \n1.用过的激活函数有哪些，答了sigmod，tanh，relu，被追问relu的缺点(没答出来[牛泪]，忘了死亡relu的问题)  \n2.优化器 脑子短路只记得adam，后面想起来了moment[栓Q](我一直以为梯度下降是算法而非优化器[笑cry])  \n3\\. 强化学习被戳，面试官好像更喜欢q网络[好无辜]  \n4.业务情景(应该算是没答上来)：给了商品id和相应的点击次数的大数据文本，要求找到点击次数为中位数的商品id。只答了用二分查找[笑cry][笑cry]，面试官特别提醒是大文本，无法读写的那种。想了想用pandas做成库然后SQL查找[尴尬][尴尬][尴尬](是不是应该用什么在线算法😢)  \n5.反问：业务场景，学习方向  \n二面总体自身感觉不太好，估计要寄  \n  \n半小时后：寄，已转推荐\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594925251020992512?sourceSSR=users",
        "title": "中航集团（国航股份）信息管理部 一面",
        "content": "室耐心等待。我们会依次连线每位同学进行面试。  \n在面试开始后，首先需要各位应聘者进行不超过3分钟的自我介绍，您可以参照以下要点准备自我介绍，要点如下：  \n1.您的个人基本信息（出生年月、生源地、政治面貌）；  \n2.学习经历（本硕学校及专业、最高学历毕业时间）；  \n3.重要实习经历（单位名称，从事工作）；  \n4.英语四级/六级成绩，IT技能；  \n5.家庭情况（父母、兄弟姐妹的职业及居住地）；  \n6.校内职务，兴趣爱好；  \n7.面试岗位方向（研发、产品、数据、安全、运维）；  \n8.工作城市意向；  \n9.Offer情况，三方协议是否已签；  \n10.留京户口期望值（百分比形容），税前月薪期望值  \n  \n问的问题：  \n你有来北京工作的想法吗？  \n你做过什么项目？有什么难点？怎么解决？  \n跨域怎么解决  \nvue生命周期  \nv-bind和v-model  \nvue界面加载太慢怎么办？  \n  \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594927813392609280?sourceSSR=users",
        "title": "百度智能客服  日常实习3.4前端一面+二面秒挂",
        "content": "分享一下，希望能帮到你，替我进没进去的百度\n\n![](https://uploadfiles.nowcoder.com/images/20240306/335948961_1709712280263/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n投递后反馈挺快的，hr过了三天就给我打电话了，约了3.4面试\n\n![](https://uploadfiles.nowcoder.com/images/20240306/335948961_1709712409008/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n**一面**\n\n一面听着是个挺年轻的男的，语气温柔，面试问的题目也不难，给的反馈也很积极，但是不开摄像头！！！（感觉不尊重人，因为我开了你不开）\n\n  * 数组去重=》使用的set，但是{}对象无法被去重，估计是内存地址不一样所以判断两个{}空对象不同，打算用新建一个数组来做，但是面试官觉得我的思路也差不多就没让我写\n  * $nextTick\n  * 宏任务微任务代码题\n\n    \n    \n    setTimeout(function () {\n        console.log('1')\n    });\n    \n    new Promise(function (resolve) {\n        console.log('2');\n        resolve();\n        console.log('3');\n    }).then(function () {\n        console.log('4')\n    });\n    console.log('5');\n    \n    输出结果是 2 3 5 4 1\n    我答错了，我回答成了2 5 4 3 1，我以为resolve会让下面的代码变成异步，结果我搞混了，异步是async await的\n    \n\n  * 数组扁平化，递归就好\n\n    \n    \n    function flatten(arr) {\n      const result = [];\n        for (const key of arr) {\n          if (Array.isArray(key)) {\n            result.push(...flatten(key));\n          } else {\n            result.push(key);\n          }\n        }\n      return result;\n    }\n    \n    const arr = [1, [2, 3], [4, [5, 6]]];\n    const flattenedArr = flatten(arr);\n    console.log(flattenedArr); // [1, 2, 3, 4, 5, 6]\n    \n\n其它的暂时想不到了，问的并不难，基本上都答上来了，反馈很快，面试完半小时就说约二面，约的第二天\n\n**二面**\n\n二面是个看上去三四十的leader，不怒自威很严肃，开了摄像头，但是全程很敷衍，漫不经心，并且通信质量很差，他那边很嘈杂，老是有人走动，感觉像刷kpi的\n\n  * 听了自我介绍问我怎么自学前端的\n  * 看我技术栈是vue问我vue的发展怎么样\n  * js高阶函数，我没回答出来\n  * 让我写了三道题，在人家的如流平台，感觉那平台的代码不好写，只有js，没有css和vue之类的\n  * 第一题，不定宽高水平垂直居中，还算简单\n  * 第二题父子组件通信，我菜了紧张了，导致有很多关键语法错误，其实是因为准备面试一直在看八股，都少了很多动手实践，一定一定要边学边实践\n  * 第三题分割字母和数字，字符串'123ab12'分割为'123 ab 12'，当时写的时候有个bug，结果在写这篇面经的时候突然知道怎么写了，晕\n  * 然后问了一些无关紧要的问题，全程给的反馈都很少，也很敷衍，就说错了也不说错哪了，也不引导一下，点名表扬字节一面的一个面试官，人好态度好耐心好语气好面试的最舒服的一次（虽然也没过）\n  * 最后反问我知道自己过不了了，就问下我有什么需要改进的地方吗，人家一脸不耐烦说问工作的事，行吧 我就随便问了工作是干啥的技术栈是啥等等就结束了，面试完后晚上上官网看就挂了\n\n面试是面试完了，但还是很烦，能不能来点尊重人的面试官，不要全是那种刷kpi的，服了都，我全程态度都很好虚心请教，不会的就一直道歉不好意思跟个舔🐕一样\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594917527688327168?sourceSSR=users",
        "title": "每日互动 一面（技术面）",
        "content": "开场三分钟吟唱\n\n  * SpringBoot自动装配\n  * 还想问我SpringMVC的，但是他忍住了\n  * 怎么创建一个Starter\n  * BloomFilter\n  * 作用\n  * 什么情况下完全正确\n  * 为什么不用Redis直接保存空数据\n  * Redis中zset的底层数据结构\n  * JVM\n  * 介绍栈\n  * 介绍堆\n  * 什么情况下对象数据不放在堆中\n  * 什么情况出现full gc \n  * 多线程了解吗，有使用吗\n  * MYSQL索引失效\n\n最后，问我有什么会的，憋了半天说没有。让我想想有什么要问他的，被问懵了，也不知道问什么，就再见了\n\n总结：菜，就多练。这场面试毁了我的面试梦[牛泪][牛泪]\n\n面试官还是挺不错的，我答不上来还跟我说答案，也没有不耐烦，大家可以多投投，问题也是由浅入深的\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594912700736520192?sourceSSR=users",
        "title": "携程测试hr面",
        "content": "1.谈谈对这个部门的了解\n\n2.讲一下你做这个项目的背景和过程\n\n3.你对于实习的期望\n\n4.平时课余时间会用来干什么\n\n5.你认为自己最大的优点和缺点\n\n6.你有什么兴趣爱好\n\n7.讲讲哪个奖项是你印象最深刻的\n\n8.你对于实习的薪资期望\n\n9.你家在广东，为什么不选择广州或者深圳而选择来北京实习\n\n10.是否有家人或者朋友在北京\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594907891715379200?sourceSSR=users",
        "title": "前端面经（Js手撕题部分）",
        "content": "## 10.1 并发限制\n\n    \n    \n    class Scheduler {\n        constructor(max){\n            this.max = max\n            this.count = 0\n            this.queue = []\n        }\n        async add(fn){\n            if(this.count >= this.max){\n                await new Promise(resolve => this.queue.push(resolve))\n            }\n            this.count++\n            const res = await fn()\n            this.count--\n            this.queue.length && this.queue.shift()()\n            return res\n        }\n    }\n    \n    class Scheduler {\n        constructor(max){\n            this.max = max\n            this.count = 0\n            this.queue = []\n        }\n        add(fn){\n            this.queue.push(fn)\n        }\n        start(){\n            for(let i = 0; i < this.max; i++){\n                this.doNext()\n            }\n        }\n        doNext(){\n            if(this.queue.length && this.max >= this.count){\n                this.count++\n                this.queue.shift()().then(()=>{\n                    this.count--\n                    this.doNext()\n                })\n    \n            }\n        }\n    }\n    \n    \n    \n    \n    const scheduler = new Scheduler(2)\n    \n    const timeout = time => new Promise(resolve => setTimeout(resolve,time))\n    \n    const addTask = (time,order) => {\n        scheduler.add(() => timeout(time).then(()=>console.log(order)))\n    }\n    \n    addTask(1000,1)\n    addTask(500,2)\n    addTask(300,3)\n    addTask(400,4)\n    \n    \n    \n    \n    function limitQueue(urls, limit) {\n        // 完成任务数\n        let i = 0;\n        // 填充满执行队列\n        for (let excuteCount = 0; excuteCount < limit; excuteCount++) {\n            run();\n        }\n        // 执行一个任务\n        function run() {\n            // 构造待执行任务 当该任务完成后 如果还有待完成的任务 继续执行任务\n            new Promise((resolve, reject) => {\n                const url = urls[i];\n                i++;\n                resolve(fn(url))\n            }).then(() => {\n                if (i < urls.length) run()\n            })\n        }\n    }\n    const fn = url => {\n        // 实际场景这里用axios等请求库 发请求即可 也不用设置延时\n        return new Promise(resolve => {\n            setTimeout(() => {\n                console.log('完成一个任务', url, new Date());\n                resolve({ url, date: new Date() });\n            }, 1000);\n        })\n    };\n    const urls = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];\n    \n    (async _ => {\n        await limitQueue(urls, 4);\n    })()\n    \n    \n\n## 10.2 Promise输出\n\n  * [40道Promise输出题，你都会了吗？🔥 - 掘金 (juejin.cn)](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjuejin.cn%2Fpost%2F7151636219036696613)\n\n## 10.3 setTimeout()\n\n​ 渲染进程所有运行在主线程上的任务都需要先添加到消息队列中,然后事件循环系统顺序执行消息队列。​ eg: 解析 DOM; 改变 web 大小, 重新布局;\njs 垃圾回收; 异步执行 js 代码​ 但是定时器的任务不能直接放置在消息队列中,他需要按照时间间隔来执行。因此,chrome\n除了消息队列外,新增了个延时队列,在每次执行完任务后,执行延迟队列中的任务,计算出到期任务,依次执行。最小执行时间4ms。\n\n代码实现:\n\n1） 在每次新增一个定时器时,将定时器添加到 DelayTask 中；2）\n执行消息循环时,在当前任务执行完成时,执行延迟队列中的任务,ProcessTimerTask\n函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务；3） 查找延迟队列中的已到期任务执行；4） 取消定时器: 从\ndelayed_incoming_queue 根据定时器 id 查找到定时器并删除；\n\n    \n    \n    DelayedIncomingQueue delayed_incoming_queue;\n    \n    // 当通过 JavaScript 调用 setTimeout 设置回调函数的时候，渲染进程将会创建一个回调任务，包含了回调函数 showName、当前发起时间、延迟执行时间\n    struct DelayTask{\n      int64 id；\n      CallBackFunction cbf;\n      int start_time;\n      int delay_time;\n    };\n    DelayTask timerTask;\n    timerTask.cbf = showName;\n    timerTask.start_time = getCurrentTime(); //获取当前时间\n    timerTask.delay_time = 200;//设置延迟执行时间\n    \n    // 创建好回调任务之后，再将该任务添加到延迟执行队列中\n    delayed_incoming_queue.push(timerTask)；\n    \n    \n    \n    void ProcessTimerTask(){\n      //从delayed_incoming_queue中取出已经到期的定时器任务\n      //依次执行这些任务\n    }\n    \n    //消息循环系统是 触发延迟队列的\n    TaskQueue task_queue；\n    void ProcessTask();\n    bool keep_running = true;\n    void MainTherad(){\n      for(;;){\n        //执行消息队列中的任务\n        Task task = task_queue.takeTask();\n        ProcessTask(task);\n    \n        //执行延迟队列中的任务\n        ProcessTimerTask()\n    \n        if(!keep_running) //如果设置了退出标志，那么直接退出线程循环\n            break;\n      }\n    }\n    \n    \n\nSettimeout有4ms的延迟可以通过postMessage解决（处理页面中嵌套iframe跨域的问题，它的通信原理类似于TCP三次握手，不但能解决各种跨域问题，而且实时性高。）\n\n参考：\n\nhttps://juejin.cn/post/6961673921150238751\n\n## 10.4 版本号排序\n\n    \n    \n    arr.sort((a, b) => {\n      let i = 0;\n      const arr1 = a.split(\".\");\n      const arr2 = b.split(\".\");\n     \n      while (true) {\n        const s1 = arr1[i];\n        const s2 = arr2[i];\n        i++;\n        if (s1 === undefined || s2 === undefined) {\n          return arr2.length - arr1.length;\n        }\n     \n        if (s1 === s2) continue;\n     \n        return s2 - s1;\n      }\n    });\n    \n    \n\n## 10.5 Sleep()\n\n    \n    \n    const sleep = time => {\n     return new Promise(resolve => setTimeout(resolve,time)\n     ) } \n    const sleep = time => {\n     return new Promise(resolve => setTimeout(()=>{resolve()},time)\n     ) } \n     sleep(1000).then(()=>{ console.log(1) })\n    \n    \n\n## 10.6 手写JS\n\nhttps://juejin.cn/post/6875152247714480136\n\n## 10.7 缓存装饰器\n\n    \n    \n    function cacheDecorator(func) {\n      let cache = new Map();\n    \n      return function (...args) {\n        let key = JSON.stringify(args);\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n    \t// 如果缓存中没有这个键，我们调用原来的函数 func，并将结果保存在 result 中。\n        let result = func.apply(this, args);\n        cache.set(key, result);\n        return result;\n      };\n    }\n    \n    \n\n## 10.8 限制次数内重试\n\n    \n    \n    function retryPromise(func, retries = 5) {\n      return new Promise((resolve, reject) => {\n        const attempt = (n) => {\n          func().then(resolve).catch((error) => {\n            if (n === 0) {\n              reject(error);\n            } else {\n              attempt(n - 1);\n            }\n          });\n        };\n        attempt(retries);\n      });\n    }\n    \n    \n\n## 10.9 bigint相加\n\n    \n    \n    let a = \"9007199254740991\";\n    let b = \"1234567899999999999\";\n    \n    function add(a ,b){\n       //取两个数字的最大长度\n       let maxLength = Math.max(a.length, b.length);\n       //用0去补齐长度\n       a = a.padStart(maxLength , 0);//\"0009007199254740991\"\n       b = b.padStart(maxLength , 0);//\"1234567899999999999\"\n       //定义加法过程中需要用到的变量\n       let t = 0;\n       let f = 0;   //\"进位\"\n       let sum = \"\";\n       for(let i=maxLength-1 ; i>=0 ; i--){\n          t = parseInt(a[i]) + parseInt(b[i]) + f;\n          f = Math.floor(t/10);\n          sum = t%10 + sum;\n       }\n       if(f == 1){\n          sum = \"1\" + sum;\n       }\n       return sum;\n    }\n    \n    \n\n## 10.10 防抖和节流\n\n**使用场景：防抖和节流**\n\n防抖：让`事件`在触发后`N`秒后执行，如果在`N`秒内重新触发，则`重新计算`时间。\n\n场景：\n\n  * 按钮双击，我们平时电脑上快速双击就有可能触发两次点击事件\n  * 输入框的input或者change时间\n  * 轮动条\n\n    \n    \n    function debounce(fn, delay){\n        let timer\n        return function(){\n            if(timer) clearTimeout(timer)\n            let args = arguments\n            timer = setTimeout(()=>{\n                fn.apply(this,args)\n            }, delay)\n        }\n    }\n    \n    \n    \n    \n    // input实现防抖\n    <div>\n    <input type=\"text\" id=\"ipt\">\n    </div> <script>\n    let ipt = document.getElementById('ipt');\n    let dbFun = debounce()\n    ipt.addEventListener('keyup', function (e) {\n    dbFun(e.target.value);\n    })\n    function debounce() {\n    let timer;\n    return function (value) {\n    clearTimeout(timer);\n    timer = setTimeout(() =>\n    {\n    console.log(value)\n    }, 500);\n    }\n    }\n    </script>\n    \n    \n\n节流：在规范时间内，只能触发一次函数，如果多次触发不会执行。\n\n    \n    \n    function throttle(func, time) {\n        let lastTime = null;\n        return function (...args) {\n            let now = +new Date()\n            if (now - lastTime > wait) {\n                lastTime = now\n                func.apply(this, args)\n            }\n        }\n    }\n    var throttle = function(fn, t) {\n        let timer = null\n        let tempArgs = null\n      const func = function(...args) {\n          if(!timer){\n              fn(...args)\n              timer = setTimeout(_=>{\n                  timer = null\n                  if(tempArgs){\n                      func(...tempArgs)\n                  }\n                  tempArgs = null\n              }, t)\n          }else{\n              tempArgs = args\n          }\n      }\n      return func\n    };\n    \n    \n\n## 10.11 Promise.all\n\n    \n    \n    function promiseAll(promises) {\n        return new Promise(function(resolve, reject) {\n            // 记录已解决的 promise 的数量\n            let resolvedCount = 0;\n            // 记录每个 promise 的结果\n            const promiseResults = new Array(promises.length);\n    \n            for (let i = 0; i < promises.length; i++) {\n                // 立即执行每个 promise\n                promises[i].then(\n                    // promise 成功解决\n                    value => {\n                        resolvedCount++;\n                        promiseResults[i] = value;\n    \n                        // 如果所有的 promise 都解决了，那么我们可以解决总的 promise\n                        if (resolvedCount === promises.length) {\n                            resolve(promiseResults);\n                        }\n                    },\n                    // 如果任何一个 promise 失败了，我们都需要拒绝总的 promise\n                    error => {\n                        reject(error);\n                    }\n                );\n            }\n        });\n    }\n    const promises = [\n        Promise.resolve('Promise 1'),\n        Promise.resolve('Promise 2'),\n        Promise.resolve('Promise 3'),\n        Promise.resolve('Promise 4')\n    ];\n    \n    promiseAll(promises)\n        .then((fulfilled) => {\n            console.log('Fulfilled promises:', fulfilled);\n        })\n        .catch((reason) => {\n            console.error('Error:', reason);\n        });\n    \n    \n    \n    \n    //race\n    //方法接收一个包含多个 Promise 对象的可迭代对象，并返回一个新的 Promise 对象，该 Promise 对象在多个 Promise 中任意一个 Promise 对象状态变为 fulfilled 或 rejected 时立即返回该 Promise 对象的值或原因。\n    function promiseRace(promises) {\n        return new Promise((resolve, reject) => {\n            if (!Array.isArray(promises)) {\n                reject(new TypeError('Promises must be an array'));\n                return;\n            }\n    \n            if (promises.length === 0) {\n                reject(new Error('Promises array must not be empty'));\n                return;\n            }\n    \n            promises.forEach((promise) => {\n                Promise.resolve(promise)\n                    .then(resolve)\n                    .catch(reject);\n            });\n        });\n    }\n    \n    \n    \n    \n    //some\n    function PromiseSome(promises, n) {\n        return new Promise((resolve, reject) => {\n            if (promises.length < n) reject('Not enough promises to fulfill the request');\n    \n            let results = [];\n            let settled = 0;\n            let stillPending = promises.length;\n    \n            promises.forEach((promise, i) => {\n                Promise.resolve(promise)\n                    .then(value => {\n                        settled += 1;\n                        results[i] = value;\n                        stillPending -= 1;\n    \n                        if (settled >= n) {\n                            resolve(results);\n                        }\n                    })\n                    .catch(() => {\n                        stillPending -= 1;\n    \n                        if (stillPending + settled < n) {\n                            reject('Too many promises rejected');\n                        }\n                    });\n            });\n        });\n    };\n    \n    \n    \n    \n    //any\n    MyPromise.any = function(promises){\n      return new Promise((resolve,reject)=>{\n        promises = Array.isArray(promises) ? promises : []\n        let len = promises.length\n        // 用于收集所有 reject \n        let errs = []\n        // 如果传入的是一个空数组，那么就直接返回 AggregateError\n        if(len === 0) return reject(new AggregateError('All promises were rejected'))\n        promises.forEach((promise)=>{\n          promise.then(value=>{\n            resolve(value)\n          },err=>{\n            len--\n            errs.push(err)\n            if(len === 0){\n              reject(new AggregateError(errs))\n            }\n          })\n        })\n      })\n    }\n    \n    \n    \n    \n    Promise.prototype.finally = function (callback) {\n    let P = this.constructor;\n    return this.then(\n    value => P.resolve(callback()).then(() => value),\n    reason => P.resolve(callback()).then(()\n    => { throw reason })\n    );\n    };\n    \n    \n    \n    \n    // none\n    Promise.none = function(promises) {\n        return Promise.all(promises.map(promise => {\n            return new Promise((resolve, reject) => {\n                // Promise.all里边的所有promise实例反过来就好了\n                return Promise.resolve(promise).then(reject, resolve)\n            })\n        }))\n    }\n    // none2\n    Promise.none = function(promises) {\n        return new Promise(function(resolve, reject) {\n            let count = promises.length;\n            let reasons = new Array(count);\n            if (count === 0) {\n                resolve(reasons);\n                return;\n            }\n    \n            promises.forEach(function(promise, index) {\n                Promise.resolve(promise).then(function() {\n                    reject(new Error(\"At least one promise resolved\"));\n                }, function(reason) {\n                    reasons[index] = reason;\n                    if (--count === 0) {\n                        resolve(reasons);\n                    }\n                });\n            });\n        });\n    };\n    const promisesForNoneTest1= [\n        Promise.reject('1'),\n        Promise.reject('2'),\n        Promise.resolve('3'),\n        Promise.reject('4'),\n    ]\n    Promise.none(promisesForNoneTest1).then(res => {\n        console.log('true promises:', res);\n    }, res => {\n        console.log('false promises:', res);\n    })\n    \n    \n    \n    \n     Promise.first = function(promises) {\n        return new Promise((resolve, reject) => {\n          let rejectNum = 0\n          promises.forEach(promise => {\n            // 如果当前 promise 决议为reslove，那就直接执行\"根promise\"的resolve\n            // 否则去记录到拒绝的promise中，然后判断全部的promise拒绝了，执行\"根promise\"的reject\n            Promise.resolve(promise).then(resolve, () => {\n              if (++rejectNum === promises.length) {\n                // 这里可以控制reject返回的信息\n                reject()\n              }\n            })\n          })\n        })\n      }\n    \n    \n    \n    \n    Promise.map = function(arr, mapper) {\n        // 首先，使用 map 将数组中的每个元素都转换为 promise。\n        let promises = arr.map((item, index, arr) => Promise.resolve(mapper(item, index, arr)));\n    \n        // 然后，使用 Promise.all 来等待所有 promise 都 resolve。\n        return Promise.all(promises);\n    };\n    let mapper = function(num) {\n        return new Promise((resolve, reject) => {\n            setTimeout(() => {\n                console.log(num);  // 输出处理的数字\n                resolve(num);\n            }, 1000);\n        });\n    };\n    let nums = [1, 2, 3, 4, 5];\n    Promise.map(nums, mapper)\n        .then(results => {\n            console.log('All promises are resolved');\n            console.log('Results:', results);  // 输出：Results: [ 1, 2, 3, 4, 5 ]\n        })\n        .catch(err => {\n            console.log('A promise rejected with', err);\n        });\n    \n    \n\n## 10.12 apply&bind\n\n    \n    \n    //apply&call\n    Function.prototype.myApply = function (context, args) {\n        console.log(this)\n        context = context || window;\n        const fnSymbol = Symbol();\n        context[fnSymbol] = this;\n        const result = context[fnSymbol](...args);\n        delete context[fnSymbol];\n        return result;\n    };\n    //bind\n    Function.prototype.myBind = function (){\n        const args = [...arguments]\n        const self = args.shift()\n        console.log(this)\n        const t = this\n        return function (){\n            t.apply(self,args.concat(...arguments))\n        }\n    }\n    \n    \n\n## 10.13 数组转树\n\n    \n    \n    function formatToTree(ary, pid, pidName = 'parentId') {\n      return ary\n          .filter((item) => item[pidName] === pid)\n          .map((item) => {\n              // 通过父节点ID查询所有子节点\n              item.children = formatToTree(ary, item.id);\n            return item;\n          });\n    }\n    const data = [{ id: 2, name: \"研发部\", parentId: 1 },...]\n    \n    \n\n## 10.14 排序\n\n冒泡排序 | O(n2) | O(n2) | O(1) | 是  \n---|---|---|---|---  \n选择排序 | O(n2) | O(n2) | O(1) | 不是  \n直接插入 | O(n2) | O(n2) | O(1) | 是  \n归并 | O(nlogn) | O(nlogn) | O(n) | 是  \n快排 | O(nlogn) | O(n2) | O(logn) | 不是  \n堆排序 | O(nlogn) | O(nlogn) | O(1) | 不是  \n希尔排序 | O(nlogn) | O(ns) | O(1) | 不是  \n计数排序 | O(n+k) | O(n+k) | O(n+k) | 是  \n基数排序 | O(N*M) | O(N*M) | O(M) | 是  \n      \n    \n    //归并排序\n    function mergeSort(arr) {\n        if (arr.length === 1) return arr;\n        const midIdx = Math.floor(arr.length / 2);\n        return merge(mergeSort(arr.slice(0, midIdx)), mergeSort(arr.slice(midIdx)))\n    }\n    \n    function merge(leftArr, rightArr) {\n        let temp = [];\n        while (leftArr.length > 0 && rightArr.length > 0) {\n            if (leftArr[0] < rightArr[0]) {\n                temp.push(leftArr.shift());\n            } else {\n                temp.push(rightArr.shift());\n            }\n        }\n        return temp.concat(leftArr).concat(rightArr);\n    }\n    \n    \n    \n    \n    //快速排序\n    \n    function quickSort(arr) {\n        // 基线条件：小于或等于1个元素的数组是有序的\n        if (arr.length <= 1) return arr;\n    \n        // 选择一个基准值，这里我们选择数组的中间值作为基准值\n        let pivotIndex = Math.floor(arr.length / 2);\n        let pivot = arr.splice(pivotIndex, 1)[0];\n    \n        // 定义两个子数组，一个用于存放比基准值小的元素，另一个用于存放比基准值大的元素\n        let left = [];\n        let right = [];\n    \n        // 遍历数组，将比基准值小的元素放入左边的子数组，比基准值大的元素放入右边的子数组\n        for (let i = 0; i < arr.length; i++) {\n            if (arr[i] > pivot) {\n                left.push(arr[i]);\n            } else {\n                right.push(arr[i]);\n            }\n        }\n    \n        // 递归地对左右两个子数组进行快速排序，然后连接这两个子数组和基准值，得到排序后的数组\n        return quickSort(left).concat([pivot], quickSort(right));\n    }\n    \n    // 时间复杂度：平均情况下为O(n log n)，最坏情况下为O(n^2)，但在实际应用中表现良好。\n    \n    console.log(quickSort([1,25,72,3,78,2,5,8,9,-2]))\n    快速排序的最坏情况发生在每次选择的基准值都是输入数组的最小值或最大值时。这会导致每次递归调用只能减少一个元素，从而使算法退化为O(n^2)的复杂度。\n    \n    具体来说，以下是一些导致最坏情况的场景：\n    \n    1. **已排序的数组**：如果输入数组已经是升序或降序，且我们每次选择第一个或最后一个元素作为基准值，那么快速排序将会退化为O(n^2)。\n    \n    2. **含有许多重复值的数组**：如果数组包含许多重复的值，并且这些重复值经常被选为基准值，那么分区可能会非常不平衡。\n    \n    为了避免这些最坏情况，通常有以下几种策略：\n    \n    1. **随机选择基准值**：每次从数组中随机选择一个元素作为基准值，这样即使在面对已排序的数组时，平均情况下也能达到O(n log n)的性能。\n    \n    2. **使用\"三数取中\"策略**：选择数组的第一个、中间和最后一个元素中的中值作为基准值。这可以减少对已排序输入或近似排序输入的不良性能。\n    \n    3. **双基准快速排序**：这是快速排序的变种，它每次选择两个基准值并将数组分为三部分。这种方法在处理有大量重复值的数组时表现得更好。\n    \n    总之，虽然快速排序在最坏情况下的性能不佳，但通过适当的策略，可以在大多数情况下获得很好的平均性能。\n    \n    function quickSort(arr) {\n        quickSort_c(arr, 0, arr.length - 1);\n    }\n    \n    function quickSort_c(arr, p, r) {\n        if (p >= r) return;\n        let q = partition(arr, p, r);\n        quickSort_c(arr, p, q - 1);\n        quickSort_c(arr, q + 1, r);\n    }\n    \n    function partition(arr, p, r) {\n        let i = j = p;\n        while (j < r) {\n            if (arr[j] < arr[r]) {\n                swap(arr, j, i);\n                i++;\n            }\n            j++;\n        }\n        swap(arr, i, r)\n        return i\n    }\n    \n    function swap(arr, i, r) {\n        let temp = arr[i];\n        arr[i] = arr[r];\n        arr[r] = temp;\n    }\n    \n    //降序\n    function quickSortDesc(arr) {\n        if (arr.length <= 1) {\n            return arr;\n        }\n    \n        const pivot = arr[Math.floor(arr.length / 2)];\n        const less = [];\n        const greater = [];\n    \n        for (let i = 0; i < arr.length; i++) {\n            if (arr[i] > pivot) {\n                less.push(arr[i]);\n            } else if (arr[i] < pivot) {\n                greater.push(arr[i]);\n            }\n        }\n    \n        return [...quickSortDesc(less), pivot, ...quickSortDesc(greater)];\n    }\n    \n    // 示例用法\n    const array = [9, 4, 2, 7, 1, 5, 8, 3, 6];\n    const sortedArray = quickSortDesc(array);\n    console.log(sortedArray);\n    \n    \n\n## 10.15 同一对象\n\n    \n    \n    function areDeeplyEqual(o1, o2) {\n        if (Object.prototype.toString.call(o1) !== Object.prototype.toString.call(o2)) {\n            return false;\n        }\n        if (o1 !== null && typeof o1 === 'object') {\n            const keys1 = Object.keys(o1);\n            const keys2 = Object.keys(o2);\n            if (keys1.length !== keys2.length) return false;\n            return keys1.every((k) => areDeeplyEqual(o1[k], o2[k]));\n        }\n    \n        return o1 === o2;\n    }\n    \n    \n\n## 10.16数组扁平化\n\n    \n    \n    // 1.递归\n    function flatDeep(arr){\n    \tlet result = [];\n    \tfor(let i = 0; i < arr.length; i++) {\n    \t\tif(Array.isArray(arr[i])){\n    \t\t\tresult = result.concat(flatDeep(arr[i]))\n    \t\t} else {\n    \t\t\tresult.push(arr[i])\n    \t\t}\n    \t}\n    \treturn result;\n    }\n    // 2.ES6\n    function flatDeep(arr) {\n    \treturn arr.flat(Infinity)\n    }\n    // 3.扩展运算符与some\n    function flatDeep(arr) {\n    \twhile(arr.some(item => Array.isArray(item))){\n    \t\tarr = [].concat(...arr)\n    \t}\n    \treturn arr;\n    }\n    // 4.reduce\n    function flatDeep(arr) {\n    \treturn arr.reduce((pre, next) => {\n    \t\treturn pre.concat(Array.isArray(next) ?  flatDeep(next) : next)\n    \t},[])\n    }\n    // 5.toString\n    function flatDeep(arr){\n    \tlet result = [];\n    \treturn result = arr.toString().split(',').map(Number)\n    }\n    // 6.正则表达式\n    const res3 = JSON.parse('[' + JSON.stringify(arr).replace(/\\[|\\]/g, '') + ']');\n    // 传参\n    var flat = function (arr, n) {  \n        if(n === 0) return arr;\n        return arr.reduce((acc, item) => {\n            if (Array.isArray(item)) {\n                acc.push(...flat(item, n - 1))\n            } else {\n                acc.push(item)\n            }\n            return acc\n        }, [])\n        \n    };\n    var flat = function (arr, n) {\n        while(arr.some(item=>Array.isArray(item))&&n>0){\n            arr=[].concat(...arr)\n            n--;\n        }\n        return arr;\n    };\n    \n    \n    \n    var array = [1, [2, [3, [4, 5]]]];\n    console.log(flatDeep(array));\n    \n    \n    \n\n## 10.17 instance\n\n    \n    \n    function myInstanceof(L = null, R) {\n        // 对于左侧参数如果是非对象直接返回false\n        if (Object(L) !== L) return false\n        // 对于右侧参数可以认为只能为函数且不能没有Prototype属性\n        if (typeof R !== 'function' || !R.prototype) throw new TypeError('Right-hand side of 'instanceof' is not an object')\n        // 声明一个变量获取对象的__proto__\n        let link = L.__proto__\n        // 做循环（当link最终指向null，如果指向null的情况下都找不到那就返回false）\n        while (link !== null) {\n            // 如果找到说明R.prototype在L的原型链上，即返回true\n            if(link === R.prototype) return true\n            // 逐级向下\n            link = link.__proto__\n        }\n        return false\n    }\n    \n    \n    \n    \n    function myTypeof(params){\n      const type = Object.prototype.toString.call(params).slice(8, -1).toLowerCase()\n      const map = {\n        'number': true,\n        'string': true,\n        'boolean': true,\n        'undefined': true,\n        'bigint': true,\n        'symbol': true,\n        'function': true\n      }\n      return map[type] ? type : 'object'\n    \n    \n\n## 10.18 登录流程\n\n1.前端校验\n\n2.发送请求\n\n3.路由跳转\n\n    \n    \n    useRouter.repalce(path)\n    \n    \n\n4.拦截器\n\n    \n    \n    const httpInstance = axios.create(baseURL,timeout)\n    httpInstance.interceptors.request.use(config=>{\n    \tif(token){config.header.Authorization = `Bearer ${token}`} //一次配置\n    \treturn config\n    },e)\n    \n    httpInstance.interceptors.response.use(res=>{},e=>{\n        e.reponse.status == 401\n    })\n    \n    \n\n5.用户管理\n\n    \n    \n    Pinia或vuex集中管理\n    \n    \n\n6.持久化\n\n    \n    \n    本地化保存Token\n    \n    \n\n7.更改页面显示\n\n    \n    \n    v-if\n    \n    \n\n8.配置退出\n\n参考：\n\nhttps://juejin.cn/post/7072771035312947207\n\n## 10.19 比较版本号\n\n    \n    \n    function compareVersion(version1, version2) {\n      const arr1 = version1.split('.')\n      const arr2 = version2.split('.')\n      const length1 = arr1.length\n      const length2 = arr2.length\n      const minlength = Math.min(length1, length2)\n      let i = 0\n      for (i ; i < minlength; i++) {\n        let a = parseInt(arr1[i])\n        let b = parseInt(arr2[i])\n        if (a > b) {\n          return 1\n        } else if (a < b) {\n          ret\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594904940875698176?sourceSSR=users",
        "title": "📯西山居春招开启，🔪沈剑心送你笔试秘籍~",
        "content": "[**春季刷题节活动正在进行中，限量周边/****100元****京东卡等你哦，和牛牛一起刷真题进大厂！**](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Flink%2Fchunjishauti2)\n\n[![](https://uploadfiles.nowcoder.com/images/20240228/999991353_1709091127200/45F820A377D8F6816998CB7A61BDB83B)](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Flink%2Fchunjishauti2)\n\n![](https://uploadfiles.nowcoder.com/images/20240306/999991353_1709707167301/DE6D90C549E5B523BF776690855F86EE)\n\n> 西山居(SEASUN)成立于1995年是金山集团的第一个游戏工作室，也是**中国大陆最早一批游戏工作室**\n>\n>\n> 西山居以“创造快乐，传递快乐，分享快乐”为使命坚持自研自发，直接面向用户，做用户喜爱的作品。自研3D引擎为业界尖端技术之一，荣获国家863计划支持。自研IP“剑侠情缘”耕耘20余年在中国和东南亚广受玩家喜爱，**《剑网3》**\n> 更是3D武侠游戏的扛鼎之作。\n\n![](https://uploadfiles.nowcoder.com/compress/mw1000/images/20240306/999991353_1709707347234/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n### ✨大侠请看👇\n\n[诶嘿]**在招项目-应届生：** 引擎渲染开发工程师、游戏开发工程师、游戏测试工程师、游戏策划\n\n[占坑]**在招项目-实习生：**\n游戏策划、游戏开发、人力、AI算法、周边开发、项目管理、游戏本地化、行政、用户研究、营销推广、直播助理、电竞品牌、运营、传播策划、同人维护、动画导演、视频策划、欧美营销、海外社群运营、游戏客户端开发、3D角色、UI、特效设计师等\n\n[MARK]**在招项目-训练营：** 美术、音频、TA、SEED、技术\n\n[喝可乐]**网申时间：** 3月5日起，招满即止，尽快投递\n\n[等offer]**工作地点：** 珠海、成都、上海、北京\n\n[瞅你]**笔试/测评时间** ：3月中旬起\n\n[没问题]**投递次数** ：每个招聘项目最多投递两个岗位\n\n[牛啤]**投递链接：**[https://app.mokahr.com/campus-\nrecruitment/xishanju/37430?sourceToken=40cdbc36ace205a6b6ced2c4813dee42#/](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fapp.mokahr.com%2Fcampus-\nrecruitment%2Fxishanju%2F37430%3FsourceToken%3D40cdbc36ace205a6b6ced2c4813dee42%23%2F)\n\n[嘤嘤嘤]**福利待遇：** 顶配公积金、绩效奖金、海景办公区、免费实习宿舍，餐饮补贴，节日福利、生日月等\n\n[锦鲤]**其他信息：** 实习&训练营均有转正机会，往届可投递美术/TA/音频训练营项目\n\n![](https://uploadfiles.nowcoder.com/images/20240306/999991353_1709708039688/E8AEF09AAB9272E96C1B054DC0089805)\n\n## **关于笔试！西山居最近刚授权我们两份全真试卷，开发和运营的友友看过来！**\n\n**游戏开发：**[https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=100&selectStatus=0&tagIds=163](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FcurrentTab%3Drecommand%26jobId%3D100%26selectStatus%3D0%26tagIds%3D163)\n\n**游戏运营：**[https://www.nowcoder.com/exam/company?currentTab=recommand&jobId=104&selectStatus=0&tagIds=163](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FcurrentTab%3Drecommand%26jobId%3D104%26selectStatus%3D0%26tagIds%3D163)\n\n**聪明的友友已经刷起来啦，春季刷题节活动也在进行中，欢迎友友报名领取****好运offe****r挂件**[锦鲤][锦鲤][锦鲤]\n\n> 小贴士：电脑端使用Ctrl+F快捷键更方便查找\n\n### **✨✨✨✨✨✨✨✨✨✨✨✨**\n\n> ###\n> **更新更多更全校招信息请关注**[**牛客校招日程**](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgw-c.nowcoder.com%2Fapi%2Fsparta%2Fjump%2Flink%3Flink%3Dhttps%253A%252F%252Fgw-c.nowcoder.com%252Fapi%252Fsparta%252Fjump%252Flink%253Flink%253Dhttps%25253A%25252F%25252Fgw-c.nowcoder.com%25252Fapi%25252Fsparta%25252Fjump%25252Flink%25253Flink%25253Dhttps%2525253A%2525252F%2525252Fgw-c.nowcoder.com%2525252Fapi%2525252Fsparta%2525252Fjump%2525252Flink%2525253Flink%2525253Dhttps%252525253A%252525252F%252525252Fgw-c.nowcoder.com%252525252Fapi%252525252Fsparta%252525252Fjump%252525252Flink%252525253Flink%252525253Dhttps%25252525253A%25252525252F%25252525252Fwww.nowcoder.com%25252525252Flink%25252525252Fstxzrc)\n>\n> ###\n> [**https://www.nowcoder.com/link/stxzrc**](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgw-c.nowcoder.com%2Fapi%2Fsparta%2Fjump%2Flink%3Flink%3Dhttps%253A%252F%252Fgw-c.nowcoder.com%252Fapi%252Fsparta%252Fjump%252Flink%253Flink%253Dhttps%25253A%25252F%25252Fgw-c.nowcoder.com%25252Fapi%25252Fsparta%25252Fjump%25252Flink%25253Flink%25253Dhttps%2525253A%2525252F%2525252Fgw-c.nowcoder.com%2525252Fapi%2525252Fsparta%2525252Fjump%2525252Flink%2525253Flink%2525253Dhttps%252525253A%252525252F%252525252Fgw-c.nowcoder.com%252525252Fapi%252525252Fsparta%252525252Fjump%252525252Flink%252525253Flink%252525253Dhttps%25252525253A%25252525252F%25252525252Fwww.nowcoder.com%25252525252Flink%25252525252Fstxzrc)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594888101340745728?sourceSSR=users",
        "title": "推荐算法面经",
        "content": "  1. 自我介绍\n  2. 简单介绍一下这个推荐项目\n  3. 用户数据量和内容数据量，总共有多少特征，具体是大概有哪些特征，用户行为序列用到了吗？\n  4. 一个特征有多个值的情况是怎么处理的？\n  5. 有做特征选择吗？训练数据量多大？多路召回怎么做的？多路召回有几路？多路召回是怎么融合的？\n  6. 有做粗排吗？\n  7. 召回的离线指标和线上指标大概是什么情况？\n  8. 用户的冷启动是怎么做的？\n  9. 介绍一下 GrapSAGE，word2vec, deepwalk, node2vec\n  10. 介绍一下 transformer， 多头注意力，encoder， decoder， LayerNorm\n  11. DeepFM\n  12. FM 的二阶交叉的权重是什么？FM的计算复杂度？\n  13. leetcode：快排\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594906914962624512?sourceSSR=users",
        "title": "前端难点（面经）",
        "content": "## 目录\n\n9.1 多图加载方案\n\n9.2 axios\n\n9.3 Koa\n\n9.4 React坑\n\n9.4.1 过期闭包\n\n9.4.2 父子引用函数\n\n9.5 登录流程\n\n9.6 图片放大镜\n\n9.7 视频播放\n\n9.7.1 图片渲染流程\n\n9.8-些坑\n\n9.9 鉴权\n\n9.10 小免鲜\n\n9.11 Web worker\n\n9.12 文件上传\n\n9.13 扫码登陆\n\n9.14 列表优化\n\n9.15 富文本编辑器\n\n9.16 SSO\n\n9.17 低代码\n\n9.18 小程序\n\n9.19 qiankun\n\n9.18 BFF中间层\n\n## 9.1 多图加载方案\n\n在前端展示1000张图片时，如果一次性加载，可能会导致页面加载缓慢，用户体验下降。以下是一些可以应用的优化策略：\n\n  1. **懒加载（Lazy Loading）** ：只有当图片进入或即将进入视口时，才加载图片。这可以减少初始页面加载的时间。在最新的HTML标准中，可以直接使用loading=\"lazy\"属性。\n\n    \n    \n    <img data-src=\"image.jpg\" alt=\"description\" loading=\"lazy\">\n    \n    \n\n如果你希望使用JavaScript来实现懒加载，可以使用Intersection Observer API。\n\n    \n    \n    let images = document.querySelectorAll('img[data-src]');\n    \n    let imgObserver = new IntersectionObserver((entries, observer) => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting) {\n          let img = entry.target;\n          img.src = img.getAttribute('data-src');\n          img.removeAttribute('data-src');\n          observer.unobserve(img);\n        }\n      });\n    });\n    \n    images.forEach(img => {\n      imgObserver.observe(img);\n    });\n    \n    \n\n  1. 图片压缩：对图片进行压缩可以减少图片的大小，从而减少加载时间。可以使用工具或库如imagemin，或者在服务器端进行图片压缩。\n  2. 使用CDN：通过使用内容分发网络（CDN），可以将图片缓存到距离用户更近的服务器上，从而减少加载时间。\n  3. 使用缩略图：如果图片的细节不重要，可以先加载缩略图，当用户点击时再加载完整的图片。\n  4. 分页加载/无限滚动：不是一次性加载所有图片，而是当用户滚动到页面底部时，加载更多图片。可以使用分页(Pagination)或无限滚动(Infinity Scrolling)的方式来实现。\n  5. 虚拟滚动。同懒加载，可以使用ElementUI和vue-virtual-scroller进行显示。\n\n以下是一个简单的无限滚动的实现：\n\n    \n    \n    let page = 0;\n    \n    let inScroll = false;\n    \n    function loadImages() {\n      if (inScroll) {\n        return;\n      }\n    //然后，我们定义一个布尔变量inScroll，用于防止在加载图片时重复发送请求。\n      inScroll = true;\n    \n      fetch(`/api/images?page=${page}`)\n        .then(response => response.json())\n        .then(data => {\n          page++;\n          data.forEach(image => {\n            let img = document.createElement('img');\n            img.src = image.url;\n            document.body.appendChild(img);\n          });\n    \n          inScroll = false;\n        });\n    }\n    \n    window.onscroll = function() {\n      if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight) {\n        loadImages();\n      }\n    };\n    \n    loadImages();\n    \n    \n\n注意，这是一个基础的实现，实际的应用可能需要进行错误处理、API防抖、空数据处理等。\n\n## 9.2 axios\n\naxios 是基于 http （基于 tcp 传输层）的网络请求库。\n\n**拦截器执行顺序：**\n\n​\n请求的发送需要在请求拦截器之后，在响应拦截器之前，所以数组先放入request，接着在数组的前后分别加入请求和响应拦截器，由于加入请求拦截器的方法是unshift，所以最后通过promise进行请求的链式调用的时候，我们可以看到执行顺序是从左往右的，所以**最后注册的请求拦截器会最先执行**\n，而响应拦截的执行顺序和注册顺序是一样的。\n\n**fetch和axios区别：**\n\n  * Axios可以兼容IE浏览器，而Fetch在IE浏览器和一些老版本浏览器上没有受到支持\n  * 传递数据的方式不同，Axios是放到`data`属性里，以对象的方式进行传递，而Fetch则是需要放在`body`属性中，以字符串的方式进行传递\n  * Axios的相应超时设置是非常简单的，直接设置`timeout`属性就可以了，而fetch需要通过new AbortController()然后设置settimeout\n  * Axios还有非常好的一点就是会自动对数据进行转化，而Fetch则不同，它需要使用者进行手动转化。\n  * Axios的一大卖点就是它提供了拦截器，可以统一对请求或响应进行一些处理，使用它可以为请求附加token、为请求增加时间戳防止请求缓存，以及拦截响应，一旦状态码不符合预期则直接将响应消息通过弹框的形式展示在界面上，比如密码错误、服务器内部错误、表单验证不通过等问题。而Fetch没有拦截器功能，但是要实现该功能并不难，直接重写全局Fetch方法就可以办到。\n  * Fetch唯一碾压Axios的一点就是现代浏览器的原生支持。\n\nhttps://juejin.cn/post/6934155066198720519#heading-2\n\n**如何取消请求：**\n\n1 利用防抖\n\n2 利用request.cancel\n\n通过 cancel 属性来取消请求 另一种方法是直接在请求对象上设置 cancel 属性，该属性是一个函数。当您需要取消请求时，只需调用此函数即可。\n\n3 利用CancelToken()\n\n我们首先创建了一个名为 source 的 CancelToken 实例，并将其传递给请求的 config 对象中。然后，在需要取消请求的位置，我们通过调用\nsource.cancel() 方法来发送取消请求信号。如果请求已经被取消，则会抛出一个包含取消原因的错误，并且您可以在 catch\n块中检查这个错误并处理它。\n\n4 利用signal\n\n参数中携带signal：controller.signal, 设置一个全局变量controller= null，第一行进行判断controller &&\ncontroller.abort()，第二行controller = new AbortController()\n\n你可以在 Vue.js 应用中创建一个单独的服务文件（例如 `httpService.js`），在这个文件中封装你的 Axios\n请求。下面是一个简单的示例：\n\n    \n    \n    // 引入axios库\n    import axios from 'axios';\n    \n    // 创建axios实例\n    const http = axios.create({\n      baseURL: 'http://api.example.com',  // API服务器的基础URL\n      timeout: 1000,  // 设置请求超时时间,时间内就接受，时间外就catch\n    });\n    \n    // 添加请求拦截器\n    http.interceptors.request.use(config => {\n      // 在发送请求之前，可以在这里做些什么，例如添加Token到header\n      config.headers['Authorization'] = 'Bearer token';\n      return config;\n    }, error => {\n      // 对请求错误做些什么\n      return Promise.reject(error);\n    });\n    \n    // 添加响应拦截器\n    http.interceptors.response.use(response => {\n      // 对响应数据做点什么，例如处理不同的HTTP状态码\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        return Promise.reject(response);\n      }\n    }, error => {\n      // 对响应错误做点什么\n      return Promise.reject(error);\n    });\n    \n    // 导出http对象\n    export default http;\n    \n    \n\n然后你可以在 Vue.js 组件中这样使用这个封装好的服务：\n\n    \n    \n    import http from './httpService';\n    \n    export default {\n      data() {\n        return {\n          posts: [],\n        };\n      },\n      async created() {\n        try {\n          this.posts = await http.get('/posts');\n        } catch (error) {\n          console.error(error);\n        }\n      },\n    };\n    \n    \n\n这个封装的服务包含了请求拦截器和响应拦截器，可以方便你在请求之前或响应之后执行某些操作，例如添加认证信息到请求头，或处理不同的 HTTP\n状态码。注意，这只是一个基本的例子，实际的需求可能更复杂。\n\n**axios底层原理XHR**\n\n    \n    \n    class Axios {\n        constructor() {\n    \n        }\n    \n        request(config) {\n            return new Promise(resolve => { //利用promise\n                const {url = '', method = 'get', data = {}} = config;\n                // 发送ajax请求\n                const xhr = new XMLHttpRequest();\n                xhr.open(method, url, true);\n                xhr.onload = function() {\n                    console.log(xhr.responseText)\n                    resolve(xhr.responseText);\n                }\n                xhr.serRequestHeader(k,v)//发送额外配置的头部字段\n                xhr.send(data);//如果data为空需要传null\n            })\n        }\n    }\n    // 最终导出axios的方法，即实例的request方法\n    function CreateAxiosFn() {\n        let axios = new Axios();\n        let req = axios.request.bind(axios);\n        return req;\n    }\n    \n    // 得到最后的全局变量axios\n    let axios = CreateAxiosFn();\n    //接收到数据后xhr对象上的一下属性会被填充\n    ```\n    reponseText：作为响应主体被返回的文本。\n    responseXML：如果响应的内容类型是“text/xml”或“application/xml”，这个属性中将保存包含着响应数据的XML DOM文档。\n    status ： 响应的HTTP状态。\n    statusText：HTTP状态的说明。\n    ```\n    //XHR头部信息：setRequestHeader\n    ```\n    Accept：浏览器能够处理的内容类型。\n    Accept-Charset：浏览器能够处理的字符集。\n    Accept-Encoding：浏览器能够处理的压缩编码。\n    Accept-Language：浏览器当前设置的语言。\n    Connection：浏览器与服务器之间连接的类型。\n    Cookie：当前页面设置的任何Cookie。\n    Host：发出请求的页面所在的域。\n    Referer：发出请求的页面的URL。注意，HTTP规范将这个头部字段拼写错了，\n    而为保证与规范一致，也只能讲错就错了。(这个英文单词的正确拼法应该是\n    referrer。）\n    User-Agent：浏览器的用户代理字符串。\n    ```\n    \n    \n    \n    \n    // 定义get,post...方法，挂在到Axios原型上 axios.method()\n    const methodsArr = ['get', 'delete', 'head', 'options', 'put', 'patch', 'post'];\n    methodsArr.forEach(met => {\n        Axios.prototype[met] = function() {\n            console.log('执行'+met+'方法');\n            // 处理单个方法\n            if (['get', 'delete', 'head', 'options'].includes(met)) { // 2个参数(url[, config])\n                return this.request({\n                    method: met,\n                    url: arguments[0],\n                    ...arguments[1] || {}\n                })\n            } else { // 3个参数(url[,data[,config]])\n                return this.request({\n                    method: met,\n                    url: arguments[0],\n                    data: arguments[1] || {},\n                    ...arguments[2] || {}\n                })\n            }\n    \n        }\n    })\n    \n    \n    \n\n  1. **创建一个新的****`axios`****实例：** 当你调用 `axios.method()` 函数时，Axios 首先会创建一个新的 `axios` 实例。这个实例包含了 Axios 的所有功能，包括拦截器、转换函数、取消功能等。\n  2. **合并配置参数：** Axios 会将你提供的配置参数与默认配置合并。例如，如果你提供了一个 URL，但没有提供方法，那么 Axios 会使用默认的 `get` 方法。合并后的配置将被应用到新创建的 `axios` 实例上。\n  3. **创建一个新的 HTTP 请求：** Axios 会使用配置中的 URL、方法、头部信息、数据等，创建一个新的 HTTP 请求。这个请求是由 XMLHttpRequest 对象（浏览器）或 http 模块（Node.js）创建的，这取决于你在哪个环境中使用 Axios。\n  4. **发送 HTTP 请求：** Axios 会将创建好的 HTTP 请求发送到服务器。发送请求的过程可能会触发请求拦截器，拦截器可以修改请求或添加额外的功能，例如日志记录。\n  5. **处理响应：** 当服务器返回响应时，Axios 会接收到这个响应。Axios 会解析响应的状态码、头部信息和数据，然后将其封装到一个新的 Promise 对象中。这个过程可能会触发响应拦截器，拦截器可以修改响应或添加额外的功能。\n  6. **返回 Promise：** Axios 的 `method()` 函数返回的是一个 Promise 对象。这个 Promise 代表了 HTTP 请求的结果，你可以使用 `.then` 或 `.catch` 来处理这个 Promise。如果请求成功，Promise 将被解析并返回响应数据；如果请求失败，Promise 将被拒绝并返回错误信息。\n\n## 9.3 Koa\n\nExpress优点：线性逻辑，通过中间件形式把业务逻辑细分、简化，一个请求进来经过一系列中间件处理后再响应给用户，清晰明了。 缺点：基于 callback\n组合业务逻辑，业务逻辑复杂时嵌套过多，异常捕获困难。\n\nKoa优点：首先，借助 co 和 generator，很好地解决了异步流程控制和异常捕获问题。其次，Koa 把 Express 中内置的\nrouter、view 等功能都移除了，使得框架本身更轻量。 缺点：社区相对较小\n\n  * express采取回调方式解决异步问题，koa采取promise方式解决异步问题\n  * express 内置许多中间件，koa只提供了核心代码，没有扩展其他中间件\n  * express中间件与koa中间件又差异\n  * express只能通过回调的方式处理错误，koa可以通过监听 on(\"error\") 处理错误\n  * koa中请求与响应都扩展到了ctx上，express是直接对请求req与响应res进行扩展\n\n**KOA启动服务的流程**\n\nkoa 主要的启动流程就是下面的 4 步：引入 koa 包 => 实例化 koa => 编写中间件 => 监听服务器\n\n实例化koa：\n\n​ 执行 constructor ，将 ctx、response、request 等对象封装在 koa 实例中；\n\n编写中间件：\n\n​ 首先判断 fn 的类型，不是方法直接抛错 => 是生成器函数的话用 co 封装 => 是 async 函数的话直接放入中间件数组中 =>\n如果是普通函数的话，1.X 版本会报错，2.X 版本可以执行，但是由于没有 next，只能执行第一个\n\n​ koa 的中间件机制巧妙的运用了闭包和 async await 的特点，形成了一个洋葱式的流程，和 JS 的事件流 (捕获 -> target ->\n冒泡) 相似\n\n    \n    \n    const koa = require(\"koa\");\n    const app = new koa();\n    app.use(function 1(){}) \n    //use 的作用就是把中间件函数依次放入 ctx.middleware 中，等待请求到来的时候顺序调用\n    app.listen(port,function(){})\n    //封装原生的 node sever 监听\n    //封装 koa.callback()，并且为这个服务器设置了 node 的 request 事件，这意味着当每一个请求到来时就会执行 koa.callback() 方法，这是极为关键的一步，是 koa 中间件原理的基础\n    \n    \n\n**普通函数采用 dispatch 算法也能取得洋葱式的流程，为何要使用 async ?**\n\n因为next()采用的异步算法。\n\n**为何要用 Promise.resolve 返回**\n\n因为他是洋葱式的层级，如果用普通的 Boolean 返回的话，只能返回到上一层，没法全局获取，对错误的把控难以控制。Promise 任何一层报错，都能用\ncatch 捕获\n\nhttps://www.ucloud.cn/yun/94307.html\n\n## 9.4 React坑\n\n### 9.4.1 过期闭包\n\n​\n过期闭包就是闭包中的变量获取的是过期的取值。解决过期闭包最好的方法就是在useEffect中合理管理依赖变量，或者是在useState中使用函数更新状态。\n当然，解决过期闭包最关键的一点就是保证闭包中的变量能够及时获取最新的数值。\n\n### 9.4.2 父子引用函数\n\n​ 一个最简单的 case 就是一个组件依赖了父组件的 callback，同时内部 useffect 依赖了这个 callback，每次 Parent\n重渲染都会生成一个新的 fetchData，因为 fetchData 是 Child 的 useEffect 的 dep，每次 fetchData\n变动都会导致子组件重新触发 effect，一方面这会导致性能问题，假如 effect 不是幂等的这也会导致业务问题（如果在 effect 里上报埋点怎么办）\n\n解决思路1：不再 useEffect 里监听 fetchData: 导致 stale closure 问题 和页面 UI 不一致。此时一方面父组件\nquery 更新，但是子组件的搜索并未更新但是子组件的 query 显示却更新了，这导致了子组件的 UI 不一致。\n\n解决思路2：在思路 1 的基础上加强刷 token\n\n  * 如果子组件的 effect 较多，需要建立 refreshToken 和 effect 的映射关系\n  * 触发 eslint-hook 的 warning，进一步的可能触发 eslint-hook 的 auto fix 功能，导致 bug\n  * fetchData 仍然可能获取的是旧的闭包？\n\n解决思路3：useCallback 包裹 fetchData, 这实际上是把 effect 强刷的控制逻辑从 callee 转移到了 caller\n\n解决思路4：使用 useEventCallback 作为逃生舱，\n\n解决思路5：拥抱 mutable，实际上这种做法就是放弃 react 的快照功能（变相放弃了 concurrent mode )，达到类似 vue3\n的编码风格。实际上我们发现 hook + mobx === vue3, vue3 后期的 api 实际上能用 mobx + hook 进行模拟。\n\n解决思路6：useReducer 这也是官方推荐的较为正统的做法我们仔细看看我们的代码，parent 里的 fetchData\n为什么每次都改变，因为我们父组件每次 render 都会生成新的函数，为什每次都会生成新的函数，我们依赖了 query 导致没法提取到组件外，除了使用\nuseCallback 我们还可以将 fetchData 的逻辑移动至 useReducer 里。因为 useReducer 返回的 dispatch\n永远是不变的，我们只需要将 dispatch 传递给子组件即可，然而 react 的 useReducer\n并没有内置对异步的处理，所以需要我们自行封装处理, 幸好有一些社区封装可以直接拿来使用，比如 zustand, 这也是我目前觉得较好的方案，尤其是\ncallback 依赖了多个状态的时候。\n\nhttps://juejin.cn/post/6916792895055855623\n\n## 9.5 登录流程\n\nhttps://juejin.cn/post/7083481223384793096\n\n## 9.6 图片放大镜\n\n  1. 黄色的遮挡层跟随鼠标功能。\n  2. 把鼠标坐标给遮挡层不合适。因为遮挡层坐标以父盒子为准。\n  3. 首先是获得鼠标在盒子的坐标。\n  4. 之后把数值给遮挡层做为left 和top值。\n  5. 此时用到鼠标移动事件，但是还是在小图片盒子内移动。\n  6. 发现，遮挡层位置不对，需要再减去盒子自身高度和宽度的一半。\n  7. 遮挡层不能超出小图片盒子范围。\n  8. 如果小于零，就把坐标设置为0\n  9. 如果大于遮挡层最大的移动距离，就把坐标设置为最大的移动距离\n  10. 遮挡层的最大移动距离：小图片盒子宽度 减去 遮挡层盒子宽度\n\n    \n    \n    <div>\n        <!-- 小图与遮罩 -->\n        <div id=\"small\">\n            <img src=\"images/189602.jpg\"  class=\"small-img\" alt=\"\" >\n            <div id=\"mark\"></div>\n        </div>\n        <!-- 等比例放大的大图 -->\n        <div id=\"big\">\n            <img src=\"images/189602.jpg\" alt=\"\" id=\"bigimg\">\n        </div>\n    </div>\n    \n    \n    \n    \n     window.addEventListener(\"load\", function() {\n            // 获取小图和遮罩、大图、大盒子\n            var small = document.getElementById(\"small\")\n            var mark = document.getElementById(\"mark\")\n            var big = document.getElementById(\"big\")\n            var bigimg = document.getElementById(\"bigimg\")\n            // 在小图区域内获取鼠标移动事件;遮罩跟随鼠标移动\n            small.onmousemove = function (e) {\n                // 得到遮罩相对于小图的偏移量(鼠标所在坐标-小图相对于body的偏移-遮罩本身宽度或高度的一半)\n                var s_left = e.pageX - mark.offsetWidth / 2 - small.offsetLeft\n                var s_top = e.pageY - mark.offsetHeight / 2 - small.offsetTop\n                // 遮罩仅可以在小图内移动，所以需要计算遮罩偏移量的临界值（相对于小图的值）\n                var max_left = small.offsetWidth - mark.offsetWidth;\n                var max_top = small.offsetHeight - mark.offsetHeight;\n                // 遮罩移动右侧大图也跟随移动（遮罩每移动1px，图片需要向相反对的方向移动n倍的距离）\n                var n = big.offsetWidth / mark.offsetWidth\n                // 遮罩跟随鼠标移动前判断：遮罩相对于小图的偏移量不能超出范围，超出范围要重新赋值（临界值在上边已经计算完成：max_left和max_top）\n                // 判断水平边界\n                if (s_left < 0) {\n                    s_left = 0\n                } else if (s_left > max_left) {\n                    s_left = max_left\n                }\n                //判断垂直边界\n                if (s_top < 0) {\n                    s_top = 0\n                } else if (s_top > max_top) {\n                    s_top = max_top\n                }\n                // 给遮罩left和top赋值（动态的？因为e.pageX和e.pageY为变化的量），动起来！\n                mark.style.left = s_left + \"px\";\n                mark.style.top = s_top + \"px\";\n                // 计算大图移动的距离\n                var levelx = -n * s_left;\n                var verticaly = -n * s_top;\n                // 让图片动起来\n                bigimg.style.left = levelx + \"px\";\n                bigimg.style.top = verticaly + \"px\";\n            }\n            // 鼠标移入小图内才会显示遮罩和跟随移动样式，移出小图后消失\n            small.onmouseenter = function () {\n                mark.style.display = \"block\"\n                big.style.display= \"block\"\n            }\n            small.onmouseleave = function () {\n                mark.style.display = \"none\"\n                big.style.display= \"none\"\n            }\n        })\n    \n    \n    \n    \n    * {\n            margin: 0;\n            padding: 0;\n        }\n    \n        #small {\n            width: 500px;\n            height: 320px;\n            float: left;\n            position: relative;\n        }\n    \n        #big {\n            /* background-color: seagreen; */\n            width: 768px;\n            height: 768px;\n            float: left;\n            /* 超出取景框的部分隐藏 */\n            overflow: hidden;\n            margin-left: 20px;\n            position: relative;\n            display: none;\n        }\n    \n        #bigimg {\n            /* width: 864px; */\n            position: absolute;\n            left: 0;\n            top: 0;\n        }\n    \n        #mark {\n            width: 220px;\n            height: 220px;\n            background-color: #fff;\n            opacity: .5;\n            position: absolute;\n            left: 0;\n            top: 0;\n            /* 鼠标箭头样式 */\n            cursor: move;\n            display: none;\n        }\n    \n        .small-img {\n            width: 100%;\n            height:100%;\n        }\n    \n    \n\n## 9.7 视频播放\n\n**RTSP和HLS的特点**\n\n​\nRTSP，是目前三大流媒体协议之一，即实时流传输协议。它本身并不传输数据，传输数据的动作可以让UDP/TCP协议完成，而且RTSP可以选择基于RTP协议传输。RTSP对流媒体提供了诸如暂停，快进等控制，它不仅提供了对于视频流的控制还定义了流格式，如TS、\nmp4\n格式。最大的特点除了控制视频操作外还具有低延时的特点，通常可实现毫秒级的延时，但是也存在一些弊端，如该视频流技术实现复杂，而且对浏览器很挑剔，且flash插件播不了，这也极大的限制了它的发展。\n\n​\nHLS，由苹果公司提出，它是基于Http的流媒体网络传输协议，主要传输TS格式流，最大的特点是安卓、苹果都能兼容，通用性强，而且码流切换流畅，满足不同网络、不同画质的用户播放需要，但是因为该种视频流协议也存在较为致命的缺陷，那就是网络延时太高。本质上HLS视频流传输是将整个视频流分成一个个小切片，可理解为切土豆片，这些小片都是基于HTTP文件来下载——先下载，后观看。用户观看视频实际上是下载这些小的视频切片，每次只下载一些，苹果官方建议是请求到3个片之后才开始播放，若是直播，时延将超10秒，所以比较适合于点播。因此HLS视频的切片一般建议10s，时间间隔太短就切容易造成碎片化太严重不方便数据存储和处理，太长容易造成时延加重。\n\n**前端加载RTSP视频流：**\n\n  1. 使用媒体服务器进行转码：你可以设置一个媒体服务器，如 Wowza、GStreamer、FFmpeg 或 Red5，将 RTSP 流转码为浏览器支持的流格式，如 HTTP Live Streaming（HLS）或者 MPEG-DASH。然后，你可以使用 video 标签或者一些 JavaScript 库（如 video.js、hls.js）在前端播放转码后的流。\n  2. 使用 WebRTC：使用WebRTC播放RTSP视频流的过程中，你需要一个媒体服务器来做转码，比如使用GStreamer或者FFmpeg，将RTSP流转成WebRTC流。这需要后端的支持。在前端，你需要用到JavaScript的WebRTC API来播放视频。WebRTC并不是将视频流转换为图片流进行发送的。它处理的是压缩编码的音视频数据流，这是一种更有效的数据传输方式。具体来说，RTSP（实时流协议）视频流通常包含H.264或其他格式的编码视频数据。这些数据是连续的帧序列，每一帧都是图像的一部分，但并非直接的图像流。这些帧包括I帧（关键帧，包含完整的图像信息）和P帧（预测帧，只包含与前一帧的差异信息）。当你使用像GStreamer这样的媒体服务器接收RTSP流时，你是在接收这些编码的视频数据，而不是逐帧图像。然后，GStreamer可以将这些编码的数据重新打包为WebRTC可以理解的格式，然后通过WebRTC协议发送出去。\n  3. 使用插件或者特定的浏览器：一些浏览器插件和特定的浏览器（如 VLC 插件、QuickTime 插件、IE 浏览器等）可以直接播放 RTSP 流。但这种方法的兼容性不好，且用户体验也不理想。\n\n    \n    \n    //<video src=\"\" poster=\"\"></video>\n    autoplay:视频会马上自动开始播放，不会停下来等着数据载入结束\n    autobuffer(preload):视频会自动开始缓存\n    crossorigin:该枚举属性指明抓取相关图片是否必须用到CORS。不加这个属性时，抓取资源不会走CORS请求(即，不会发送 Origin: HTTP 头)，保证其在 <canvas> 元素中使用时不会被污染。\n    width|height\n    \n    \n\nRTSP视频流：\n\n    \n    \n    1 rtsp2web 是一个依赖 ffmpeg，能实时将传入的 rtsp 视频流转码成图像数据并通过 ws 推送到前端的智能工具包。\n    优点：\n    高性能，配置丰富。\n    并发，支持同时播放多路视频。\n    合并同源，多个视频窗口同时播放同一个rtsp视频源时，只会创建一个转码进程，不会创建多个。\n    智能释放资源，智能检测当前没有在使用的转码进程，将其关闭，并释放电脑资源。\n    \n    2 将RTSP视频流在后端进行转码通过IPB视频压缩进行传输(base64)，然后通过websocket进行发送，要使\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594906574930362368?sourceSSR=users",
        "title": "前端面经（其他部分）",
        "content": "## 目录：\n\n(一)Webpack\n\n6.1 构建流程\n\n6.2 对比vite\n\n6.3 sourceMap\n\n6.4 热更新\n\n6.5 代理proxy\n\n6.6 package\n\n6.7 性能优化\n\n6.8 treeShaking\n\n6.9 babel\n\n6.10 生命周期\n\n6.11 webpack5\n\n(二)版本控制\n\n2.1 git\n\n2.2 SourceTree\n\n(三)数据库\n\n3.1 Redis\n\n3.2 MySQI\n\n(四)npm\n\n## (一) Webpack\n\n最早的时候，我们会通过文件划分的形式实现模块化，约定每个文件是一个独立的模块，然后再将这些js文件引入到页面。但这种模块弊端十分的明显，模块都是在全局中工作，大量模块成员污染了环境，模块与模块之间并没有依赖关系、维护困难、没有私有空间等问题。\n\n​ `webpack` 是一个用于现代`JavaScript`应用程序的静态模块打包工具。这里的静态模块指的是开发阶段，可以被 `webpack`\n直接引用的资源（可以直接被获取打包进`bundle.js`的资源）当\nwebpack处理应用程序时，它会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块（不再局限js文件），并生成一个或多个 bundle。\n\n通过`webpack`优化前端的手段有：\n\n  * JS代码压缩\n  * CSS代码压缩，去除无用的空格，可以通过另一个插件css-minimizer-plugin\n  * Html文件代码压缩\n  * 文件大小压缩\n  * 图片压缩\n  * Tree Shaking 在计算机中表示消除死代码，依赖于ES Module的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）在webpack实现Trss shaking有两种不同的方案：usedExports：通过标记某些函数是否被使用，之后通过Terser来进行优化的sideEffects：跳过整个模块/文件，直接查看该文件是否有副作用\n  * 代码分离\n  * 内联 chunk\n\n### 6.1 构建流程\n\n**多文件入口** 是使用对象语法来通过支持多个entry，多文件入口的对象语法相对于单文件入口，具有较高的灵活性，例如多页应用、页面模块分离优化。\n\n    \n    \n    module.exports = {\n        entry: {\n            home: 'path/to/my/entry/home.js',\n            search: 'path/to/my/entry/search.js',\n            list: 'path/to/my/entry/list.js'\n        }\n    };\n    \n    \n\n上面的语法将entry分成了 3 个独立的入口文件，这样会打包出来三个对应的 bundle。一个 webpack\n的配置，可以包含多个entry**，**但是只能有一个output。对于不同的entry可以通过output.filename占位符语法来区分。\n\n**多页面** 就是指的多个 HTML 页面，这时候可以直接借助 html-webpack-plugin 插件来实现，我们只需要多次实例化一个 html-\nwebpack-plugin 的实例即可。\n\n​ 如果我们的项目是一个由多个路由或页面组成的，但是代码中只有一个单独的 JavaScript 文件（一个单独的入口\nchunk），这样会导致不管访问任何页面都会加载整站资源，让用户付出额外的流量。此外，如果这个用户经常只是访问其中的某个页面，但是当我们更改了其它页面的代码，Webpack\n将会重新编译，那么整个 bundle 的文件名哈希值就会发生变化，最终导致用户重新下载整个网站的代码，造成不必要的浪费。​\n这时候合理的做法是将整个项目利用多页面打包方案进行划分，将代码按照页面进行拆分，这样用户访问某个页面的时候，实际下载的只是当前页面的代码，而不是整个网站的代码，浏览器也更好的缓存了这部分代码，当其他页面代码发生变化的时候，当前代码的哈希值不会失效，自然用户不会重复下载相同的代码了。\n\nhttps://zhuanlan.zhihu.com/p/117656993\n\n  * 运行流程：(利用广播机制)1 初始化流程：从配置文件（webpack.config.js）和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数。Loader与Plugin区别：loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中plugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事两者在运行时机上的区别：loader 运行在打包文件之前plugins 在整个编译周期都起作用在Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过Webpack提供的 API改变输出结果对于loader，实质是一个转换器，将A文件进行编译形成B文件，操作的是文件，比如将A.scss或A.less转变为B.css，单纯的文件转换过程2 编译构建流程：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。​ 3. 输出流程：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统。\n\n### 6.2 对比vite\n\n**Vite** 是一个新兴的前端构建工具，由 Vue.js\n的作者尤雨溪创建。它的特点是快速的启动时间和构建速度。这意味着你可以更快地进行开发和调试，并且构建时间更短，这对于大型项目来说非常重要。\n\n​ Webpack 则是一个已经被广泛使用的前端构建工具，它可以打包 JavaScript 文件，CSS 文件和其他资源文件。Webpack\n可以通过各种插件和加载器来扩展其功能。\n\n​ 区别：\n\n​ 1 构建速度：Vite 是一个基于 ES modules 的构建工具，它利用浏览器原生的 ES module\n支持来实现更快的构建速度。在开发模式下，Vite 会直接从源代码中导入模块，而不是像 Webpack 那样需要先构建整个应用程序再运行。这就使得Vite\n的启动时间和热更新速度比 Webpack 要快得多。轻量快速的热重载（HMR）， 真正的按需编译，不用等待整个应用编译完成.\n\n​ 其构建速度主要由于内部采用的是ESbuild，它是go编写的，支持 ES6 和 CommonJS 模块；支持对 ES6 模块进行 tree\nshaking。\n\n​ 2 打包大小：Webpack 会将所有的代码打包到一起，而 Vite 只会在需要时按需导入。这意味着 Vite\n可以更好地利用浏览器的缓存来减少加载时间和带宽消耗，从而优化网页性能。\n\n​ 3 插件生态系统：Webpack 有一个非常庞大的插件生态系统，可以很容易地扩展其功能。虽然 Vite 也支持插件，但是它的插件数量远不及\nWebpack。\n\n​ 4 支持的文件类型：Webpack 可以处理各种类型的文件，包括 JavaScript、CSS、图片、字体等。而 Vite 目前仅支持\nJavaScript 和 CSS。\n\n​ 5 无需打包可快速的冷启动\n\n### 6.3 sourceMap\n\n`source-map`作用就在于能够帮你定位到错误的代码在那个文件哪一行，如果项目中配置了一些将 `es6`写代码转换成\n`es5`代码的插件`source-map`也能够将已转换的代码映射到原始的文件使浏览器可以重构原始源并在调试器中显示重建的原始源\n\n### 6.4 热更新\n\n关于`webpack`热模块更新的总结如下：Hot Module\nReplacement（HMR）这个特性允许开发者在不重新加载整个页面的情况下，替换、添加或删除模块。\n\n  1. 启动阶段：当 webpack-dev-server 启动后，会创建两个服务器，提供静态资源的服务（express）和Socket服务。客户端（浏览器）和服务端（webpack-dev-server）通过 Socket 进行通信。express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）\n  2. 编译阶段：当文件发生变化时，Webpack 会重新编译改变的模块，然后通过 Socket 向客户端发送更新的哈希值和改变的模块路径。\n  3. 客户端处理阶段：客户端接收到更新信息后，会通过 JSONP 请求新的模块文件。然后客户端对新的模块进行更新或替换。会生成两个文件.json（manifest文件）和.js文件（update chunk）浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新\n\n以下是这个过程中涉及的一些关键点：\n\n  * Webpack 编译：Webpack 通过文件系统监听到某个文件发生了改变，它会找出这个文件以及和它有直接关系的文件进行编译，然后生成一个或多个更新的模块。\n  * 模块热替换：HMR 插件会将这些更新的模块以 JSONP 的形式发送给客户端。客户端再把这些更新的模块替换到旧的模块上，或者在需要的地方加上新的模块。\n  * Socket 通信：HMR 使用 WebSocket 实现客户端和服务端之间的通信。服务端发生改变后，会通过 Socket 向客户端发送更新。\n\n需要注意的是，HMR 并不适用于所有的模块，比如一些会改变模块结构的改动（例如添加新的路由）可能仍需要刷新页面。并且，使用 HMR\n时，需要在代码中处理模块被替换后的情况，例如使用 `module.hot.accept`。\n\n### 6.5 代理proxy\n\n`webpack proxy`，即`webpack`提供的代理服务，基本行为就是接收客户端发送的请求后转发给其他服务器\n\n    \n    \n    module.exports = {\n        devServer: {\n        \tcontentBase,\n        \tport,\n        \tproxy:{target:表示的是代理到的目标地址,}\n        }\n     }\n    \n    \n\n`proxy`工作原理实质上是利用`http-proxy-middleware`\n这个`http`代理中间件，实现请求转发给其他服务器,**只适用在开发阶段**\n\n**服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制**\n\n### 6.6 package\n\ndependencies：生产环境下，项目运行所需依赖。\n\ndevDependencies：开发环境下，项目所需依赖。\n\nbin：内部命令对应的可执行文件的路径。\n\nmain：项目默认执行文件，比如 require(‘webpack’)；就会默认加载 lib 目录下的 webpack.js\n文件，如果没有设置，则默认加载项目跟目录下的 index.js 文件。\n\nmodule：是以 ES Module(也就是 ES6)模块化方式进行加载，因为早期没有 ES6 模块化方案时，都是遵循 CommonJS 规范，而\nCommonJS 规范的包是以 main 的方式表示入口文件的，为了区分就新增了 module 方式，但是 ES6 模块化方案效率更高，所以会优先查看是否有\nmodule 字段，没有才使用 main 字段。\n\neslintConfig：EsLint 检查文件配置，自动读取验证。\n\nresolutions：字段统一所有依赖和依赖的依赖当依赖版本可以灵活调整时，比如依赖的版本号是 `^`\n开头的，两者都使用最新版本是可以互相兼容的，而现在更多的第三方依赖都会定死他所依赖的库的版本号以稳定功能，确保不会产生第三方依赖做出了 BREAKING\nCHANGE 而导致大面积的报错停用。\n\n### 6.7 性能优化\n\n**1 基础优化**\n\n  * 缩小文件范围， 优化loader配置\n\n​ test、include、exclude三个配置项来缩⼩loader的处理范围，推荐include\n\n    \n    \n    include: path.resolve(__dirname, \"./src\"),\n    \n    \n\n  * resolve.modules用于配置webpack去哪些目录下寻找第三方模块，默认是 ['node_modules']。\n\n​\n寻找第三方，默认是在当前项目目录下的node_modules里面去找，如果没有找到，就会去上一级目录../node_modules找，再没有会去../../node_modules中找，以此类推，和Node.js的模块寻找机制很类似。\n\n​\nresolve.alias配置通过别名来将原导⼊路径映射成⼀个新的导⼊路径。拿react为例，我们引⼊的react库，⼀般存在两套代码：cjs（采⽤commonJS规范的模块化代码）umd\n（已经打包好的完整代码，没有采⽤模块化，可以直接执⾏）\n\n  * 使用mini-css-extract-plugin进行css抽离\n  * 压缩css，optimize-css-assets-webpack-plugin，cssnano\n  * 压缩html，html-webpack-plugin，// 移除HTML中的注释，压缩内联css\n  * 模块区分打包，webpack-merge\n  * tree shaking\n\n    \n    \n    Dead Code⼀般具有以下⼏个特征：代码不会被执⾏，不可到达|代码执⾏的结果不会被⽤到|代码只会影响死变量（只写不读）|Js tree shaking只⽀持ES module的引⼊⽅式\n    \n    \n\n  * 代码分割，所有的 chunks 代码公共的部分分离出来成为⼀个单独的⽂件\n\n    \n    \n    单⻚⾯应⽤spa：\n    打包完后，所有⻚⾯只⽣成了⼀个bundle.js。\n    \n    代码体积变⼤，不利于下载\n    没有合理利⽤浏览器资源\n    \n    多⻚⾯应⽤mpa:\n    如果多个⻚⾯引⼊了⼀些公共模块，那么可以把这些公共的模块抽离出来，单独打包。公共代码只需要下载⼀次就缓存起来了，避免了重复下载。\n    假如我们引⼊⼀个第三⽅的⼯具库，体积为1mb，⽽我们的业务逻辑代码也有1mb，那么打包出来的体积⼤⼩会在2mb，这就会导致问题：\n    \n    文件体积⼤，加载时间⻓。\n    业务逻辑会变化，而第三⽅⼯具库不会，所以业务逻辑⼀变更，第三⽅⼯具库也要跟着变。\n    \n    \n\n  * 使用happypack\n\n运⾏在Node.js之上的Webpack是单线程模型的，也就是说Webpack需要⼀个⼀个地处理任务，不能同时处理多个任务。Happy\nPack就能让Webpack做到这⼀点，它将任务分解给多个⼦进程去并发执⾏，⼦进程处理完后再将结果发送给主进程。从⽽发挥多核CPU电脑的威⼒。\n\n  * 将互相依赖的资源版本统一\n\n**2 文件优化**\n\n### 6.8 treeShaking\n\n​ ES6 module 特点：\n\n  * 只能作为模块顶层的语句出现\n  * import 的模块名只能是字符串常量\n  * import binding 是 immutable的\n\n​ ES6模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是tree-shaking的基础。\n\n​\n所谓静态分析就是不执行代码，从字面量上对代码进行分析，ES6之前的模块化，比如我们可以动态require一个模块，只有执行后才知道引用的什么模块，这个就不能通过静态分析去做优化。\n\n​ 这是 ES6 modules 在设计时的一个重要考量，也是为什么没有直接采用 CommonJS，正是基于这个基础上，才使得 tree-shaking\n成为可能，这也是为什么 rollup 和 webpack 2 都要用 ES6 module syntax 才能 tree-shaking。\n\n**webpack**\n\n​ 打包过程中，先对代码进行标记，主要是对 import & export 语句标记为 3 类：\n\n  * 所有 import 标记为 `/* harmony import */`\n  * 所有被使用过的 export 标记为`/* harmony export ([type]) */`，其中 `[type]` 和 webpack 内部有关，可能是 binding, immutable 等等\n  * 没被使用过的 export 标记为`/* unused harmony export [FuncName] */`，其中 `[FuncName]` 为 export 的方法名称\n\n​ 然后使用uglify、terser等压缩工具，根据标记以及静态分析程序流，去压缩删除无用代码。简单来说，就是压缩工具读取 webpack\n打包结果，在压缩之前移除 bundle 中未使用的代码。\n\n**rollup**\n\nrollup本身内置就是支持tree-shaking的\n\n  1. rollup()阶段，解析源码，生成 AST tree，对 AST tree 上的每个节点进行遍历，判断出是否import(标记避免重复打包)，是的话标记，然后生成 chunks，最后导出。\n  2. generate()/writ\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594906158004015104?sourceSSR=users",
        "title": "计算机网络面经（前端）",
        "content": "## 目录\n\n5.1 URL加载的过程\n\n5.2 Http\n\n5.2.1 发展\n\n5.2.2 请求|Option\n\n5.2.3 请求方法\n\n5.2.4 缓存\n\n5.2.5 tcp udp\n\n5.3 TCP三次握手与四次挥手\n\n5.4 Cookie\n\n5.5 OSI七层模型\n\n5.6 Http状态码\n\n5.7 CDN\n\n5.9 JWT\n\n5.11 网站攻击\n\n5.12 WebSocket\n\n5.13 跨域和同源\n\n5.14 网站性能\n\n5.15 加密\n\n5.16 DNS\n\n5.18 白屏问题\n\n5.20 Storage\n\n5.21 标签间通信\n\n5.22 网站指标\n\n##\n\n## 5.1 URL加载的过程\n\n1）首先，在浏览器地址栏中输入url\n\n​ 如果为非url结构的字符串，交给浏览器默认引擎去搜索改字符串；若为url结构的字符串，浏览器主进程会交给 网络进程，开始干活。\n\n2）浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。\n\n​ 网络进程会先看看是否存在本地缓存，如果有就直接返回资源给浏览器进程，无则下一步 DNS-> IP -> TCP。\n\n3）在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。\n\n​ 网络进程拿到url后，先会进行DNS域名解析得到IP地址。如果请求协议是HTTPS，那么还需要建立TLS连接。\n\n4）浏览器向服务器利用IP地址和服务器建立TCP连接。，与浏览器建立tcp三次握手。\n\n5）握手成功后，浏览器向服务器发送http请求，请求数据包。\n\n连接建立之后，向服务器发送请求。服务器收到请求信息后，会根据请求信息生成响应行、响应头、响应体，并发给网络进程。网络进程接受了响应信息之后，就开始解析响应头的内容。\n\n6）服务器处理收到的请求，将数据返回至浏览器\n\n​ 默认情况，每个页面一个渲染进程。但若处于同一站点（同根域名+协议），那么渲染进程就会复用。\n\n7）浏览器收到HTTP响应\n\n8）读取页面内容，浏览器渲染，解析html源码\n\n​\n渲染进程准备好后，浏览器进程发出“提交文档的消息”，渲染进程接受了消息之后，会跟网络进程简历传输数据的管道。等数据传输完成了，渲染进程会告诉浏览器进程，确认文档提交，这时候浏览器会更新页面，安全状态，url，前进后退的历史。\n\n9）渲染进程接受到数据，生成Dom树、解析css样式、js交互,渲染显示页面。\n\n​\n同步构建DOM树和CSSOM树，当CSSOM生成结束执行js。浏览器会先从DOM树的根节点开始遍历每个可见节点，并把这些节点添加到渲染树中。不可见的节点不会添加到渲染树，比如css设置了display为none\n属性的节点。根据生成的渲染树，进行布局（也可以叫做回流），得到各个节点在页面中的确切位置和大小。生成分层树，页面都是一层一层叠加在一起形成的。比如一些复杂的css动画，z-index等，渲染引擎会为他们生成专用的图层，并生成对应的图层树。\n\n## 5.2 Http\n\n### 5.2.1 发展\n\n0.9 | html文件传输 | 确定了客户端请求，服务器响应的通信流程  \n---|---|---  \n1.0 | 不同类型文件传输 | 设立头部字段  \n1.1 | 创建/断开TCP连接开销大 | 建立长连接进行复用  \n2 | 并发数有限 | 二进制分帧  \n3 | TCP丢包阻塞 | 采用UDP协议  \n  \n**对头阻塞：**\n\n​ 头部阻塞是 TCP中的一个问题，当一个 TCP 流中的一个数据包丢失时，整个流都会被阻塞，直到丢失的数据包被重新发送和接收。HTTP/1.1\n时代建立一个 TCP 连接，三个请求组成一个队列发出去，服务器接收到这个队列之后会依次响应，一旦前面的请求阻塞，后面的请求就会无法响应。\n\n​ HTTP/2 并没有解决 TCP 的队首阻塞问题，它仅仅是通过**多路复用** 解决了以前 HTTP1.1 **管线化**\n请求时的队首阻塞。HTTP/2 是通过**分帧** 并且给每个帧打上**流** 的 ID 去避免依次响应的问题，对方接收到帧之后根据 ID\n拼接出流，这样就可以做到乱序响应从而避免请求时的队首阻塞问题。但是 TCP 层面的队首阻塞是 HTTP/2 无法解决的（HTTP 只是应用层协议，TCP\n是传输层协议），TCP 的阻塞问题是因为传输阶段可能会丢包，一旦丢包就会等待重新发包，阻塞后续传输，这个问题虽然有**滑动窗口（Sliding\nWindow）**这个方案，但是只能增强抗干扰，并没有彻底解决。\n\n​ HTTP/3 通过使用基于 UDP 的 QUIC 协议来解决这个问题。在 QUIC\n中，流是独立的，如果一个流中的数据包丢失，它不会影响其他的流。这就意味着，即使在一个流中发生了数据包丢失，其他的流仍然可以继续传输数据。这样就消除了头部阻塞问题。\n\n**长连接与管道：**\n\n​ 在 HTTP/0.9 版本中，HTTP 请求是以短连接进行的，因此在发送完 HTTP 的响应之后，服务器就会断开 TCP\n连接。可是这样是一件很耗资源、很耗时间的事情，所以在 1.0 版本中，新增了 keep-alive 字段，让长连接被 HTTP\n支持了（此时默认还是不会开启长连接）。所谓长连接，就是完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP\n连接。好处是连接可以被重新使用，之后发送 HTTP 请求的时候就不需要重新建立 TCP 连接了，以及如果维持连接，那么 SSL 的开销也可以避免。\n\n好处如此之多，所以 HTTP/1.1 就把 Connection: keep-alive 头写进了标准，并且默认开启持久连接(两小时，心跳检测 5次)。\n\n必须在请求中声明：Connection: close 才会让每次 HTTP 请求都重新建立 TCP 连接。\n\n  * 如果是「短连接」，那么一次 TCP 连接就只能对应一次 HTTP 请求；\n  * 如果是「长连接」，那么一次 TCP 连接就可以发送多个 HTTP 请求了。\n\n管道是 HTTP/1.1 规范中的字段，能将多个 HTTP 请求整批提交，在发送过程中不需先等待服务器的回应。因为该技术存在很多问题：\n\n  1. 一些代理服务器不能正确的处理 HTTP Pipelining；\n  2. 正确的流水线实现是复杂的；\n  3. Head-of-line Blocking 连接头阻塞：在建立起一个 TCP 连接之后，假设客户端在这个连接连续向服务器发送了几个请求。按照标准，服务器应该按照收到请求的顺序返回结果，假设服务器在处理首个请求时花费了大量时间，那么后面所有的请求都需要等着首个请求结束才能响应。\n\nHTTP2 提供了 Multiplexing 多路传输特性，让我们可以在一个 TCP 连接中同时完成多个 HTTP\n请求。（可以将数据拆成包，给每个包打上标签。到了服务器在进行拼接即可，本质上还是管道）\n\n连接上限：\n\n​ 浏览器允许我们对同一 host 开启多个 TCP 连接，每个浏览器的数量是不一样的。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。\n\n​ **Http和Https的区别：**\n\n​\nHTTP协议也就是超文本传输协议，是一种使用明文数据传输的网络协议。一直以来HTTP协议都是最主流的网页协议，HTTP协议被用于在Web浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。\n\n​\n为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL/TLS协议，SSL/TLS依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。HTTPS协议可以理解为HTTP协议的升级，就是在HTTP的基础上增加了数据加密。在数据进行传输之前，对数据进行加密，然后再发送到服务器。这样，就算数据被第三者所截获，但是由于数据是加密的，所以你的个人信息仍然是安全的。\n\n​ 具体过程为：客户端发起 SSL orTLS握手 -> 服务端将证书发送给客户端 -> 客户端检查是否为 CA （双方约定可信任证书签发机构）->\n服务端检查客户端 CA 证书 ；\n\n**Http2和Http3区别：**\n\n​ HTTP2协议虽然大幅提升了HTTP/1.1的性能，然而，基于TCP实现的HTTP2遗留下3个问题：\n\n  * 有序字节流引出的队头阻塞（Head-of-line blocking），使得HTTP2的多路复用能力大打折扣；\n  * TCP与TLS叠加了握手时延，建链时长还有1倍的下降空间；\n  * 基于TCP四元组确定一个连接，这种诞生于有线网络的设计，并不适合移动状态下的无线网络，这意味着IP地址的频繁变动会导致TCP连接、TLS会话反复握手，成本高昂。\n\n​ HTTP3协议解决了这些问题：\n\n  * HTTP3基于UDP协议重新定义了连接，在QUIC层实现了无序、并发字节流的传输，解决了队头阻塞问题（包括基于QPACK解决了动态表的队头阻塞）；\n  * HTTP3重新定义了TLS协议加密QUIC头部的方式，既提高了网络攻击成本，又降低了建立连接的速度（仅需1个RTT就可以同时完成建链与密钥协商）；\n  * HTTP3 将Packet、QUIC Frame、HTTP3 Frame分离，实现了连接迁移功能，降低了5G环境下高速移动设备的连接维护成本。\n\n**Https发展**\n\n背景：早期的数据在网络传输中使用的http协议，这种协议采取的是明文传输的方式。从一个结点到另一个结点传输的过程中会存在一些不法分子从中窃取信息。早起的运营商也会利用职务之便进行数据劫持，在web里插入代码显示广告。在20世纪90年代中期，当人们意识到互联网应用越来越广泛，所传递的信息价值越来越高时，便不得不考虑对网络进行安全性处理。最早吃螃蟹的是当时最大的网景公司，在1994年对**http1.1**\n进行了升级。https发展:最早采用的方法便是加密，加密和解密采用相同的密钥，如凯撒加密，恩格码机等，这种加密方式就是对称加密。但是要想让传输双方进行解密，那在传递的过程中需要把密钥一起传递，这种加密方式就失去了意义。于是产生了非对称加密，利用公钥和私钥。服务器先将自己的公钥发送给浏览器。浏览器生成一个随机的数据，用服务器的公钥加密然后发送给服务器，服务器利用自己的私钥进行解密，于是就产生了一份相同的数据。这份数据用作双方传递的密钥进行加密传输。这是一套独立于http协议的流程，被称为安全套接字层（secure\nsocket layer-\nssl）后来ssl进行了三次升级，最后一次升级后被冠以TSL进行正式发布。所以TSL1.0也被叫做ssl3.1。升级过程是对加密方式的升级，比如舍弃了md5采用sha-256。但是如果有人将服务器传递给浏览器的公钥进行窃取然后更换成自己的公钥发送给浏览器，依旧会存在安全性问题。因此引入了CA的概念，ca会进行第三方加密以验证服务器身份，这就是TsL证书。这些ca机构会被保存在客户端本地以供浏览器需要。前几年有些网站自己给自己颁发证书，会存在不被认可的问题，12306。但是ca机构的权利过于集中，一旦ca机构出现问题，导致的问题不可估量。比如google和赛门铁克，还有棱镜门利用虚假的证书来窃听用户隐私。因此，引入了证书透明化，ct。但是这种套娃的操作并不能很好的解决该类问题。因此我认为去中心化才是核心。区块链给人们最大的启示就是任何中心化的技术都是不被信任的，无论他如何权威。ct中的日志服务采用了区块链中的默克尔树进行防篡改实现。这是一种类似于归并去计算每一层hash的方法，将根hash保存在每一个客户端上。\n\n**HTTPS 握手过程中，客户端如何验证证书的合法性**\n\n    \n    \n    校验证书的颁发机构是否受客户端信任。\n    2. 通过 CRL 或 OCSP 的方式校验证书是否被吊销。\n    3. 对比系统时间，校验证书是否在有效期内。\n    4. 通过校验对方是否存在证书的私钥，判断证书的网站域名是否与证书颁发的域名一致。\n    证书包含：公钥、公钥拥有者名称、CA的数字签名、有效期、授权中心名称、证书序列号等信息。\n    \n    \n\n**怎么通过数字证书验证服务器身份**\n\n  1. 客户端发起连接请求：客户端向服务器发起连接请求，例如使用HTTPS协议访问一个网站。\n\nssl握手过程中，浏览器会通过证书链层层验证，直至操作系统上的根证书，根证书存储在客户端本地【`C:\\Windows\\System32`】，其余的存储在服务器上。\n\n  1. 服务器发送数字证书：服务器将其数字证书发送给客户端。数字证书是由可信任的证书颁发机构（CA）颁发的，其中包含了服务器的公钥以及其他相关信息。\n  2. 客户端验证数字证书的合法性：客户端会使用内置的根证书颁发机构列表（或者操作系统提供的信任存储）来验证服务器发送的数字证书的合法性。客户端会检查证书的签名是否有效、证书是否过期、证书是否被吊销等。\n\n以下三步：向服务器发送一个随机数，从证书中获取服务器端的公钥，对随机数加密；编码改变通知，表示随后信息都将使用双方协定的加密方法和密钥发送；客户端握手结束通知。\n\n  1. 公钥提取：如果数字证书通过验证，客户端会从证书中提取出服务器的公钥。\n  2. 生成随机密钥：客户端会生成一个随机的对称密钥，用于加密通信过程中的数据。\n  3. 使用服务器的公钥加密对称密钥：客户端使用服务器的公钥对随机生成的对称密钥进行加密，然后将加密后的对称密钥发送给服务器。\n\n服务器端对数据解密得到随机数，发送消息：编码改变通知，表示随后信息都将使用双方协定的加密方法和密钥发送。\n\n  1. 服务器使用私钥解密对称密钥：服务器使用自己的私钥解密收到的加密对称密钥。\n  2. 建立加密通道：客户端和服务器双方现在都拥有相同的对称密钥，它们可以使用该密钥来进行加密和解密通信内容，建立安全的加密通道。\n\n​ **SSL和TLS区别：**\n\nSSL：（Secure Socket\nLayer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。\n\nTLS：(Transport Layer\nSecurity，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。\n\nSSL协议提供的服务主要有：\n\n1）认证用户和服务器，确保数据发送到正确的客户机和服务器；\n\n2）加密数据以防止数据中途被窃取；\n\n3）维护数据的完整性，确保数据在传输过程中不被改变。\n\nTLS 记录协议提供的连接安全性具有两个基本特性：\n\n​ 私有――对称加密用以数据加密（DES 、RC4\n等）。对称加密所产生的密钥对每个连接都是唯一的，且此密钥基于另一个协议（如握手协议）协商。记录协议也可以不加密使用。\n\n​ 可靠――信息传输包括使用密钥的MAC进行信息完整性检查。安全哈希功能（ SHA、MD5 等）用于 MAC 计算。记录协议在没有 MAC\n的情况下也能操作，但一般只能用于这种模式，即有另一个协议正在使用记录协议传输协商安全参数。\n\n![](https://uploadfiles.nowcoder.com/files/20240306/707453548_1709708620300/v2-0a145c61756af47c470679edd400d390_720w.webp)\n\n参考：\n\n  * HTTP发展史，HTTP1.1与HTTP2.0的区别 https://juejin.cn/post/7079936383925616653\n  * https://www.cnblogs.com/xhyccc/p/14392670.html\n  * https://segmentfault.com/q/1010000005167289\n\n### 5.2.2 请求｜Option\n\n1 客户端请求消息**客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request\nline）、请求头部（header）、空行和请求数据四个部分组成。\n\n    \n    \n    GET /hello.txt HTTP/1.1\n    //HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。\n    //HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。\n    User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3\n    Host: www.example.com\n    Accept-Language: en, mi\n    \n    \n\n**request header**\n\n1.Accept\n\n作用： 浏览器端可以接受的媒体类型, 例如： Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html\n也就是我们常说的html文档,如果服务器无法返回text/html类型的数据,服务器应该返回一个406错误(non acceptable)\n\n2.Accept-Encoding：\n\n作用： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）; 例如：\nAccept-Encoding: zh-CN,zh;q=0.8\n\n4.Connection\n\nConnection: keep-alive\n当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接\n\n8.Cache-Control\n\nCache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。\n\n**2 服务器响应消息** HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。\n\n    \n    \n    HTTP/1.1 200 OK\n    // 当前的GMT时间。\n    Date: Mon, 27 Jul 2009 12:28:53 GMT\n    //服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。\n    Server: Apache\n    //文档的最后改动时间。\n    Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT\n    // 指纹，比较两次请求是否变化，允许缓存更有效并节省带宽\n    ETag: \"34aa387-d-1568eb00\"\n    Accept-Ranges: bytes\n    //表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。\n    Content-Length: 51\n    //过期时间\n    Expires：\n    Set-cookie:\n    Vary: Accept-Encoding\n    //用于定义网络文件的类型和网页的编码:\n    //text/html ： HTML格式 /plain ：纯文本格式 /xml ： XML格式 /png：png图片格式\n    //application/xhtml+xml ：XHTML格式 /json： JSON数据格式 /pdf：pdf格式\n    Content-Type: text/plain //Content-Type 标头告诉客户端实际返回的内容的内容类型。一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些 PHP 网页点击的结果却是下载一个文件或一张图片的原因。\n    /*\n    text/html ： HTML格式\n    text/plain ：纯文本格式\n    text/xml ： XML格式\n    image/jpeg ：jpg图片格式 png gif图片格式\n    application/xhtml+xml ：XHTML格式\n    application/xml： XML数据格式\n    application/atom+xml ：Atom XML聚合格式\n    application/json： JSON数据格式\n    application/pdf：pdf格式\n    application/msword ： Word文档格式\n    application/octet-stream ： 二进制流数据（如常见的文件下载）\n    */\n    \n    \n    \n\n**response header**\n\n1.刷新和延时跳转\n\n一秒刷新页面一次 response.setHeader(“refresh”,“1”);\n\n二秒跳到其他页面 response.setHeader(“refresh”,“2;URL=otherPagename”);\n\n2.没有缓存\n\nresponse.setHeader(“Pragma”, “No-cache”);\n\nresponse.setHeader(“Cache-Control”, “no-cache”);\n\n3.设置过期的时间期限\n\nresponse.setDateHeader(“Expires”, System.currentTimeMillis()+自己设置的时间期限);\n\n4.设置请求文件最后修改时间\n\nresponse.setDateHeader(“Last-Modified”, System.currentTimeMillis());\n\n5.访问别的页面(重定向)\n\nresponse.setStatus（302）;\n\nresponse.setHeader(“location”,“url”);\n\n**3 OPTIONS**\n\n在CORS机制一个域名A要访问域名B的服务，在一些特殊的复杂请求下（简单请求并不会进行预请求），浏览器必须先使用OPTIONS请求进行一个预检请求（preflight\nrequest）来获取B服务是否允许跨域请求，服务进行确认之后，才会发起真正的HTTP请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括\nCookies 和 HTTP 认证相关数据）。\n\n简单请求：\n\n  1. http方法是以下之一：GET | HEAD | POST\n  2. HTTP的头信息不超出以下几种字段：\n\n  * Accept\n  * Accept-Language | Content-Language\n  * Content-Type （需要注意额外的限制）\n\n  1. Content-Type 的值为 text/plain\n\n请求情况：\n\n  * withCredentials为true不会产生预请求\n  * 请求头Content-Type为application/json会产生预请求\n  * 设置了用户自定义请求头会产生预检请求\n  * delete方法产生预检请求\n\n**预检请求不一定每一次都会产生**\n\n这个因为浏览器会对预检请求进行缓存，同时通过服务器端设置 Access-Control-Max-Age 字段来设置缓存时间。\n\n那么当第一次请求该 URL 时会发出 OPTIONS 请求，浏览器会根据返回的 Access-Control-Max-Age 字段缓存该请求的\nOPTIONS 预检请求的响应结果。\n\n### 5.2.3 请求方法\n\n**以资源为基础**\n：资源可以是一个图片、音乐、一个XML格式、HTML格式或者JSON格式等网络上的一个实体，除了一些二进制的资源外普通的文本资源更多以JSON为载体、面向用户的一组数据(通常从数据库中查询而得到)。**统一接口**\n:\n对资源的操作包括获取、创建、修改和删除，这些操作正好对应HTTP协议提供的GET、POST、PUT和DELETE方法。换言而知，使用RESTful风格的接口但从接口上你可能只能定位其资源，但是无法知晓它具体进行了什么操作，需要具体了解其发生了什么操作动作要从其HTTP请求方法类型上进行判断。具体的HTTP方法和方法含义如下：\n\n  * GET（SELECT）：从服务器取出资源（一项或多项）。\n  * POST（CREATE）：在服务器新建一个资源。\n  * PUT（UPDATE）：在服务器更新资源（客户端提供完整资源数据）。\n  * PATCH（UPDATE）：在服务器更新资源（客户端提供需要修改的资源数据）。\n  * DELETE（DELETE）：从服务器删除资源。\n\n**URI指向资源** ：URI = Universal Resource Identifier\n统一资源标志符，用来标识抽象或物理资源的一个紧凑字符串。URI包括URL和URN，在这里更多时候可能代指URL(统一资源定位符)。RESTful是面向资源的，每种资源可能由一个或多个URI对应，但一个URI只指向一种资源。\n\n**无状态** ：服务器不能保存客户端的信息， 每一次从客户端发送的请求中，要包含所有必须的状态信息，会话信息由客户端保存，\n服务器端根据这些状态信息来处理请求。 当客户端可以切换到一个新状态的时候发送请求信息， 当一个或者多个请求被发送之后, 客户端就处于一个状态变迁过程中。\n每一个应用的状态描述可以被客户端用来初始化下一次的状态变迁。\n\n**其他方法：**\n\nCONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。OPTIONS HTTP1.1 允许客户端查看服务器的性能。TRACE\nHTTP1.1 回显服务器收到的请求，主要用于测试或诊断。PATCH HTTP1.1 是对 PUT 方法的补充，用来对已知资源进行局部更新 。\n\n**post一定安全吗？**\n\n​\n只要拦截到了传递的数据体，用户名和密码就能轻松获取。MD5是一种常用的加密方法，它是一种散列函数，利用MD5对用户信息进行加密，会增加用户信息安全性。但是依旧可以利用一些方法破解(cmd5网)，因此可以在此之上加盐，在密码后面接一组乱码同时加密\n\n**幂等性**\n\n​ HTTP 方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。说白了就是，同一个请求，发送一次和发送 N\n次效果是一样的！幂等性是分布式系统设计中十分重要的概念，而 HTTP 的分布式本质也决定了它在 HTTP 中具有重要地位。\n\n1.GET 方法用于获取资源，不应有副作用，所以是幂等的。\n\n  1. DELETE 方法用于删除资源，有副作用，但它应该满足幂等性。比如：DELETE http://www.forum.com/article/4231，调用一次和 N 次对系统产生的副作用是相同的，即删掉 id 为 4231 的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。\n\n3.PUT 方法用于创建或更新操作，有副作用，与 DELETE 相同，对同一资源无论调用一次还是多次，其副作用是相同的，因此也满足幂等性。比如：PUT\nhttp://www.forum/articles/4231 的语义是创建或更新 ID 为 4231 的帖子。对同一 URI 进行多次 PUT\n的副作用和一次 PUT 是相同的；因此，PUT 方法具有幂等性。\n\n4.POST 方法与 PUT 方法的区别主要在于幂等性，POST 不具备幂等性，因为 POST 请求每次都会创建一个文件，而 PUT\n方法会在服务器验证是否有 ENTITY，若有则更新该 ENTITY 而不是重新创建。比如：POST\nhttp://www.forum.com/articles 的语义是在 http://www.forum.com/articles 下创建一篇帖子，HTTP\n响应中应包含帖子的创建状态以及帖子的 URI。两次相同的 POST 请求会在服务器端创建两份资源，它们具有不同的 URI；所以，POST 方法不具备幂等性。\n\n**如何防范 POST 重复提交**\n\nHTTP POST 操作既不是安全的，也不是幂等的（至少在 HTTP 规范里没有保证）。当我们因为反复刷新浏览器导致多次提交表单，多次发出同样的 POST\n请求，导致远端服务器重复创建出了资源。\n\n所以，对于电商应用来说，第一、对应的后端 WebService 一定要做到幂等性，第二、服务器端收到 POST 请求，在操作成功后必须 302\n跳转到另外一个页面，这样即使用户刷新页面，也不会重复提交表单。\n\n在前端开发中，GET 和 POST 是两种常用的 HTTP 请求方法，它们的主要区别在于数据传输的方式和用途：\n\n  1. 数据传输的方式：GET 方法：GET 请求通常用于请求数据，并将请求参数附加到 URL 中。请求的数据会被视为查询字符串，并在 URL 中可见。这意味着 GET 请求的 URL 中包含了所有需要的信息。这也意味着你不能通过 GET 请求发送大量的数据，因为 URL 的长度是有限制的。get比post快两倍。POST 方法：POST 请求通常用于发送数据，并将请求的数据放在请求体中。请求的数据不会在 URL 中可见，可以发送大量的数据。\n  2. 用途：GET 方法：通常用于获取（或查询）数据，比如获取用户列表、获取某篇文章等。根据 HTTP 规范，GET 请求应该是只读的，并且没有副作用。POST 方法：通常用于发送（或提交）数据，比如创建一个新用户、发布一篇新文章等。POST 请求可能会改变服务器上的数据。\n  3. 缓存： GET 方法：GET 请求能被浏览器缓存。 POST 方法：POST 请求不会被缓存。\n  4. 历史记录： GET 方法：GET 请求会被浏览器保存在历史记录中。 POST 方法：POST 请求不会被保存在历史记录中。\n  5. 书签： GET 方法：可以被添加为书签。POST 方法：不能被添加为书签。\n  6. 传参：get方法：从服务器获取数据,效率比POST高.GET请求能够被缓存在 HTTP 协议定义中,没有对GET请求的数据大小限制,不过因为浏览器不同一般限制在 2~8K 之间.GET发送请求时,URL中除了资源路径以外,所有的参数(查询字符串)也包装在URL中参数格式在资源路径末尾添加 ? 表示追加参数.每一个变量及值按照 变量名=变量值 方式设定,不能包含空格或者中文.多个参数使用 & 连接.注意 : URL 字符串中如果包含空格或者中文,需要添加百分号转义post方法：\n\n​ 向服务器发送数据,也可以获得服务器处理之后的结果,效率不如GET.\n\n​ POST请求不能被缓存.\n\n​ POST提交数据比较大,大小靠服务器的设定值限制,PHP通常限定 2M.\n\n​ POST发送请求时,URL中只有资源路径,但不包含参数,服务器日志不会记录参数,相对更安全.\n\n​ 参数被包装成二进制的数据体,格式与 GET 基本一致,只是不包含 ?.\n\n​ 注意 : 所有涉及到用户隐私的数据（密码，银行卡号）一定记住使用 POST 方式传递.\n\n​ **7\\. GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。**\n\n  * 对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）；\n  * 而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）。\n\n    \n    \n    axios.get('https://api.example.com/users', {\n        params: {\n            userId: 123\n        }\n    })\n       export let getStats = (a) => { \n           return axios({ \n               url: \"/login\",\n               method: \"get\", \n               // 传参 \n               params: { user: '123123' }\n           }); \n    axios.post('https://api.example.com/users', {\n        name: 'John Doe',\n        email: 'john@example.com'\n    })\n    .then(function (response) {\n        // handle success\n        console.log(response.data);\n    })\n    .catch(function (error) {\n        // handle error\n        console.log(error);\n    })\n    .finally(function () {\n        // always executed\n    });\n    \n    \n\n### 5.2.4 缓存\n\n​ 浏览器缓存指在本地使用的计算机中开辟一个内存区，同时也开辟一个硬盘区作为数据传输的缓冲区，然后用这个缓冲区来暂时保存用户以前访问过的信息。\n\nHTTP 缓存主要是通过请求和响应报文头中的对应 Header 信息，来控制缓存的策略。\n\nHTTP缓存可以缩短网页请求资源的距离，减少延迟，节省网络流量，并且由于缓存文件可以重复利用，降低网络负荷，提高客户端响应。缺点是服务端更改内容不能及时同步到客户端。\n\n根据是否需要重新向服务器发起请求，可分为**强缓存和协商缓存**\n\n**1 强缓存**\n\n定义：当命中强缓存的时候，客户端不会再请求服务器，直接从缓存中读取内容，并返回HTTP状态码200。\n\n强制缓存，在响应头由 Expires、Cache-Control 和 Pragma控制\n\n    \n    \n    Expires：值为服务器返回的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。（HTTP1.0的属性，缺点是客户端和服务器时间不一致会导致命中误差）(绝对时间)\n    Cache-Control：HTTP1.1属性，优先级更高，以下为常用属性\n    \tno-store： 禁用缓存\n    \tno-cache：不使用强缓存，每次需向服务器验证缓存是否失效\n    \tprivate/public：private指的单个用户，public可以被任何中间人、CDN等缓存\n    \tmax-age=：max-age是距离请求发起的时间的秒数(相对时间)\n    \tmust-revalidate：在缓存过期前可以使用，过期后必须向服务器验证\n    Pragma\n    \tno-cache：效果和cache-control等no-cache一致。\n    \t优先级Pragma > Cache-Control > Expires\n    \n    \n\n**知道 from disk cache和from memory cache吗，他们都是什么时候会触发？** 当强缓存的时候会触发这个，\n浏览器缓存是存储在磁盘和内存中，当需要使用到缓存的时候会先从内存查找，没有查找到就从磁盘中查找。如果还是找不到就向服务器请求，得到数据再存到内存和磁盘。\n\n**如何刷新强缓存**\n从上面的强缓存知识中，知道如果缓存时间没有过，我们一直都是在缓存中拿数据的，那么当我们把服务器的数据更新，如何让强缓存也能拿到最新的数据。因为强缓存都是判断url来判断是从缓存中拿数据还是从服务器拿数据，所以只要我们更改了这个url就可以。例如我们在url的后面添加一个version版本或者使用hash来让原来的url改变就可以刷新浏览器的缓存了。\n\n**2 协商缓存**\n\n定义：向服务器发送请求，服务器会根据这个请求的请求头的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的响应头通知浏览器从缓存中读取资源。\n\n协商缓存，响应头中有两个字段标记规则\n\n    \n    \n    Last-Modified / If-Modified-Since\n    \tLast-Modified是浏览器第一个请求资源，服务器响应头字段，是资源文件最后一次更改时间(精确到秒)。\n    \t下一次发送请求时，请求头里的If-Modified-Since就是之前的Last-Modified\n    \t 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304且不返回资源、不返回last-modify，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中.\n    \n    Etag / If-None-Match：Etag 的校验优先级高于 Last-Modified\n    \tEtag是加载资源时，服务器返回的响应头字段，是对资源的唯一标记，值是hash码， 根据实体内容生成的一段hash字符串（类似于MD5或者SHA1之后的结果），可以标识资源的状态。 当资源发送改变时，ETag也随之发生变化。\n    \t浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到请求头里的If-None-Match里\n    \t服务器接受到If-None-Match的值后，会拿来跟该资源文件的Etag值做比较，如果相同，则表示资源文件没有发生改变，命中协商缓存。\n    \n    \n\n**缓存验证流程**\n\n1 ) 浏览器创建了一个请求, 首先请求到达的地方是在本地缓存, 当然是建立在有Cache-\nControl头的情况下如果在本地缓存里查找，如果找到，则直接返回给浏览器渲染页面这种情况下, 不会经过任何网络的传输，也就是from memory\ncache的效果2 ) 如果没有找到，就会去网络请求，在网络请求中，如果经过代理服务器(代理缓存)那么首先会在代理服务器上查找相关缓存信息,\n如果找到就会返回给客户端经过本地缓存，再返回给浏览器渲染页面3 )\n如果在代理服务器上没有找到该缓存信息，那么就直接去源服务器上查找资源获取了新的内容之后，再逐级向下进行返回和二次缓存最终返回给浏览器进行页面的渲染\n\n**为什么还要使用ETag呢？** 主要是为了解决Last-Modified 无法解决的一些问题：\n\n  * 某些服务器不能精确得到文件的最后修改时间， 这样就无法通过最后修改时间来判断文件是否更新了。\n  * 某些文件的修改非常频繁，在秒以下的时间内进行修改. Last-Modified只能精确到秒。\n  * 一些文件的最后修改时间改变了，但是内容并未改变。 我们不希望客户端认为这个文件修改了。\n\nhttps://blog.csdn.net/Tyro_java/article/details/122952039\n\n**协商缓存失效怎么办？**\n\n  1. **服务端配置问题** ：确保服务端正确地设置了Etag或者Last-Modified响应头，且在收到含有If-None-Match或If-Modified-Since请求头的请求时，能正确地返回304状态码。\n  2. **网络问题** ：一些网络设备或软件可能会修改或移除这些头部信息，导致协商缓存失效。在这种情况下，你可能需要联系你的网络服务提供商或检查你的网络设备和软件配置。\n  3. **浏览器问题** ：不同的浏览器可能在处理协商缓存时有不同的行为。确保你的代码和配置在你的目标浏览器上可以正常工作。\n\n如果协商缓存无法正常工作，你可以采取以下步骤进行调试：\n\n  1. **查看网络请求** ：在浏览器的开发者工具中查看网络请求，检查请求和响应头部是否正确。查看服务器是否在响应中发送了Etag或Last-Modified，以及是否正确处理了If-None-Match或If-Modified-Since请求头。\n  2. **查看服务器日志** ：服务器的日志可能包含关于请求和响应的有用信息。如果服务器支持，你也可以在服务器上开启详细的日志记录。\n  3. **检查服务器配置** ：确保你的服务器配置正确，并且支持协商缓存。你可能需要查阅你的服务器文档，或者联系你的服务器供应商。\n\n如果问题仍然无法解决，你可能需要寻求专业的帮助，或者考虑使用一种不同的缓存策略。\n\n**3 启发式缓存**\n\n​ 只有在没有明确缓存策略时，会激活启发式缓存。所以要合理设置缓存，否则会因没有设置缓存时间等原因，导致内容缓存不刷新。\n\n**接口数据缓存在浏览器**\n\n缓存数据的场景分为两种：\n\n  * 与用户无关的数据\n  * 与用户相关的数据\n\n需要使用缓存的接口是无参数且为get类型的请求\n\n  1. 对于用户无关的数据，可以存储在localStorage中\n  2. 对于用户相关的数据，可以存储在sessionStorage中\n  3. 不修改原有的接口使用方法，创建一个新的接口调用函数，并使调用方式保持不变\n  4. 调用该方法时，先创建用于保存的key，再在对应的storage中查找是否有该key的缓存值，有则返回一个伪造的axios请求的Promise结果对象\n  5. 没有缓存时请求到数据后需要将响应数据保存在本地存储中，并且需注意的是要对请求结果做判断，只保存成功拿到数据的结果，否则一次失败后将无法再获取成功的结果\n  6. 创建用于缓存数据到localStorage的key时，使用了LOCALSTORAGE_CACHE_VERSION常量，该常用是使用webpack.DefinePlugin插件注入的值，这样是为了让每次重新发版后可以自动刷新本地缓存的数据\n  7. 创建sessionRequest方法来请求用户相关的数据，与localRequest的区别在于key的创建\n  8. 关于session缓存用户相关的数据，如果没有userId可供使用，可以使用一个全局的key来代替，确保该key会随着页面的刷新而变化即可，比如可以用进入页面后的某个时间点的时间戳\n  9. 清除旧的localStorage缓存，由于浏览器对localStorage的大小是有限制的，所以在发版后对于先前保存的数据应当予以清除\n\n参考：\n\n  * 接口数据缓存在浏览器 https://juejin.cn/post/7086056735588220958\n  * https://juejin.cn/post/7074924039348699167\n\n### 5.2.5 tcp|udp\n\nHTTP、TCP 和 UDP 是网络通信中的三个重要协议，它们各自在网络通信的不同层次和环节起到了关键的作用。\n\nHTTP（HyperText Transfer\nProtocol）是应用层协议，主要用于在Web上传输信息，如HTML文档。它可以运行在TCP之上，也可以运行在其他的网络协议上。HTTP定义了客户端（通常是Web浏览器）如何向服务器发送请求，以及服务器如何返回响应。\n\nTCP（Transmission Control\nProtocol）是传输层协议，负责在网络中的两个主机之间提供可靠的、有序的和基于字节流的数据传输。TCP使用确认和重传机制来保证数据的可靠传输，并使用拥塞控制机制来避免网络拥塞。HTTP就是运行在TCP之上的一个应用层协议。\n\nUDP（User Datagram\nProtocol）也是传输层协议，但它与TCP不同，它提供的是一种无连接的服务，数据的传输既不保证可靠，也不保证有序。由于UDP没有TCP那样的确认和重传机制，因此它的开销比TCP小，实时性更好，适合于对实时性要求高的应用，如VoIP（网络电话）和实时视频会议等。\n\n以下是它们的主要区别：\n\n  * 可靠性：TCP提供了可靠的数据传输，保证了数据的有序和无误。而UDP不保证数据的可靠传输，数据可能会丢失或者乱序。HTTP运行在TCP之上，因此也是可靠的。\n  * 连接性：TCP是连接导向的，通信双方在传输数据之前需要先建立连接。而UDP是无连接的，每个数据报都是独立传输的。HTTP作为应用层协议，其连接性取决于底层的传输协议，通常情况下，HTTP会在TCP的基础上建立连接。\n  * 实时性：由于UDP没有TCP那样复杂的确认和重传机制，因此UDP的实时性更好，适合于对实时性要求高的应用。而HTTP和TCP则更适合于对可靠性要求高的应用。\n  * 头部开销：TCP的头部开销比UDP大，因为TCP需要包含更多的信息，如序列号、确认号等，以支持它的可靠性和连接性。HTTP的头部开销则取决于HTTP的版本，HTTP/1.1的头部开销比较大，而HTTP/2和HTTP/3采用了头部压缩技术，大大减小了头部开销。\n  * 使用场景：HTTP主要用于Web应用，如网页浏览、表单提交等。TCP则可以用于各种需要可靠传输的网络应用，如文件传输、电子邮件、远程登录等。UDP则适合于需要快速传输和对实时性要求高的应用，如网络电话、实时视频会议和在线游戏等。\n\n**TCP和 UDP 区别**\n\nTCP 是**面向连接** 的、**可靠** 的流协议。流就是指不间断的数据结构，当应用程序采用 TCP\n发送消息时，虽然可以保证发送的顺序，但还是犹如没有任何间隔的数据流发送给接收端。TCP是面向**面向字节流**\n，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。\n\nTCP 为提供可靠性传输，实行“**顺序控制** ”或“**重发控制** ”机制。此外还具备“**流控制（流量控制）** ”、“**拥塞控制**\n”、提高网络利用率等众多功能。\n\nTCP有以下特点：\n\n  * TCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。\n  * 此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。\n  * 根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ **主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制** 等机制实现）。\n\n基于 TCP 的应用层协议：FTP（文件传输）、HTTP（万维网）、SMTP（电子邮件）\n\n当**网络拥塞** 时，减少数据的发送。发送方有拥塞窗口，发送数据前比对接收方发过来的接收窗口，取两者的最小值---慢启动、拥塞避免、拥塞发送、快速恢复\n\n**UDP**\n\n​ UDP是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。\n在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、 计算机的能力和传输带宽的限制；\n在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。\n\nUDP 是**面向报文**\n的，所谓面向报文，是指面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。\n\nUDP 是**不具有可靠性** 的数据报协议，细微的处理它会交给上层的应用去完成。在 UDP\n的情况下，虽然可以确保发送消息的大小，却不能保证消息一定会到达。因此，应用有时会根据自己的需要进行重发处理。\n\nUDP有以下特点：\n\n  * UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。\n  * 传输途中出现丢包，UDP 也不负责重发。\n  * 当包的到达顺序出现乱序时，UDP没有纠正的功能。\n  * 并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为。\n  * 如果需要以上的细节控制，不得不交由采用 UDP 的应用程序去处理。\n\n基于 UDP 的应用层协议：DNS（域名转换）、TFTP（文件传输）、NFS（远程文件服务器）\n\n**UDP**\n\n    \n    \n    //UDP收包率低/丢包率高的原因分析\n    1 缓存太小，不能及时接收数据。\n    连续多个UDP包超过了UDP接收缓冲区大小 ，比如：\n    如：UDP包过大 || UDP发包速率过快，突发大数据流量超过了缓冲区上限\n    2 recvfrom()接收到数据之后处理速度太慢\n    如果数据接收和处理是连续进行的，那么可能由于数据处理过慢，两次recvfrom调用的时间间隔里发过来的包丢失。\n    \n    //对应的解决方法\n    1 UDP包过大\n    解决方法：增加系统发送或接收缓冲区大小\n    2 发包速率过快\n    解决方法:增加应答机制，处理完一个包后，在继续发包\n    3 recvfrom()接收到数据之后处理速度太慢\n    服务器程序启动之出，开辟两个线程，一个线程专门用于接收数据包，并存放在应用层的缓存区；另外一个线程用于专门处理和响应数据包请求，避免因为处理数据造成数据丢包。其本质上还是增大了缓冲区大小，只是将系统缓冲区转移到了应用层自己的缓冲区。\n    4 最复杂的方式\n    在应用层实现丢包重发机制和超时机制，确保数据包不丢失。\n    \n    //如果UDP编程的时候的数据大于64kb 会怎么样？\n    1、在应用层进行数据包的拆分和组合。\n    2、 大于64KB 时不处理，会交给TCP/IP协议去处理，在网络层进行分包和组包，但是这种方式不用，容易丢包，一旦丢包便整体舍弃，及其不稳定。\n    \n    //基于UDP实现的协议\n    DNS（域名解析服务）\n    \n    \n\n## 5.3 TCP三次握手与四次挥手\n\n​\n\n​\n\n  * 第一次握手： 客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；\n  * 第二次握手： 服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；\n  * 第三次握手： 客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。\n  * 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。\n\n​ 与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。\n\n  * 第一次挥手： 主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。\n  * 第二次挥手： 被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。\n  * 第三次挥手： 被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。\n  * 第四次挥手： 主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。\n\n为什么需要四次挥手?其实是客户端和服务端的两次挥手，也就是客户端和服务端分别释放连接的过程.\n\n​ 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。服务器收到客户端的 FIN 报文时，先回一个 ACK\n应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。\n\n  * 面试题24：三次握手和四次挥手（计算机网络） https://blog.csdn.net/qq_51066068/article/details/124439302\n\n## 5.4 Cookie\n\n**cookie 和 token 都存放在 header 中，为什么不会劫持 token？**\n\n​\ncookie:登录后服务端生成的sessionid，并在http请求里返回到客户端，同时服务端保存sessionid，以后客户端的每次http请求都带上cookie（sessionid）,服务端会获取cookie（sessionid）然后验证用户的身份。所以拿到cookie就拿到了sessionid，就可验证通过。同时浏览器会自动携带cookie;\n\n​ token：同样是登录后服务端返回一个token，客户端保存起来，在以后http请求里手动的加入到请求头里，服务端根据token\n进行身份的校验。浏览器不会自动携带token。\n\n​ token不是为了防止xss攻击的，以CSRF攻击为例：\n\n​ cookie：用户点击了链接，cookie未失效，导致发起请求后后端以为是用户正常操作，于是进行扣款操作；​\ntoken：用户点击链接，由于浏览器不会自动带上token，所以即使发了请求，后端的token验证不会通过，所以不会进行扣款操作；\n\n**相同域名不同端口的两个应用，cookie名字、路径都相同的情况下，后面的cookie会覆盖前面的cookie吗？**\n\n如果浏览器访问的服务是ip或localhost的话,会覆盖；如果浏览器访问的是域名(在HOST中配置)的话,不会。\n\n**Cookie的其他的重要作用：**\n\n  1. 会话管理：Cookies常常用于记录用户的登录状态。当用户登录一个网站后，服务器会返回一个包含用户ID的cookie，然后浏览器在后续的请求中将这个cookie包含在内，以便服务器知道用户的登录状态。\n  2. 个性化设置：许多网站允许用户个性化他们的体验，例如更改布局、设置主题、设置语言等。这些设置可以被存储在cookie中，然后在用户下次访问时使用。\n  3. 跟踪用户行为：Cookies可用于跟踪用户在网站上的行为。例如，网站可以记录用户访问过哪些页面，点击过哪些链接，以便了解用户的兴趣和行为习惯，然后提供个性化的内容或者广告。\n  4. 状态保持：在没有Cookie的情况下，HTTP协议本身是无状态的，也就是说服务器无法区分两个连续的请求是否来自同一用户。通过使用Cookie，服务器可以在用户的每次请求中识别出用户，以保持用户的状态。\n\n**为什么有些cookie客户端访问不到但是服务端可以？**因为设置了HttpOnly后不能被doc.cookie访问。\n\n1.1）Cookie是什么\n\n  * cookie本身是由服务器产生的，生成之后发送给浏览器，并保存在浏览器。\n  * cookie就是浏览器存储本地目录的一小段文本。\n  * cookie是以key-value形式存储的。\n  * cookie大小有限制，为了保证cookie不占用太多磁盘空间，每个cookie大小一般不超过4KB。\n  * cookie默认在会话结束后直接销毁，此种cookie称之为会话cookie。\n  * cookie可以设置过期时间，此种cookie称之为持久cookie。\n  * **相同浏览器下，并且是同源窗口（协议、域名、端口一致），不同页面可以共享localStorage，Cookies值，通过跳转的页面可以共享sessionStorage值。**\n\nCookie 是服务器发送到用户浏览器并保存在浏览器上的一种数据。它用于在浏览器和服务器间保持状态，例如用户登录信息。以下是一个 Cookie\n的主要字段及其作用：\n\n  1. Name：Cookie 的名称。每个 Cookie 必须有一个唯一的名称。\n  2. \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594905735432081408?sourceSSR=users",
        "title": "React面经",
        "content": "## 目录\n\n1 React和vue的区别\n\n4.2 lmmutable\n\n4.3 无状态组件\n\n4.4 Hooks\n\n4.4.1 useState\n\n4.4.2 useEffect\n\n4.4.3 usecontext\n\n4.4.4 其他\n\n4.4.5 高阶组件\n\n4.4.6 原理\n\n4.5 状态管理\n\n4.5.1 Redux\n\n4.5.2 Mobx\n\n4.5.3 zuStand\n\n4.6 Router\n\n4.6.1 Router\n\n4.6.2 模式\n\n4.6.3 对比Vue\n\n4.7 虚拟DOM\n\n4.7.1 Render\n\n4.7.2 Fiber\n\n4.7.3 Diff\n\n4.8 错误边界\n\n4.9 事件代理\n\n4.10 Class组件\n\n4.12 组件通信\n\n4.13 vue 实现\n\n4.14 受控组件\n\n4.15 优先级\n\n## 4.1 React和vue的区别\n\n1）相同点\n\n  * 都有组件化思想\n  * 都支持服务器端渲染\n  * 都有Virtual DOM（虚拟dom）\n  * 数据驱动视图\n  * 都有支持native的方案：Vue的weex、React的React native\n  * 都有自己的构建工具：Vue的vue-cli、React的Create React App\n\n2）区别\n\n    \n    \n    写在前面：\n    \n    前端选型无非是考虑包体积和响应速度两种，目前的前端框架都需要编译这一步骤，分为构建时编译（AOT），宿主环境执行时编译（JIT）【区别：JIT首次加载慢于AOT，因为需要先编译，且体积可能大于AOT，因为运行时会增加编译器代码】，Angular提供了两种方式但是没人用。\n    \n    借助AOT对模板语法编译时的优化，比如vue3由于模板是固定的，因此在编译时可以分析模板语法中的静态部分和动态部分做出优化，Svelte可以利用AOT直接建立这部分的关系，在运行时当自变量发生变化直接驱动UI变化，但是JSX很灵活导致很难进行静态分析。【react采用prepack进行过改进，但2019年放弃了。也尝试过使用forget自动生成等效于memo等的代码的编译器，但使用模板减少了jsx的灵活性，也有人使用millionJS直接将元素绑定在dom上等】。\n    \n    既然jsx无法实现AOT，那么就采用了vDom进行优化，并把memo等缓存交给程序员进行work。\n    \n    前端框架分为元素级（svelte），组件级（vue），应用级（react），对于svelte来说，由于可以确定自变量是否变化，如果组件没有使用store则不会引入这一特性，会使得其对于小型应用比react的体积小，对于大型应用由于元素级直接绑定dom导致体积逐渐增大。vue采用模板语法，建立自变量与组件之间的关系，因此可以受益于AOT。react每次从应用的根节点开始遍历，甚至不知道哪个自变量变了就开始更新，导致不需要细粒度更新和AOT，当然也采用了调度，时间切片等进行优化。\n    \n    框架性能瓶颈：\n    \n    **react：**\n    \n    高频率的交互往往会导致明显的性能问题，在 antd 的 Form 组件也使用了将数据下放到每一个 Item 的方式来优化性能，store 中用 useRef 存储数据而不是 useState，antd 内部为每个 Form.Item 定义了 forceUpdate 来强制更新 Item UI。又例如拖拽/resize等事件。此时我们只需要通过操作原生 DOM 的方式来实现对应的逻辑即可。从而绕开高频率的 diff 逻辑。\n    \n    react 常常因为闭包问题，被各种攻击。认为这是 react 的缺陷。\n    \n    事实上，原生 DOM 本身在高频交互上也存在明显的性能瓶颈。因此许多前端项目不得不采用抛弃 DOM 渲染的方式来完成整个项目【DOM 换成了 canvas，或者 webGPU..】。但是这些项目我们仍然可以结合 react 来完成，例如著名的前端项目 **Figma**，或者国内有的团队使用 react + skia 的方式来完成一些对性能要求很高的项目\n    \n    **Solid：**\n    \n     为了极致的性能体验，完全弃用了虚拟 DOM，也就意味着，他放弃了跨平台的特性。只把主要精力集中在 web 项目上。也就是说，他的全局生态建设，永远也赶不上 react。\n    \n    **vue：**\n    \n    丢失响应式，如解构。\n    \n    \n\n  * 数据流向的不同。react从诞生开始就推崇单向数据流，而Vue是双向数据流\n\n    \n    \n    在双向绑定的建立过程中，有一个理想的结果：我们可以轻易的知道数据与 DOM 节点的对应关系，那么通过数据驱动 UI 的形式来开发代码将会变得非常容易。双向绑定采取的措施是递归遍历监听所有数据，依次建立与对应 UI 的绑定关系。这种解决方案所花费的成本主要体现在对数据的处理上，他面临两个问题：\n    一是数据的变化需要监听，但是某些数据类型的监听在实现上有难度，比如 forceUpdate，比如大量的 Watcher，还有性能损耗更严重的 Deep Watcher。另一个问题就是数据的层级与变化问题，数据层级越深，我们想要深度监听，就得使用递归的方式。当数据发生变化时，部分数据与 UI 的绑定关系需要重新建立「在 vue 中，就是重复依赖收集的过程」，如果数据量过大，或者数据变化频繁，就会有性能风险。\n    react 把所有的精力都放在了 UI 层。使用我们现在熟知的 diff 算法，当数据发生变化时，react 会创建一个新的虚拟DOM树，与之前的树做对比，找出需要改变的元素。\n    从总体思路上来说，vue 的主要压力在于处理数据，react 的主要压力在于处理 UI。react 不建立数据与 UI 的对应关系，那么也就意味着另外一个压力的产生，那就是当数据发生变化时，react 并不知道哪一个 UI 发生了变化，于此同时 react 为了保持自己对于 Js 的弱侵入性，也没有在 setState 上进行任何魔改，例如绑定当前上下文从而得知具体哪个组件的 state 发生了变化。[如果进行了这个魔改，diff 的压力会小一些]。因此，每一次的 state 变化，都是整棵 DOM 树的 diff。\n    Vue2中借鉴了diff算法，vue3中使用Proxy 能够监听数组的变化，能够监听删除对象字段的变化... 于是 Vue3 的底层实现，在数据侧的代码会简洁很多，并且与此同时，Vue 的后续版本，也可以彻底放弃虚拟 DOM 来进一步提高自己的运行性能。但是，依然有一个问题没有解决，那就是深度监听仍然需要递归。当数据量很大的时候，依赖追踪的压力也会逐渐变大，当你的项目变得越来越大，全局数据变得越来越复杂，层级越来越深，他的性能压力也会逐渐变大。因此这也是目前大多数大厂中后台采用React的原因，而面向用户则采用Vue的原因。\n    \n    \n\n  * 数据变化的实现原理不同。react使用的是不可变数据，而Vue使用的是可变的数据\n\n    \n    \n    Vue2 响应式的特点就是依赖收集，数据可变，自动派发更新，初始化时通过 Object.defineProperty 递归劫持 data 所有属性添加 getter/setter，触发 getter 的时候进行依赖收集，修改时触发 setter 自动派发更新找到引用组件重新渲染。\n    Vue3 响应式使用原生 Proxy 重构了响应式，一是 proxy 不存在 Vue2响应式存在的缺陷，二是性能更好，不仅支持更多的数据结构，而且不再一开始递归劫持对象属性，而是代理第一层对象本身。运行时才递归，用到才代理，用 effect 副作用来代替 Vue2 里的 watcher，用一个依赖管理中心 trackMap 来统一管理依赖代替 Vue2 中的 Dep，这样也不需要维护特别多的依赖关系，性能上取得很大进步。\n    React 则是基于状态，单向数据流，数据不可变（需要创建数据的副本来替换掉原数据，为了保证浅比较的正确性），需要手动 setState 来更新，始终保持state的原值不变,在生命周期 shouldComponentUpdate 中，React会对新旧state进行比较，如果直接修改state去用于其他变量的计算，而实际上state并不需要修改，则会导致怪异的更新以及没必要的更新。第二，可追踪修改痕迹，便于排错。而且当数据改变时会以组件根为目录，默认全部重新渲染整个组件树，只能额外用 pureComponent/shouldComponentUpdate/useMemo/useCallback 等方法来进行控制，更新粒度更大一些。\n    \n    \n\n  * 组件化通信的不同。react中我们通过使用回调函数来进行通信的，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数\n  * diff算法不同。react主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。Vue 使用双向指针，边对比，边更新DOM\n\n    \n    \n    Vue2 是同层比较新老 vnode，新的不存在老的存在就删除，新的存在老的不存在就创建，子节点采用双指针头对尾两端对比的方式，全量diff，然后移动节点时通过 splice 进行数组操作\n    Vue3 是采用 Map 数据结构以及动静结合的方式，在编译阶段提前标记静态节点，Diff 过程中直接跳过有静态标记的节点，并且子节点对比会使用一个 source 数组来记录节点位置及最长递增子序列算法优化了对比流程，快速 Diff，需要处理的边际条件会更少\n    React 是递归同层比较，标识差异点保存到 Diff 队列保存，得到 patch 树，再统一操作批量更新 DOM。Diff 总共就是移动、删除、增加三个操作，如果结构发生改变就直接卸载重新创建，如果没有则将节点在新集合中的位置和老集合中的 lastIndex 进行比较是否需要移动，如果遍历过程中发现新集合没有，但老集合有就删除\n    \n    \n\n  * vue3 做了自己的一套编译优化处理方式。\n\n3）其他\n\n  * React的核心理念是用一个hooks解决所有问题，vue的理念是解决不了就新增api\n\nReact一直在淡化hooks（useEffect）和生命周期的联系，甚至淡化其与组件的关系。\n如在严格模式下，dev环境会触发多次useEffect的回调，目的是想让开发者将useEffect看做针对某个数据源的同步过程。\n\n【如果react支持keepalive，从生命周期的角度理解，effect回调应该执行，从状态角度理解不应该执行】\n\nreact的更新策略是掌握在开发者自己手中的，可以主动开启并发更新，对更新做结果优化缓存优化及渲染优化；vue是自动收集依赖的精准更新，没有并发更新特性\n\n## 4.2 Immutable\n\n**1 Immutable**\n\n​ Immutable.js 源自 Facebook ，一个非常棒的不可变数据结构的库。使用另一套数据结构的\nAPI，将所有的原生数据类型转化成Immutable.js 的内部对象,并且任何操作最终都会返回一个新的`Immutable`值\n\n`Immutable` 实现的原理是 `Persistent Data Structure`（持久化数据结构）:\n\n  * 用一种数据结构来保存数据\n  * 当数据被修改时，会返回一个对象，但是新的对象会尽可能的利用之前的数据结构而不会对内存造成浪费\n\n其出现场景在于弥补 Javascript 没有不可变数据结构的问题，通过 structural sharing来解决的性能问题，内部提供了一套完整的\nPersistent Data\nStructure，还有很多易用的数据类型，如`Collection`、`List`、`Map`、`Set`、`Record`、`Seq`，其中：\n\n  * List: 有序索引集，类似 JavaScript 中的 Array\n  * Map: 无序索引集，类似 JavaScript 中的 Object\n  * Set: 没有重复值的集合\n\n主要方法：\n\n  * fromJS()：将js数据转化成Immutable数据；\n  * toJS()：将一个Immutable数据转换为JS类型的数据；\n  * is()：对两个对象进行比较\n  * get(key)：对数据或对象取值\n\n使用 `Immutable`可以给 `React` 应用带来性能的优化，主要体现在减少渲染的次数\n\n在做`react`性能优化的时候，为了避免重复渲染，我们会在`shouldComponentUpdate()`中做对比，当返回`true`执行`render`方法\n\n`Immutable`通过`is`方法则可以完成对比，而无需像一样通过深度比较的方式比较\n\n**2 Immer**\n\n​ 深层次的对象在没有修改的情况仍然能保证严格相等。这也是它另外一个特点：深层嵌套对象的结构共享相比与 Immer.js，Immutable.js 的不足：\n\n  * 自己维护一套数据结构、JavaScript 的数据类型和 Immutable.js 需要相互转换，有入侵性\n  * 他的操作结果需要通过 toJS 方法才能得到原生对象，这样导致在开发中需要时刻关注操作的是原生对象还是 Immutable.js 返回的结果\n  * 库的体积大约在 63KB、而 Immer.js 仅有12KB\n  * API 丰富、学习成本较高\n\nimmer 缺点：\n\n  * 兼容性：对于不支持`proxy`的浏览器使用`defineProperty`实现，在性能上为`proxy`的两倍\n\n## 4.3 无状态组件\n\n有状态组件： 是一个class类，继承componet （用于需要一些状态去存储和修改数据）\n\n无状态组件： 是一个es6写的箭头函数函数，并不继承 componet（用于一些简单的逻辑，比如，父组件向子组件传属性值）\n\n​ （1） 最大的区别是无状态组件，无法使用state，因为state是继承 componet\n\n​ （2）无状态组件，没有生命周期函数，生命周期函数是基于state的\n\n​\n通常，函数（`function`）与类（`class`）最大的区别是：是否能够维护自己的数据（即状态）。函数基本上仅关注动作（`action`），而不关心数据的维护，不用维持一个状态，不用把自己的数据保存在内存中。函数使用的数据是从外部获取（或者不获取数据），函数运行时，会完成一系列的动作，最后将结果返回（也可能不返回，仅仅是完成指定的动作）。相对而言，类有能力维护状态（保存数据），也可以定义自己的一系列动作。\n\n​ 一般来说，函数的速度较快，适合用于做表现层，而类能够处理复杂逻辑和状态，适合做逻辑层和数据层。所以，对于 `React`\n来说，一般选择函数来无状态组件，得到所谓的无状态函数（`stateless\nfunction`），好处是渲染的速度快，所以多使用无状态组件，尽量不要让数据散落在各个组件中。数据集中管理可以更好的保持数据的一致性和可维护性。\n\n​\n有状态组件就是使用类来生成。类可以有自己的状态，维护自己的数据，也是完全符合有状态组件的要求。但是类相对来说速度比函数慢，影响渲染的性能，同时数据过于分散会给后期的维护带来比较大的困难（这也是为什么状态过多时要使用\n`Redux`\n的原因），因此要尽量控制有状态组件的数量。当然，类也可以生成无状态组件，但是既然不需要维护状态的工作，用函数能完成得更好，其实也就没有必要使用类来做无状态组件。\n\n**在无状态组件每一次函数上下文执行的时候，react用什么方式记录了hooks的状态？**\n\n​ React 使用了一个叫做 \"Fiber\" 的数据结构来跟踪组件的状态和其它信息。每个函数组件都有一个与之相关的 Fiber，它的 hooks\n是按照声明顺序存储在一个数组中。在组件的不同渲染阶段，React 会利用这个 Fiber 和 hooks 数组来追踪和更新每个 hook 的状态。\n\n## 4.4 Hooks\n\nHook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React\n特性(钩子函数)。为了解决难以重用和共享组件中的与状态相关的逻辑、this的学习成本、逻辑复杂的组件难以开发与维护（当我们的组件需要处理多个互不相关的\nlocal state 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面）。\n\n  * 只能在函数内部的最外层调用 `Hook` ，不要在循环、条件判断或者子函数中调用；\n  * 只能在 `React` 的函数组件中调用 `Hook` ，不要在其他 `JavaScript` 函数中调用。\n\n参考：\n\nhttps://juejin.cn/post/6857139132259532814\n\n### 4.4.1 useState\n\n**function函数组件中的useState，和 class类组件 setState有什么区别？**\n\n​ `useState` 与 `setState` 的最大区别在于函数组件中的 `useState` 不会合并更新的状态，而类组件的 `setState`\n会。此外，`useState` 返回的状态更新函数保证在组件的生命周期内保持不变，而 `setState` 的回调函数可能在组件重新渲染时变化。\n\n**为什么两次传入useState的值相同，函数组件不更新?**\n\n​ 当传递给 `useState` 的值与当前状态相同时，React\n将跳过渲染和子组件的重新渲染。这是一个优化，因为重新渲染会带来额外的性能开销。如果你需要强制渲染，可以使用\n`forceUpdate`，或者更改状态值的引用类型（例如，对于对象和数组）。\n\n【setState(obj)如果obj地址不变，那么React就认为数据没有变化。】\n\n**setState 拿不到最新的 state**\n\n​\n函数组件每次`state`变化重渲染，都是新的函数，拥有自身唯一不变的`state`值，即`memoizedState`上保存的对应的`state`值。（**capture\nvalue** 特性）。\n\n​\n这也是为什么明明已经`setState`却拿不到最新的`state`的原因，渲染发生在state更新之前，所以state是当次函数执行时的值，可以通过`setState`的回调或`ref`的特性来解决这个问题。\n\n**为什么组件都重渲染了，数据不会重新初始化？**\n\n​\n可以先从业务上理解，比如两个select组件，初始值都是未选中，select_A选中选项后，select_B再选中，select_A不会重置为未选，只有刷新页面组件重载时，数据状态才会初始化为未选。\n\n​\n知道`state`状态是怎样保存的之后，其实就很好理解了。**重渲染≠重载，组件并没有被卸载，****`state`****值仍然存在在fiber节点中。并且****`useState`****只会在组件首次加载时初始化state的值。**\n\n​\n常有小伙伴遇到组件没正常更新的场景就纳闷，父组件重渲染子组件也会重渲染，但为什么子组件的状态值不更新？就是因为rerender只是rerender，不是重载，你不人为更新它的`state`，它怎么会重置/更新呢？\n\nps：面对有些非受控组件不更新状态的情况，我们可以通过改变组件的key值，使之重载来解决。\n\n**React 中 setState 什么时候是同步的，什么时候是异步的**\n\n1、由 React 控制的事件处理程序，以及生命周期函数调用 setState 不会同步更新 state\n。只在合成事件如`onClick`等和钩子函数包括`componentDidMount`、`useEffect`等中是“异步”的。\n\n​\n这里的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”。\n\n​ 假如在一个合成事件中，循环调用了`setState`方法`n`次，如果 React\n没有优化，当前组件就要被渲染`n`次，这对性能来说是很大的浪费。所以，React\n为了性能原因，对调用多次`setState`方法合并为一个来执行。当执行`setState`的时候，`state`中的数据并不会马上更新。\n\n2、React 控制之外的事件中调用 setState 是同步更新的。比如原生 js 绑定的事件，`setTimeoutsetInterval` 或者直接在\n`DOM` 上绑定原生事件和`Promise.then`等异步事件中会同步更新。\n\n​\n每次渲染，函数都会重新执行。我们知道，每当函数执行完毕，所有的内存都会被释放掉。因此想让函数式组件拥有内部状态，并不是一件理所当然的事情。useState就是帮助我们做这个事情,useState利用闭包，在函数内部创建一个当前函数组件的状态。并提供一个修改该状态的方法。\n\n`useState()`是使用 useReducer 构建的。纯函数不能有状态，所以把状态放在钩子里面。\n\n  * `initialState` 参数只会在组件的初始化渲染中起作用，后续渲染时会被忽略；\n  * 如果初始 `state` 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 `state` ，此函数只在初始渲染时被调用。\n\n​ `useState()` 是异步函数 ，我们 setState() 后不会立刻对值进行改变，而是会将其暂时放入 pending 队列中。react\n会合并多个 state ，然后值 render 一次，因此一些情况下useState获取不到最新的值。\n\n解决办法：\n\n  * 通过对setState传递一个回调函数，回调函数会保证其拿到最新的值。\n  * 通过Ref，但是ref.current 值的改变，是无法通过 useEffect()，useCallback()来监控到的，因为useRef创建的ref对象在整个组件生命周期内保持不变，即使ref的.current属性改变时。因此，useEffect或useCallback无法直接监听ref的改变，因为他们依赖值的更改来重新运行。在useEffect或useCallback的依赖项数组中添加ref.current没有意义，因为ref对象本身没有改变。但是，你可以结合状态钩子（useState）来监听useRef的.current属性的变化\n\n**执行useState 后发生了什么**\n\n  1. 首先生成调用函数生成一个更新对象，这个更新对象带有任务的优先级、fiber实例等。\n  2. 再把这个对象放入更新队列中，等待协调。\n  3. react会以优先级高低先后调用方法，创建Fiber树以及生成副作用列表。\n  4. 在这个阶段会先判断主线程是否有时间，有的话先生成`workInProgress tree`并遍历之。\n  5. 之后进入调教阶段，将`workInProgress tree`与`current Fiber`对比，并操作更新真实dom。\n\n**mountState**\n\n​ 首先会得到初始化的`state`，将它赋值给`hook`对象的\n`memoizedState`和`baseState`属性，然后创建一个`queue`对象，里面保存了负责更新的信息。\n\n    \n    \n    //useState和useReducer触发函数更新的方法都是dispatchAction,useState\n    const [ number , setNumber ] = useState(0)\n    //dispatchAction 就是 setNumber , dispatchAction 第一个参数和第二个参数，已经被bind给改成currentlyRenderingFiber和 queue,我们传入的参数是第三个参数action\n    \n    \n\n​ 无论是类组件调用`setState`,还是函数组件的`dispatchAction` ，都会产生一个\n`update`对象，里面记录了此次更新的信息，然后将此`update`放入待更新的`pending`队列中，`dispatchAction`第二步就是判断当前函数组件的`fiber`对象是否处于渲染阶段，如果处于渲染阶段，那么不需要我们在更新当前函数组件，只需要更新一下当前`update`的`expirationTime`即可。\n\n​\n如果当前`fiber`没有处于更新阶段。那么通过调用`lastRenderedReducer`获取最新的`state`,和上一次的`currentState`，进行浅比较，如果相等，那么就退出，这就证实了为什么`useState`，两次值相等的时候，组件不渲染的原因了，这个机制和`Component`模式下的`setState`有一定的区别。\n\n​\n如果两次`state`不相等，那么调用`scheduleUpdateOnFiber`调度渲染当前`fiber`，`scheduleUpdateOnFiber`是`react`渲染更新的主要函数。\n\n**updateState**\n\n​ 当一个hook里使用三次`setState`产生的`update`会暂且放入`pending queue`，在下一次函数组件执行时候，三次\n`update`被合并到 `baseQueue`。\n\n​\n接下来会把当前useState或是useReduer对应的hooks上的baseState和baseQueue更新到最新的状态。会循环baseQueue的update，复制一份update,更新expirationTime，对于有足够优先级的update（上述三个setNumber产生的update都具有足够的优先级），我们要获取最新的state状态。，会一次执行useState上的每一个action。得到最新的state。\n\n### 4.4.2 useEffect\n\n**如何初次渲染不更新useEffect？**\n\n    \n    \n    你可以引入一个额外的 state 变量作为标记来跳过第一次的运行。\n    const [isFirstRender, setIsFirstRender] = useState(true);\n    useEffect(() => {\n        if (isFirstRender) {\n          setIsFirstRender(false);\n        } else {\n          // 在组件更新后执行你的副作用\n          console.log('This will not run on the first render');\n        }\n      }, [count]);  // 这里依赖 count 变量\n    也可以自定义一个hooks\n    const useUpdateEffect = (fn: Function, inputs: any[]) => {\n        const didMountRef = useRef(false);\n        useEffect(() => {\n          if (didMountRef.current) fn();\n          else didMountRef.current = true;\n        }, inputs);\n      };\n    \n    \n\n**dep为数组时会发生什么**\n\n由于react出于性能考虑用了Object.is来做浅比较，因此检测不到深层结构。\n\nuseEffect监听数据变化时，只有在数组元素类型为基本数据类型时可以起到作用。\n\nuseEffect 会检测两次监测的对象 内存地址是否相同,相同就跳过,不同才会执行useEffect\n\n    \n    \n    //解决方法\n    const MyComponent = ({ arrayProp }) => {\n      const serialized = JSON.stringify(arrayProp); //通过js的序列化实现\n      useEffect(() => {\n      }, [serialized]);\n    }\n    这种方法的问题是，对于大数组，序列化可能会很消耗性能。另外，这种方法也不能处理数组中包含循环引用的情况。\n    对于更复杂的情况，你可能需要使用一些库，如lodash的_.isEqual函数，结合useRef和useEffect来手动实现深度比较。\n    \n    \n\n​\nuseEffect用于处理大多数副作用，useEffect第一个参数接受一个回调函数，默认情况下，useEffect会在第一次渲染和更新之后都会执行，相当于在componentDidMount和componentDidUpdate两个生命周期函数中执行回调。\n\n​\n其中的回调函数会在render执行之后在调用(渲染时异步调用，渲染完成后再执行)，确保不会阻止浏览器的渲染，这跟componentDidMount和componentDidUpdate是不一样的，他们会在渲染时同步执行。useEffect的特点：\n\n  * 有两个参数 callback 和 dependencies 数组\n  * 如果 dependencies 不存在，那么 callback 每次 render 都会执行\n  * 如果 dependencies 存在，只有当它发生了变化， callback 才会执行\n  * useEffect的第二个参数为一个空数组，初始化调用一次之后不再执行，相当于componentDidMount。\n\n    \n    \n    //如果某些特定值在两次重渲染之间没有发生变化，你可以跳过对 effect 的调用，这时候只需要传入第二个参数\n    //回调函数中可以返回一个清除函数，这是effect可选的清除机制，相当于类组件中componentwillUnmount生命周期函数。清理规则：首次渲染不会进行清理，会在下一次执行前，清除上一次的副作用；卸载阶段也会执行清除操作。\n    \n    \n\n**mountEffect**\n\n​ mountEffect里的pushEffect 创建effect对象，挂载updateQueue。首先创建一个 `effect`\n，判断组件如果第一次渲染，那么创建 `componentUpdateQueue`\n，就是`workInProgress`的`updateQueue`。然后将`effect`放入`updateQueue`中。\n\n​ `effect list` 可以理解为是一个存储 `effectTag` 副作用列表容器。它是由 `fiber` 节点和指针 `nextEffect`\n构成的单链表结构，这其中还包括第一个节点 `firstEffect` ，和最后一个节点 `lastEffect`。 `React` 采用深度优先搜索算法，在\n`render` 阶段遍历 `fiber` 树时，把每一个有副作用的 `fiber` 筛选出来，最后构建生成一个只带副作用的 `effect list`\n链表。 在 `commit` 阶段，`React` 拿到 `effect list` 数据后，通过遍历 `effect list`，并根据每一个\n`effect` 节点的 `effectTag` 类型，执行每个`effect`，从而对相应的 `DOM` 树执行更改。\n\n**updateEffect**\n\n`useEffect` 做的事很简单，判断两次`deps` 相等，如果相等说明此次更新不需要执行，则直接调用 `pushEffect`,这里注意 `effect`的标签，`hookEffectTag`,如果不相等，那么更新 `effect` ,并且赋值给`hook.memoizedState`，这里标签是 `HookHasEffect | hookEffectTag`,然后在`commit`阶段，`react`会通过标签来判断，是否执行当前的 `effect` 函数。\n\n**useLayoutEffect**\n\nu seEffect 是官方推荐拿来代替 componentDidMount / componentDidUpdate /\ncomponentWillUnmount 这 3 个生命周期函数的，但其实他们并不是完全等价，useEffect\n是在浏览器渲染结束之后才执行的，而这三个生命周期函数是在浏览器渲染之前同步执行的，React 还有一个官方的 hook 是完全等价于这三个生命周期函数的，叫\nuseLayoutEffect。\n\n​\n在大多数情况下，我们都可以使用useEffect处理副作用，但是，如果副作用是跟DOM相关的，就需要使用useLayoutEffect。useLayoutEffect中的副作用会在DOM更新之后同步执行。\n\n​ 由于 JS 线程和浏览器渲染线程是互斥的，即使内存中的真实 DOM\n已经变化，浏览器也没有立刻渲染到屏幕上，此时会进行收尾工作，同步执行对应的生命周期方法，我们说的componentDidMount，componentDidUpdate\n以及 useLayoutEffect(create, deps) 的 create 函数(已经可以拿到最新的 DOM\n节点)都是在这个阶段被同步执行。commit阶段的操作执行完，浏览器把发生变化的 DOM 渲染到屏幕上，到此为止 react\n仅用一次回流、重绘的代价，就把所有需要更新的 DOM 节点全部更新完成。浏览器渲染完成后，浏览器通知 react 自己处于空闲阶段，react\n开始执行自己调度队列中的任务，此时才开始执行 useEffect(create, deps) 的产生的函数。\n\n**在副作用函数中处理异步请求：**\n\n在副作用中编写 `fetch` 调用是一个\n[请求数据的流行方式](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.robinwieruch.de%2Freact-\nhooks-fetch-data%2F)，尤其是在完全客户端的应用中。 然而，这是一种非常手动的方法，它有很大的缺点：\n\n  * **副作用不在服务器上运行。** 这意味着初始服务器渲染的 HTML 将仅包含没有数据的加载状态。 客户端计算机必须下载所有 JavaScript 并渲染你的应用，然后才发现它现在需要加载数据。 这不是很有效。\n  * **直接在副作用中请求可以轻松创建 “网络瀑布”。** 你渲染父组件，它获取一些数据，渲染子组件，然后它们开始获取数据。 如果网络不是很快，这比并行获取所有数据要慢得多。\n  * **直接在副作用中请求通常意味着你没有预加载或缓存数据。** 例如，如果组件卸载然后再次挂载，则它必须再次获取数据。\n  * **这不是很符合人体工程学。** 在以一种不会出现像 [竞态条件](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fmaxrozen.com%2Frace-conditions-fetching-data-react-with-useeffect) 这样的错误的方式编写 `fetch` 调用时，涉及到相当多的样板代码。\n\n这个缺点列表并不是 React 特有的。 它适用于使用任何库在挂载上获取数据。 与路由一样，要做好数据获取并非易事，因此我们推荐以下方法：\n\n  * **如果你使用**[框架](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Freact.nodejs.cn%2Flearn%2Fstart-a-new-react-project%23production-grade-react-frameworks)**，请使用其内置的数据请求机制。** 现代 React 框架集成了高效的数据请求机制，不会出现上述问题。\n  * **否则，请考虑使用或构建客户端缓存。** 流行的开源解决方案包括 [React 查询](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Ftanstack.com%2Fquery%2Flatest)、[useSWR](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fswr.vercel.app%2F) 和 [React 路由 6.4+。](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fbeta.reactrouter.com%2Fen%2Fmain%2Fstart%2Foverview) 你也可以构建自己的解决方案，在这种情况下，你可以在后台使用副作用，但添加用于删除重复请求、缓存响应和避免网络瀑布的逻辑（通过预加载数据或提升 路由的数据要求）。\n\n**全局或可变值可以是依赖吗？**\n\n**像**[`location.pathname`](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-\nUS%2Fdocs%2FWeb%2FAPI%2FLocation%2Fpathname)**这样的可变值不能是依赖。** 它是可变的，因此它可以完全在\nReact 渲染数据流之外随时更改。 更改它不会触发组件的重新渲染。 因此，即使你在依赖中指定它，React 也不会知道在副作用发生变化时重新同步它。\n这也违反了 React 的规则，因为在渲染期间读取可变数据（计算依赖时）会破坏\n[渲染的纯粹。](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Freact.nodejs.cn%2Flearn%2Fkeeping-\ncomponents-pure) 而是，你应该使用\n[`useSyncExternalStore`](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Freact.nodejs.cn%2Flearn%2Fyou-\nmight-not-need-an-effect%23subscribing-to-an-external-store) 读取和订阅外部可变值\n\n**像**[`ref.current`](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Freact.nodejs.cn%2Freference%2Freact%2FuseRef%23reference)**这样的可变值或你从中读取的内容也不能是依赖。**`useRef`\n本身返回的引用对象可以是依赖，但它的 `current` 属性是有意可变的。 它让你\n[在不触发重新渲染的情况下跟踪某些内容。](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Freact.nodejs.cn%2Flearn%2Freferencing-\nvalues-with-refs) 但是因为改变它不会触发重新渲染，它不是一个 React 值，并且 React 不会知道在它改变时重新运行你的副作用。\n\n### 4.4.3 useContext\n\n​ 接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context\n值由上层组件中距离当前组件最近的 <MyContext.Provider> 的 value prop 决定。\n\n​ 当组件上层最近的 <MyContext.Provider> 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider\n的 context value 值。即使祖先使用 React.memo 或 shouldComponentUpdate，也会在组件本身使用\nuseContext 时重新渲染。\n\n​ useContext不能实现精准更新，想要减少二次渲染，可以使用Memo，利用第二个参数做比较（位运算），使用第三方库。。\n\n    \n    \n    //类组件\n    const {Provider, Consumer} = React.createContext(defaultValue);\n    //创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。\n    //只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。这有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 undefined 传递给 Provider 的 value 时，消费组件的 defaultValue 不会生效。\n    <Provider value={/*共享的数据*/}>\n        /*里面可以渲染对应的内容*/\n    </Provider>\n    <Consumer>\n      {value => /*根据上下文  进行渲染相应内容*/}\n    </Consumer>\n    \n    \n    \n    \n    //hooks\n    // createContext主要功能是创建一个context，提供Provider和Consumer。Provider主要将context内容暴露出来，Consumer可以拿到对应context的Provider暴露的内容使用。\n    const Context = createContext()\n    <UserContext.Provider value={'chuanshi'}>\n      <ComponentC />\n    </UserContext.Provider>\n    //每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。\n    //Provider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 //Provider 也可以嵌套使用，里层的会覆盖外层的数据。\n    //当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。\n    <UserContext.Consumer>\n      {(user) => (\n        <div>\n          User context value {user}\n        </div>)}\n    </UserContext.Consumer>\n    //这里，React 组件也可以订阅到 context 变更。这能让你在函数式组件中完成订阅 context。\n    //这需要函数作为子元素（function as a child）这种做法。这个函数接收当前的 context 值，返回一个 React 节点。传递给函数的 value 值等同于往上组件树离这个 context 最近的 Provider 提供的 value 值。如果没有对应的 Provider，value 参数等同于传递给 createContext() 的 defaultValue。\n    当需要多处进行消费时，通过 useContext(Context(React.createContext 的返回值))\n    //当前的 context 值由上层组件中距离当前组件最近的 <MyContext.Provider> 的 value prop 决定。\n    \n    \n\n**原理：**\n\n​ `useContext`的原理类似于观察者模式。`Provider`是被观察者，\n`Consumer`和`useContext`是观察者。当`Provider`上的值发生变化， 观察者是可以观察到的，从而同步信息给到组件。\n\n​\n在技术层面上，Provider组件在其内部创建了一个特殊的React对象，这个对象存储了Context的当前值。当组件被渲染时，React就会使用这个对象来决定useContext应该返回什么值。当你改变Provider的值时，React就会重新渲染所有使用了这个Context的组件，以保证它们总是获取到最新的值。\n\n​ 具体来说，在更新状态时, 由`ContextProvider`节点负责查找所有`ContextConsumer`节点,\n并设置消费节点的父路径上所有节点的`fiber.childLanes`, 保证消费节点可以得到更新。深度优先遍历所有的子代 fiber ，然后找到里面具有\ndependencies 的属性，这个属性中挂载了一个元素依赖的所有 context，对比 dependencies 中的 context 和当前\nProvider 的 context 是否是同一个；如果是同一个，它会创建一个更新，设定高 fiber 的更新优先级，类似于调用\nthis.forceUpdate 带来的更新\n\n    \n    \n    \tConsumer 指向 context 本身，其生成 fiber 时会识别 REACT_CONTEXT_TYPE 类型然后添加 ContextConsumer tag ，当我们识别到这个 tag ，就会调用 updateContextConsumer 进行处理。updateContextConsumer 中的逻辑是先通过 prepareToReadContext 和 readContext 获取最新的 context 的值，再把最新的值传入子组件进行更新操作：\n    \n    \n\n**一些点：**\n\n  * 当创建了一个Context对象，在React渲染出了订阅这个对象的组件（这里是组件B），它能获取到组件树中距离最近Provider中value的值。当没有匹配到Provider的时候创建时传递的初始值会生效。如果value的值是undefined初始值不生效。\n  * Provider 及其内部 consumer 组件都不受制于 `shouldComponentUpdate` 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。\n  * 通过新旧值检测来确定变化，使用了与 Object.is 相同的算法。\n\n**配合 useReducer 做状态管理：**\n\n​ 将 dispatch 函数作为 context 的 value，共享给页面的子组件，在 useReducer 结合 useCountext，通过\ncontext 把 dispatch 函数提供给组件树中的所有组件使用，而不是通过 props 添加回调函数到方式一层层传递。\n\n    \n    \n    import React, { useReducer, useContext, createContext } from 'react';\n    \n    // 初始状态\n    const initialState = {\n      isLoggedIn: false,\n    };\n    \n    // action类型\n    const LOGIN = 'LOGIN';\n    const LOGOUT = 'LOGOUT';\n    \n    // reducer函数\n    function loginReducer(state, action) {\n      switch (action.type) {\n        case LOGIN:\n          return { ...state, isLoggedIn: true };\n        case LOGOUT:\n          return { ...state, isLoggedIn: false };\n        default:\n          return state;\n      }\n    }\n    \n    // 创建一个context\n    const LoginContext = createContext();\n    \n    // 创建一个Provider组件\n    function LoginProvider({ children }) {\n      const [state, dispatch] = useReducer(loginReducer, initialState);\n      \n      return (\n        <LoginContext.Provider value={{ state, dispatch }}>\n          {children}\n        </LoginContext.Provider>\n      );\n    }\n    \n    // 在其他组件中使用这个Context\n    function LoginComponent() {\n      const { state, dispatch } = useContext(LoginContext);\n      \n      return (\n        <div>\n          <p>User is {state.isLoggedIn ? 'logged in' : 'logged out'}.</p >\n          <button onClick={() => dispatch({ type: LOGIN })}>Log In</button>\n          <button onClick={() => dispatch({ type: LOGOUT })}>Log Out</button>\n        </div>\n      );\n    }\n    \n    // 使用LoginProvider在应用中共享状态\n    function App() {\n      return (\n        <LoginProvider>\n          <LoginComponent />\n        </LoginProvider>\n      );\n    }\n    \n    \n\n### 4.4.4 其他\n\n**1 useRef**\n\n`Refs` 是一个获取 `DOM` 节点或 `React` 元素实例的工具。在 `React` 中 `Refs` 提供了一种方式，允许用户访问 `DOM`\n节点或 `render` 方法中创建的 `React` 元素。\n\n`mountRef`初始化很简单, 创建一个ref对象， 对象的`current`\n属性来保存初始化的值，最后用`memoizedState`保存`ref`，完成整个操作。\n\n函数组件更新useRef做的事情更简单，就是返回了缓存下来的值，也就是无论函数组件怎么执行，执行多少次，hook.memoizedState内存中都指向了一个对象\n\n    \n    \n    类组件\n    //当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性；\n    createRef 每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用(persist)。\n    //当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性；\n    //不能在函数组件上使用 ref 属性，因为他们没有实例。但可以改成 class 组件，React.forwardRef 进行包装\n    \n    \n    \n    \n    函数组件\n    //useRef 返回一个可变的 ref 对象，其 current 属性被初始化为传入的参数（ initialValue ）。返回的 ref 对象在组件的整个生命周期内保持不变。\n     const inputRef = useRef(null);\n     return ( <input ref={inputRef} type=\"text\" onChange={handleChange} />)\n    注意：refObj.current\n    //1 被引用对象的值在重新渲染之间保持不变。\n    //2 更新被引用对象的值不会触发重新渲染。\n    \n    \n\n**useRef和ref的区别：**\n\n`useRef` 用于创建引用对象，本质上就是一个js对象(js对象每次渲染会重新执行)，而 `ref` 用于访问 DOM 节点或将 `render`\n方法中的 react 组件分配给引用对象。另外，可以使用 `useRef` hook 或 `createRef` 函数创建\n`ref`，这是其他方法无法实现的。\n\n`useRef` 可以用来引用任何类型的对象，React `ref` 只是一个用于引用 DOM 元素的 DOM 属性。\n\n**useRef获取前一次的值**\n\n  1. useRef保持引用不变；\n  2. 函数式组件的声明周期决定，jsx的渲染比useEffect早；\n  3. 手动修改ref.current并不会触发组件的重新渲染；\n\n拿到前一个值这件事，想到了什么？\n\n​ 想到了class\nreact中的生命周期`shouldComponentUpdate(nextProps,nextState)`中比较前后两次属性是否相同来做优化，减少渲染次数，和`componentWillReceiveProps(nextProps)`比较子组件前后两次属性值的变化来执行某些方法。\n\n**React.forwardRef作用 ** 如果需要访问自己组件的Ref，需要使用forwardRef\n\n  * 转发refs到DOM组件\n  * 在高阶组件中转发refs\n\n解决函数组件不能直接传递ref的问题。这是因为使用`ref`会脱离**React的控制** 。比如：**DOM聚焦**\n需要调用`input.focus()`，直接执行`DOM API`是不受`React`控制的。但为了保证应用的健壮，`React`也要尽可能防止他们失控。\n\n首先来看**不失控** 的情况：\n\n  * 执行`ref.current`的`focus`、`blur`等方法\n  * 执行`ref.current.scrollIntoView`使`element`滚动到视野内\n\n那**失控** 的情况：\n\n  * 执行`ref.current.remove`移除`DOM`\n  * 执行`ref.current.appendChild`插入子节点\n\n限制失控：基于dom封装的组件(低阶组件)是可以直接把ref指向dom，「高阶组件」无法直接将ref指向DOM，这一限制就将「ref失控」的范围控制在单个组件内，不会出现跨越组件的「ref失控」\n\n当 `ref` 对象内容发生变化时，`useRef` 并不会通知你。变更 `.current` 属性不会引发组件重新渲染。如果想要在 `React`\n绑定或解绑 `DOM` 节点的 `ref` 时运行某些代码，则需要使用回调 `ref` 来实现.\n\n    \n    \n    const inputEl = useRef(null);\n      const onButtonClick = () => {\n        // `current` 指向已挂载到 DOM 上的文本输入元素\n        inputEl.current.focus();\n      };\n    \n    \n    \n\n**useImperativeHandle** 的第一个参数是定义 current 对象的 ref，第二个参数是一个函数，返回值是一个对象，即这个 ref\n的 current 对象\n\n​ 在介绍 useImperativeHandle 之前一定要清楚 React 关于 ref 转发（也叫透传）的知识点，是使用\nReact.forwardRef 方法实现的，该方法返回一个组件，参数为函数（props callback，并不是函数组件），函数的第一个参数为父组件传递的\nprops，第二给参数为父组件传递的 ref，其目的就是希望可以在封装组件时，外层组件可以通过 ref\n直接控制内层组件或元素的行为useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。\n\n​ 通常与forwardRef一起使用，暴露之后父组件就可以通过 `\nselectFileModalRef.current?.handleCancel();`来调用子组件的暴露方法。\n\n**2 useReducer**\n\n​ useReducer 是一个用于状态管理的 Hook Api。是useState 的替代方案。它接收一个形如 (state, action) =>\nnewState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。useReducer 这个 Hooks\n在使用上几乎跟 Redux一模一样，唯一缺点的就是无法使用 redux 提供的中间件。\n\n​ 在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的\nstate 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 。\n\n    \n    \n    const [state, dispatch] = useReducer(reducer, initialState, init);\n    //它接受 Reducer 函数和状态的初始值作为参数.第3参数它是一个回调函数且一定要返回一个对象数据,当然你也可以直接返回一个值也可以。如果useReducer它有第3个参数，则第2个参数就没有意义，它以第3个参数优先，第3个参数，惰性初始化，提升性能(调用的时候初始化数据)\n    //返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 action  的 dispatch 函数。\n    //计数器实例：\n    const initialState = 0;\n    const reducer = (state, action) => { //为了避免重复渲染，会定义在组件外进行创建\n      switch (action) {\n        case 'increment':\n          return state + 1\n        default:\n          return state}}\n    function UseReducerHook (){\n        const [count, dispatch] = useReducer(reducer, initialState);\n        return (<div>\n                <div>Count - {count}</div>\n                <button onClick={() => dispatch('increment')}>增加</button>\n          \t\t</div>)}\n    \n    \n\n由于 `Hooks` 可以提供共享状态和 `Reducer` 函数，所以它在这些方面可以取代 `Redux` 。但是它没法提供中间件（\n`middleware` ）这样高级功能。\n\n**3 useCallback** 为 useMemo 的语法糖\n\n**useCallback后的函数 组件会重新分配地址吗?**\n\n​ 其实 **useCallback 需要配合经过优化的并使用引用相等性去避免非必要渲染的子组件**\n时，它才能发挥它的作用。`useCallback`的真正目的是在于缓存每次渲染时内联函数的实例，这样方便配合上子组件的`shouldComponentUpdate`或者`React.memo`起到减少不必要的渲染的作用，父子俩层一定需要配对使用，缺了一个都可能导致性能不升反“降”，毕竟无意义的浅比较也是要消耗那么一点的性能消耗的。**不管是否使用****`useCallback`****，都无法避免重新创建内部函数。**\n\n​ 使用持久化的 function 的 Hook，理论上，可以使用 usePersistFn 完全代替 useCallback。在某些场景中，我们需要使用\nuseCallback 来记住一个函数，但是在第二个参数 deps 变化时，会重新生成函数导致函数地址变化。使用 ref\n的能力保证函数地址永远不会变化，子组建不会因为函数所需要的变量而重新渲染\n\n    \n    \n    function usePersistFn(fn) {\n      if (typeof fn !== 'function') {\n        console.error('param is not a function')\n      }\n    \n      const fnRef = useRef(fn)\n      fnRef.current = useMemo(() => fn, [fn])\n    \n      const persistFn = useRef()\n      if (!persistFn.current) {\n        persistFn.current = function (...args) {\n          return fnRef.current.apply(this, args)\n        }\n      }\n    \n      return persistFn.current\n    }\n    \n    \n\n**UseCallBack 基础**\n\n​ 把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized\n版本，该回调函数仅在某个依赖项改变时才会更新，避免非必要渲染。\n\n    \n    \n    let lastCallback;\n    let lastCallbackDependencies; \n    function useCallback(callback,dependencies){ \n        if (lastCallbackDependencies) { \n            let changed = !dependencies.every((item,index)=>{ \n                return item === lastCallbackDependencies[index]; \n            });\n        } else { \n            // 第一次(即lastCallbackDependencies为undefined)\n            // 或者非第一次但没有传入依赖项(即dependencies为[]) \n            lastCallback = callback;\n            lastCallbackDependencies = dependencies;\n        } \n        return lastCallback;\n    }\n    \n    \n\n`useEventCallback`是在React中通常用于确保事件处理器的行为的一种Hook。它的主要目的是解决事件处理函数中的闭包问题。\n\n当你在组件中使用函数时，如果这个函数引用了组件的state或props，那么它就会“捕获”那个特定的state或props。这就是所谓的\"闭包\"。因此，如果你在一个事件处理器中使用这样的函数，并且你希望它总是引用最新的state或props，那么你就需要用到`useEventCallback`。\n\n`useEventCallback`的基本使用形式如下：\n\n    \n    \n    import { useEventCallback } from 'react-event-callback-hook';\n    \n    function MyComponent() {\n      const [count, setCount] = useState(0);\n    \n      const handleClick = useEventCallback(() => {\n        console.log(count);\n        setCount(count + 1);\n      }, [count]);\n    \n      return <button onClick={handleClick}>Click me</button>;\n    }\n    \n    \n\n在上述代码中，`handleClick`函数总是引用最新的`count`状态，即使点击事件发生在状态改变之前。因此，它总是打印出最新的状态值。\n\n    \n    \n    function useEventCallback(fn, dependencies) {\n        const ref = useRef(() => {\n            throw new Error('Cannot call an event handler while rendering.');\n        });\n    \n        // 根据依赖去更新 ref ，保证最终调用的函数是最新的\n        useEffect(() => {\n            ref.current = fn;\n        }, [fn, ...dependencies]);\n    \n        // useCallback 返回的结果不会改变\n        return useCallback(() => {\n            const fn = ref.current;\n            return fn();\n        }, [ref]);\n    }\n    \n    \n\n**4 useMemo**\n\n​ 接受两个参数，分别是：“创建”函数 和 依赖项数\n，如果不传依赖数组，传入的函数每次都会重新执行计算；如果传空的依赖数组，则返回值被初始化后，不会再变化。在组件首次加载和重渲染期间执行。**同步方法，不能异步调用。**\n\n  * 相当于vue里的计算属性\n  * useMemo 缓存的结果是回调函数中return回来的值，主要用于缓存计算结果的值，应用场景如需要计算的状态。\n  * useCallback 缓存的结果是函数，优化针对于子组件渲染，主要用于缓存函数，应用场景如需要缓存的函数，因为函数式组件每次任何一个state发生变化，会触发整个组件更新，一些函数是没有必要更新的，此时就应该缓存起来，提高性能，减少对资源的浪费；另外还需要注意的是，useCallback应该和React.memo配套使用，缺了一个都可能导致性能不升反而下降。\n\n原理：\n\nmountMemo：初始化`useMemo`，就是创建一个`hook`，然后执行`useMemo`的第一个参数,得到需要缓存的值，然后将值和`deps`记录下来，赋值给当前`hook`的`memoizedState`\n\nupdateMemo：在组件更新过程中，我们执行`useMemo`函数，做的事情实际很简单，就是判断两次\n`deps`是否相等，如果不想等，证明依赖项发生改变，那么执行\n`useMemo`的第一个函数，得到新的值，然后重新赋值给`hook.memoizedState`,如果相等 证明没有依赖项改变，那么直接获取缓存的值。\n\n在update阶段中，`areHookInputsEqual` 函数接受两个依赖项数组 `nextDeps` 和\n`prevDeps`。它首先检查两个数组的长度是否相等，如果不相等，将在开发模式下发出警告。然后，它遍历数组并使用 `is` 函数（类似于\n`Object.is`）逐个比较元素。如果发现任何不相等的元素，函数将返回 `false`。否则，返回 `true`。\n\n不过这里有一点，值得注意，执行，如果里面引用了等信息，变量会被引用，无法被垃圾回收机制回\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594905000560607232?sourceSSR=users",
        "title": "Vue面经",
        "content": "# 目录\n\n(一)Vue2和Vue3区别\n\n(二)MVVM数据流\n\n(三)一些方法\n\n3.1 Keep-alive\n\n3.2 NextTick\n\n3.3 插槽slot\n\n3.4 lazyload\n\n(四) 基础\n\n4.1 Vue2\n\n4.2 Vue3\n\n(五)生命周期\n\n5.1 Vue2\n\n5.2 Vue3\n\n(六) 通信方式\n\n(七)路由\n\n7.1 模式\n\n7.2 加载跳转\n\n7.3 导航守卫\n\n7.4 跳转方式\n\n7.5 刷新\n\n7.6 源码\n\n(八)状态管理\n\n8.1 VueX\n\n8.2 Pinia\n\n(九)虚拟Dom\n\n(十)双向绑定\n\n10.1 Vue2\n\n10.2 Vue3\n\n(十一)编译渲染SSG、SEO\n\n(十二)SSR、CSR.\n\n(十三) 异步更新\n\n## (一) Vue2和Vue3区别\n\n**1.1 JS**\n\n​ 1 解耦视图和数据\n\n​ 2 双向数据绑定\n\n​ 3 可复用的组件\n\n​ 4 前端路由技术（单页面）\n\n​ 5 状态管理\n\n​ 6 虚拟DOM\n\n**1.2vue2 和 vue3**\n\n**1）组件化开发思想**\n\n组合式API，简单来说就是将同一逻辑关注点的代码配置在一起。Vue2的以下局限性：\n\n  * 代码的可读性问题：如果组件越来越大，代码难于理解和维护。\n  * 组件逻辑复用问题：相同的逻辑代码，很难在多个组件里面进行复用。\n\n**2） 支持多根结点，放入虚拟fragment中，对TypeScript的支持**\n\n**3）响应式原理**\n\n​ Vue2 响应式原理基础是 Object.defineProperty；Vue3 响应式原理基础是 Proxy。\n\n​ Object.defineProperty\n基本用法：直接在一个对象上定义新的属性或修改现有的属性，并返回对象。他无法监听对象或数组新增、删除的元素。比如：给对象添加属性但是界面不刷新；监测\n.length 修改。\n\n​ 若想实现数据与视图同步更新，可采取下面三种解决方案：\n\n  * 如果为对象添加少量的新属性，可以直接采用`Vue.set()`\n  * 如果需要为新对象添加大量的新属性，则通过`Object.assign()`创建新对象\n  * 修改数组后触发界面更新，可采取`this.$forceUpdate()`进行强制刷新 (不建议)\n\n​ Proxy Proxy 是 ES6 新特性，通过第2个参数 handler 拦截目标对象的行为。相较于 Object.defineProperty\n提供语言全范围的响应能力，消除了局限性。\n\n**4）虚拟DOM和diff算法的优化**\n\n**5）打包优化**\n\n**6）setup生命周期函数里加on。beforeDestroy 生命周期选项被重命名为 onBeforeUnmount。**\n\n**7） Composition API：setup（）、ref &reactive**\n\n**8）移除了一些组件，如filter和v-on等**\n\n**9）轻量化，如创建使用createApp()而不是new Vue()，比new Vue()轻量**\n\nVue3其他改进：\n\n​ **1 watch属性**\n\n​ 1） 用reactive监视对象时，不能监视到oldvalue\n\n​ 2） 默认开启了deep，且关不掉\n\n​ 3） 当传入reactive的某一属性时，需要传递函数才可以实现监视，因为watch只能监视数组、ref和reactive\n\n​ **2 hook** 本质是一个函数，相当于mixin\n\n​ **3 provide和inject** 实现祖孙之间通信\n\n​ **4 watchEffect** 也是一个帧听器，是一个副作用函数。\n它会监听引用数据类型的所有属性，不需要具体到某个属性，一旦运行就会立即监听，组件卸载的时候会停止监听。\n\n​ **5 toRef shallowReactive toRaw和markRaw**\n\n​ **6 v-for** 除了可以遍历数组之外，还可以遍历对象、迭代器等\n\n​ **7 更好的错误处理**\n\n**Vue3 编译优化**\n\n编译优化：编译器将模版编译为渲染函数的过程中，尽可能地提取关键信息，并以此指导生成最优代码的过程。\n\n原因：传统diff算法的问题： 无法利用编译时提取到的任何关键信息，导致渲染器在运行时不会去做相关的优化。\n\n目的：尽可能地区分动态内容和静态内容，并针对不同的内容采用不同的优化策略。vue3的编译器会将编译得到的关键信息“附着”在它生成的虚拟DOM上，传递给渲染器，执行“快捷路径”。\n\n方法：\n\n  1. Block 与 PatchFlag：传统Diff算法无法避免新旧虚拟DOM树间无用的比较操作，是因为运行时得不到足够的关键信息，从而无法区分动态内容和静态内容。 现在在虚拟节点多了一个额外的属性，即 patchFlag（补丁标志），存在该属性，就认为是动态节点。在虚拟节点的创建阶段，把它的动态子节点提取出来，并存储到该虚拟节点的 dynamicChildren 数组中。\n\n    \n    \n    Block定义: 带有 dynamicChildren 属性的虚拟节点称为“块” ，即（Block）\n    一个Block本质上也是一个虚拟DOM, 比普通的虚拟节点多处一个用来存储动态节点的 dynamicChildren属性。（能够收集所有的动态子代节点）\n    渲染器的更新操作会以Block为维度。当渲染器在更新一个Block时，会忽略虚拟节点的children数组，直接找到dynamicChildren数组，并只更新该数组中的动态节点。跳过了静态内容，只更新动态内容。同时，由于存在对应的补丁标志，也能够做到靶向更新。\n    Block节点有哪些： 模版根节点、 带有v-for、v-if/v-else-if/v-else等指令的节点\n    \n    \n\n  1. 静态提升：减少更新时创建虚拟DOM带来的性能开销和内存占用。把纯静态的节点提升到渲染函数之外，响应式数据变化后，不会重新创建静态的虚拟节点，包含动态绑定的节点本身不会被提升，但是该节点上的静态属性是可以被提升的。\n  2. 预字符串化：基于静态提升，进一步采用预字符串化优化。采用预字符串化将这些静态节点序列化为字符串， 并生成一个Static类型的VNode，超过 20 个静态会进行静态提升。大块的静态内容可以通过 innerHTML设置， 在性能上有一定优势。\n  3. v-once 可以对虚拟DOM进行缓存\n\n## (二) MVVM数据流\n\n​ MVVM 和 MVC都是一种设计思想，都是为了保证高内聚低耦合和可重用性的优点。MVVM 与 MVC\n最大的区别就是：它实现了View和Model的自动同步，当Model属性改变时，不用手动操作Dom元素去改变View的显示。而改变属性后，该属性对应View的显示会自动改变，因此开发者只需要专注对数据的维护操作即可，而不需要一直操作\ndom。\n\n**1 阐述一下你所理解的MVVM响应式原理**\n\n​ vue是采用数据劫持配合发布者-\n订阅者的模式的方式，通过Object.defineProperty()来劫持各个属性的getter和setter，在数据变动时，发布消息给依赖收集器（dep中的subs），去通知（notify）观察者，做出对应的回调函数，更新视图。MVVM作为绑定的入口，整合Observer,Compile和Watcher三者，通过Observer来监听model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer，Compile之间的通信桥路，达到数据变化Observer）=>视图更新；视图交互变化=>数据model变更的双向绑定效果。\n\n**2 双向数据流**\n\n​ 在双向数据流中，Model（可以理解为状态的集合） 中可以修改自己或其他Model的状态，\n用户的操作（如在输入框中输入内容）也可以修改状态。（双向数据流也可以叫双向数据绑定）\n\n双向数据流 - 优点\n\n  1. 数据模型变化与更新，会自动同步到页面上，用户在页面的数据操作，也会自动同步到数据模型\n  2. 无需进行和单向数据绑定的那些相关操作；\n  3. 在表单交互较多的场景下，会简化大量业务无关的代码。\n\n双向数据流 - 缺点\n\n  1. 无法追踪局部状态的变化；\n  2. “暗箱操作”，增加了出错时 debug 的难度；\n  3. 由于组件数据变化来源入口变得可能不止一个，数据流转方向易紊乱。\n  4. 改变一个状态有可能会触发一连串的状态的变化，最后很难预测最终的状态是什么样的。使得代码变得很难调试\n\n**3 单项数据流**\n\n对于 Vue 来说，组件之间的数据传递具有单向数据流这样的特性。\n\n  1. 父组件总是通过 props 向子组件传递数据；\n  2. 所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定；\n  3. 父级 prop 的更新会向下流动到子组件中，但是反过来则不行；\n  4. 这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解；\n  5. 每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值；\n  6. 这意味着不应该在一个子组件内部改变 prop。如果这样做，Vue 会在浏览器的控制台中发出警告。\n\n单向数据流 - 优点\n\n  1. 所有状态的改变可记录、可跟踪，源头易追溯；\n  2. 所有的数据，具有唯一出口和入口，使得数据操作更直观更容易理解，可维护性强；\n  3. 当数据变化时，页面会自动变化\n  4. 当你需要修改状态，完全重新开始走一个修改的流程。这限制了状态修改的方式，让状态变得可预测，容易调试。\n\n单向数据流 - 缺点\n\n  1. 页面渲染完成后，有新数据不能自动更新，需要手动整合新数据和模板重新渲染\n  2. 代码量上升，数据流转过程变长，代码重复性变大\n  3. 由于对应用状态独立管理的严格要求(单一的全局 store，如：Vuex)，在处理局部状态较多的场景时(如用户输入交互较多的“富表单型”应用)，会显得啰嗦及繁琐。\n\n**4 依赖收集**\n\n​\n我们知道，当一个可观测对象的属性被读写时，会触发它的getter/setter方法。如果我们可以在可观测对象的getter/setter里面，去执行监听器里面的onComputedUpdate()方法，是不是就能够实现让对象主动发出通知的功能呢？由于监听器内的onComputedUpdate()方法需要接收回调函数的值作为参数，而可观测对象内并没有这个回调函数，所以我们需要借助一个第三方来帮助我们把监听器和可观测对象连接起来。这个第三方就做一件事情——收集监听器内的回调函数的值以及onComputedUpdate()方法。\n\n​\nVue为数据中的每一个key维护一个订阅者列表。对于生成的数据，通过`Object.defineProperty`对其中的每一个key进行处理，主要是为每一个key设置`get`,\n`set`方法，以此来为对应的key收集订阅者，并在值改变时通知对应的订阅者。\n\n在对key进行取值时，如果`Dep.target`有值，除正常的取值操作外会进行一些额外的操作来添加订阅者。大多数时间里，`Dep.target`的值都为`null`，只有订阅者在进行订阅操作时，`Dep.target`才有值，为正在进行订阅的订阅者。此时进行取值操作，会将订阅者加入到对应的订阅者列表中。\n\n订阅者在进行订阅操作时，主要包含以下3个步骤：\n\n  * 将自己放在`Dep.target`上\n  * 对自己依赖的key进行取值\n  * 将自己从`Dep.target`移除\n\nVue 的响应式系统中的一个重要部分是依赖收集。这个过程确保只有当某个状态改变时，依赖于这个状态的计算值或组件才会重新计算或渲染。\n\n以下是一个简化的依赖收集系统的实现：\n\n    \n    \n    class Dep {\n      //这个例子中，我们创建了一个Dep类，它代表了一个依赖项。每个依赖项都有一个subscribers集合，用于存储所有依赖于这个依赖项的更新函数。\n      constructor() {\n        this.subscribers = new Set();\n      }\n    \n      depend() {\n        if (activeUpdate) {\n          this.subscribers.add(activeUpdate);\n        }\n      }\n    \n      notify() {\n        this.subscribers.forEach(sub => sub());\n      }\n    }\n    //autorun函数接收一个更新函数，并将其包装在一个新的函数中，这个新的函数会在每次运行更新函数时将自己设置为activeUpdate。这样，当我们访问响应式对象的某个属性时，我们就可以将 activeUpdate 添加到这个属性对应的依赖项的 subscribers集合中。\n    let activeUpdate;\n    function autorun(update) {\n      function wrappedUpdate() {\n        activeUpdate = wrappedUpdate;\n        update();\n        activeUpdate = null;\n      }\n    \n      wrappedUpdate();\n    }\n    //最后，当我们修改响应式对象的某个属性的值时，我们会通知这个属性对应的依赖项，让其调用所有的更新函数，这就实现了状态改变时的响应更新。\n    function reactive(obj) {\n      const deps = new Map();\n      return new Proxy(obj, {\n        get(obj, key) {\n          let dep = deps.get(key);\n          if (!dep) {\n            dep = new Dep();\n            deps.set(key, dep);\n          }\n    \n          dep.depend();\n          return obj[key];\n        },\n        set(obj, key, newVal) {\n          obj[key] = newVal;\n          const dep = deps.get(key);\n          if (dep) {\n            dep.notify();\n          }\n          return true;\n        }\n      });\n    }\n    \n    const state = reactive({ count: 0 });\n    \n    autorun(() => {\n      console.log(state.count);\n    });\n    \n    state.count++; // 控制台输出：1\n    \n    \n\nhttps://www.jianshu.com/p/e6e1fa824849\n\n## (三) 一些方法\n\n### 3.1 Keep-alive\n\n​ keep-alive作为一种vue的内置组件，主要作用是缓存组件状态。当需要组件的切换时，不用重新渲染组件，避免多次渲染，就可以使用keep-\nalive包裹组件。\n\n    \n    \n    <!-- 基本 --> \n    <keep-alive> \n        <component :is=\"view\"></component> \n    </keep-alive> \n    <!-- 多个条件判断的子组件 -->\n    <keep-alive> \n        <comp-a v-if=\"a > 1\"></comp-a> \n        <comp-b v-else></comp-b> \n    </keep-alive>\n    <!-- 和 `<transition>` 一起使用 -->\n    <transition> \n        <keep-alive> \n            <component :is=\"view\"></component> \n        </keep-alive> \n    </transition>\n    \n    \n\n​ `keep-\nalive`是一个组件，这个组件中有三个属性，分别是`include`、`exclude`、`max`，在`created`中创建缓存列表和缓存组件的key列表，销毁的时候会做一个循环销毁清空所有的缓存和key。当`mounted`时会监控`include`和`include`属性，进行组件的缓存处理。按需缓存，keep-\nalive组件如果设置了 include ，就只有和 include 匹配的组件会被缓存。\n\n​\n\n​ 该组件如果缓存过，就直接拿到组件实例，如果没有就存进当前的`vnode`中，和key做一个对应关系。\n\n在 keep-alive 的源码定义中，它作为一个组件有自己的 render() 阶段会缓存 vnode 和组件名称 key 等操作。\n\n首先会判断是否存在缓存，如果存在，则直接从缓存中获取组件的实例，并进行缓存优化处理（这里面有一个算法叫`LRU`，如果有key就不停的取，如果超限了就采用`LRU`进行删除最近最久未使用的，从前面删除，`LRU`就是将当前使用的往数组的后面移，在最前面的就是最久未使用的）。\n\n​\n如果发生变化会动态的添加和删除缓存，渲染的时候会去拿`默认插槽`，只缓存第一个组件，根据组件的名字判断是否在缓存中，如果在就缓存，不在就return掉，不在就直接return掉。缓存的时候，如果组件没有key，就自己通过组件的标签，key和cid拼接一个key。\n\n    \n    \n    var KeepAlive = {\n      ...\n      props: {\n        include: patternTypes,  // 名称匹配的组件会被缓存，对外暴露 include 属性 api\n        exclude: patternTypes,  // 名称匹配的组件不会被缓存，对外暴露 exclude 属性 api\n        max: [String, Number]  // 可以缓存的组件最大个数，对外暴露 max 属性 api\n      },\n    \n    \n\n注意：\n\n    \n    \n    iframe 标签承载了一个单独的嵌入的窗口，它有自己的 document 和 window (浏览器会检查 iframe 是否具有相同的源)\n    \n    \n\n​ iframe中keep-alive机制失效原因：iframe页里的内容并不属于节点的信息，所以使用keep-\nalive依然会重新渲染iframe内的内容。而且iframe每一次渲染就相当于打开一个新的网页窗口，即使把节点保存下来，在渲染时iframe页还是刷新的。\n\n解决策略：\n\n  1. 切换不含iframe的界面时使用vue路由，在切换含iframe页的界面时利用v-show来控制显示隐藏，使iframe的节点不被删除，以此来防止界面节点被重新更新，从而达到保存iframe节点数据的效果\n  2. 使用不带iframe的组件正常使用keep-alive，带iframe的组件开始时隐藏，切换到带iframe的组件时，隐藏其他不带iframe的组件，显示带iframe的组件，通过v-if将iframe的显示做成懒加载形式的，只有在用户进入相应的页面时才触发渲染，在渲染完毕后再通过v-show去控制界面在切换时的显示与隐藏。\n\nhttps://juejin.cn/post/7133038641370595365\n\nhttps://juejin.cn/post/7037321886019092510#heading-6\n\n### 3.2 NextTick\n\n​ 定义：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。\n\n​\nnextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。\n\n​ 将传入的回调函数包装成异步任务，异步任务又分微任务和宏任务，为了尽快执行所以优先选择微任务；Vue 在内部对异步队列尝试使用原生的\nPromise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0)\n代替。\n\n**DOM树更新是同步的**\n\n每一轮事件循环的最后会进行一次页面渲染，并且从上面我们知道渲染过程也是个宏任务，这里可能会有个误区，那就是DOM\ntree的修改是同步的，只有渲染过程是异步的，也就是说我们在修改完DOM后能够立即获取到更新的DOM。\n\n**为什么Vue却需要借用$nextTick来处理**\n\n因为Vue处于性能考虑，Vue会将用户同步修改的多次数据缓存起来，等同步代码执行完，说明这一次的数据修改就结束了，然后才会去更新对应DOM，一方面可以省去不必要的DOM操作，比如同时修改一个数据多次，只需要关心最后一次就好了，另一方面可以将DOM操作聚集，提升render性能。\n\n**为什么优先使用微任务？**\n\n因为微任务一定比宏任务优先执行，如果nextTick是微任务，它会在当前同步任务执行完立即执行所有的微任务，也就是修改DOM的操作也会在当前tick内执行，等本轮tick任务全部执行完成，才是开始执行UI\nrendering。如果nextTick是宏任务，它会被推进宏任务队列，并且在本轮tick执行完之后的某一轮执行，注意，它并不一定是下一轮，因为你不确定宏任务队列中它之前还有所少个宏任务在等待着。所以为了能够尽快更新DOM，Vue中优先采用的是微任务，并且在Vue3中，它没有了兼容判断，直接使用的是promise.then微任务，不再考虑宏任务了。\n\n​\nVue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中，原因是在created()钩子函数执行的时候DOM\n其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载已完成。\n\n​\n当项目中你想在改变DOM元素的数据后基于新的dom做点什么，对新DOM一系列的js操作都需要放进Vue.nextTick()的回调函数中；通俗的理解是：更改数据后当你想立即使用js操作新的视图的时候需要使用它。\n\n​ Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的\nwatcher\n推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。​\n当设置 vm.someData = 'new value'，DOM\n并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM\n状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用\nVue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。\n\n参考：\n\n  * vue.nextTick()方法的使用详解（简单明了）https://blog.csdn.net/zhouzuoluo/article/details/84752280\n  * https://juejin.cn/post/7089980191329484830#heading-10\n\n### 3.3 插槽slot\n\n1.插槽是使用在子组件中的。\n\n2.插槽是为了将父组件中的子组件模板数据正常显示\n\n    \n    \n    //home.vue\n    <test>\n         Hello Word\n    </test>\n    //test.vue\n    <a href=\"#\">\n    \t <slot></slot>\n    </a>\n    //当组件渲染的时候，<slot></slot>会被替换为Hello Word\n    \n    \n\n3 插槽内可以包含普通文本，也可以包含任何模板代码，包括HTML\n\n    \n    \n    //home.vue\n    <test>\n    \t//插槽可以获取到home组件里的内容\n    \tHello {{enhavo}}\n    </test>\n    \n    data(){\n    \treturn{\n    \t\tenhavo:'word'\n    \t}\n    }\n    //home.vue\n    //这里是获取不到name的，因为这个值是传给<test>的\n    <test name='you'>\n        Hello {{name}}\n    </test>\n    \n    \n\n4\n插槽跟模板其他地方一样都可以访问相同的实例属性(也就是相同的\"作用域\")，而不能访问<test>的作用域。原因是父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。\n\n**具名插槽**\n\n​ 有时候我们一个组件里需要**多个插槽** ，对于这样的情况，`<slot>`元素有一个特殊的特性：`name` ，这个特性可以用来**定义额外的插槽**\n\n​\n如果一个`<slot>`不带`name`属性的话，那么它的`name`默认为`default`。在向具名插槽提供内容的时候，我们可以在`<template>`元素上使用`v-slot`指令，并以参数的形式提供其名称\n\n具名插槽的缩写(2.6.0新增)\n\n​ 跟 `v-on` 和 `v-bind` 一样，`v-slot` 也有缩写，即把参数之前的所有内容 `(v-slot:)` 替换为字符 `#`。例如\n`v-slot:header` 可以被重写为 `#header`：\n\n**作用域插槽**\n\n我们可以在父组件中使用slot-scope 特性从子组件获取数据， 前提是需要在子组件中使用:data=data 先传递data 的数据。\n\n**动态插槽**\n\n动态指令参数也可以用在v-slot上，来定义动态的插槽名：\n\n    \n    \n    <base-layout>\n      <template v-slot:[dynamicSlotName]>\n        ...\n      </template>\n    </base-layout>\n    \n    \n\n### 3.4 lazyload\n\n核心逻辑是： 图片在视图范围内，就显示，否则只显示加载图标。而图片在不在视图范围内，是动态变化的，比如滚动的时候，图片就可能从视图外到视图内。\n\n    \n    \n    import VueLazyload from 'vue-lazyload'\n    \n    Vue.use(VueLazyload,{\n      preLoad: 1.3,\n      loading: 'dist/loading.gif',\n    })\n    \n    // 使用的时候，直接在想懒加载的img上，加个指令就好了\n    // <img v-lazy=\"img.src\">\n    \n    \n\n**原理：**\n\n​ 通过getBoundingClientRect可以知道,元素相对于视图窗口的**左上角** 的距离。\n\n    \n    \n    Element.getBoundingClientRect() //方法返回一个 DOMRect 对象，其提供了元素的大小及其相对于视口的位置。\n    \n    \n\n​ **元素在不在视图内，其实本质上就是判断：****`top>\nwindowHeight`**。`top`越大，元素离地址栏就会越来越远，当距离**大于**`windowHeight`，就不在视图范围内。\n\n    \n    \n    const windowHeight = window.innerHeight\n    // 元素离地址栏的近似距离\n    const {top} = ele.getBoundingClientRect()\n    const isInView = top<windowHeight\n    \n    \n\n  1. vue-lazyload是通过指令的方式实现的，定义的指令是v-lazy指令\n  2. 指令被bind时会创建一个listener，并将其添加到listener queue里面， 并且搜索target dom节点，为其注册dom事件(如scroll事件)\n  3. 上面的dom事件回调中，会遍历 listener queue里的listener，判断此listener绑定的dom是否处于页面中perload的位置，如果处于则加载异步加载当前图片的资源\n  4. 同时listener会在当前图片加载的过程的loading，loaded，error三种状态触发当前dom渲染的函数，分别渲染三种状态下dom的内容\n\n## (四) 基础\n\n### 5.1 Vue2\n\n**1 指令**\n\n​ v-text：设置标签文本值(textContent)\n\n​ v-html：设置标签的innerHtml\n\n​ v-on(@)：为元素绑定事件\n\n​ v-show：针对表达式的真假，控制元素的显示与隐藏（有就执行`transition`没有就display:none）\n\n​ v-if：针对表达式的真假，控制元素的显示与隐藏（操作dom）\n\n​ v-bind(:)：设置元素属性(src,title,class)\n\n​ v-for：v-for 具有比 v-if 更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中\n\n​ v-model：获取和设置表单元素(input|textarea|button|datalist)的值\n\n    \n    \n    <input v-bind:value=\"something\" v-on:input=\"something=$event.target.value\">\n    \n    \n\n想要组件 v-model生效 它必须: 1. 接收一个value属性。 2. 在value值改变时 触发input事件。\n\n自定义组件使用：\n\n  1. 在你的组件的 props 中定义一个属性，通常叫做 value。\n  2. 当需要更新 v-model 绑定的值时，你的组件需要触发一个 update:modelValue 事件，并将新的值作为参数。在 Vue 3 之前，事件名是 input。\n  3. 在使用你的组件时，使用 v-model 指令绑定一个值。\n\n    \n    \n      <input\n        :value=\"modelValue\"\n        @input=\"$emit('update:modelValue', $event.target.value)\"\n      />\n    <my-input v-model=\"message\"></my-input>\n    \n    \n\n**2 el：挂载点**\n\n​\nel的作用是设置vue实例挂载管理的元素；vue会管理el命中的元素以及其后代元素；可以使用其他选择但是建议使用id选择器；可以使用其他双标签，但不能使用html和body。\n\n**3 计算属性**\n\n​ 计算属性实际上是一个懒执行的副作用函数。computed = 闭包 + effect() + lazy。\n当我们不希望effect立即执行时，通过增加lazy属性延迟执行。\n\n  1. 一开始每个 `computed` 新建自己的 `watcher`时，会设置 watcher.dirty = true，以便于 `computed` 被使用时，会计算得到值\n  2. 当依赖的数据变化了，通知 `computed` 时，会赋值 watcher.dirty = true，此时重新读取 `computed` 时，会执行 `get` 函数重新计算。\n  3. `computed` 计算完成之后，会设置 watcher.dirty = false，以便于其他地方再次读取时，使用缓存，免于计算。\n\n​\n通过为effect添加scheduler调度器函数，在getter中所依赖的响应式数据发生变化时将scheduler中的dirty重置为true。computed\n会让 【data依赖】 收集到 【依赖computed的watcher】，从而 data 变化时，会同时通知 computed 和\n依赖computed的地方。\n\n    \n    \n    const computedList = computed(()=>{ return xxx })\n    // 计算属性不应有副作用，如异步/修改dom\n    // 应该只读，不应赋值\n    \n    \n\n**4 watch**\n\n本质就是观测一个响应式数据，并传递一个回调函数，当修改数据时执行。\n\nvue3中可以通过设置flush定义回调函数执行时机，当flush为post时将其添加到微任务队列中。\n\n    \n    \n    watch(监听谁，(newValue, oldValue) => {xxx})\n    watch([监听谁s]，([newValue], [oldValue]) => {xxx})\n    \n    deep | immediately\n    \n    \n\n`watchEffect` 是 vue3 的一个新特性，与 Vue2 中的 `watch` 不同，`watchEffect`\n不需要指定要监听的数据，而是会自动追踪函数中使用的响应式数据，并在这些数据发生变化时重新执行回调函数。这种自动追踪的特性可以简化代码，并提高应用的性能。\n\n触发时机：watchEffect：立即执行一次回调函数，并在回调函数中自动收集依赖。每当依赖发生变化时，回调函数都会被重新执行。\n\n​ watch：需要显式指定要监视的响应式数据或计算属性，并在其发生变化时执行回调函数。\n\n依赖追踪：watchEffect：会自动追踪在回调函数中使用的响应式数据或计算属性，并建立依赖关系。当依赖变化时，回调函数将重新执行。\n\n​ watch：需要手动指定要监视的响应式数据或计算属性，只有在指定的数据变化时才会执行回调函数。\n\n回调函数参数：watchEffect：回调函数中没有参数，但可以使用响应式数据和计算属性。\n\n​ watch：回调函数接收两个参数：新值和旧值。可以通过这两个参数来执行特定的操作，例如比较新旧值之间的差异。\n\n**5 this【Vue2 this 能够直接获取到 data 和 methods】 **\n\n以method举例，只要关注initMethod即可，其实整个`initMethods`方法核心就是将`this`绑定到了实例身上，因为`methods`里面都是函数，所以只需要遍历将所有的函数在调用的时候将`this`指向实例就可以实现通过`this`直接调用的效果。\n\n通过`this`直接访问到`methods`里面的函数的原因是：因为`methods`里的方法通过 `bind` 指定了`this`为 `new\nVue`的实例(`vm`)。【`bind`函数中主要是做了兼容性的处理，如果不支持原生的`bind`函数，则根据参数个数的不同分别使用`call/apply`来进行`this`的绑定，而`call/apply`最大的区别就是传入参数的不同，一个分别传入参数，另一个接受一个数组。】\n\n通过 `this` 直接访问到 `data` 里面的数据的原因是：data里的属性最终会存储到`new Vue`的实例（`vm`）上的\n`_data`对象中，访问 `this.xxx`，是访问`Object.defineProperty`代理后的 `this._data.xxx`。\n\n### 5.2 Vue3\n\n**0 proxy 和 define.property**\n\n  * `Proxy`可以直接监听对象而非属性；\n  * `Proxy`可以直接监听数组的变化；\n  * `Proxy`有多达13种拦截方法,不限于`apply、ownKeys、deleteProperty、has`等等是`Object.defineProperty`不具备的；\n  * `Proxy`返回的是一个新对象,我们可以只操作新的对象达到目的,而`Object.defineProperty`只能遍历对象属性直接修改；\n\n`Object.defineProperty (obj, prop, descriptor)` 的问题主要有三个：\n\n  * 无法监听数组的变化 `Vue` 把会修改原来[数组](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fso.csdn.net%2Fso%2Fsearch%3Fq%3D%25E6%2595%25B0%25E7%25BB%2584%26spm%3D1001.2101.3001.7020)的方法定义为变异方法。 变异方法例如 `push、pop、shift、unshift、splice、sort、reverse`等，是无法触发 `set` 的。 非变异方法，例如 `filter，concat，slice` 等，它们都不会修改原始数组，而会返回一个新的数组。 `Vue` 的做法是把这些变异方法重写来实现监听数组变化。\n  * 必须遍历对象的每个属性 使用 `Object.defineProperty` 多数情况下要配合 `Object.keys` 和遍历，于是就多了一层嵌套。 并且由于遍历的原因，假如对象上的某个属性并不需要“劫持”，但此时依然会对其添加“劫持”。\n  * 必须深层遍历嵌套的对象 当一个对象为深层嵌套的时候，必须进行逐层遍历，直到把每个对象的每个属性都调用 `Object.defineProperty()` 为止。\n\n**1 组件**\n\n组件的本质就是一组dom的封装，用一个函数定义组件，返回值对象（render）就是要渲染的内容。通过判断vnode.type是否为函数判断是否为组件（patch会判断的类型有string、text、Fragment和object）。然后以递归的方式去挂载组件。\n\n​ 组件初始化：\n\n  * ​ const state = reactive(data())将数据变为响应式。\n  * ​ const subTree = render.call(state, state) 将this只想设置为响应式的state，同时将state作为第一个参数传递。\n  * ​ patch(null, subTree, contianer, anchor) 更新虚拟dom。\n\n​\n使用effect()对reactive数据进行实时更新，但是由于effect是同步的，每次数据变化时都会导致渲染器更新，因此需要实现一个调度器，当副作用函数需要被执行时放入一个微任务队列中并对任务进行去重。\n\n    \n    \n    const queue = new Set()\n    let isFlushing = flase //是否正在刷新任务队列\n    const p = Promise.resolve()\n    function queueJob(job){\n    \tquque.add(job)\n    \tif(!isFlushing){\n    \t\tifFlushing = true\n    \t\tp.then(()=>{\n    \t\t\ttry{\n    \t\t\t\tqueue.forEach(job=>job())\n    \t\t\t}finally{\n    \t\t\t\tisFlushing = false\n    \t\t\t\tqueue.clear = 0\n    \t\t\t}\n    \t\t})\n    \t}\n    }\n    effect(()={subTree;path()},{scheduler:ququeJob})\n    \n    \n\n**2 setup**\n\n​ **scrtpt setup** 是 vue3 的语法糖，简化了组合式 API 的写法，并且运行性能更好。使用 **script setup**\n语法糖的特点：\n\n  * 属性和方法无需返回，可以直接使用。\n  * 引入组件的时候，会自动注册，无需通过 components 手动注册。\n  * 使用 defineProps 接收父组件传递的值。\n  * useAttrs 获取属性，useSlots 获取插槽，defineEmits 获取自定义事件。\n  * 默认不会对外暴露任何属性，如果有需要可使用 defineExpose 。\n\nsetup函数(取代了onCreated)只会在挂载时被执行一次，它可以返回一个函数作为组件的渲染函数；也可以返回一个对象，将数据暴露给模板使用（可以通过this访问）。它接受两个参数，一个是props数据对象，一个是setupContext与组件接口相关的数据。\n\n​ setupContext包含{emit、slots、attrs、expose}\n\nemit用来发射组件的自定义事件。\n\nslot插槽，与React中的render\nprops相似。将vnode.children作为slots对象添加到setupContext中，在render中通过this.$slot访问。然后对renderContext代理对象的get拦截函数做处理，当读取到slot时返回slot对象。\n\n    \n    \n    <script setup> 省略原来setup(){return xxx}\n    \n    \n\n​\nVue2中，可以通过this来获取当前组件实例；Vue3中setup执行时机是在beforeCreate钩子前自动执行，不指向this，指向undefined，通过getCurrentInstance()获得；\n\n**3 Ref和Reactive**\n\n` ref`本质也是`reactive`，`ref(obj)`等价于`reactive({value: obj})`\n\n1.reactive\n\n​ reactive的参数**必须是一个对象**\n，不能是单一的值，包括json数据和数组都可以，否则不具有响应式。如果给reactive传递了其他对象（如时间对象），默认情况下修改对象界面不会自动更新，如果想更新，可以通过给对象重新赋值来解决\n\n​ 在使用vue3中，使用`reactive`创建的对象或者数组进行赋值时，可以正常赋值，但是**不会触发响应式变化**\n。每次直接把一个对象或者数组赋值给`reactive`创建的对象或数组时，导致reactive创建的响应式对象被新赋值的直接代理，再vue3中操作的都是proxy代理对象，所以失去了响应式。在vue3中不管是对象还是数组都不能直接将整个数据进行赋值，这样会造成reactive定义的响应式失效。通俗说：\n就像对象的地址被替换，就不是原来的那个对象了。\n\n​ 解决方法：不是直接赋值，包裹一层；使用ref赋值，包裹了一层对象， _ref重新赋值时，通过.value赋值_\n\n2.ref当我们只想让某个变量实现响应式的时候，采用reactive就会比较麻烦，因此vue3提供了ref方法进行简单值的监听，但并不是说ref只能传入简单值，他的底层是reactive，所以reactive有的，他都有。\n\n  * 在中使用的值，不用通过获取（解包）；在中使用\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594903293256581120?sourceSSR=users",
        "title": "前端面经（CSS部分）",
        "content": "## 目录：\n\n(一)CSS语法\n\n1.1 单位\n\n1.2 块级元素\n\n1.3 隐藏\n\n1.4 清除浮动\n\n1.5 动画\n\n1.6 权重\n\n1.7 居中\n\n1.8 定位与脱标\n\n1.9选择器\n\n1.10 CSS3\n\n1.11 BFC\n\n1.12 canvas\n\n1.13 src和href\n\n(二)布局\n\n2.1 Flex\n\n2.2 响应|移动\n\n2.3 grid\n\n2.4 flexible\n\n(三)渲染\n\n3.1 阻塞渲染\n\n3.2 重排重绘\n\n3.3 加载优化\n\n3.4 浏览器\n\n(四)scoped|Module\n\n(五)UI\n\n4.1 Echarts\n\n4.2 Sass Less\n\n4.5 ElementUl\n\n4.6 Antd\n\n4.7 H5\n\n4.8 csslnjs\n\n(六)Demo\n\n6.1 滑动穿透\n\n6.2 固定导航栏\n\n6.3 两栏布局\n\n6.4 0.5px的线\n\n6.5 截断文本\n\n6.6 禁止复制\n\n6.7 图片优化\n\n6.8 三角形\n\n6.9 1px 像素\n\n6.10 z-index\n\nCSS其他\n\n##\n\n##\n\n## (一) CSS语法\n\n### 1.1 单位\n\n​\npx全称`pixel`像素，是相对于屏幕分辨率而言的，它是一个绝对单位，但同时具有一定的相对性。因为在同一个设备上每个像素代表的物理长度是固定不变的，这点表现的是绝对性。但是在不同的设备之间每个设备像素所代表的物理长度是可以变化的，这点表现的是相对性。\n\n​\nem是一个相对长度单位，具体的大小需要相对于父元素计算，比如父元素的字体大小为80px，那么子元素1em就表示大小和父元素一样为80px，0.5em就表示字体大小是父元素的一半为40px。em\n作为尺度单位时是以 font-size 属性为参考依据的。\n\n​ rem 是 root em 的简称，表示设置以网页根元素 ( html ) 的字符高度为单位。因此可以只对 html 元素设置字体大小，其他元素用\nrem 单位设置百分比大小，例如 h 1{font-size:1.25 rem}。一般的浏览器默认的 1 rem 是 16 px。\n\n​ _vw_ 和 _vh_ 是 _CSS3_ 新单位，即 _view width_ 可视窗口宽度 和 _view height_ 可视窗口高度。1 _vw_\n就等于可视窗口宽度的百分之一，1 _vh_ 就等于可视窗口高度的百分之一。\n\n### 1.2 块级元素\n\n    \n    \n    块级：form h li p table th\n    \n    \n\n  * 每个块级元素都是独自占一行；\n  * 高度，行高，外边距（margin）以及内边距（padding）都可以控制；\n  * 元素的宽度如果不设置的话，默认为父元素的宽度（父元素宽度100%；\n  * 多个块状元素标签写在一起，默认排列方式为从上至下；\n\n    \n    \n    行内：a br i label small textarea select strong\n    \n    \n\n  * 不会独占一行，相邻的行内元素会排列在同一行里，直到一行排不下才会自动换行，其宽度随元素的内容而变化；\n  * 高宽无效，对外边距（margin）和内边距（padding）仅设置左右方向有效 上下无效；\n  * 设置行高有效，等同于给父级元素设置行高；\n  * 元素的宽度就是它包含的文字或图片的宽度，不可改变；\n  * 行内元素中不能放块级元素，a 链接里面不能再放链接；\n\n    \n    \n    行内块：button input textarea select img\n    \n    \n\n  * 高度、行高、外边距以及内边距都可以控制；\n  * 默认宽度就是它本身内容的宽度，不独占一行，但是之间会有空白缝隙，设置它上一级的 font-size 为 0，才会消除间隙；\n\n### 1.3 隐藏\n\n分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景\n\n  * 结构： display:none: 会让元素完全从渲染树中消失，渲染的时候不占据任何空间, 不能点击， visibility: hidden:不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，不能点击 ，opacity: 0: 不会让元素从渲染树消失，渲染元素继续占据空间，只是内容不可见，可以点击。\n  * 继承： display: none和opacity: 0：是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示。 visibility: hidden：是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式。\n  * 性能： display: none : 修改元素会造成文档回流,读屏器不会读取display: none元素内容，性能消耗较大 visibility: hidden: 修改元素只会造成本元素的重绘,性能消耗较少读屏器读取visibility: hidden元素内容 opacity: 0 ： 修改元素会造成重绘，性能消耗较少。通过display: none隐藏一个DOM节点-触发重排和重绘通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化（详见 3.2）\n\n​\n屏幕并不是唯一的输出机制，比如说屏幕上看不见的元素（隐藏的元素），其中一些依然能够被读屏软件阅读出来（因为读屏软件依赖于可访问性树来阐述）。为了消除它们之间的歧义，我们将隐藏类型归为三大类：\n\n完全隐藏：元素从渲染树中消失，不占据空间。视觉上的隐藏：屏幕中不可见，占据空间。语义上的隐藏：读屏软件不可读，但正常占据空。\n\n**完全隐藏**\n\n(1) display 属性\n\n    \n    \n     display: none;\n    \n    \n\n(2) hidden 属性 HTML5 新增属性，相当于 display: none\n\n    \n    \n    <div hidden></div>\n    \n    \n\n**视觉上的隐藏**\n\n(1) 设置 posoition 为 absolute 或 fixed，通过设置 top、left 等值，将其移出可视区域。\n\n    \n    \n    position:absolute;\n    left: -99999px;\n    \n    \n\n(2) 设置 position 为 relative，通过设置 top、left 等值，将其移出可视区域。\n\n    \n    \n    position: relative;\n    left: -99999px;\n    height: 0\n    \n    \n\n(3) 设置 margin 值，将其移出可视区域范围（可视区域占位）。\n\n    \n    \n    margin-left: -99999px;\n    height: 0;\n    \n    \n\n**语义上隐藏**\n\n_aria-hidden 属性_\n\n读屏软件不可读，占据空间，可见。\n\n    \n    \n    <div aria-hidden=\"true\"></div>\n    \n    \n\n### 1.4 清除浮动\n\n​\n清除浮动是清除浮动带来的负面影响。因为子元素浮动了，脱离标准流，不再占用之前的位置，导致无法撑开没有设置高度的父元素浮动的父元素高度为0,进而导致后续结构直接跑上来，导致高度塌陷。\n\n  * ​ clear 清除浮动（添加空div法）在浮动元素下方添加空div，并给该元素写css样式：{clear:both;height:0;overflow:hidden;}​ 缺点：添加无意义标签，语义化差；\n  * ​ 给浮动元素父级设置高度\n  * ​ 父级同时浮动（需要给父级同级元素添加浮动）\n  * ​ 父级设置成inline-block​ 缺点：需要设置宽度，margin: 0 auto居中方式失效；\n  * ​ 给父级添加overflow:hidden​ 缺点：内容增多的时候容易造成不会自动换行导致内容被隐藏掉，无法显示要溢出的元素；\n  * ​ 万能清除法 ::after 伪元素清浮动（现在主流方法，推荐使用）​ 缺点：：ie6-7不支持伪元素：after，使用zoom:1触发hasLayout.\n\n### 1.5 动画\n\nss中实现动画有两种方式：`transition`过渡动画、 `animation`自定义动画。\n\n**1\\. transition：**\n\n  * transition-property：指定使用过渡效果的css属性 w| h| color |font-size | all\n  * transition-duration：设置过渡动画持续时间\n  * transition-timing-function：设置动画的时间函数。linear | ease（缓解）| cubic-bezier(_n_ ,_n_ ,_n_ ,_n_)\n  * transition-delay：设置动画的延迟时间\n\n注意：\n\n​ 不支持z-index | display\n\n**2\\. animation:**\n\n通过@keyframes自定义关键帧动画并为动画命名，可以在其中对每一帧进行设置。\n\n    \n    \n    @keyframes animateName{\n        from|0%   { width:50px; height:50px; }\t\n        50%  { width:100px; height:100px; }\t\n        to|100% { width:50px; height:50px; }\n    }\n    \n    \n    \n    \n    // 从左往右滑动，或者用transition实现，或者使用jQuery的window.requestAnimationFrame实现\n    @keyframes slideInFromLeft {\n      0% {\n        transform: translateX(-100%);\n      }\n      100% {\n        transform: translateX(0);\n      }\n    }\n    .slideInElement {\n      animation: 2s ease-out 0s 1 slideInFromLeft;\n    }\n    \n    \n\n使用自定义动画的元素，需要通过animation相关属性进行配置\n\n  * animation-name: 某个元素想要使用对应名称的动画\n  * animation-duration：默认为0\n  * animation-timing-function：可配置动画随时间的运动速率和轨迹\n  * animation-delay\n  * animation-iteration-count：用于定义动画迭代次数，默认为1|infinite\n  * animation-direction：设置动画执行方向 normal|reverse|alternate|inherit\n  * animation-fill-mode：动画的填充模式 none|forwards|backwards\n  * animation-play-state：设置动画的执行状态，通常通过JavaScript动态控制。running|paused\n\n多动画：\n\n  1. 首先使用`animation-name`来锁定使用的各个动画\n  2. 之后使用其它的`animation`族属性，分别约束对应动画，且设置顺序与`animation-name`使用动画的顺序保持一致。\n\n**为什么transform比top快**\n\n​ 因为top和left的改变会触发浏览器的 reflow和 repaint\n。整个动画过程都在不断触发浏览器的重新渲染，这个过程是很影响性能的。而`transform`\n动画由GPU控制该过程发生在合成线程，与渲染主线程无关，支持硬件加速。\n\n​ CSS\ntransform属性并不会触发当前元素或附近元素的relayout。浏览器将当前元素视为一个整体，它会缩放、旋转、移动这一整个元素。浏览器只需要在动画开始之时生成位图，然后将位图发送给GPU。之后浏览器不需要做额外的relayout和repaint，甚至不需要发送位图给GPU。浏览器只需要充分发挥GPU的长处：绘制同一张位图到不同的位置、旋转角度和缩放比例。\n\n    \n    \n    现代浏览器通常由两个重要的线程组成（主线程 和 合成线程）。这两个线程一起工作完成绘制页面的任务：\n    主线程需要做的任务如下：\n    - 运行Javascript\n    - 计算HTML元素的CSS样式\n    - layout (relayout)\n    - 将页面元素绘制成一张或多张位图\n    - 将位图发送给合成线程\n    \n    合成线程主要任务是：\n    \n    - 利用GPU将位图绘制到屏幕上\n    - 让主线程将可见的或即将可见的位图发给自己\n    - 计算哪部分页面是可见的\n    - 计算哪部分页面是即将可见的（当你的滚动页面的时候）\n    - 在你滚动时移动部分页面\n    \n    在很长的一段时间内，主线程都在忙于运行Javascript和绘制元素。\n    \n    \n\n**其他优化的策略还有：** \\- opacity替代visibility- 多个DOM统一操作（虽然V8会有缓存优化）-\n先将DOM离线，即display：none；修改后显示- 不要把DOM放在已给循环中作为循环变量- 不要使用table\n\n合成层与渲染层https://blog.csdn.net/weixin_44100002/article/details/121606441\n\n### 1.6 权重\n\n第一优先级：无条件优先的属性只需要在属性后面使用！important。它会覆盖页面内任何位置定义的元素样式。ie6不支持该属性。\n\n第二优先级：在html中给元素标签加style，即内联样式。该方法会造成css难以管理，所以不推荐使用。\n\n第三优先级：由一个或多个id选择器来定义。例如，#id{margin:0;}会覆盖.classname{margin:3pxl}\n\n第四优先级：由一个或多个类选择器、属性选择器、伪类选择器定义。如.classname{margin:3px}会覆盖div{margin:6px;}\n\n第五优先级：由一个或多个类型选择器定义。如div{marigin:6px;}覆盖*{margin:10px；}\n\n第六优先级：通配选择器，如*{marigin:6px;}\n\n权重优先级：行内样式（1000）>ID选择器（100）>类选择器（10）>标签选择器（1）>通用选择器（0）\n\n对于一个已经定位的盒子（即其 `position` 属性值不是 `static`，这里要注意的是 CSS 把元素看作盒子），`z-index` 属性指定：\n\n  1. 盒子在当前堆叠上下文中的堆叠层级。\n  2. 盒子是否创建一个本地堆叠上下文。\n\n### 1.7 居中\n\n​ 1）父、子元素宽高未知时\n\n  * table-cell（使用表格样式）\n\n    \n    \n    <style>\n    .table-wrap{\n            display: table-cell;\n            height: 200px;\n            width: 100px;\n            padding: 20px;\n            vertical-align: middle;\n            text-align: center;\n            border: 1px solid red;\n            }\n    </style>\n    <div  class=\"table-wrap\">\n        我是一大推文字，我想要垂直居中，这是省略这是省略这是省略这是省略\n    </div>\n    \n    \n\n  * flex 布局（父级 justify-content: center 和 align-items: center 即可）\n  * absolute + transform（定位的上、左为 50%，translate 上、左负 50%）\n  * absolute + margin: 0 auto（定位的上下左右为 0）\n  * Grid 网格布局\n  * 直接使用 table（改变结构实现，和第一条类似）\n\n​ 2）子元素固定宽高已知时（假设子元素宽高为 200px）\n\n  * absolute + calc（定位上、左负50%时减去子元素宽、高）\n  * absolute + 负margin（定位的上、左为 50%，margin 的上、左负子元素的一半）\n\n​ 3）父元素高度已知（假设为 400px），子元素宽高未知\n\n  * text-align + vertical-align\n\n​ text-align: center; 是给父元素设置的，使得父元素设置之后，它里面的行内级元素居中\n\n### 1.8 定位与脱标\n\n1）脱标：\n\n  * 元素设置position，并且position的值为fixed或absolute；【这里有两种**在流** 定位值，他们分别是`static`和`relative`】\n  * 元素添加浮动float，并且float的值不为none；\n\n​ 特点：\n\n  * 元素不再严格区分块级(block)、行内级(inline)，行内块级(inline-block)，若元素未设置宽度高度，那么元素的宽高将完全由内容决定；\n  * 不再给父元素汇报自身宽高，若父元素没有设置宽高，将不能撑起父元素；\n  * 即使原来是行内级元素也可以随意设置宽度高度；\n\n2）子绝父相\n\n​ 子绝父绝，子绝父固定都是可以的，absolute 的 left、right、top、bottom\n这几个定位的属性参照对象是最邻近的定位祖先元素，所以只要我们要相对与哪个祖先来定位只要将祖先设置为定位元素就行，至于是哪种就得看你的实际需求了，当希望子元素相对于父元素进行定位，又不希望父元素脱标的时候，我们才会会用到子绝父相。\n\n3） 定位属性\n\n  1. `position: static;`默认值。没有定位，元素出现在正常的流中（忽略 `top, bottom, left, right` 或者 `z-index` 声明）。元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。\n  2. `position: inherit;`即继承父元素的`position`值。\n  3. `position: relative;`\n  4. `position: absolute;`绝对定位的元素的位置相对于**最近的已定位祖先元素** ，如果元素没有已定位的祖先元素，那么它的位置相对于**最初的包含块** 。\n  5. `position: fixed;``fixed`元素脱离正常的文档流，所以它与`absolute`元素很相似，同样会被周围元素忽略，支持`top,bottom,left,right`属性，固定在屏幕的某个位置。不支持`IE6、IE7、IE8`。可以通过给该元素设置`position: absolute`并获取滚动条距离顶部高度加上某个固定高度来实现。\n  6. `position: sticky;`当元素距离页面视口（Viewport，也就是fixed定位的参照）顶部距离大于 0px 时，元素以 relative 定位表现，而当元素距离页面视口小于 0px 时，元素表现为 fixed 定位，也就会固定在顶部。\n\n须指定 top、right、bottom、left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。并且 top 和 bottom 同时设置时，top 生效的优先级高，left 和 right 同时设置时，left 的优先级高。设定为sticky 元素的任意父节点的 overflow 属性必须是 visible，否则 sticky 不会生效。如果 sticky 元素的任意父节点定位设置为 hidden，则父容器无法进行滚动，所以sticky 元素也不会有滚动然后固定的情况。如果 position:sticky 元素的任意父节点定位设置为 relative | absolute | fixed，则元素相对父元素进行定位，而不会相对 viewport 定位。\n\n### 1.9 选择器\n\n  * **伪类** ：以冒号(:)开头，用于选择处于特定状态的元素。\n\n    \n    \n    动态伪类：:visited(链接已访问时)、:focus、:hover等\n    状态伪类：:disabled、:empty、:required(表单项是否必填) 等\n    结构伪类：:first-child、:nth-of-type等\n    p:nth-child(odd){} //奇数行\n    p:nth-child(even){} //偶数行\n    其他伪类：:target(元素 id 匹配到哈希值时)、:lang(匹配到指定语言时)、:not()等\n    //顺序：link、visited、focus、hover、active 前三个无所谓，后两个保持一致\n    \n    \n\n  * 伪元素：以双冒号(::)开头，用于在文档中插入虚构的元素。\n  * 相邻选择器：\n\n​ +选择器。如果需要选择紧接在另一个元素后的元素，而且二者有相同的父元素，可以使用相邻兄弟选择器。\n\n​ ~ 选择器。作用是查找某一个指定元素的后面的所有兄弟结点。\n\n### 1.10 CSS3\n\n**CSS3** 新增东西众多，这里列举出一些关键的新增内容：\n\n  * 选择器：通用兄弟选择器、伪类选择器、伪元素选择器、否定选择器、状态伪类选择器\n  * 盒子模型属性： _border-radius、box-shadow、border-image_\n  * 背景： _background-size、background-origin、background-clip_\n  * 文本效果： _text-shadow、word-wrap_\n  * 颜色：新增 _RGBA，HSLA_ 模式\n  * 渐变：线性渐变、径向渐变\n  * 字体： _@font-face_\n  * 2D/3D转换： _transform、transform-origin_\n  * 过渡与动画： _transition、@keyframes、animation_\n  * 多列布局\n  * 媒体查询\n\n1）transition：transition-property | transition-duration | transition-timing-function | transition-delay |\n\n2）transform：translate() | rotate() | scale() | skew() |\n\n### 1.11 BFC\n\n块格式化上下文（Block Formatting Context，BFC）\n是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。它是页面中的一块渲染区域，并且有一套属于自己的渲染规则，它决定了元素如何对齐内容进行布局，以及与其他元素的关系和相互作用。\n当涉及到可视化布局的时候，BFC提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。\n\n​ BFC是一个独立的布局环境，BFC内部的元素布局与外部互不影响。\n\n​ BFC的布局规则：​ 1 内部的Box会在垂直方向一个接着一个地放置。​ 2\nBox垂直方向上的距离由margin决定。属于同一个BFC的两个相邻的Box的margin会发生重叠。​ 3\n每个盒子的左外边框紧挨着包含块的左边框，即使浮动元素也是如此。​ 4 BFC的区域不会与float box重叠。​ 5\nBFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。​ 6 计算BFC的高度时，浮动子元素也参与计算。\n\n​ 如何触发BFS:\n\n![](https://uploadfiles.nowcoder.com/files/20240306/707453548_1709707906758/v2-7d7017c7cd579f71ea67a6eb6dbf247e_720w.webp)\n\n​ BFC可以解决哪些问题？\n\n1 解决浮动元素令父元素高度坍塌的问题\n\n2 非浮动元素被浮动元素覆盖\n\n3 两栏自适应布局\n\n参考文献：\n\n  * ​ [一次弄懂css的BFC - 知乎 (zhihu.com)](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F127187654)\n\n**文档流：**\n\n文档流是由 CSS 定位语句定义的页面元素的排列，以及 HTML 元素的顺序。 也就是说，每个元素如何占用空间以及其他元素如何相应地定位自己。\n\n简单点说，就是 _document flow_ 指示了页面上的元素如何去**排列** 。接着，讲到了 _document flow_\n的三种影响元素位置的方法：\n\n>   * 显示类型：HTML 元素最初按其显示类型定位。 这种显示类型决定了其他元素是否能够位于它们旁边，以及填充、边距和其他 CSS 属性如何影响它。\n> 两种最重要的显示类型是：block 和 inline\n>   *\n> Float：浮动框是一种CSS属性，它允许你应用在一个块级元素上，可以把这个块级元素推到父类块的左边界或者右边界。浮动元素离开了正常的文档流。一个周知的问题是当多个子元素都为浮动时，造成父类块高度的丢失。关于`clearfix`，本质上也是利用BFC\n>   * 定位：这里有几个可以应该在元素上的定位值。应该在所有元素上的初始值是`static`，一个在“在流”类型，我们将在之后谈到。\n>\n\n​\n\n### 1.12 canvas\n\n1.canvas是html5的一个新标签，属于h5的新特性2.canvas标签是一个图形的容器，简单点说就是一块画布，你可以在上画矩形，圆形，三角形，折线等等,也可以用来画logo3.它是通过javascript来画的，即脚本绘制图形\n\ncanvas可以用来干啥呢？1.制作web网页游戏（但是如果代码写的不咋的游戏可能会非常卡）2.数据可视化（这么说你可能不明白，但我告诉你echarts就是基于canvas）3.广告banner的动态效果非常适合用canvas制作4.canvas还可以用来内嵌一些网页\n\n### 1.13 src和href\n\nhref标识超文本引用，用在link和a等元素上，href是引用和页面关联，是在当前元素和引用资源之间建立联系\n\nsrc表示引用资源，表示替换当前元素，用在img，script，iframe上，src是页面内容不可缺少的一部分。\n\nsrc是source的缩写，是指向外部资源的位置，指向的内部会迁入到文档中当前标签所在的位置；在请求src资源时会将其指向的资源下载并应用到当前文档中，例如js脚本，img图片和frame等元素。\n\n    \n    \n    <script src=\"js.js\"></script>当浏览器解析到这一句的时候会暂停其他资源的下载和处理，直至将该资源加载，编译，执行完毕，图片和框架等元素也是如此，类似于该元素所指向的资源嵌套如当前标签内，这也是为什么要把js饭再底部而不是头部。\n    \n    <link href=\"common.css\" rel=\"stylesheet\"/>当浏览器解析到这一句的时候会识别该文档为css文件，会下载并且不会停止对当前文档的处理，这也是为什么建议使用link方式来加载css而不是使用@import。\n    \n    \n\nlink和@import，两者都是外部引用CSS的方式，但是存在一定的区别：\n\n  * link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。\n  * link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。\n  * link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。\n  * ink支持使用Javascript控制DOM去改变样式；而@import不支持\n\n## (二)布局\n\n移动端布局主要分为单独制作移动端页面和响应式页面。单独制作分为流式布局（百分比）、flex布局、媒体查询布局和混合布局。响应式分为媒体查询和bootstarp。\n\n前端布局包括：静态布局、弹性布局（flexbox）、自适应布局（bootstrap）、流式布局（fluid）、响应式布局、浮动布局、定位布局。\n\n### 2.1 Flex\n\n​ flex 是 Flexible Box 的缩写，意为\"弹性布局\"。**块级和行内都可以指定** 。指定容器display: flex即可。​\n父容器有以下属性：flex-direction，flex-wrap，flex-flow，justify-content，align-items，align-\ncontent。\n\n  * ​ **flex-direction** 属性决定主轴的方向（row、column、row-resverse ）；\n  * ​ **flex-wrap** 属性定义，默认不换行，装不下会缩小子元素宽度；使用wrap换行；\n  * ​ **flex-flow** 属性是flex-direction属性和flex-wrap属性的简写形式 ，默认值为row nowrap；\n  * ​ **justify-content** 属性定义了项目在主轴上的对齐方式。(center\\flex-start\\space-around\\space-between)\n  * ​ **align-items** 属性定义单行在交叉轴上如何对齐。\n  * ​ **align-content** 属性定义了多行的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n​ 项目（子元素）也有一些属性：order，flex-grow，flex-shrink，flex-basis，flex，align-self。\n\n  * ​ flex定义子项目剩余空间，适合三栏布局。 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。（1 [1 1 auto]就是代表均匀分配元素，`flex:0`等同于`flex: 0 1 0%`相当于不可扩大，可缩小,表现形式为最小内容宽度。`flex:none`等同于设置`flex: 0 0 auto`相当于不可扩大，不可缩小,内容本身的宽度是多少就是多少）\n  * ​ order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n  * ​ flex-grow属性定义项目的放大比例，默认为0（不瓜分剩余空间），可以小于1但和要等于1。若min-content超出空间则作为最终宽度（可以通过设为0解决）。\n\n    \n    \n    剩余空间：x\n    假设有三个flex item元素，flex-grow 的值分别为a, b, c\n    每个元素可以分配的剩余空间为： a/(a+b+c) * x，b/(a+b+c) * x，c/(a+b+c) * x\n    \n    \n\n  * ​ flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\n    \n    \n    三个flex item元素的width: w1, w2, w3\n    三个flex item元素的flex-shrink：a, b, c\n    计算总压缩权重：\n    sum = a * w1 + b * w2 + c * w3\n    计算每个元素压缩率：\n    S1 = a * w1 / sum，S2 =b * w2 / sum，S3 =c * w3 / sum\n    计算每个元素宽度：width - 压缩率 * 溢出空间\n    \n    \n\n  * ​ flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。 max-width/min-width > flex-basis > width > box\n  * ​ align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 _auto_ ，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n\n### 2.2 响应｜移动\n\n**移动端布局：**\n\nviewport 即视窗、视口，用于显示网页部分的区域，在 PC\n端视口即是浏览器窗口区域，在移动端，为了让页面展示更多的内容，视窗的宽度默认不为设备的宽度，在移动端视窗有三个概念：布局视窗、视觉视窗、理想视窗\n\n  * 布局视窗：在浏览器窗口css的布局区域，布局视口的宽度限制css布局的宽。为了能在移动设备上正常显示那些为pc端浏览器设计的网站，移动设备上的浏览器都会把自己默认的 viewport 设为 980px 或其他值，通过 box-sizing 改变，一般都比移动端浏览器可视区域大很多，所以就会出现浏览器出现横向滚动条的情况\n  * 视觉视窗：终端设备显示网页的区域\n  * 理想视窗：针对当前设备最理想的展示页面的视窗，不会出现横向滚动条，页面刚好全部展现在视窗内，理想视窗也就是终端屏幕的宽度。\n\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-\nscalable=no, minimum-sacle=1, maximum-scale=1\" >//只对移动端浏览器有效\n\nwidth定义视口的宽度，单位为像素正整数或设备宽度；device-widthheight定义视口的高度，单位为像素正整数或device-\nheight；initial-scale定义网页初始缩放值整数或小数，小数为缩小，反之放大；maximum-\nscale定义缩放最大值整数或小数；minimum-scale定义缩放最小值整数或小数；user-scalable定义用户是否可以缩放yes/no\n\n**布局方法：** vw/vh 和百分比布局，响应式和 REM 布局。\n\n响应式布局：\n\n​ 需要为父级做一个布局容器，在不同的屏幕下通过媒体查询来改变布局容器的大小，在改变里面子元素的排列方式和大小。\n\n    \n    \n    @media screen and (max-width: 320px) {\n        body {background-color: red;}\n    \n    \n\n不管是移动优先还是PC优先，都是依据当随着屏幕宽度增大或减小的时候，后面的样式会覆盖前面的样式。因此，移动端优先首先使用的是`min-\nwidth`，PC端优先使用的`max-width`\n\n    \n    \n    -webkit-min-device-pixel-ratio: 1.5 //是指当时显示屏最小的色倍为1.5倍的\n    它是设备上物理像素和设备独立像素( device-independent pixels (dips) )的比例\n    \n    \n\n子元素的`height`或`width`中使用百分比，是相对于子元素的直接父元素，`width`相对于父元素的`width`，`height`相对于父元素的`height`；\n\n子元素的`top`和`bottom`如果设置百分比，则相对于直接非`static`定位(默认定位)的父元素的高度；\n\n子元素的`padding`如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的`width`，而与父元素的`height`无关。跟`padding`一样，`margin`也是如此；\n\n`border-radius`不一样，如果设置`border-radius`为百分比，则是相对于自身的宽度，除了`border-\nradius`外，还有比如`translate`、`background-size`等都是相对于自身的；\n\n从上述对于百分比单位的介绍我们很容易看出如果全部使用百分比单位来实现响应式的布局，有明显的以下两个缺点：\n\n  * 计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。\n  * 可以看出，各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如`width`和`height`相对于父元素的`width`和`height`，而`margin`、`padding`不管垂直还是水平方向都相对比父元素的宽度、`border-radius`则是相对于元素自身等等，造成我们使用百分比单位容易使布局问题变得复杂。\n\n**REM布局**\n\n`REM`是`CSS3`新增的单位，并且移动端的支持度很高，Android2.x+,ios5+都支持。`rem`单位都是相对于根元素html的`font-\nsize`来决定大小的,根元素的`font-size`相当于提供了一个基准，当页面的size发生变化时，只需要改变`font-\nsize`的值，那么以`rem`为固定单位的元素的大小也会发生响应的变化。\n因此，如果通过`rem`来实现响应式的布局，只需要根据视图容器的大小，动态的改变`font-size`即可（而`em`是相对于父元素的）。\n\n`css3`中引入了一个新的单位`vw/vh`，与视图窗口有关，`vw`表示相对于视图窗口的宽度，`vh`表示相对于视图窗口高度，除了`vw`和`vh`外，还有`vmin`和`vmax`两个相关的单位。(相对于视窗的宽度，1vw\n等于视口宽度的1%，即视窗宽度是100vw)\n\n注意：\n\n1物理像素线（也就是普通屏幕下1px,高清屏幕下0.5px的情况）采用`transform`属性`scale`实现\n\n`lib-flexible`并不独立出现，而是搭配`px2rem-loader`一起做适配方案，目的是**自动将css中的px转换成rem** 。\n\n**图片响应式**\n\n    \n    \n    img {\n        display: inline-block;\n        max-width: 100%;\n        height: auto;//证图片进行等比缩放而不至于失真\n    }\n    <img srcset=\"photo_w350.jpg 1x, photo_w640.jpg 2x\" src=\"photo_w350.jpg\" alt=\"\">\n    如果屏幕的dpi = 1的话则加载1倍图，而dpi = 2则加载2倍图，手机和mac基本上dpi都达到了2以上，这样子对于普通屏幕来说不会浪费流量，而对于视网膜屏来说又有高清的体验。\n    \n    \n\n参考：\n\nhttps://juejin.cn/post/6844903814332432397\n\n### 2.3 grid\n\n首先引入grid.css。定义：display：grid\n\n容器属性：\n\n**grid-template-** * (columns\\rows) 定义n×m的网格。可以利用repeat(auto-\nfill,x)自己分配，x可以定义为fr等分。\n\n**grid-*-gap** （缩写为gap）定义间距\n\n**grid-template-areas:** 定义每个项目的名字，不同区域名字可以相同，用.表示匿名\n\n**grid-auto-flow:** row column dense; 定自动布局算法按照通过逐行/列填充来排列元素\n\n**justify-items：**start|end|center|stretch 水平方向（align垂直） 两者合并为place-items\n\n**justify-content：**start|end|center|stretch|space-around 水平方向（align垂直）\n\n**grid-auto-*：**用来设置多出来的项目的宽和高\n\n项目属性：\n\n**grid-column|row-start|end:**指定item的具体位置，具体在那根网格线之间。简写grid-column：1 **/** 3;\n\n**justify-self / align-self** 只作用于单个项目设置垂直和水平\n\n### 2.4 flexible\n\n现在我们把设计稿分成10等份，设计稿 A =\nW/10，我们把设备可视区域也就是我们的各种移动端设备的这个画布也分成10份，并赋值给根元素的fontSize，我们都知道rem是根据根元素字体大小计算的，所以我们的1rem也就是设备可视区域/10，现在设计稿上有一块区域宽B，那它是不是等比放到设备可视区域的宽度为\nB/A rem。再啰嗦一下，B在设计稿上占B/A份，那在设备可视区域上也要占B/A份对不对，所以宽是B/A rem。\n\n    \n    \n    // 首先是一个立即执行函数，执行时传入的参数是window和document\n    function flexible (window, document) {\n      var docEl = document.documentElement // 返回文档的root元素\n      var dpr = window.devicePixelRatio || 1 \n      // 获取设备的dpr，即当前设置下物理像素与虚拟像素的比值\n      // 调整body标签的fontSize，fontSize = (12 * dpr) + 'px'\n      // 设置默认字体大小，默认的字体大小继承自body\n      // 当页面展示或重新设置大小的时候，触发重新\n      // 检测0.5px的支持，支持则root元素的class中有hairlines\n    }\n    \n    \n\n## (三)渲染\n\n### 3.1 阻塞渲染\n\n​\nHTML解析器在解析过程中如果遇到外部CSS与外部JS文件，就会同时发起请求对文件进行下载，这个过程DOM构建的过程会停止，需要等CSS文件下载完成并构建完CSSOM，JS文件下载完成并执行结束，才会开始构建DOM。如果遇到\nscript 标签，渲染线程会暂停渲染过程，将控制权交给 JS 引擎。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染线程，继续 DOM\n的解析。我们知道**CSS会阻塞JS的执行，所以JS必须要等到CSSOM构建完成之后再执行**\n\n  * js执行会阻塞DOM树的解析和渲染\n  * css加载不会阻塞DOM树的解析\n  * css加载会阻塞DOM树的渲染\n  * css加载会阻塞后面js语句的执行\n\n​\n当要执行一个html页面时，他需要预先加载从上往下读取html里面的内容：首先，它会创建一个存放标签名的栈，然后会创建一个dom树，当html的根节点<html>也被加载到栈中时,才会形成完整的dom树，页面展示以及前端的操作都是基于这个dom树的；\n\n而加载形成dom树的过程中：css是非阻塞的，它被下载完\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594864462255894528?sourceSSR=users",
        "title": "T3.整数分解结果的枚举(300分) - 华为机试真题题解",
        "content": "> 考试平台：\n> [时习知](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fshixizhi.huawei.com%2F)\n>\n> 分值： 300分（第三题）\n>\n> 考试时间： 2024-01-31 （两小时）\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n### 题目描述\n\n给你一个整数N(1<N<256),它的一个分解是![](https://www.nowcoder.com/equation?tex=N%20%3D%20a_1%20%20*%20%20%20a_2%20%20*%20%20a_3%20%20...%20%20%20a_x&preview=true)，其中![](https://www.nowcoder.com/equation?tex=1%3Ca_i%20%3C%20a_j%20\\(i%3Cj\\)&preview=true)\n对于整数N，请依次输出每一个分解(按照字典序)。\n\n例如，给定整数24，输出是\n\n    \n    \n    24=2*2*2*3\n    24=2*2*6\n    24=2*3*4\n    24=2*12\n    24=3*8\n    24=4*6\n    24=24\n    \n\n### 输入\n\n输入只有一个整数N\n\n### 输出\n\n按照字典序，依次输出整数N的每一个分解。\n\n### 示例1\n\n    \n    \n    输入：\n    11\n    \n    输出：\n    11=11\n    \n\n### 示例2\n\n    \n    \n    输入：\n    12\n    \n    输出：\n    12=2*2*3\n    12=2*6\n    12=3*4\n    12=12\n    \n\n### 题解\n\n> **题目解析:**\n>\n> 题目要求对给定的整数N进行因子分解，按照字典序依次输出每一个分解。分解要求每一个因子的值都不能小于前一个因子的值。\n>\n> **解题思路:**\n>\n>   1. 从最小的可能因子开始，遍历所有可能的因子。\n>\n>   2. 使用递归进行因子分解，递归的过程中维护一个因子列表，记录当前已经分解的因子。\n>\n>   3. 在递归的过程中，更新当前的因子列表，并在每一步判断是否满足因子的顺序条件。\n>\n>   4. 当整数N被分解成1时，输出当前的因子列表。\n>\n>\n\n>\n> **代码解释:**\n>\n>   * 定义一个全局变量 `N` 用于记录输入的整数N。\n>   * 定义 函数进行递归因子分解，参数包括待分解的数 和当前已分解的因子列表\n>\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594858622069354496?sourceSSR=users",
        "title": "腾讯实习基地一面（凉经）-IEG游戏数据",
        "content": "> 2024 -3月6日 10：00，50分钟\n\nJava后端岗，写了基架项目\n\n## 算法\n\n排序算法有哪些？\n\n手撕归并排序 （忙着背八股没复习）\n\n## 八股\n\n八股一句没问，全程拷打项目\n\n## web项目\n\nJWT令牌的原理\n\n## 数据库内核\n\n数据库持久性怎么实现？\n\n数据库日志的异步刷盘怎么实现？\n\n异步刷盘中持久性还能保证吗？\n\n## OS\n\nfork() 的原理，哪里体现了fork分配资源？\n\nfork()是把进程从1个变成2个，那么最初的进程是从哪里来的？\n\n启动进程是用户态还是内核态？\n\n进程和线程的关系和区别？\n\n进程是通过fork创建的，linux下线程是怎么创建的？\n\n## 反问：\n\n  * 游戏数据部门做基架还是算法？答：推荐算法落地\n  * 我第一次面试，有哪些需要深入学习的地方？ 答：我们部门对算法要求至少要做出一道，这是一个很大的要求\n\n## 感受\n\n非竞赛小白纯fw第一次面试，归并细节没处理好题没做出来项目问的很深，只要是简历上写了的词都会很详细地拷打\n\n面完秒挂，符合自身表现😅\n\n感觉不能胡投了，专心提升算法水平😭😭\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594856254258810880?sourceSSR=users",
        "title": "阿里云实习一面",
        "content": "电话面，全程二十几分钟，因为之前加过面试官微信做过笔试，所以感觉这个时间也是合理的。\n\n笔试\n\n  1. 写一个单例\n  2. 三个线程循环打印a, l, i\n  3. 一道算法题，mid吧，实在想不起来了\n\n电话面\n\n  1. 自我介绍\n  2. 实习项目，围绕项目问了一堆问题\n  3. Kafka相关，消息积压怎么办？如何保证消息有序？\n  4. 介绍Java面向对象特性，多态如何实现的？\n  5. 浏览器输入url到页面渲染的总过程\n  6. TCP三次握手过程，两次行不？\n  7. JVM内存模型，gc具体过程\n  8. 反问\n\n大概就是这些，不知道能不能过。阿里云流程看往年的面经是比较长的，走一步算一步吧..\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594844541245530112?sourceSSR=users",
        "title": "天讯瑞达测试一面",
        "content": "1.自我介绍\n\n2.怎么针对你自己项目进行测试的，测试了哪些方面\n\n3.测试的流程\n\n4.项目开发或者测试的过程中遇到过什么难点，怎么解决的\n\n5.项目中遇到过难以复现的bug吗，怎么解决的\n\n6.为什么选择测试这条路\n\n7.反问主要业务\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594840002828177408?sourceSSR=users",
        "title": "阿帕斯大模型  测开",
        "content": "一面\n\n深挖项目\n\n聊前同事\n\n离职原因\n\n反问\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594817738107781120?sourceSSR=users",
        "title": "大数据开发面经汇总【持续更新...】",
        "content": "美团高频数开面试题分享|2024届校园招聘即将开始：[https://www.nowcoder.com/discuss/515311167196160000?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F515311167196160000%3FsourceSSR%3Dusers)\n\n字节最全数开面试题|有同学拿了字节提前批offer：[https://www.nowcoder.com/discuss/509134018885992448?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F509134018885992448%3FsourceSSR%3Dusers)\n\n快手大数据开发高频面试题及答案【海量hc】：[https://www.nowcoder.com/discuss/527892445468577792?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F527892445468577792%3FsourceSSR%3Dusers)\n\n微众大数据开发高频面试题及答案【附JD分析】：[https://www.nowcoder.com/discuss/524354930111537152?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F524354930111537152%3FsourceSSR%3Dusers)\n\n阿里巴巴大数据开发高频面试题及答案【互联网回暖了！！！】：[https://www.nowcoder.com/discuss/519811764528136192?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F519811764528136192%3FsourceSSR%3Dusers)\n\n京东大数据开发高频面试题及答案【互联网回暖了！！！】：[https://www.nowcoder.com/discuss/516538688231227392?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F516538688231227392%3FsourceSSR%3Dusers)\n\n字节跳动大数据开发面经答案汇总之Hadoop篇：[https://www.nowcoder.com/discuss/491283988275896320?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F491283988275896320%3FsourceSSR%3Dusers)\n\n字节跳动大数据开发面经答案汇总之zookeeper篇：[https://www.nowcoder.com/discuss/491555813824221184?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F491555813824221184%3FsourceSSR%3Dusers)\n\n字节跳动大数据开发面经答案汇总之Flink篇：[https://www.nowcoder.com/discuss/492276100182163456?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F492276100182163456%3FsourceSSR%3Dusers)\n\n字节跳动大数据开发面经答案汇总之Spark篇上集：[https://www.nowcoder.com/discuss/492689877264302080?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F492689877264302080%3FsourceSSR%3Dusers)\n\n字节跳动大数据开发面经答案汇总之Spark篇下集：[https://www.nowcoder.com/discuss/493441649276649472?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F493441649276649472%3FsourceSSR%3Dusers)\n\n百度数开高频面试题|有同学收到面试邀请了吗：[https://www.nowcoder.com/discuss/512348773390036992?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F512348773390036992%3FsourceSSR%3Dusers)\n\noppo数开高频面试题|有同学拿了OPPO提前批offer：[https://www.nowcoder.com/discuss/507507301431992320?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F507507301431992320%3FsourceSSR%3Dusers)\n\nshein大数据开发暑期实习面经答案：[https://www.nowcoder.com/discuss/494087402147835904?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F494087402147835904%3FsourceSSR%3Dusers)\n\n结合真实场景的Flink面试题【附答案解析】：[https://www.nowcoder.com/discuss/576530758798491648?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F576530758798491648%3FsourceSSR%3Dusers)\n\nFlink六道必考面试题总结【附答案解析】：[https://www.nowcoder.com/discuss/564572980232065024?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F564572980232065024%3FsourceSSR%3Dusers)\n\n数据人必会的面试场景题【字节、美团、阿里等大厂】：[https://www.nowcoder.com/discuss/562201750090813440?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F562201750090813440%3FsourceSSR%3Dusers)\n\n大数据面试大厂真题【附答案详细解析】：[https://www.nowcoder.com/discuss/558258646493208576?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F558258646493208576%3FsourceSSR%3Dusers)\n\n震惊！！！数据倾斜满分回答模板来了【大厂面试必问】：[https://www.nowcoder.com/discuss/551853196625330176?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F551853196625330176%3FsourceSSR%3Dusers)\n\n一篇文章带你了解MapReduce的前世今生：[https://www.nowcoder.com/discuss/540642611804057600?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F540642611804057600%3FsourceSSR%3Dusers)\n\n大数据开发场景题【大厂面试常问】：[https://www.nowcoder.com/discuss/535423705904644096?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F535423705904644096%3FsourceSSR%3Dusers)\n\n2023最新大数据开发面试笔记V4.0：[https://www.nowcoder.com/discuss/500412002142003200?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F500412002142003200%3FsourceSSR%3Dusers)\n\n大数据核心101问：[https://www.nowcoder.com/discuss/539736719088799744?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F539736719088799744%3FsourceSSR%3Dusers)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594811070066307072?sourceSSR=users",
        "title": "查找接口成功率最优时间段 - 华为OD统一考试(C卷)",
        "content": "> OD统一考试（C卷）\n>\n> 分值： 100分\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n服务之间交换的接口成功率作为服务调用关键质量特性，某个时间段内的接口失败率使用一个数组表示。\n\n数组中每个元素都是单位时间内失败率数值，数组中的数值为0~100的整数，\n\n给定一个数值(minAverageLost)表示某个时间段内平均失败率容忍值，即平均失败率小于等于minAverageLost.找出数组中最长时间段，\n\n如果未找到则直接返回NULL。\n\n## 输入描述\n\n有两行内容，\n\n第一行为 minAverageLost，\n\n第二行为数组，数组元素通过空格(\" \")分隔,\n\nminAverageLost及数组中元素取值范围为0~100的整数，数组元素的个数不会超过100个\n\n## 输出描述\n\n找出平均值小于等于minAverageLost的最长时间段，输出数组下标对，格式{beginIndex}-{endIndex} (下标从0开始)，\n\n如果同时存在多个最长时间段，则输出多个下标对且下标对之间使用空格(” “)拼接，多个下标对按下标从小到大排序。\n\n## 示例1\n\n    \n    \n    输入：\n    1\n    0 1 2 3 4\n    \n    输出：\n    0-2\n    \n    说明：\n    A、输入解释：minAverageLost=1，数组[0, 1, 2, 3, 4]\n    B、前3个元素的平均值为1，因此数组第一个至第三个数组下标，即0-2\n    \n\n## 示例2\n\n    \n    \n    输入：\n    2\n    0 0 100 2 2 99 0 2\n    \n    输出：\n    0-1 3-4 6-7\n    \n    说明：\n    A、输入解释：minAverageLost=2，数组[0, 0, 100, 2, 2, 99, 0, 2]\n    B、通过计算小于等于2的最长时间段为：数组下标为0-1即[0, 0]，数组下标为3-4即[2, 2]，数组下标为6-7即[0, 2]，这三个部分都满足平均值小于等2的要求，因此输出0-1 3-4 6-7\n    \n\n## 题解\n\n> **解题思路：**\n>\n>   1. 输入最小平均失败率和失败率数据。\n>   2. 使用前缀和数组 `psum` 记录从头开始到每个位置的失败率累加和。\n>   3. 使用两层循环遍历所有可能的时间段，通过前缀和数组判断平均失败率是否小于等于给定的阈值。\n>   4. 如果找到一个满足条件的时间段，比较其长度是否大于当前已知的最大长度，更新最大长度和结果数组。\n>   5. 最终输出所有满足条件的最长时间段。\n>\n\n### Java\n\n    \n    \n    import java.util.ArrayList;\n    import java.util.List;\n    import java.util.Scanner;\n    /**\n     * @author code5bug\n     */\n    public class Main {\n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n    \n            int minAverageLost = scanner.nextInt();\n    \n            List<Integer> losts = new ArrayList<>();\n            while (scanner.hasNextInt()) {\n                losts.add(scanner.nextInt());\n            }\n    \n            int n = losts.size();\n    \n            // 前缀和\n            int[] psum = new int[n + 1];\n            for (int i = 0; i < n; i++) {\n                psum[i + 1] = psum[i] + losts.get(i);\n            }\n    \n            int maxLength = 1;\n            List<int[]> result = new ArrayList<>();\n    \n            for (int l = 0; l < n; l++) {\n                for (int r = l + maxLength - 1; r < n; r++) {\n                    int length = r - l + 1;\n               \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594810895365120000?sourceSSR=users",
        "title": "上海某小厂java面经",
        "content": "1.拷打项目\n\n2.经典八股\n\n2.1 jvm内存模型\n\n2.2 垃圾回收算法有哪些\n\n2.3 熟悉的垃圾回收器\n\n2.4 cms有哪些阶段是stw的\n\n2.5 G1 里面的young gc和mixed gc区别\n\n2.6 一个对象是怎么从年轻代到老年代的\n\n2.7 full gc什么时候发生\n\n2.8 项目中full gc的次数怎么样\n\n2.9 mysql当中的索引\n\n2.10 聚簇索引和非聚簇索引的区别\n\n2.11 docker 如何查看挂载目录\n\n2.12 git常用命令\n\n2.13 git reset 中 -hard 和 -soft 区别 , 默认是哪个？\n\nupdate: 已oc\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594684856647286784?sourceSSR=users",
        "title": "滴滴Android实习面经",
        "content": "## 一面（2024/3/5 52min）\n\n  1. 自我介绍\n  2. 聊实习，实习的主要工作是什么？\n  3. 聊项目，手机上有这个项目吗？展示一下\n  4. 说一下MVP模式\n  5. 说一下MVVM模式的set()和get()是怎么实现的，数据的绑定是通过什么实现的？当时没有get到要问啥，现在想想应该是要问DataBinding和ViewBinding\n  6. 说一下抽象类和接口的区别？抽象类和接口可以有方法体吗？Java可以多实现或者多继承吗？\n  7. 如何保证线程安全？\n  8. ArrayList和LinkedList的区别？LinkedList的链表是单链表还是双链表?双向链表\n  9. HashMap和HashTable的区别?\n  10. HashMap的底层实现？哈希冲突如何解决？\n  11. 说一说你熟悉的几个设计模式？\n  12. 单例模式的分类？\n  13. 写一个双重校验锁\n  14. 写一个冒泡排序\n  15. JVM的内存划分？\n  16. String s1=\"1\"; String s2=new String();这两个字符串创建所存在的位置\n  17. ==和equals的区别？\n  18. 深拷贝和浅拷贝的区别？\n  19. 说一说Kotlin的扩展函数？扩展函数的原理是什么？\n  20. 垃圾回收算法都有哪些？年轻代和老年代所用的算法的区别？\n  21. 讲一讲Handler机制？Looper是线程唯一的吗？主线程的Looper的创建时机？ActivityThread的main()方法\n  22. 现在push一个延迟消息到消息队列里，这时候忽然退出应用程序了，会有什么问题？\n  23. 如何解决内存泄漏？\n  24. View的事件分发机制？解决过滑动冲突吗？自定义过View吗？如何实现的？\n  25. 触发invalidate()和requestLayout()会发生什么？\n  26. 现在需要设置RecyclerView的每个item都不一样如何实现？\n  27. TCP和UDP的区别？可以多连接吗？\n  28. HTTP和HTTPS的区别？对称加密和非对称加密？说一些常见网络错误码？\n\n反问：\n\n  1. 部门技术栈？Kotlin语言为主，有一套自己设计的架构\n  2. 面试官您觉得我还有哪方面的不足吗？\n  3. 这个岗位是日常还是暑期转正实习？\n  4. 面试一共有几面？至少还有一轮技术面\n\n总结：第一次遇到这么多八股的面试，在面试的时候就感觉问的好多，整理面经发现真的好多，2024年的首面，发挥的不是很好，有些八股没遇到过，还有实习不是写业务的，有些业务问题感觉说的不是很好，那道业务的场景题也没答上来。\n\n—————————更新—————————\n\n## 二面（2024/3/10 70min）\n\n  1. 自我介绍\n  2. 聊实习做了什么工作，问的很细节，会问到具体是怎么实现的\n  3. MVP架构的引用关系？内存泄漏如何解决？\n  4. Kotlin的空检验机制，如果说在Java调用Kotlin可空参数函数传入null，会发生什么情况？空指针异常\n  5. 说一说协程？协程和线程的区别？\n  6. 说一说高阶函数和内联函数？内联函数高效的原因？\n  7. 说一说泛型？泛型擦除？如何获取泛型的实际类型？\n  8. 手写一个可以不需判空的扩展函数，面试官自己出的，因为有个概念我不清楚所以面试官也就没让我写下去了\n  9. 说一说Fragment，Fragment的生命周期\n  10. 说一说Handler机制\n  11. 如何获取view的视图的宽高\n  12. view.post()的原理\n\n反问：\n\n同一面\n\n总结：二面没有像一面一样有那么多的八股，但是会问的很深很细节\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594677947966009344?sourceSSR=users",
        "title": "今日战绩 java约面",
        "content": "![](https://uploadfiles.nowcoder.com/images/20240305/489166760_1709653891567/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n今天的份额投满了，13家要简历，约了一个面试，还有一个打电话问情况，大概内容如下：\n\n  * 介绍一下参加的比赛\n  * 介绍一下项目负责内容\n  * 怎么实现一致性\n  * 还有就是时间和找这个实习的目的\n  * 反问\n\n打电话的应该是G了，感觉没回答好，比较突然\n\n有没有佬说说反问应该问什么[牛泪][牛泪]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594675242270793728?sourceSSR=users",
        "title": "3.4腾讯后台开发一面｜讲解｜0305",
        "content": "今天挑选一篇腾讯的后台开发实习一面，给大家做**讲解分析，参考回答和学习资料指引** ，期望对大家有所帮助～\n\n>\n> [原贴链接](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F594457518957408256)\n>\n>\n> ![alt](https://uploadfiles.nowcoder.com/images/20240305/7538287_1709653197416/D2B5CA33BD970F64A6301FA75AE2EB22)\n> **感谢这位同学的分享，预祝后续Offer 多多～～**\n\n面试题中，如果简历或项目没用过Flink的话，一般不会考察，所以这里也不做讲解\n\n开始吧～～～\n\n## 1.讲一下TCP三次握手 为什么要3次，两次或者四次不行吗\n\n**解析：** ：\n\nTCP三次握手四次挥手，重点掌握\n\n**参考回答：**\n\n> TCP 建立连接时，通过三次握手能**防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号**\n> 。序列号能够保证数据包不重复、不丢弃和按序传输。\n>\n> **不使用「两次握手」和「四次握手」的原因：**\n>\n>   * 「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；\n>   * 「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。\n>\n\n**学习指引：**\n\n理解学习：[《小林coding》｜图解网络｜为什么是三次握手？不是两次、四次？](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fxiaolincoding.com%2Fnetwork%2F3_tcp%2Ftcp_interview.html%23%25E4%25B8%25BA%25E4%25BB%2580%25E4%25B9%2588%25E6%2598%25AF%25E4%25B8%2589%25E6%25AC%25A1%25E6%258F%25A1%25E6%2589%258B-%25E4%25B8%258D%25E6%2598%25AF%25E4%25B8%25A4%25E6%25AC%25A1%25E3%2580%2581%25E5%259B%259B%25E6%25AC%25A1)\n\n## 2.讲一下常见的针对TCP的网络攻击？如何应对SYN flood攻击？\n\n**解析：** ：\n\n推荐需要掌握。\n\n**参考回答：**\n\n>   * **SYN Flood攻击** ：这是一种利用TCP协议握手过程中的缺陷进行的攻击。攻击者发送大量的TCP\n> SYN请求到目标服务器，但在收到服务器的SYN+ACK响应后并不发送最后的ACK确认，导致服务器上留下大量等待完成的半开连接，耗尽服务器资源，使得正常的TCP连接无法建立。\n>   * **TCP会话劫持**\n> :这种攻击方式是通过窃取TCP会话中的序列号等信息，然后冒充合法用户接入到会话中。攻击者可以监听网络上的TCP会话，分析并预测序列号，然后发送伪造的数据包，中断或篡改原有的会话内容。\n>   * **TCP重置攻击** : 在这种攻击中，攻击者发送伪造的TCP\n> RST（重置）数据包到目标主机，中断正常的TCP连接。由于TCP协议的设计，当接收到RST数据包时，连接的两端都会关闭连接，这使得攻击者可以成功地中断服务或进行拒绝服务攻击。\n>\n\n> **如何应对SYN flood攻击？**\n>\n>   1. 启用SYN Cookie技术：SYN\n> Cookie是一种无状态的TCP连接技术，它通过计算一个独特的Cookie来验证TCP连接的合法性，而不需要在服务器上保存每个连接的状态信息。当服务器收到SYN请求时，它会计算一个Cookie并发送给客户端，客户端在后续的ACK报文中携带该Cookie，服务器通过验证Cookie的有效性来判断连接是否合法。这样可以有效减少服务器资源的消耗，并防止SYN\n> flood攻击导致的资源耗尽。\n>   2. 调整TCP协议栈参数：通过调整TCP协议栈的参数，可以优化服务器的性能和防御SYN flood攻击。例如，可以减小SYN\n> Timeout时间，使服务器更快地释放无效的连接请求；增大TCP连接的队列长度，提高服务器处理连接请求的能力；启用TCP Fast\n> Open等特性，加快TCP连接的建立过程。\n>   3.\n> 使用防火墙或入侵检测系统（IDS）：防火墙或IDS可以监控网络流量，并识别出异常的SYN请求流量。它们可以根据预设的规则对恶意流量进行过滤或限制，从而保护服务器免受SYN\n> flood攻击的侵害。\n>\n\n**学习指引：**\n\n面试学习：[《JavaGuild》|网络攻击常见手段总结](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjavaguide.cn%2Fcs-\nbasics%2Fnetwork%2Fnetwork-attack-means.html%23syn-\nflood-%25E6%25B4%25AA%25E6%25B0%25B4)\n\n## 3.讲一下TCP的TIME_WAIT状态，如果服务器中存在大量的这个状态应该怎么排查？\n\n**解析：** ： 系统掌握TCP的三次握手四次挥手相关内容，再按自己理解回答这个问题。\n\n**参考回答：**\n\n> **介绍TIME_WAIT状态**\n> ：当TCP连接的一方（通常是客户端）主动关闭连接时，会发送一个FIN包给对方，表示希望关闭连接。服务端通常会回一个ACK确认包。当服务端也完成发送后，会再次发送一个FIN包给客户端，此时客户端接收到FIN后会回复一个ACK给服务端，之后客户端会进入TIME_WAIT状态。在TIME_WAIT状态下，连接会保持一段时间（通常是2MSL，即最大报文段生存时间的两倍），以确保在网络中延迟的数据包能够被正确处理\n> ![alt](https://uploadfiles.nowcoder.com/images/20240306/7538287_1709689597610/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n> **如何排查TIME_WAIT**\n>\n>   1. **确认TIME_WAIT状态的数量** ： 使用`netstat`命令来查看当前TCP连接的状态分布。例如，运行`netstat -nat | grep TIME_WAIT | wc -l`可以查看TIME_WAIT状态的连接数。\n>\n>   2. **查看系统TCP参数** ： 使用`sysctl -a | grep tcp`命令可以查看系统中与TCP相关的内核参数设置，特别关注`net.ipv4.tcp_tw_reuse`、`net.ipv4.tcp_tw_recycle`（在某些情况下可能不推荐启用）和`net.ipv4.tcp_fin_timeout`等参数的设置。\n>\n>   3. **分析网络连接和应用程序行为** ： 确定哪些应用程序或服务正在产生大量的TIME_WAIT连接。使用`netstat\n> -natp`可以查看每个连接的进程ID和程序名称。\n>\n>\n\n>   4. **检查网络问题和延迟** ：\n> 网络问题或延迟可能导致连接不能正常关闭，从而产生大量的TIME_WAIT状态。使用网络诊断工具（如`ping`、`traceroute`等）来检查网络状况。\n>\n\n**学习指引：** [《知乎》｜运维排查篇\n服务器产生大量的TIME_WAIT的原因你知道吗？](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F419752048)\n\n## 4.如果项目中出现CPU占用过高的情况，该怎么排查和处理？\n\n**解析：** ： 高频面试题，需要掌握\n\n**参考回答：**\n\n> 在Linux环境下，项目出现CPU占用过高的情况时，可以按照以下步骤进行排查和处理：\n>\n>   1. **定位高CPU占用的进程** ：\n>\n\n>   * 使用`top`命令查看系统中CPU占用率最高的进程。\n>\n>\n\n>   2. **分析进程中的线程** ：\n>\n\n>   * 如果发现某个进程的CPU占用率特别高，可以使用`top -H -p [PID]`来查看该进程中各个线程的CPU占用情况。\n>\n>   * 找出占用CPU最高的线程ID。\n>\n>\n\n>   3. **转换线程ID为16进制** ：\n>\n\n>   * 使用`printf \"%x\\n\" [线程ID]`命令将线程ID转换为16进制格式。\n>\n>\n\n>   4. **获取线程堆栈信息** ：\n>\n\n>   * 使用`jstack [进程PID] | grep [线程ID的16进制] -A 30`命令获取该线程的Java堆栈信息（如果是Java进程）。这可以帮助定位到具体的代码行或方法调用。\n>\n>   * 如果不是Java进程，可以使用`gdb`或其他相应的调试工具来获取线程的堆栈信息。\n>\n>\n\n>   5. **分析代码和日志** ：\n>\n\n>   * 根据堆栈信息，检查相关的代码逻辑，看是否有死循环、资源泄露、复杂计算等导致CPU占用过高的问题。\n>\n>   * 同时检查应用程序的日志，看是否有异常或错误信息与高CPU占用相关。\n>\n>\n\n>   6. **处理措施** ：\n>\n\n>   * 如果是代码问题，修复相应的bug或优化算法。\n>   * 如果是配置问题，调整系统或应用程序的配置参数。\n>   * 如果是资源不足，考虑增加硬件资源或优化资源分配。\n>   * 如果是外部攻击，加强系统的安全防护措施。\n>\n\n**学习指引：**\n[博客｜线上高CPU占用、高内存占用排查思路](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fbaiye_xing%2Farticle%2Fdetails%2F90483169)\n\n## 5.介绍一下Linux常见命令？top命令具体是做什么的？\n\n**解析：** ： linux 常用命令需要掌握，top就是最简单最重要的的之一 **参考回答：**\n\n> 大家记忆一些，根据记忆回答就行，例如\n>\n>   * chmod：更改文件或目录的权限。\n>   * cat：查看文件内容。 ......\n>\n\n> **top命令具体是做什么的？**\n> top命令，它是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况.该命令可以提供实时的对系统处理器的状态监视，它会显示系统中CPU最“敏感”的任务列表，并且可以按CPU使用、内存使用和执行时间对任务进行排序\n\n**学习指引：**\n\n[面试常考21条Linux命令](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.jianshu.com%2Fp%2F4bca8fe8a878)\n\n[一周学会Linux](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1Sv411r7vd%2F%3Fvd_source%3D7671cf3fe9ab7359cf92eaa34075e23d)\n\n## 6.讲一下HashMap，为什么HashMap要引入红黑树？为什么树化的默认节点是8？如果不用红黑树如何处理过长的链表？\n\n**解析：** ： HashMap是Java容器最高频的面试点。 **参考回答：**\n\n> **为什么HashMap要引入红黑树？**\n> 引入之前，当发生哈希冲突时，数据是以链表的形式进行存储的，如果冲突严重，链表就会过长，链表O（N）的复杂度性能太差。用红黑树期望是把复杂度降到O（log\n> n）\n\n> **为什么树化的默认节点是8？** 根据JDK 设计者的解释：和hashcode碰撞次数的泊松分布有关，主要是为了寻找一种时间和空间的平衡。\n>\n>\n> 红黑树中的TreeNode是链表中的Node所占空间的2倍，虽然红黑树的查找效率为o(logN)，要优于链表的o(N)，但是当链表长度比较小的时候，即使全部遍历，时间复杂度也不会太高。固，要寻找一种时间和空间的平衡，即在链表长度达到一个阈值之后再转换为红黑树。\n> 之所以是8，是因为Java的源码贡献者在进行大量实验发现，hash碰撞发生8次的概率已经降低到了0.00000006，几乎为不可能事件，如果真的碰撞发生了8次，那么这个时候说明由于元素本身和hash函数的原因，此时的链表性能已经已经很差了，操作的hash碰撞的可能性非常大了，后序可能还会继续发生hash碰撞。所以，在这种极端的情况下才会把链表转换为红黑树.\n\n> **如果不用红黑树如何处理过长的链表？**\n>\n>   * **使用其他数据结构** :除了红黑树之外，还可以考虑使用其他数据结构来优化长链表的问题。例如，可以使用平衡树（如 AVL\n> 树）、B树或B+树等。这些数据结构都可以在 O(log n) 的时间复杂度内完成查找、插入和删除操作.\n>\n\n**学习指引：**\n\n系统学习：[《JavaGuide》| HashMap\n源码分析](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjavaguide.cn%2Fjava%2Fcollection%2Fhashmap-\nsource-code.html)\n\n面试题学习：[博客｜HashMap的树化门槛为什么是8](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2FCSDN4006600%2Farticle%2Fdetails%2F101201003)\n\n## 1.HashMap是线程安全的吗？如果不是那什么是？为什么ConcurrentHashMap是线程安全的？是如何实现线程安全的呢？\n\n**解析：** ： 面试常见套路，先问HashMap 再 问 ConcurrentHashMap。\n关于线程安全的实现，一般会结合JDK1.7和JDK1.8一起来回答，当然也可以只回答JDK1.8,如果面试官问到1.7你再回答。所以需要两个版本一起掌握\n\n**参考回答：**\n\n> HashMap 不是现成安全的，需要保证现成安全的话，推荐使用ConcurrentHashMap。\n\n> **如何实现线程安全的？**\n>\n>   * JDK\n> 1.7中的ConcurrentHashMap通过分段锁（Segmentation）实现线程安全。它将整个哈希表分成多个段（Segment），每个段都是一个小的哈希表，并且拥有自己的锁。这样，多个线程可以并发地访问不同的段，从而减少了锁的竞争，提高了并发性能。\n>   * JDK\n> 1.8中的ConcurrentHashMap则采用了完全不同的设计。它摒弃了分段锁的概念，转而使用了一种更细粒度的锁策略，结合CAS（Compare-\n> and-Swap）无锁算法来实现线程安全。在JDK\n> 1.8中，ConcurrentHashMap将整个哈希表看作一个整体，不再进行分段。而是通过数组+链表+红黑树的结构来存储数据，并使用Synchronized和CAS来协调并发访问。\n>\n\n**学习指引：** 面试学习：[《JavaGuide》｜ConcurrentHashMap\n源码分析](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjavaguide.cn%2Fjava%2Fcollection%2Fconcurrent-\nhash-map-source-code.html)\n\n## 1.介绍一下Base64编码的原理，为什么Base64编码会使数据体积变大33%？\n\n**解析：** ： 不太高频。推荐了解掌握。\n\n**参考回答：**\n\n> **Base64编码是**\n> :一种基于64个可打印字符来表示二进制数据的方法。其编码原理是将一个8位字节序列拆散为6位的片段，并为每个6位的片段分配一个字符，这64个字符包括小写字母a-z、大写字母A-Z、数字0-9、符号\"+\"和\"/\"。实际上，还有一个垫字符\"=\"，用于编码后的数据长度不是4的倍数时进行填充，因此严格来说有65个字符。\n\n> **Base64编码会使数据体积变大33%左右的原因**\n> :在于其编码方式。原始的二进制数据是按照8位一个字节进行存储的，而Base64编码将其拆分为6位一组，并用一个字符表示。这样，原本3个字节（24位）的数据被编码成了4个字符（每个字符8位，共32位）。因此，编码后的数据长度大约是原始数据长度的4/3，即增加了约33%。\n\n**学习指引：**\n\n了解学习：[Base64编码使数据量变大的原因详解](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fweixin_40611659%2Farticle%2Fdetails%2F104917094)\n\n## 1.为什么Redis Pub/Sub比Kafka更快一些？二者之间如何选取？\n\n**解析：** ：\n\n频率一般，推荐掌握。重在理解redis本身特点和Kafka的实现原理。然后推导回答，不要背。\n\n**参考回答：**\n\n> **为什么Redis Pub/Sub比Kafka更快一些？**\n> Redis是一个内存数据库，其Pub/Sub功能将消息保存在内存中。由于内存访问速度通常远快于磁盘访问速度，因此Redis在处理实时性较高的消息推送时具有优势。此外，Redis的Pub/Sub模型相对简单，使得它在处理发布和订阅操作时的开销较小。\n> 然而，Kafka是一个完整的系统，提供了高吞吐量、分布式的提交日志。它旨在处理大规模数据流，具有强大的持久化能力和容错性。Kafka的分布式架构和分区机制使得它能够在多个消费者之间实现负载均衡，从而提高整体处理能力。\n\n> **二者之间如何选取？**\n>\n> **Redis PUB/SUB使用场景：**\n>\n>   1. 消息持久性需求不高\n>   2. 吞吐量要求不高\n>   3. 可以忍受数据丢失\n>   4. 数据量不大\n>\n\n>\n> **Kafka使用场景：**(上面以外的其他场景)\n>\n>   1. 高可靠性\n>   2. 高吞吐量\n>   3. 持久性高\n>   4. 多样化的消费处理模型\n>\n\n**学习指引：**\n面试学习：[《知乎》｜Redis与Kafka的区别](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F140760487)\n\n## 1.Kafka是如何做到数据持久化的？\n\n**解析：** ：\n\nKafka相关高频面试题，Kafka重要原理知识点之一，推荐掌握\n\n**参考回答：**\n\n>   1. Kafka把Topic中一个Partition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完成的文件，减少磁盘占用\n>   2. 通过索引信息可以快速定位Message和确定response的最大大小\n>   3. 通过将索引元数据全部映射到 memory，可以避免 Segment 文件的磁盘I/O操作\n>   4. 通过索引文件稀疏存储，可以大幅降低索引文件元数据占用空间大小\n>\n\n**学习指引：** 面试学习：[《40 道精选 Kafka\n面试题》](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjavabetter.cn%2Finterview%2Fkafka-40.html%23_3%25E3%2580%2581kafka-%25E6%2596%2587%25E4%25BB%25B6%25E9%25AB%2598%25E6%2595%2588%25E5%25AD%2598%25E5%2582%25A8%25E8%25AE%25BE%25E8%25AE%25A1%25E5%258E%259F%25E7%2590%2586)\n\n本文也是 **《热门面经讲解》专栏** 系列文章之一，**文末尾有专栏链接** ，大家可以**点个关注** ，我会持续更新～～\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594669710751305728?sourceSSR=users",
        "title": "阿里淘天二面面经（社招）",
        "content": "## 一面面经\n\n[https://www.nowcoder.com/feed/main/detail/6886adb319e14f859f48ce5e413968d7?sourceSSR=users](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Ffeed%2Fmain%2Fdetail%2F6886adb319e14f859f48ce5e413968d7%3FsourceSSR%3Dusers)\n\n## 楼主背景\n\n应届被裁。学历985本，一年大厂工作经验。\n\n一面都很久了，感觉快一个月了，兜兜转转了半天终于到二面了\n\n## 面试方式\n\n提前3天收到邮件，阿里会议视频面试。\n\n## 面试过程\n\n面试过程这次问题都比较开放，我就不放我的回答了，因为我自己也答的一塌糊涂。\n\n  1. 自我介绍\n  2. 你是怎么学习Java的，如果让初学者学Java你会推荐啥学习顺序\n  3. 你在学Java时候遇到了什么问题，怎么解决的\n  4. Java，Golang，Python这几种语言如果初学者要学你怎么推荐(PS：刚提到我会这几个语言)\n  5. 最近这段时间做了什么\n  6. 刚才提到RPC，什么场景下要用RPC，PRC都做了什么\n  7. 以后打算怎么学习\n  8. 反问\n\n## 总结\n\n这次二面没八股，没算法，全是开放性问题。不同面试官侧重点还是挺不一样的\n\n\\---------------------------------------------------------------------------------------------------------\n\n已挂， 面试完第二天早上收到感谢信\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594658834405240832?sourceSSR=users",
        "title": "杭州半糖科技（java开发）一面",
        "content": "时间：2024.3.4\n\n时长：30分钟\n\n1、自我介绍\n\n2、挑一个自己最熟悉的项目介绍\n\n3、权限是写在那里的，过滤器里还是拦截器里怎么实现的？\n\n4、接口的权限校验怎么做的？\n\n5、session设置永不过期的原因是什么？TWT有用过吗？\n\n6、session和cookie的区别\n\n7、过滤器和拦截器的区别\n\n8、一个完整的http请求由哪些部分组成的？\n\n9、integer和long类型数据大小比较（他们的equals方法都会先判断类型然后再比较，类型不同直接返回false）\n\n10、redies的基本数据类型\n\n总结：这次是实习岗主要问的项目比较多，发现自己的项目细节设计上还有很多不足，之前一直忽略了项目上问答的准备，这次都暴露出来了，项目这块还是要多下功夫的，毕竟每次面试官都会先让介绍项目，对项目问题的回答可以看出个人对业务功能实现上的一些思考方式和解决能力，还是非常重要的！\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594653054293581824?sourceSSR=users",
        "title": "拼多多面经",
        "content": "# 八股文\n\n1.java的垃圾回收有哪几种\n\n2.介绍一下多路复用技术\n\n3.介绍一下线程池 （项目中用到了 所以是介绍项目的过程中问的该问题）\n\n4.什么是零拷贝（项目中用到了 所以是介绍项目的过程中问的该问题）\n\n# 算法题\n\n1.二叉树的中序遍历\n\n2.开放性题目：设计一种二叉树，可以迅速找到最中间的值\n\n3.写代码 获取topk个数据（小顶堆）\n\n4.接雨水（hard题目） 前面答得不错，面试官上难度了。。。 不过这题我没写出来，只是跟面试官聊了下大概的思路。\n\n# 项目\n\n1.做过一点sql引擎的优化。所以面试官问了算子下推、小表join大表相关优化\n\n2.做过flink相关的join优化，用到了线程池。所以面试官问了线程池相关的内容。\n\n# 个人感悟：\n\n如果项目出彩，八股文问的会比较少。面试官全程听项目，并在项目介绍过程中问涉及到的知识。\n\n算法题会逐渐上难度。我个人的经历是如果出了hard题，做不出来没关系。但要有沟通意识、思路分享意识。\n\n# 其他同学遇到过的开放性题目\n\n有100亿个int32，内存只有10MB，如何找出所有重复的数据？\n\n个人感觉应该用hash分桶的思路。 但是那个同学答偏了，后来面试官还考了道让他手写hash map的题提示他。\n\n# *****\n\n***********\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594637127346888704?sourceSSR=users",
        "title": "腾讯后台开发实习一面",
        "content": "很早之前投的，前几天实习基地那个顺手点了一下确认，然后昨天就约面了，我也不确定有没有关系哈。刚面完。\n\n找实习和工作都太玄学了，自我感觉真没用，过不过全靠缘分。\n\n没录音，凭记忆写个面经，全程一个小时。\n\n  1. 自我介绍\n  2. 项目、实习经历\n  3. 算法题，[****](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fedit-distance%2Fdescription%2F)，hot100上的，一会就写好了，运行了，然后说了下思路\n\n接下来就是一堆八股，算是比较常规\n\n  1. HashMap和ConcurrentHashMap\n  2. Java内存模型\n  3. Java IO模型\n  4. 垃圾收集器\n  5. MySql 索引、事务等\n  6. TCP和UDP，TCP连接和断开过程\n  7. 进程和线程，进程通信方式\n  8. 学校，反问\n\n应该还有一些，暂时想不起来了==\n\n腾讯面试官好像都不喜欢开摄像头，去年我面也是这样，不过也没要求我开..\n\n明早还要面阿里云，希望面试官大佬温柔点，别压力我[牛泪]\n\n希望能过吧，确实挺想去的。\n\nupdate 面完一个半小时，刚看官网一面过了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594610089441406976?sourceSSR=users",
        "title": "嵌入式面经",
        "content": "海康嵌入式面经\n\n[海康威视嵌入式一面](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Ffeed%2Fmain%2Fdetail%2Fbf55d722cacc47fea0ee214f519ecdaa%3FsourceSSR%3Dsearch)\n\n[海康威视软件开发（嵌入式） 面经 &\nTimeline](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F555344296782700544%3FsourceSSR%3Dsearch)\n\n[海康一面\n嵌入式软开面经](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Ffeed%2Fmain%2Fdetail%2F677f9112b4e1470197da0a5dd095509a%3FsourceSSR%3Dsearch)\n\n[海康C++面经](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Ffeed%2Fmain%2Fdetail%2Fee325fc7752a431ebb9203287420dafb%3FsourceSSR%3Dsearch)\n\n[海康威视 嵌入式 应用\n面经(SP已发起三方)](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F545752494723403776%3FsourceSSR%3Dsearch)\n\n[【投稿】海康威视嵌入式软件开发面经汇总](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F499920887068504064%3FsourceSSR%3Dsearch)\n\n[海康威视BSP一面（18分37秒）](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F536490142991708160%3FsourceSSR%3Dsearch)\n\n二叉树层序遍历(力扣102) 手撕快速排序\n\n[海康威视数字技术股份有限公司 嵌入式软件开发工程师\n面经](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F445780226874916864%3FsourceSSR%3Dsearch)\n\n[海康威视 嵌入式\n面经](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F353155540077453312%3FsourceSSR%3Dsearch)\n\n[海康威视嵌入式【2023校招面经】](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Ffeed%2Fmain%2Fdetail%2Fa1a997aece6f4aa1aeea09f428537187%3FsourceSSR%3Dsearch)\n\n[海康威视嵌入式软件开发（应用）面经](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F353157179714772992%3FsourceSSR%3Dsearch)\n\n[海康威视嵌入式软件开发面经（笔试+面试）](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F353159481901129728%3FsourceSSR%3Dsearch)\n\n[Oppo和海康嵌入式软件工程师面经分享](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F353159145127878656%3FsourceSSR%3Dsearch)\n\n[海康 软件开发 面经\n](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F410486078275166208%3FsourceSSR%3Dsearch)自己编写一个strcpy函数\n\n[海康威视嵌入式软件（应用）一面二面面经](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F353157033392283648%3FsourceSSR%3Dsearch)\n\n[【硬件专场】海康 +\n中兴最强面经汇总](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F389156195653754880%3FsourceSSR%3Dsearch)\n\n[海康威视\n嵌入式软开（应用）技术一面（44mins）](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F353158473443647488%3FsourceSSR%3Dsearch)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594592553605877760?sourceSSR=users",
        "title": "面试题解析|宝洁八大问-合作能力",
        "content": "‼️题目：举例证明你可以与他人合作，共同实现一个重要目标。\n\n关键词：合作  \n\n  \n\n💡提示：合作题是八大问中比较容易回答的问题，在这里，通力合作统一目标是合作，互为上下游，推进结果也是合作..同学们不用过于纠结所选案例是否能完美的体现合作的力量，将视线更多聚焦在展示：你看待合作的态度以及你在合作中起到的作用。\n\n  \n\n🏆讲述逻辑：\n\n1.简述项目要点，重点说明项目中需要合作的情况以及其重要性。\n\n2.讲述合作过程的细节及你在合作中的个人亮点。\n\n3.合作的结果，后续影响及你在这件事上的总结。\n\n  \n\n宝洁八大问作为非常经典的问题合集，能够很好的帮助大家总结自己的个人经历，建议每一位候选人在求职前都可以深入学习了解下宝洁八大问的回答技巧。如果有疑问，可以后台私信详细咨询。\n![8Z5FfI3Awe18qegoPnKMkU1mCdCgD1S1.jpg](https://uploadfiles.nowcoder.com/images/20240305/722513612_1709633856038/0C9C6EDB7B65511EB6D196272A9A6EC8)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594586340616912896?sourceSSR=users",
        "title": "腾讯云 客户端实习 一面 40min",
        "content": "1.自我介绍\n\n2.TCP的稳定性机制\n\n3.TCP为什么四次挥手\n\n4.对称加密和非对称加密\n\n5.C语言，指针需要注意的地方\n\n6.用户态和内核态的互换、条件\n\n7.B树和B+树\n\n8.了解红黑树吗\n\n9.数组和链表的不同特性、各自的应用\n\n10.多进程编程\n\n11.项目难点和解决（说了redux）\n\n12.对redux的了解\n\n13.编程（ACM模式）：移动零，以及优化（不使用额外空间、降低时间复杂度）\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/594576774558683136?sourceSSR=users",
        "title": "分月饼 - 华为OD统一考试（C卷）",
        "content": "> OD统一考试（C卷）\n>\n> 分值： 200分\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n中秋节，公司分月饼，m个员工，买了n个月饼，m<=n，每个员工至少分1个月饼，但可以分多个，单人分到最多月饼的个数是Max1，单人分到第二多月饼个数是Max2，Max1-Max2<=3，单人分到第n-1多月饼个数是Max(n-1)，单人分到第n多月饼个数是Max(n)，Max(n-1)-Max(n)<=3问有多少种分月饼的方法?\n\n## 输入描述\n\n每一行输入m n，表示m个员工，n个月饼，m<=n\n\n## 输出描述\n\n输出有多少种月饼分法\n\n## 示例1\n\n    \n    \n    输入：\n    2 4\n    \n    输出：\n    2\n    \n    说明：\n    分法有2种\n    4=1+3\n    4=2+2\n    注意:1+3和3+1算一种分法\n    \n\n## 示例2\n\n    \n    \n    输入：\n    3 5\n    \n    输出：\n    2\n    \n    说明：\n    5=1+1+3\n    5=1+2+2\n    \n\n## 示例3\n\n    \n    \n    输入：\n    3 12\n    \n    输出：\n    6\n    \n    说明：\n    满足要求的有6种分法:\n    12=1+1+10(Max1=10,Max2=1，不满足要求)\n    12=1+2+9(Max1=9,Max2=2,不满足要求)\n    12=1+3+8(Max1=8,Max2=3 不满足要求)\n    12=1+4+7(Max1=7,Max2=4,Max3=1, 满足要求)\n    12=1+5+6(Max1=6,Max2=5,Max3=1，不满足要求)\n    12=2+2+8(Max1=8,Max2=2,不满足要求)\n    12=2+3+7(Max1=7,Max2=3,不满足要求)\n    12=2+4+6(Max1=6,Max2=4,Max3=2，满足要求)\n    12=2+5+5(Max1=5,Max2=2，满足要求)\n    12=3+3+6(Max1=6,Max2=3,满足要求)\n    12=3+4+5(Max1=5,Max2=4,Max3=3，满足要求)\n    12=4+4+4(Max1=4,满足要求)\n    \n\n## 题解\n\n> 这个问题可以通过**递归** 的方式解决。\n>\n> 首先，每个员工至少分到一个月饼，因此可以将每个员工分到一个月饼后，剩余的月饼数量为`n - m`。然后，可以枚举分配多余月饼的情况，并递归计算方案数。\n>\n> 因题目 （1,2,3）（1,3,2）（2,1,3）（2,3,1）\n> 是一同一种分配月饼的方法，因此为了方便我们枚举分配情况，我考虑使用**非递减的方式来分配月饼** （即第 i + 1个人分配的月饼数 >= 第 i\n> 个人分配的月饼数）。\n>\n> 递归的方法定义就是：\n>\n> // **有m个人n个月饼，每人最少分配 start 个月饼的分配方案数** int assign(int m, int n, int start)\n\n### Java\n\n    \n    \n    import java.util.Scanner;\n    /**\n     * @author code5bug\n     */\n    public class Main {\n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n            int m = scanner.nextInt(), n = scanner.nextInt();\n            int tot = 0;\n    \n            int up = n - m;  // 每人分配一个月饼后剩余的月饼数\n            for (int i = 0; i <= up; i++) {\n                tot += assign(m - 1,\n\n"
    }
]