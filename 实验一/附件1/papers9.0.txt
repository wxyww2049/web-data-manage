[
    {
        "url": "https://www.nowcoder.com/discuss/599205101282021376?sourceSSR=users",
        "title": "2月份 日常实习记录 Java后端",
        "content": "# **点创科技 2.19**\n\n简单问项目\n\n# **凡华科技 2.19**\n\nMySQL：红黑树和B＋树MVCC三种日志log(n)\n\n当前读和快照读 select、update语句\n\nRedis：一致性哈希key-value\n\nG1新生代老年代，链表bitmap\n\n# 亚信安全 2.20\n\n分表以后，按照时间日期select，怎么做？\n\n路由网络、有漏洞、辨别攻击、ip\n\n开发调试接口，来回成本，热部署python调用设备，小脚本。\n\n# 数新网络一面 2.21\n\n类加载过程\n\n类的生命周期\n\n创建线程的方式\n\n线程池的应用场景\n\nStringBuffer和StringBuilder区别\n\nStringBuffer如何实现线程安全\n\nMySQL索引类型\n\nMySQL锁\n\nMySQL日志\n\n慢SQL优化\n\nredis数据类型\n\nredis持久化\n\nredis事务\n\n布隆过滤器优缺点\n\nLinux常用命令\n\nDocker\n\n时间复杂度\n\n# Momenta 一面 2.21\n\n聊天、竞赛、科研\n\n项目 CDN、minIO\n\n快速排序，nlogn，是否稳定\n\nMySQL存储引擎\n\n消息队列可靠性\n\n算法题矩阵重叠面积\n\n# Momenta 二面 2.22\n\n拷打项目\n\n是否有前端预加载？\n\n数据表设计\n\n用户密码的明文密文，数据库处理保存，前端明文与数据库密文？\n\n定时任务\n\nip工具类\n\nrabbitmq\n\n人员分工、组长、题目\n\nhttps、TSL、连接过程\n\n浏览器输入url的过程\n\n跨域解决及原理\n\n设计模式了解么，细讲一个单例模式及其用法\n\nHashMap、红黑树、底层原理目的、为什么效率高\n\n最左匹配原则\n\n联合索引\n\n孤儿进程、僵尸进程\n\n算法题，点连接成线段，时间复杂度\n\n2.29 OC 接了\n\n# 快手 2.22\n\n定时任务怎么做的\n\n点赞数大key问题影响、解决办法\n\n数据表设计\n\n表拆分\n\n慢SQL分析\n\nip检测怎么做，怎么计数？redis并发问题？\n\n消息队列可靠性\n\n消息持久化\n\nkafuka\n\n一致性哈希\n\nLRU\n\nRPC需要考虑哪些问题\n\nMySQL隔离级别\n\nMVCC\n\nZoomKeeper\n\n设计模式、如何实现单例模式\n\n单例static class 可能会有什么问题\n\n类加载过程\n\n算法题，ip地址分割，回溯\n\n# 安思源 2.23\n\n项目分工负责部分\n\nredis点赞定时任务落库有什么问题，怎么改进？\n\n缓存穿透、击穿、雪崩\n\n推模式和拉模式优劣选择\n\n布隆过滤器解释\n\n用户注销如何改进，布隆过滤器没有删除\n\n数模难点，解决关键\n\n科研经历解释\n\n# 番茄互娱 2.23\n\n简单问项目\n\n视频上传异步\n\nip库更新问题\n\nOC拒了\n\n# 蓝色脉动 2.26\n\n大视频上传时间长、失败解决办法\n\n异步、压缩、编码、带宽\n\nlist a=b 浅拷贝\n\n手写map遍历方式\n\n降序数组两数之和\n\n# 数新网络二面 2.26\n\nsharding-jdbc\n\nHashMap遍历方式、边遍历边添加，线程安全？\n\nArrayList和Linkedlist适用场景有什么区别\n\n链表排序算法\n\n二叉树遍历方式\n\n二叉树找p,q的公共父节点\n\nMVCC\n\n数据库集群\n\n# 罗格数据 2.26\n\nJava数据类型，占几个字节，汉字呢？\n\nString是可变的吗？如何编辑？\n\nStringBuffer线程安全，StringBuilder线程不安全\n\nMySQL limit 三个参数含义\n\nselect score from table where name = ‘张三’ orderby score\n\nSpring和SpringBoot区别\n\n线程池七大参数和机制\n\nRunTimeException、error、exception\n\n解释前缀树\n\n# 启思码 2.26\n\nArrayList和LinkdList\n\nHashMap\n\nAQS\n\nReentrantLock\n\nredis内存淘汰、过期删除策略\n\nMySQL的B+树索引\n\nMySQL事务ACID\n\nMySQL隔离级别\n\nMVCC\n\n消息队列工作模式\n\nSpring、SpringBoot、SpringCloud区别\n\nminIO\n\n手写LRU\n\n# 数新网络三面 2.29\n\n短链接项目\n\nCAS解释和哪些地方用到\n\nsynchronized为什么锁升级\n\n线程池原理及使用场景、估计最大线程数量\n\n垃圾回收CMS\n\n开发中会用到JVM吗\n\nOOM遇到过吗 DL中怎么解决的\n\n了解情况和规划\n\njdk1.8区别新特性\n\nMaven、生命周期\n\nSpringBoot 注解\n\n反问\n\n# 数新网络HR面 3.4\n\n聊天基本情况\n\nOC拒了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599203965657542656?sourceSSR=users",
        "title": "oppo校招结构工程师",
        "content": "秋招投过，忘记鸽了多久然后给的面试，春招也是早早的又填了，上周五面的，刷kpl了，不过还是挺好的，小姐姐真漂亮，加vx\n\n自我介绍\n\n深挖简历\n\n实习项目（跟机械根本不搭边，还好我有2版简历）\n\n问的真的挺细的，挺认真的，还好我是真水军\n\n提问项目\n\n闲聊，然后反问\n\n结束\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599201644647149568?sourceSSR=users",
        "title": "24春招，快手测试开发工程师三面（下）",
        "content": "**大家好，我是chowley，进回顾一下之前参加的快手面试下半程**\n\n部门：商业化\n\n时间：50min\n\n平台：轻雀，这平台纯nt，用Mac面试，麦克风老连我iPhone\n\n## 过程\n\n实习三-测试开发\n\n### 1\\. 压力测试咋做的？\n\n先需求分析-找QPS高的接口，制定测试计划-啥时候测，写测试用例-衡量测试预期，写脚本-\n用JMeter，选定接口、加线程组、多少个线程、每个线程每秒请求几次，进行测试-执行脚本，看报告-是否符合预期，分析原因-为啥不符合，改进接口资源-重新测试\n\n  * 需求分析：确定测试的目的、范围和重点。\n  * 制定测试计划：包括测试的时间、资源、环境等安排。\n  * 编写测试用例：根据需求和接口特点编写测试用例，包括预期结果和执行步骤。\n  * 编写测试脚本：使用压力测试工具如 JMeter 编写测试脚本，设置线程组、请求频率等参数。\n  * 执行测试：运行测试脚本，生成测试报告。\n  * 分析报告：分析测试报告，查看接口性能是否符合预期。\n  * 改进接口资源：根据分析结果优化接口或增加资源。\n  * 重新测试：重新执行测试，验证改进效果。\n\n### 2\\. 测试脚本要注意哪些内容？\n\n  * 确保脚本能够覆盖到所有需要测试的接口和场景。\n  * 设置合理的并发线程数和请求频率，模拟真实的用户行为。\n  * 编写脚本时考虑到参数化，使得可以灵活地修改请求参数。\n  * 处理好脚本中的异常情况，如请求超时、服务器错误等。\n  * 定期更新脚本，适应接口和系统的变化。\n\n### 3\\. 覆盖率是算的增量还是全量？\n\n覆盖率可以是增量的，也可以是全量的。增量覆盖率是指新增的代码或功能被测试覆盖的程度；全量覆盖率是指整个代码或功能的测试覆盖程度。\n\n### 4\\. 测试覆盖率如何保障？\n\n  1. 编写充分的测试用例：编写能够覆盖各种情况和分支的测试用例，包括正常情况、边界情况和异常情况。\n  2. 使用测试覆盖率工具：使用工具如JaCoCo（Java）、Coverage.py（Python）等来分析代码覆盖情况，查看哪些代码行被测试覆盖到了，哪些没有覆盖到。\n  3. 定期执行测试：定期执行测试用例，并分析测试覆盖率报告，确保代码得到充分覆盖。\n  4. 持续集成：将测试集成到持续集成流程中，每次代码提交都自动运行测试用例，并生成测试覆盖率报告。\n  5. 代码审查：进行代码审查，检查代码是否充分测试覆盖，是否存在遗漏的测试场景。\n  6. 测试策略优化：根据测试覆盖率报告的反馈，优化测试策略，增加测试用例覆盖不足的部分。\n\n### 5\\. 测试一下微信支付功能\n\n身份：支付者、收款者\n\n条件：二维码实时刷新、绑定扫码人的账号ID、实时性\n\n功能：扫码支付、商家收款码收款、展示支付成功界面、唯一性、完整性、原子性、顺序、金额、数字键盘弹出、中断事件、断电、断网、进度保存、金额限制、支付顺序、账户扣款、实时性\n\n其他方面：性能、兼容性、易用性、可靠性、安全性、可维护、可移植性等\n\n### 6\\. 手撕：匹配栈，注意元素入栈先后顺序\n\n### 7\\. 为啥选择测试？\n\n测试实习经历让我重新认识了这个岗位，性格让我更期待能在QA领域有一些建树\n\n## 总结\n\n难度：3.5/5\n\n面试官专业程度：还行，但他一直在那回消息，还频繁莫名其妙的笑\n\n体验打分：3/5，体验一般，反问他说我表现的还行，不知真假\n\n**好了，以上就是本文的全部内容，如有问题可留言讨论。**\n\n**本人正在组建校招测试开发方向的交流社区，如果您对测试求职方面感兴趣，欢迎加入了解。**\n\n**我是chowley，一个专注互联网技术和产品质量保障领域的博主，我们下次再见！**\n\n**欢迎点赞、评论、收藏，it's important for me.**\n\n**Searching for QALog.**\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599196385883213824?sourceSSR=users",
        "title": "影石insta360测试实习一面",
        "content": "全程大约20min，氛围良好\n\n  * 自我介绍\n  * 为什么选择测试岗\n  * 怎么设置测试用例（比如测试登录模块）\n  * 给你一支笔，你会测什么\n  * TCP三次握手，为什么不能两次\n  * 如果测试时手上的模块有比较严重的bug，应该怎么办\n  * 做过的最有挑战性的事情\n  * 自己的未来规划\n  * 对加班的看法\n  * 在学校哪门课程学的最好\n  * 熟悉哪些编程语言\n  * 说一下对面向对象的理解\n  * 对公司的了解\n  * 反问（实习生日常工作内容，筛选候选人标准）\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599185499676319744?sourceSSR=users",
        "title": "某外包面经--一面",
        "content": "1.自我介绍\n\n2.问一些项目的情况\n\n3.问数据库用的什么---mysql\n\n做过表优化吗\n\n怎么会导致回表\n\n怎么会导致索引失效\n\n4.redis\n\n常见数据类型\n\n持久化机制\n\n淘汰机制\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599177965083054080?sourceSSR=users",
        "title": "模型部署/推理优化/高性能计算方向社招面经总结",
        "content": "背景：lz在自驾公司做bev模型在orin上的部署和优化，三年工作经验。最近面了几家公司，主要是自驾公司的模型部署和工程化岗位，也有一些是推理框架和大模型推理优化相关的岗位。这两周大概搞了二十多场面试，也该总结一下经验，顺便攒一波rp了:)\n\nlz既然是社招，那肯定是项目问的比较多，这块没啥好讲的，每个人的项目都不一样，只要保证简历上写的东西是自己做的，面试的时候能讲清楚就可以了。\n\n### CUDA和C++八股\n\nlz的cuda基本都是自学的，自我感觉良好，结果面试的时候被各路面试官吊打，还是自己太菜了[牛泪]cuda的问题有下面这些\n\n  1. cuda graph作用原理，kernel launch流程\n  2. 如何确定blocksize和gridsize\n  3. 什么是default stream，它存在什么问题\n  4. shared memor的bank conflict及解决方法\n  5. threadfence的作用\n  6. 如何debug cuda kernel\n  7. unified memory和zero-copy memory\n  8. cuda sort如何实现\n  9. sin函数在哪个硬件计算，这个硬件还能算什么\n  10. Volat架构特性，ITS\n  11. 3090上单个block能用的shmem最大有多少\n  12. PTX与SASS的区别\n  13. GPU性能xx TFLOPS是怎么计算的\n\nC++的八股问的也挺多，不过翻来覆去就下面几个问题\n\n  1. C++虚函数实现机制，单继承、多继承、虚继承的内存布局\n  2. 四种cast\n  3. 三种智能指针\n  4. 函数模板声明与定义能否分离\n  5. CRTP静态多态\n  6. vector扩容，resize和reserve\n  7. 单例模式\n\n### 手撕题目\n\n做推理优化和高性能计算肯定是要懂点cuda，所以大部分的题目都是用cuda实现，一些不太好用cuda实现的如NMS就用c++写了。当然也遇到过一些力扣题目，基本是hot100的范畴，这里不再赘述。\n\ncuda实现：reduction，softmax，matrix transpose，avg\npooling，算两堆bbox的iou，大部分情况下都是实现kernel即可，少数情况需要跟cpu对齐。\n\nc++实现：NMS，conv2d，双线性插值，layernorm，单例模式\n\n这里面让我印象比较深刻的是layernorm，用cuda写个layernorm不难，但面试官让我用vadd/vsub/vmul/vdiv等向量指令实现一个layernorm，我人都傻了。一是咱平时写cuda都是SIMT的编程模型，cpu优化是SIMD，这俩写起来有差别；二是没提供sqrt，得自己用牛顿法求，而且还没有比较运算符，浮点数的比较还有一些trick，最后肯定是寄了。\n\n另外就是某大模型公司，要求实现softmax，需要跟cpu版本对齐。我写了个3pass的softmax，可惜面试过程中结果没有对齐，面完下来5分钟就解了bug，也算比较可惜吧。还有个小插曲就是面试官让我把代码通过腾讯会议发给他，但是我发错文件了，目录下有test.cc和test.cu，test.cc里面是另一个家面试的手撕，test.cu里面才是softmax。手滑了，发给面试官的是test.cc[笑cry]第二天我重新发了调通的test.cu，希望他能看到吧[笑cry]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599193951991611392?sourceSSR=users",
        "title": "德科信息前端实习二面",
        "content": "全程15min左右，我开摄像头，面试官不开[笑cry]\n\n全程几乎都在问项目\n\n  * 自我介绍\n  * 项目部署\n  * 项目的难点\n  * 难点的解决办法\n  * 学习规划\n  * 反问\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599170646790238208?sourceSSR=users",
        "title": "2024.3.16 美团暑期实习第二场笔试",
        "content": "图片转自小红书：[https://www.xiaohongshu.com/explore/65f59c1c000000001203d36a](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.xiaohongshu.com%2Fexplore%2F65f59c1c000000001203d36a)\n\n# 第一题\n\n![](https://uploadfiles.nowcoder.com/images/20240318/235802090_1710725085452/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n100%\n\n# 第二题\n\n![](https://uploadfiles.nowcoder.com/images/20240318/235802090_1710725143379/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n100%\n\n# 第三题\n\n![](https://uploadfiles.nowcoder.com/images/20240318/235802090_1710725170220/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n![](https://uploadfiles.nowcoder.com/images/20240318/235802090_1710725216791/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n16.67%\n\n# 第四题\n\n![](https://uploadfiles.nowcoder.com/images/20240318/235802090_1710725238902/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n![](https://uploadfiles.nowcoder.com/images/20240318/235802090_1710725253982/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n0% 因为把 Hashmap 的 value 存成数组了。。\n\n# 第五题\n\n![](https://uploadfiles.nowcoder.com/images/20240318/235802090_1710725319838/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n![](https://uploadfiles.nowcoder.com/images/20240318/235802090_1710725334371/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n0%\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598987289603207168?sourceSSR=users",
        "title": "腾讯校招实习后端开发二面：灵活而深入的八股最可怕",
        "content": "嗨～我是可拟雀，一个后端开发工程师，毕业于某985大学，目前供职于bat某大厂核心部门后端。每天分享最新面经答案，希望在大环境不好的当下能帮到你，让你多积累面试经验。需要内推或者面经合集请评论哦。\n\n1\\. Tbase用过吗？咋用的？\n\n答：TBase是鹅基于开源PostgreSQL开发的一款分布式数据库产品，它拥有高可用、高性能、低延迟等特点，在鹅内部得到了广泛应用。TBase的架构原理主要由分布式协调器、分布式存储引擎和分布式节点三部分组成，这三部分相互协作，共同实现了TBase的特性。\n\nTBase提供了一套Java SDK和插件，可以简化接入进程，提高开发效率。开发者可以依照TBase提供的文档和示例代码使用Java\nAPI来接入TBase，实现数据存储和管理功能。同时，TBase还提供了死锁检测机制，使用基于图论的死锁检测算法来检测死锁，确保在并发执行中能够解决可能出现的死锁问题。\n\n2\\. Mysql什么结构？数据怎么写的？buffer pool？redolog？log buffer？\n\n答：\n\n结构分层：MySQL的体系结构可以分为几个主要部分，包括客户端连接器、数据库连接层、数据库服务层等。每一层都有其特定的功能和职责，共同支持MySQL数据库的正常运行。\n\nMySQL写数据的底层原理涉及多个层次和组件的交互。面试版本简单的说：\n\n客户端请求：\n\n客户端（如应用程序）向MySQL服务器发送写入请求，这通常是一个SQL语句，如INSERT、UPDATE或DELETE。请求中包含了要写入的数据、目标表以及其他相关信息。\n\nSQL解析与优化：\n\nMySQL服务器接收到请求后，首先会进行SQL语句的解析。解析器会检查语句的语法是否正确，并生成一个解析树。然后，优化器会对解析树进行优化，选择最佳的执行计划。\n\n写入InnoDB存储引擎（以InnoDB为例）：\n\nMySQL支持多种存储引擎，每种存储引擎都有其特定的数据写入方式。以InnoDB为例，它是MySQL的默认存储引擎，支持事务和行级锁定。\n\na. 写入Buffer Pool：\n\n当数据需要写入时，它首先会被写入到InnoDB的Buffer Pool中。Buffer\nPool是InnoDB用于缓存数据和索引的内存区域，通过缓存可以显著提高读写性能。\n\nb. 更改页（Change Buffer）：\n\n对于非主键索引的更改，InnoDB可能会使用更改页（Change\nBuffer）来缓存这些更改，而不是直接写入磁盘。这样做可以减少磁盘I/O操作，提高性能。当这些页被读取到Buffer Pool中时，更改会被合并到页中。\n\nc. Redo Log（重做日志）：\n\n为了确保数据的持久性，InnoDB会将数据的更改写入到Redo Log中。Redo\nLog是循环使用的日志文件，用于记录对数据库的物理更改。即使在数据库崩溃的情况下，也可以通过Redo Log来恢复数据。\n\nd. 后台刷新：\n\n后台进程会定期将Buffer Pool中的数据和索引页刷新到磁盘上，确保数据的持久保存。这个过程是异步的，不会影响前台的SQL执行。\n\n写入磁盘：\n\n最终，数据和索引的更改会被写入到磁盘上的数据文件和索引文件中。MySQL使用特定的文件格式和存储机制来组织和管理这些数据。\n\n需要注意的是，上述过程是一个简化的概述，实际的MySQL写入过程可能涉及更多的细节和复杂性。此外，不同的存储引擎和配置可能会影响写入性能和数据一致性。因此，在实际应用中，需要根据具体的需求和场景来选择合适的存储引擎和配置参数。\n\nBuffer Pool：是MySQL数据库引擎用于缓存数据页（页是磁盘上的一块固定大小的数据单元）的内存区域。在MySQL服务器启动时，Buffer\nPool会被初始化，并在整个数据库生命周期中用于高效地管理数据库页的读取和写入。通过缓存数据页，Buffer\nPool可以显著减少与磁盘I/O相关的开销，从而提高数据库的性能。\n\nredo\nlog：是InnoDB存储引擎特有的日志，又称重做日志。它是物理日志，可以理解为一个具有固定空间大小的队列，用于记录对数据库所做的更改。当事务提交时，这些更改会被写入redo\nlog，以确保在发生故障时能够恢复数据。redo log的循环复制机制使得其能够持续记录数据库的更改，保持数据的持久性。\n\nLog Buffer：是一块内存区域，用于保存要写入磁盘上的日志文件的数据。对于InnoDB存储引擎，Log\nBuffer主要存储redo日志和undo日志。其大小由innodb_log_buffer_size变量定义，默认大小为16MB。Log\nBuffer的内容会定期刷新到磁盘上，以确保日志的持久性。大的Log\nBuffer可以允许较大的事务运行，而无需在事务提交之前将日志数据写入磁盘，从而节省磁盘I/O操作。\n\n总的来说，MySQL的体系结构、数据写入方式以及Buffer Pool、redo log和log\nbuffer等组件共同构成了其高效、可靠的数据存储和管理机制。通过合理配置和管理这些组件，可以优化MySQL数据库的性能和稳定性。\n\n3\\. Mysql主从，主节点binlog是同步还是异步的？主机挂了数据是不是没了？写数据时主节点宕机，但向客户端返回成功了，如何保证从节点数据写进去？\n\n答：MySQL的主从复制中，主节点的二进制日志（binlog）的写入是同步的，但binlog的传输到从节点以及从节点应用这些日志是异步的。\n\n  1. 主节点binlog的写入：当在主节点上执行写操作时（如INSERT、UPDATE、DELETE等），这些操作首先会在主节点的内存中完成，并随后同步地写入到主节点的binlog中。这一步是同步的，意味着写操作在返回给客户端之前，必须确保binlog已经成功写入。\n  2. binlog的传输：一旦binlog在主节点上生成，它会被传输到从节点。这个传输过程是异步的，意味着主节点不会等待从节点接收并应用这些日志后再继续处理其他操作。\n  3. 从节点应用binlog：从节点接收到binlog后，会异步地应用这些日志到其自己的数据文件中。这也是一个异步过程，从节点不会因为应用日志而阻塞主节点的写操作。\n\n**主机挂了数据是不是没了？**\n\n如果主节点崩溃，并且没有备份或高可用解决方案（如自动故障转移），那么从该崩溃点开始，尚未复制到从节点的数据将会丢失。但是，已经写入到主节点binlog的数据（并且在崩溃前已经传输到从节点）仍然可以在从节点上恢复。\n\n**写数据时主节点宕机，但向客户端返回成功了，如何保证从节点数据写进去？**\n\n当主节点宕机时，任何已经返回给客户端的成功写操作都已经被写入到主节点的binlog中。但是，这些变更可能还没有被传输到从节点，或者即使已经传输，也可能还没有被从节点应用。\n\n为了保证从节点上的数据一致性，你可以采取以下策略：\n\n  * **使用半同步复制** ：MySQL的半同步复制模式确保至少一个从节点已经接收并确认了binlog事件，主节点才会返回写操作的成功给客户端。这增加了数据的安全性，但也可能增加写操作的延迟。\n  * **设置多个从节点** ：通过配置多个从节点，你可以增加数据的冗余性。即使一个从节点失败，其他从节点仍然可以保持数据的副本。\n  * **定期备份主节点** ：定期备份主节点的数据和binlog，以便在必要时恢复数据。\n  * **使用GTID或其他复制管理工具** ：这些工具可以帮助你更好地管理和监控复制过程，确保数据的一致性。\n  * **实施故障转移策略** ：例如，使用像ProxySQL或MHA（Master High Availability Manager）这样的工具来自动检测主节点的故障，并快速地将一个从节点提升为新的主节点。\n\n4\\. innodb相关，索引为啥用b+树，其他索引为啥不行？数据量很大内存放不下咋办？\n\n答：\n\n  1. **多路搜索特性** ：B+树是一种多路搜索树，这意味着每个节点可以有多于两个的子节点。这种特性使得B+树在树的高度上相对于二叉树有明显的优势，因此可以减少磁盘I/O次数，提高查询效率。\n  2. **有序链表特性** ：B+树的叶子节点形成了一个有序链表，这使得范围查询变得非常高效。而B+树的叶子节点存储了所有数据记录的指针，可以直接进行范围查询和排序操作。\n  3. **内部节点设计** ：B+树的内部节点只存储索引信息，可以存储更多的索引信息，提高索引的覆盖度，减少回表操作。\n\n因此，使用B+树作为索引结构可以显著提高查询效率和覆盖度，减少回表操作，并支持高效的范围查询。\n\n至于数据量很大导致内存放不下的问题，有以下几种常用的解决方案：\n\n  1. **索引优化** ：选择性创建索引，避免过度索引，以减少索引占用的空间。同时，可以考虑使用复合索引来覆盖多个列的查询需求。\n  2. **分区表** ：对于大型数据库，可以考虑使用分区表来分散数据和索引的存储。通过将数据水平或垂直拆分到不同的分区中，可以减少单个表的内存占用。\n  3. **硬件升级** ：如果以上方法无法解决问题，可以考虑升级服务器的硬件，特别是增加内存容量，以提供更大的内存空间给MySQL使用。\n  4. **数据缓存** ：使用缓存技术如Redis来存储热点数据，减少对数据库的直接访问压力。这样可以释放部分数据库内存，用于存储更多的数据和索引。\n\n5\\. redis主从了解吗？\n\n5\\. 实习项目，细问\n\n6\\. 之前项目中遇到过的困难，有什么收获？说了一个，又被追着问细节..\n\n7\\. 最后写一个题，LRUCache\n\n[原文链接](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fshare%2Fjump%2F56634314667947747)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598983465450717184?sourceSSR=users",
        "title": "小红书3-17笔试",
        "content": "3道编程题100 100 9\n\n1.有一个技能可以随机消除数组中的一个元素，求使用两次后刚好消除掉最左边和最右边的概率，保留10位小数。\n\n例子\n\n输入\n\nn = 2\n\n输出\n\n1.000000\n\n输入\n\nn =3\n\n输出\n\n0.3333333333\n\n2.模拟题，就是简单根据商品关键词命中用户搜索的关键词的数量进行排序输出。\n\n3.有n篇小红书笔记，每个笔记被点赞的概率相等，问当所有笔记的点赞数都是偶数时，点赞总数的期望是多少？答案mod10^9+7。\n\n没什么头绪。。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/599168405727367168?sourceSSR=users",
        "title": "2024.3.16 蚂蚁工程研发暑期实习笔试",
        "content": "图片转自小红书：[https://www.xiaohongshu.com/explore/65f5b29400000000120209cc](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.xiaohongshu.com%2Fexplore%2F65f5b29400000000120209cc)\n\n若干道单选、多选、选做题没有记录。\n\n# 第一道\n\n![](https://uploadfiles.nowcoder.com/images/20240318/235802090_1710724638421/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n![](https://uploadfiles.nowcoder.com/images/20240318/235802090_1710724667469/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n100%\n\n# 第二题\n\n![](https://uploadfiles.nowcoder.com/images/20240318/235802090_1710724705464/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n![](https://uploadfiles.nowcoder.com/images/20240318/235802090_1710724779333/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n50% 想到了复杂度为 n 的但是没时间了。\n\n# 第三题\n\n![](https://uploadfiles.nowcoder.com/images/20240318/235802090_1710724830426/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n![](https://uploadfiles.nowcoder.com/images/20240318/235802090_1710724871152/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n0%\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598976174236233728?sourceSSR=users",
        "title": "小红书笔试",
        "content": "100 100 18\n\n第三题求期望真不是人做的[笑cry]\n\n\\----------------------------------------------------\n\n统一回复：\n\n第一题：1/(n(n-1)/2)，注意用 double，直接秒\n\n第二题：稳定排序直接秒\n\n第三题：print(sum(arr) + oddCnt * 3)，骗 18%\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598979386355871744?sourceSSR=users",
        "title": "滴滴3-17笔试",
        "content": "滴滴笔试题不算太难，这里说一下编程题吧，一共两道编程题。\n\n1.陨石砸一维地面，地面长度为n，输入多个[left, right]，代表被砸区域，输入一个q，代表q次查询，问某个坐标点被砸次数。\n\n用前缀和做，树状好像也可以我记得。\n\n2.员工申请资源时，需要向leader申请，但是leader有多个，比如leader，leader上级，leader上上级，\n\n所以规定向和自己技术能力最匹配的leader申请，最匹配的定义为：两者的技术能力相减取绝对值最小，\n\n如果有多个则取最靠近自己的那个leader。\n\n输入n代表有n个员工\n\n输入n-1个数，代表第i个员工的直属leader是谁，第n个数不用输入，默认为最高级leader。\n\n输入n个数，代表每个人的技术能力。\n\n该题就按照思路写代码，答案就出来了，好像没啥可以讲的。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598975635544993792?sourceSSR=users",
        "title": "美团3.16笔试-算法策略",
        "content": "### 3.16 算法策略\n\n#### Q1\n\n**题目描述**\n\n小美是美团外卖的忠实用户，她经常去美团外卖 app上面点外卖，因为会员红包的性价比太高。现在小美点了若干道菜，她希望你计算一个订单的总价。你能帮帮她吗？\n\n**输入描述**\n\n第一行输入一个正整数n，代表菜品总数。\n\n第二行输入n个正整数ax，代表每道菜的价格。\n\n第三行输入两个正整数…和y，z代表满减的价格，g代表红包的价格。\n\n**输出描述**\n\n一个正整数，代表小美最终应付的钱数。\n\n**样例输入**\n\n    \n    \n    4\n    10 20 10 20\n    25 10\n    \n\n**输出**\n\n    \n    \n    25\n    \n\n##### A1\n\n    \n    \n    n=int(input())\n    ax=list(map(int,input().split()))\n    x,y=map(int,input().split())\n    print(sum(ax)-x-y)\n    \n\n#### Q2\n\n**题目描述**\n\n小美定义以下三种单词是合法的：\n\n  1. ﻿﻿所有字母都是小写。例如：good\n  2. ﻿﻿所有字母都是大写。例如：APP\n  3. ﻿﻿第一个字母大写，后面所有字母都是小写。例如：Alice\n\n现在小美拿到了一个单词，她每次操作可以修改任意一个字符的大小写。小美根知道最少操作几次可以使得单词变成合法的？\n\n**输入描述**\n\n一个仅由大写字母和小写字母组成的字符串，长度不超过10^5\n\n**输出描述**\n\n一个整数，代表操作的最小次数。\n\n**样例输入**\n\n    \n    \n    AbC\n    \n\n**输出**\n\n    \n    \n    1\n    \n\n##### A2\n\n    \n    \n    import sys\n    \n    s = str(sys.stdin.readline())\n    n = len(s)\n    up = 0\n    for c in s:\n      if c.isupper():\n        up+=1\n    return min(n-up,up-int(s[0].isupper()))\n    # 最小只有两种情况(1)全改大写(2)尽量改成首字母大写\n    \n\n#### Q3\n\n**题目描述**\n\n小美拿到了一个数组，她每次操作会将除了第x个元素的其余元素翻倍，一共操作了q次。请你帮小美计算操作结束后所有元素之和。\n\n由于答案过大，请对10^9＋7取模。\n\n**输入描述**\n\n第一行输入两个正整数n，q，代表数组的大小和操作次数。\n\n第二行输入n个正整数a_i，代表数组的元素。\n\n接下来的q行，每行输入一个正整数x_i。代表第i次操作未被翻倍的元素。\n\n    \n    \n    1 ≤ n,q ≤ 10^5\n    1 ≤ x_i ≤ n\n    1 ≤ a_i ≤ 10^9\n    \n\n**输出描述**\n\n一个整数，代表操作结束后所有元素之和模10^9＋7的值。\n\n**样例输入**\n\n    \n    \n    4 2\n    1 2 3 4\n    1\n    2\n    \n\n**输出**\n\n    \n    \n    34\n    \n\n##### A3\n\n    \n    \n    # 快速幂也可以自己写，其实用内置pow就可以\n    def mypow(base,n,mod):\n      res = 1\n      while n:\n        if n&1:\n          res=(res*base)%mod\n        base=(base*base)%mod\n        n>>=1\n      return res\n    \n    n,q = map(int,input().split())\n    a = list(map(int,input().split()))\n    mod = 10**9+7\n    s = [q]*(n+1)\n    for _ in range(q):\n      x = int(input())\n      s[x]-=1\n    res = 0\n    for i in range(n):\n      res+=(pow(2,s[i+1],mod)*a[i])%mod\n      res%mod\n    print(res)\n    \n\n#### Q4\n\n**题目描述**\n\n小美拿到了一个数组，她希里你求出所有区间众数之和，你能帮帮她吗？\n\n定义区间的众数为出现次数最多的那个数，如果有多个数出现次数最多，那么众数是其中最小的那个数。\n\n**输入描述**\n\n第一行输入一个正整数n，代表数组的大小第二行输入n个正整数a_i。代表数组的元素\n\n    \n    \n    1 ≤ n ≤ 2×10^5\n    1 ≤ a_i ≤ 2\n    \n\n**输出描述**\n\n一个正整数，代表所有区间的众数之和。\n\n**样例输入**\n\n    \n    \n    3\n    2 1 2\n    \n\n**输出**\n\n    \n    \n    9\n    \n\n**说明**\n\n［2］,［2,1,2］,［2］的众数是 2\n\n［2,1］,［1］,［1,2］的众数是 1\n\n因此答案是 9.\n\n##### A4\n\n  * mergesort法，详见Q5，不写了\n  * 树状数组\n\n    \n    \n    def lbt(x):\n      return x & -x\n    def add(x,tr):\n      x+=n+1\n      while x<len(tr):\n        tr[x]+=1\n        x+=lbt(x)\n    def get(left,right,tr):\n      left+=n\n      right+=n+1\n      res = 0\n      while right:\n        res+=tr[right]\n        right-=lbt(right)\n      while left:\n        res-=tr[left]\n        left-=lbt(left)\n      return res\n    n=int(input())\n    ax=list(map(int,input().split()))\n    tr = [0]*(2*n+100)\n    add(0,tr)\n    pre,cnt = 0,0\n    for a in ax:\n      if a==2:\n        pre+=1\n      else:\n        pre-=1\n      cnt+=get(-n,pre-1,tr)\n      add(pre,tr)\n    cnt1 = (n+1)*n//2-cnt\n    print(2*cnt+cnt1)\n    \n\n#### Q5\n\n**题目描述**\n\n小美拿到了一个排列，她定义f(i)为：将第i个元素取反后，形成的数组的逆序对数量。小美希望你求出f(1) 到\nf(n)的值。排列是指一个长度为n的数组，1到n每个元素恰好出现了一次。\n\n**输入描述**\n\n第一行输入一个正整数n，代表排列的大小。\n\n第二行输入n个正整数ai，代表排列的元素。\n\n    \n    \n    1 ≤ n ≤ 2x10^5\n    1 ≤ a_i ≤ n\n    \n\n**输出描述**\n\n输出n个整数，第i个整数是f(i)的值。\n\n**输入**\n\n    \n    \n    3\n    1 2 3\n    \n\n**输出**\n\n    \n    \n    0 1 2\n    \n\n**说明**\n\n第一个元素取反，数组将变成［-1，2,3］，逆序对数量为 0. 第二个元素取反，数组将变成［2，-2,3］，逆序对数量为1.\n第三个元素取反，数组将变成［2,2，-3］，逆序对数量为2.\n\n##### A5\n\n  * mergesort yyds法\n\n    \n    \n    from collections import defaultdict\n    n=int(input())\n    values=list(map(int,input().split()))\n    pre, suf = defaultdict(int), defaultdict(int)\n    # pre,suf 记录每一个数字前后小于它的数字个数\n    \n    def mergesort(l,r):\n      if r-l<1:\n        return 0\n      mi = (l+r)>>1\n      a = mergesort(l,mi)\n      b = mergesort(mi+1,r)\n      c = merge(l,mi,r)\n      return a+b+c\n    \n    def merge(l,mi,r):\n      a = values[l:mi+1]\n      b = values[mi+1:r+1]\n      pa,lena,pb,lenb,ind = 0,mi+1-l,0,r-mi,l\n      res = 0\n      resa,resb=0,0\n      while pa<lena and pb<lenb:\n        if a[pa]<=b[pb]:\n          values[ind]=a[pa]\n          suf[a[pa]]+=resb\n          resa+=1\n          pa+=1\n        else:\n          res+=lena-pa\n          values[ind]=b[pb]\n          pre[b[pb]]+=resa\n          resb+=1\n          pb+=1\n        ind+=1\n      while pa<lena:\n        values[ind]=a[pa]\n        suf[a[pa]]+=resb\n        resa+=1\n        pa+=1\n        ind+=1\n      while pb<lenb:\n        values[ind]=b[pb]\n        pre[b[pb]]+=resa\n        resb+=1\n        pb+=1\n        ind+=1\n      return res\n    \n    cop_values = values.copy()\n    t = mergesort(0,n-1)\n    for i,v in enumerate(cop_values):\n      print(t+pre[v]-suf[v],end=\" \")\n    \n\n  * 树状数组\n\n    \n    \n    import sys\n    \n    def lbt(x):\n      return x & -x\n    \n    def add(x,tr):\n      while x<len(tr):\n        tr[x]+=1\n        x+=lbt(x)\n    \n    def get(x,tr):\n      res = 0\n      while x:\n        res+=tr[x]\n        x-=lbt(x)\n      return res\n    \n    n=int(input())\n    values=list(map(int,input().split()))\n    tmp = [0]*(n+1) # 存i-th之前大于的数+i-th之后小于的数（这部分要从res中减去）\n    tr1,tr2 = [0]*(n+1),[0]*(n+1)\n    res = 0\n    for i,v in enumerate(values,1):\n      val=get(n,tr1)-get(v,tr1)\n      res+=val\n      tmp[i]=val\n      add(v,tr1)\n    for i in range(n,0,-1):\n      tmp[i]+=get(values[i-1],tr2)\n      add(values[i-1],tr2)\n    for i in range(1,n+1):\n      print(res-tmp[i]+i-1,end=\" \")\n    \n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598951671028367360?sourceSSR=users",
        "title": "万声音乐golang面筋",
        "content": "目前oc率100%，继续保持😁。\n\n因为自身在绿盟实习，这里纯玩啥也不用干，问了下学长的意见就不去了，打算狠狠带薪沉淀了，过俩月all in大厂。\n\n\\-----我是一条分割线------\n\n一面：\n\n》自我介绍\n\n说了下自己的学校，专业，年级，工作室负责的事，最近在学的东西，微服务，cs课程比如raft。\n\n》展示下自己最值的一提的项目\n\n我选的是一个raft相关的项目，把6.824移植出来弄了个高可用的kv，开屏幕共享展示了下容错表现，以及状态机实现思路，亮点是基于消息/事件，事件循环。\n\n》你对于raft的理解，你认为raft是一个强一致性还是最终一致性的？\n\n准确的说叫线性一致性，但是对程序来说可以看成强一致性的。这里我说了下我对raft的理解就是多个节点绑定成为一个不可宕机/或宕机机率非常小的单机节点，而单机节点就可以理解为一般意义上的强一致性了。\n\n》你说下redis集群的一致性？最终一致性或强一致性？\n\nredis主节点负责拿写入操作，从节点重放，其实会发生丢数据的情况，可以认为它是最终一致性，且会丢数据，根本不是强一致的。\n\n》CAP理论了解吗?\n\n说下AP系统或CP系统，trade off说下，常见场景说下就OK。\n\n》有没有使用过redis，说下自己做了什么功能？\n\n可以说zset实现排行榜，聊下跳表，红黑树，时间复杂度。可以说缓存。可以说stream实现消息队列。set实现共同关注。\n\n》说下B+树和跳表有什么优劣？\n\n先说下它们最底下一层都是链的数据，范围查询都很方便。此时可以说一下红黑树范围查询实现很难受，要返回父节点，来回捣腾。可以说B+树实现困难，跳表实现简单。可以说B+树存放2kw数据就只需要三层，IO少，查询快。那么为什么使用跳表?\n可以说内存数据库不存在磁盘IO，此时只需要插入的快就不错了，B+树为了平衡会做额外的算法，较慢。\n\n》为什么四次挥手？\n\n从半关角度的方向说，说一下FIN包过程状态。扯一下muduo那本书的设计。\n\n》进程线程协程?\n\n写过简单的时间片调度器，简单聊聊设计就行。\n\n》协程在操作系统层面是可见的吗?\n\n协程是程序调度器自己切换的，寄存器信息都放内存里的，操作系统不知道这块内存干啥的。\n\n》go的map并法安全要求\n\n简单八股，说下write的标志导致panic就行。此时可以扯一下sync.Map的设计。\n\n》说下gc过程\n\n白给了，没背，直接说暂未了解。回头看刘丹冰的视频吟唱八股。\n\n》mq你用过吗? 如果用redis实现延时队列\n\n我说的轮询+list。面试官觉得不好，我从定时器设计角度说了下堆排，感觉差不多。其实我没有怎么了解这个，说的有漏洞，其实真的答案是zset，score存时间戳，排进去就立马把时间戳小的挤前面了。\n\n》如何实现限流\n\n说漏桶，令牌桶，滑动窗口。之前没了解这方面，只说了漏桶的思路，面试官好像不满意，他应该想听滑动窗口。\n\n》写道简单题，acm模式，输出最长连续递增子序列的长度，1 2 3 4 1 1 1 7 8 9 10，输出5\n\n简单dp，3min秒了。\n\n》反问\n\n反问1，业务用的什么框架? 说golang的gin，提供http服务。\n\n反问2，对我有什么建议/评价？面试官的大概意思是让我多了解点常见的问题，比如常见八股，限流，gc，redis实现延时队列，实现mq诸如此类。\n\n反问3，如果有下次面试，是什么时候？他说之后流程不是自己负责了。\n\n面试官人很好，一直鼓励我，说话很委婉，爱了！\n\n二面：\n\n最汗流浃背的一集，感觉是个大佬，简单问题没答好。\n\n》问下redis，说下基础数据结构\n\n草了，脑子抽了压根没背，纯乱说，真实个煞笔，真想给自己两耳屎，听录音真尴尬啊！\n\n》说下zadd, zcard, zrange的时间复杂度\n\n简单。\n\n》说下golang基础，下面输出是什么\n\n![](https://uploadfiles.nowcoder.com/images/20240317/638692521_1710671503971/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n简单，考察defer先进后出。\n\n》golang基础，说下下面能通过编译吗\n\n![](https://uploadfiles.nowcoder.com/images/20240317/638692521_1710671561500/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n草了，这个脑抽忘了，我说第二句会不通过编译，他说错了。汗流浃背了。\n\n》说下下面语句后的len和cap\n\n![](https://uploadfiles.nowcoder.com/images/20240317/638692521_1710671618662/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n简单，这个是切片的扩容策略，扯一下之后版本的优化，在达到一定的大小后不再2倍扩容。\n\n然后又问了，a的地址发生改变了吗？这个问题要分两段答，本身没有改变，但是底下的pointer指向了新的地址。\n\n又问如果a再次append一次呢? 两倍扩容。\n\n》说下下面的输出\n\n![](https://uploadfiles.nowcoder.com/images/20240317/638692521_1710671693390/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n简单，这就是个闭包。输出1，2\n\n》谈谈下面的代码。\n\n![](https://uploadfiles.nowcoder.com/images/20240317/638692521_1710671857846/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n我说会panic。\n\n》说下预期输出结果\n\n![](https://uploadfiles.nowcoder.com/images/20240317/638692521_1710671896631/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n我坚持认为结果是未定义的，abc，abb，acc，ccc都可能。但是面试官坚持说ccc。无语了啊！！这里我说了go1.22的改进，以及v其实是同一个变量。\n\n》goroutine什么时候会让出时间分片？\n\n领域展开，可以说大栈消耗的函数调用，可以说信号抢占，直接说自己实现过信号抢占的调度器。可以说sleep这些api，read底下的wait会等待fd\nreadable，此时被挂起。还可以说golang比较重要的信号量，好多sync的实现都依赖于它。还可以说系统调用会开新的线程，此时也会发生调度。我还说了调用c语言，但是我不确定，这点需要研究下。\n\n》读写锁原理？\n\n不知道，我说了C语言的锁实现原理。CAS，Fetch And Add，然后futex系统调用。这个真得去研究下代码了。\n\n》写sql，说下获得某一天得所有data\n\n![](https://uploadfiles.nowcoder.com/images/20240317/638692521_1710672487764/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n简单，create_time限制一下范围。\n\n又问，再考虑一下分页问题，用limit, offset就行。\n\n》网络方面，说下拥塞控制\n\n草了，没背！！！胡言乱语，汗流浃背了！！！\n\n》http1.1和2的重要升级，3和2的区别\n\n啊！！没背，只说到了队头阻塞。真得好好背了！3和2区别说了quic，我说了udp，不可靠得udp上面重新发明tcp。\n\n》10TB url，50M内存，说下如何判断path出现得种类数。\n\n这个很简单，把同样的url hash到同一个文件中，可以扯下mapreduce思想。\n\n》反问：\n\n  1. 怎么提升自己？golang基础还差点，有俩基础问题没答上来。多了解下redis的基础数据类型等基础八股。\n  2. 业务做什么？省略了...\n\n总结：去看看小林coding的mysql，redis，网络，狠狠准备八股。去看刘丹冰/小徐同学的gc，内存管理，以及一些sync的实现原理，比如mutex和rwmutex,\nwaitgroup, cond，context，channel。去研究下golang调用c语言的原理。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598938448799592448?sourceSSR=users",
        "title": "好未来 校招 笔试真题",
        "content": "8.16投\n\n8.24 java笔试\n\n24校招-服务端（JAVA方向）试卷-1\n\n牛客 90min\n\n单选x8（java、数据结构、计网）、问答x3（常用端口、程序运行结构、实现前缀树）\n\n挂了\n\n9.1 基础平台笔试\n\n牛客 90min\n\n24校招-服务端（通用）试卷2\n\n单选x14（计网、c、数据结构）、编程x4（33%、75%、100%、100%）\n\n  * 给定两个单词word1和word2,计算出将word1转换成word2所使用的最少操作次数。\n  * 给你一个32位的有符号整数X，返回将X中的数字部分反转后的结果。如果反转后整数超过32位的有符号整数的范围[-231,231-1],就返回0.假设环境不允许存储64位整数（有符号或无符号）\n  * 合并K个升序链表\n  * 给定整数n返回所有小于非负整数n的质数的数量\n\n约面放弃了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598914678395260928?sourceSSR=users",
        "title": "正式通过的第三道笔试题，终于意识到什么时候应该使用贪心算法",
        "content": "小美种果树小美在手机上种果树，只要成熟了就可以领到免费的水果了。\n\n小美每天可以给果树浇水，果树的成长值加x。同时也可以给果树施肥，两次施肥至少需要间隔 2 天，果树的成长值加y。果树成长值达到 z 就成熟了。\n\n小红想知道，最少需要多少天可以领到免费的水果。\n\n    \n    \n    import java.util.Scanner;\n    \n    // 注意类名必须为 Main, 不要有任何 package xxx 信息\n    public class Main {\n        public static void main(String[] args) {\n            Scanner in = new Scanner(System.in);\n            // 注意 hasNext 和 hasNextLine 的区别\n    \n            Long x = in.nextLong();\n            Long y = in.nextLong();\n            Long z = in.nextLong();\n            Long myz=0L;\n            int day=0;\n            while(myz<z){\n                if(day%3==0) myz+=y;\n                myz+=x;\n                day++;\n            }\n            System.out.println(day);\n        }\n    }\n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598908065131380736?sourceSSR=users",
        "title": "360笔试 360笔试题 0309",
        "content": "笔试时间：2024年03月09日 春招实习\n\n**备注：题解待更新**\n\n历史笔试传送门：[2023秋招笔试合集](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fcreation%2Fmanager%2FcolumnDetail%2F0ODrNm)\n\n# 第一题\n\n### 题目：项目派遣\n\n某公司有n名员工，第i名员工具有的能力可以用一个正整数ai描述，称为员工的能力值，现在，公司有一个项目需要交给恰好n/2名员工负责。为了保证项目能顺利进行，要求负责该项目的所有员工能力值之和大于等于x。公司希望你可以帮忙求出，有多少种不同的派遣员工来负责这个项目的方案。上文中，[x]表示大于等于x的最小整数，例[4]\n=4，[4.2]=5。认为两个方案不同，当且仅当存在一名员工在一种方案中负责该项目，而在另一种方案中不负责。\n\n### 输入描述\n\n输入包含多组数据，输入第一行包含一个整数T (1<=T<=10) ，表示数据组数；\n\n接下来2T行，每两行描述了一组数据，每组数据第一行包含两个正整数n(1<=n<=16) 和x\n(1<=x<=2*10^4)，分别表示公司的员工总数和项目对负责员工能力值之和的要求；\n\n每组数据第二行包含n个整数，第i个整数表示第i名员工的能力值ai(1<=ai<=10^3)。\n\n对于100%的数据，满足1<=n<=16，1<=x<=2*10^4，1<=T<=10，1<=ai<=10^3。\n\n### 输出描述\n\n输出包含T行。对于每组数据输出一行一个整数，表示可行的派遣方案数。\n\n### 样例输入\n\n> 3\n>\n> 5 10\n>\n> 3 2 3 4 5\n>\n> 3\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598936684331384832?sourceSSR=users",
        "title": "京东 校招 面经/时间线",
        "content": "8.1开\n\n8.21投\n\n8.22测评\n\n一周内完成\n\n北森三部分\n\n性格特征测评（四个选项中选最符合和最不符合的性格描述）x98\n\n10.18一面\n\ncho-企业信息化\n\nJoymeet 15min\n\n  * 实习难点\n  * 项目背景\n  * 实习提升\n  * 实习整体体系化思考\n\nkpi味浓\n\n10.26面试官鸽了 笑\n\n官网显示初试 已转推荐 待筛选\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598903871280377856?sourceSSR=users",
        "title": "嵌入式面经111题答案汇总(含技术答疑)_嵌入式项目源码分享",
        "content": "> 111道嵌入式面试题答案汇总专栏链接（承诺免费技术答疑） -->\n> [《嵌入式/C++面试题解析大全》](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.nowcoder.net%2Fzhuanlan%2F3m2ONj)\n\n# 1、简介\n\n本人是2020年毕业于广东工业大学研究生：许乔丹。曾任**牛客大学讲师，资深牛客专栏作者** 。\n\n有国内大厂CVTE和世界500强企业工作经验，整理**超全面111道嵌入式面试题目答案解析（承诺提供专栏内容免费技术答疑）** ，本专栏内容主要有：\n\n  * 面试过程口头提问的问题答案汇总，承诺提供免费技术答疑，以及其他的交流，如要怎么入门c++，简历如何写，算法题如何刷等等，实现校招全陪伴！\n\n# 2、项目经验\n\n如果你找的是单片机，那就只要单片机的项目，如果你是嵌入式linux，你可以最多写一个单片机项目，其他都要写嵌入式linux的项目。\n\n如果你找嵌入式linux应用开发工作，也可以写linux驱动项目，但必须有一个应用层的项目。\n\n如果你找嵌入式linux驱动开发项目，最好也要有一个应用层项目，突出你对多进程多线程那些知识点有所了解。\n\n项目数量2-4个，此时就需要靠过往的经验积累了，如果确实没有项目，可以向身边做嵌入式的同学请教一下，快速掌握，同时也分享几个项目供参考：\n\n### 2.1 基于人脸属性识别的嵌入式电影推荐系统（嵌入式人工智能项目、可提供源码）\n\n1）情况：为解决“信息过载”问题，提出基于人脸属性识别的广告推荐系统。\n\n2）目标：独立负责，摄像头捕捉人脸并预测年龄、性别，显示屏可输入用户职业，系统根据此三大信息推荐8部电影并在显示屏显示。\n\n3）行动：搭建RK3399开发板开发环境，通过OpenCV获取摄像头图像，Dlib检测人脸，采用WRN神经网络预测年龄、性别，结合基于用户的协同过滤以及决策树模型进行电影推荐。使用PyQt5设计人机交互界面实现职业获取和电影信息显示。\n\n4）成果：在RK3399开发板可实时获取被推荐人年龄、性别、职业，据此推荐8部电影并将其电影名字和海报图显示在屏幕上。\n\n![alt](https://uploadfiles.nowcoder.com/images/20230830/545613072_1693410727968/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n### 2.2 基于Linux6818开发板的视频播放器（最好的入门项目，可提供源码）\n\n本项目基于嵌入式linux6818开发板，制作一个音视频播放器。开发板移植安装好mplayer，我提前下载了5个mv，使用mplayer命令分别在5个视频里截取某一秒的画面，共得到5张图片，也就是所谓的视频缩略图，将5个缩略图显示在显示屏的右边，当作是播放列表，支持上下滑动浏览播放列表，点击其中某个图片，即可播放对应视频，并实现播放器常见的开始、停止、上下首、音量调节、进度调节、全屏、静音等功能。使用到多进程技术：有名管道、消息队列、信号量；使用到多线程技术：互斥锁、条件变量。\n\n![alt](https://uploadfiles.nowcoder.com/images/20230830/545613072_1693410608066/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n### 2.3 基于Linux6818开发板的智能车库项目（进阶项目，可提供源码）\n\n没错，也是粤嵌6818开发板，搭配触摸屏、USB摄像头、音响，模拟实现真实场景中的智能车库常见功能:\n\n  * 实时视频监控\n  * 自动识别车牌\n  * 自动语音播报\n  * 停车计费\n\n需要使用到V4L2子系统，FrameBuffer子系统、OpenCV、多进程多线程编程、ALSA子系统、智能语音引擎、网络编程、数据库编程等。\n\n![alt](https://uploadfiles.nowcoder.com/images/20230831/545613072_1693411280940/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n# 3、嵌入式111道高频面试题\n\n> **八股文不在于量多，熟悉以下111道题就够啦** 。\n\n整理**超全面111道嵌入式面试题目答案解析（承诺提供专栏内容免费技术答疑）** ，本专栏内容主要有：\n\n  * 面试过程口头提问的问题答案汇总，承诺提供免费技术答疑，以及其他的交流，如要怎么入门c++，简历如何写，算法题如何刷等等，实现校招全陪伴！\n\n## 第一章 进程线程\n\n### 1.1 进程线程的基本概念\n\n  * 1.1.1 什么是进程，线程，彼此有什么区别⭐⭐⭐⭐⭐\n  * 1.1.2多进程、多线程的优缺点⭐⭐⭐⭐\n  * 1.1.3什么时候用进程，什么时候用线程⭐⭐⭐\n  * 1.1.4多进程、多线程同步（通讯）的方法⭐⭐⭐⭐⭐\n  * 1.1.5进程的空间模型⭐⭐⭐⭐\n  * 1.1.6进程线程的状态转换图 什么时候阻塞，什么时候就绪⭐⭐⭐\n  * 1.1.7父进程、子进程的关系以及区别⭐⭐⭐⭐\n  * 1.1.8什么是进程上下文、中断上下文⭐⭐\n  * 1.1.9一个进程可以创建多少线程，和什么有关⭐⭐\n\n### 1.2 并发，同步，异步，互斥，阻塞，非阻塞的理解\n\n  * 1.2.1什么是线程同步和互斥⭐⭐⭐⭐⭐\n  * 1.2.2线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？⭐⭐⭐⭐\n  * 1.2.3并发，同步，异步，互斥，阻塞，非阻塞的理解⭐⭐⭐⭐⭐\n\n### 1.3 孤儿进程、僵尸进程、守护进程的概念\n\n  * 1.3.1基本概念⭐⭐⭐⭐⭐\n  * 1.3.2如何创建守护进程：⭐⭐\n  * 1.3.3正确处理僵尸进程的方法⭐⭐⭐⭐\n\n## 第二章 C/C++高频面试题\n\n### 2.1 c和c++区别、概念相关面试题\n\n  * 2.1.1 new和malloc的区别⭐⭐⭐⭐⭐\n  * 2.1.2 malloc的底层实现⭐⭐⭐⭐\n  * 2.1.3在1G内存的计算机中能否malloc(1.2G)？为什么？⭐⭐\n  * 2.1.4指针与引用的相同和区别；如何相互转换？⭐⭐⭐⭐⭐\n  * 2.1.5 C语言检索内存情况 内存分配的方式⭐⭐⭐\n  * 2.1.6 extern”C” 的作用⭐⭐⭐\n  * 2.1.7头文件声明时加extern定义时不要加 因为extern可以多次声明，但只有一个定义⭐⭐⭐⭐\n  * 2.1.8函数参数压栈顺序，即关于__stdcall和__cdecl调用方式的理解⭐⭐⭐\n  * 2.1.9重写memcpy()函数需要注意哪些问题⭐⭐\n  * 2.1.10数组到底存放在哪里⭐⭐⭐\n  * 2.1.11 struct和class的区别 ⭐⭐⭐⭐⭐\n  * 2.1.12 char和int之间的转换；⭐⭐⭐\n  * 2.1.13 static的用法（定义和用途）⭐⭐⭐⭐⭐\n  * 2.1.14 static的用法（定义和用途）⭐⭐⭐⭐⭐\n  * 2.1.15const常量和#define的区别（编译阶段、安全性、内存占用等） ⭐⭐⭐⭐\n  * 2.1.16 volatile作用和用法 ⭐⭐⭐⭐⭐\n  * 2.1.17有常量指针 指针常量 常量引用 没有 引用常量⭐⭐⭐\n  * 2.1.18没有指向引用的指针，因为引用是没有地址的，但是有指针的引用⭐⭐⭐\n  * 2.1.19c/c++中变量的作用域⭐⭐⭐⭐⭐\n  * 2.1.20 c++中类型转换机制？各适用什么环境？dynamic_cast转换失败时，会出现什么情况？⭐⭐⭐\n\n### 2.2 继承、多态相关面试题 ⭐⭐⭐⭐⭐\n\n  * 2.2.1继承和虚继承 ⭐⭐⭐⭐⭐\n  * 2.2.2多态的类，内存布局是怎么样的 ⭐⭐⭐⭐⭐\n  * 2.2.3被隐藏的基类函数如何调用或者子类调用父类的同名函数和父类成员变量 ⭐⭐⭐⭐⭐\n  * 2.2.4多态实现的三个条件、实现的原理 ⭐⭐⭐⭐⭐\n  * 2.2.5对拷贝构造函数 深浅拷贝 的理解 拷贝构造函数作用及用途？什么时候需要自定义拷贝构造函数？⭐⭐⭐\n  * 2.2.6析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？⭐⭐⭐\n  * 2.2.7什么情况下会调用拷贝构造函数（三种情况）⭐⭐⭐\n  * 2.2.8析构函数一般写成虚函数的原因⭐⭐⭐⭐⭐\n  * 2.2.9构造函数为什么一般不定义为虚函数⭐⭐⭐⭐⭐\n  * 2.2.10什么是纯虚函数⭐⭐⭐⭐⭐\n  * 2.2.11静态绑定和动态绑定的介绍⭐⭐⭐⭐\n  * 2.2.12 C++所有的构造函数 ⭐⭐⭐\n  * 2.2.13重写、重载、覆盖的区别⭐⭐⭐⭐⭐\n  * 2.2.14成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？⭐⭐⭐⭐\n  * 2.2.15如何避免编译器进行的隐式类型转换；（explicit）⭐⭐⭐⭐\n\n## 第三章 网络编程\n\n### 3.1 TCP UDP\n\n  * 3.1.1 TCP、UDP的区别 ⭐⭐⭐⭐⭐\n  * 3.1.2 TCP、UDP的优缺点⭐⭐⭐\n  * 3.1.3 TCP UDP适用场景⭐⭐⭐\n  * 3.1.4 TCP为什么是可靠连接⭐⭐⭐⭐\n  * 3.1.5典型网络模型，简单说说有哪些；⭐⭐⭐\n  * 3.1.6 Http1.1和Http1.0的区别⭐⭐⭐\n  * 3.1.7 URI（统一资源标识符）和URL（统一资源定位符）之间的区别⭐⭐\n\n### 3.2 三次握手、四次挥手\n\n  * 3.2.1什么是三次握手⭐⭐⭐⭐⭐\n  * 3.2.2为什么三次握手中客户端还要发送一次确认呢？可以二次握手吗？⭐⭐⭐⭐\n  * 3.2.3为什么服务端易受到SYN攻击？⭐⭐⭐⭐\n  * 3.2.4什么是四次挥手⭐⭐⭐⭐⭐\n  * 3.2.5为什么客户端最后还要等待2MSL？⭐⭐⭐⭐\n  * 3.2.6为什么建立连接是三次握手，关闭连接确是四次挥手呢？⭐⭐⭐⭐\n\n## 第四章 常见算法\n\n### 4.1 排序算法\n\n  * 4.1.1各种排序算法的时间空间复杂度、稳定性⭐⭐⭐⭐⭐\n  * 4.1.2各种排序算法什么时候有最好情况、最坏情况（尤其是快排） ⭐⭐⭐⭐\n  * 4.1.3冒泡排序⭐⭐⭐⭐\n  * 4.1.4选择排序⭐⭐⭐⭐\n  * 4.1.5插入排序⭐⭐⭐⭐\n  * 4.1.6希尔排序⭐⭐⭐⭐\n  * 4.1.7归并排序⭐⭐⭐⭐\n  * 4.1.8快速排序⭐⭐⭐⭐⭐\n  * 4.1.9快排的partition函数与归并的Merge函数⭐⭐⭐\n\n### 4.2 STL库相关\n\n  * 4.2.1 vector list异同⭐⭐⭐⭐⭐\n  * 4.2.2 vector内存是怎么增长的vector的底层实现⭐⭐⭐⭐\n  * 4.2.3 vector和deque的比较⭐⭐⭐⭐\n  * 4.2.4为什么stl里面有sort函数list里面还要再定义一个sort⭐⭐⭐\n  * 4.2.5 STL底层数据结构实现⭐⭐⭐⭐\n  * 4.2.6利用迭代器删除元素会发生什么？⭐⭐⭐⭐\n  * 4.2.7 map是如何实现的，查找效率是多少⭐⭐⭐⭐⭐\n  * 4.2.8几种模板插入的时间复杂度 ⭐⭐⭐⭐⭐\n\n## 第五章 Linux操作系统常见面试题\n\n### 5.1 Linux内核相关\n\n  * 5.1.1 Linux内核的组成⭐⭐\n  * 5.1.2用户空间与内核通信方式有哪些？⭐⭐⭐⭐⭐\n  * 5.1.3系统调用read()/write()，内核具体做了哪些事情⭐⭐\n  * 5.1.4系统调用的作用⭐⭐⭐⭐⭐\n  * 5.1.5内核态，用户态的区别⭐⭐⭐⭐⭐\n  * 5.1.6 bootloader内核 根文件的关系⭐⭐⭐⭐\n  * 5.1.7 Bootloader多数有两个阶段的启动过程：⭐⭐⭐\n  * 5.1.8 linux的内核是由bootloader装载到内存中的？⭐⭐⭐\n  * 5.1.9为什么需要BootLoader⭐⭐⭐⭐\n  * 5.1.10 Linux内核同步方式总结⭐⭐⭐⭐\n  * 5.1.11为什么自旋锁不能睡眠 而在拥有信号量时就可以？⭐⭐⭐⭐\n  * 5.1.12 linux下检查内存状态的命令⭐⭐⭐\n\n### 5.2 其他操作系统常见面试题\n\n  * 5.2.1大小端的区别以及各自的优点，哪种时候用⭐⭐⭐⭐⭐\n  * 5.2.2 一个程序从开始运行到结束的完整过程（四个过程）⭐⭐⭐⭐⭐\n  * 5.2.3什么是堆，栈，内存泄漏和内存溢出？⭐⭐⭐⭐\n  * 5.2.4堆和栈的区别⭐⭐⭐⭐⭐\n  * 5.2.5死锁的原因、条件 创建一个死锁，以及如何预防⭐⭐⭐⭐⭐\n  * 5.2.6硬链接与软链接的区别；⭐⭐⭐⭐⭐\n  * 5.2.7虚拟内存，虚拟地址与物理地址的转换⭐⭐⭐⭐\n  * 5.2.8计算机中，32bit与64bit有什么区别⭐⭐⭐\n  * 5.2.9中断和异常的区别⭐⭐⭐⭐⭐\n  * 5.2.10中断怎么发生，中断处理大概流程⭐⭐⭐⭐\n  * 5.2.11 Linux 操作系统挂起、休眠、关机相关命令⭐⭐\n  * 5.2.12数据库为什么要建立索引，以及索引的缺点⭐⭐\n\n## 第六章 单片机常见面试题\n\n  * 6.1 CPU 内存 虚拟内存 磁盘/硬盘 的关系⭐⭐⭐\n  * 6.2 CPU内部结构⭐⭐⭐⭐\n  * 6.3 ARM结构处理器简析 ⭐⭐\n  * 6.4波特率是什么，为什么双方波特率要相同，高低波特率有什么区别；⭐⭐⭐⭐\n  * 6.5arm和dsp有什么区别⭐⭐\n  * 6.6 ROM RAM的概念浅析⭐⭐⭐\n  * 6.7 IO口工作方式：上拉输入 下拉输入 推挽输出 开漏输出⭐⭐⭐⭐\n  * 6.8扇区 块 页 簇的概念⭐⭐⭐⭐\n  * 6.9简述处理器在读内存的过程中，CPU核、cache、MMU如何协同工作？画出CPU核、cache、MMU、内存之间的关系示意图加以说明⭐⭐\n  * 6.10请说明总线接口USRT、I2C、USB的异同点（串/并、速度、全/半双工、总线拓扑等）⭐⭐⭐⭐⭐\n  * 6.11什么是异步串口和同步串口⭐⭐⭐⭐⭐\n  * 6.12 I2C时序图⭐⭐⭐⭐⭐\n\n![alt](https://uploadfiles.nowcoder.com/images/20230206/545613072_1675674726255/0761E04C9A30D48C6C719FF49D3CC5ED)\n\n## 高级系列专栏：\n\n## 安卓（安卓系统开发也要掌握）\n\n  * 想通关安卓面试，请看：[《150道安卓高频面试题目录及答案链接》](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F396383934924292096)\n  * 想通关安卓系统面试，请看：[《140道安卓系统Framework面试题目录及答案链接》](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F456922214454091776)\n  * 想进阶安卓开发，请看：[《Android进阶知识体系解析_15大安卓进阶必备知识点》](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F462666906584043520)\n  * 想了解安卓APP完整开发流程，请看：[《安卓APP完整开发流程》](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.nowcoder.net%2Fzhuanlan%2FMQ2yE0)\n  * 想掌握安卓App性能优化，请看：[《安卓性能优化讲解和实战专栏》](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F483578208504250368)\n  * 想掌握Gradle语法，制作Gradle插件，请看：[《安卓Gradle语法解析和实践大全》](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F483578554362380288)\n\n## 嵌入式\n\n  * 想通关嵌入式面试，请看： [《111道嵌入式面试题目录及答案链接》](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F419423154676789248)\n  * 想多掌握几个嵌入式项目，请看：[《6个嵌入式项目交流分享（附源码）》](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fdiscuss%2F389554189238751232)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598894632692465664?sourceSSR=users",
        "title": "3.17 乐刻运动 测试开发 一面",
        "content": "自我介绍\n\n实习了多长时间\n\n为什么不转正\n\n问竞赛经历\n\n偏向前端还是后端\n\n了解哪些测试框架\n\n有没有搭建过自动化测试框架\n\n怎样设计这个框架？\n\n有没有试过大厂的实习？\n\n熟悉Java吗？\n\n设计模式了解吗？\n\n介绍一下单例模式？扯到Webserver的项目介绍\n\n简单介绍下单例模式\n\n转语言的问题\n\n刷题用什么平台？\n\n刷的难度怎样？\n\n熟悉什么算法？\n\n不擅长什么算法？（把我问懵了）\n\n还投了什么公司？\n\n面试有几个？（没几个...）\n\n测开和开发二选一？（送命题）\n\n黑盒测试？\n\n白盒测试？\n\n数据库索引实现\n\n介绍下B+树\n\n数据库高阶特性和编译原理学校教过吗\n\n查询优化，索引存储有接触过吗\n\n反问\n\n啥时候通知\n\n开发占测开的比例\n\n主要业务\n\n总结下来就是，好长时间没面试，话都不会说了，答得语无伦次，想到啥说啥。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598880004616863744?sourceSSR=users",
        "title": "拼多多实习面经（附内推）",
        "content": "# 背景：\n\n楼主往届校招pdd，已入职\n\n# 一面\n\n面试官：先来个布局的吧！如何让一个元素垂直居中\n\n我：行内元素就line-height、块级元素就flex、grid、table-cell布局都可以，还有定位+translate，这个兼容性较好。\n\n面试官：了解过新的css属性？比如layer\n\n我：没有\n\n面试官：说一下this\n\n我：this是运行时上下文，是函数内为了访问类的属性而存在，其中箭头函数的this就是其定义时外部的this，而bind、call、apply都可以改变函数内this的指向。\n\n面试官：箭头函数的this可以改变吗？\n\n我：没试过\n\n面试官：做道题吧，深拷贝\n\n我：知道，但是没写过\n\n我：写了个递归+复制对象的属性\n\n面试官：如果入参不是对象怎么办，比如boolean、number、string、null、undefined、array\n\n我：补充了很多判断代码，基础数据类型/null/undefined就直接返回、array/objet就forin遍历然后返回\n\n面试官：如果a对象引用了b对象，b对象引用了a对象怎么办，引用循环问题\n\n我：写了一个cache缓存器，如果遍历过程中cache中有a，则直接返回，不再深拷贝\n\n面试官：你这个cache怎么清空，什么时候清空\n\n我：这里我并没有将cache传入给深拷贝函数，在函数体里面清空，而是在函数体外定义、清空cache。然后面试官推荐了一个写法，将cache传入进去，然后在深度为1时清空它。属于缓存优化\n\n面试官：再做一道题吧，promise相关的\n\n我：如果了解promise的话，这题不难，说出打印顺序即可\n\n一面说实在我还是很菜的，深拷贝得面试官多次提醒才能完善，但至少还在可接受范围内，面试官很柔和。\n\n# 二面\n\n面试官：你先做一下这道题，只能使用队列，不能使用别的数据结构来实现栈的功能。\n\n我：考虑了几分钟后，我说出了思路，在入栈时，调用的入队，同时更新min最小值。\n\n出栈时将队列中的最后一位的前面的元素都拿出来，然后放入队列后，然后拿出最后一个就是出栈元素。\n\n但是打印最小值时有点问题，我想了一会，然后得出，在出栈时，会遍历到所有的元素，所以可以在这个过程更新最小值。\n\n面试官：好，那你写出来吧\n\n我：写呀写，写完之后，有个用例没法通过，然后人脑debug一下，原来在出栈时，更新最小值时，得先将最小值重置。\n\n面试官：问了简历里，写的所有的项目\n\n面试官：那你说一下vue和react的差别吧\n\n我：vue2了解的多，react了解不多，两者最大的区别是虚拟dom结构，vue2是一颗结构很正常的树，react是一个fiber树，两者树的实现方式不一样。react的patchnode算法和vue的不一样，react是全量比较vDom，vue是组件层级比较vDom。react和vue的对于children的比较算法也不一样，然后，个人觉得vue高效一些（这里答的有点模糊了我）。\n\n二面面试官属于硬核派，上来先做题，但确实是知识面碾压。\n\n# 三面-主管面-电话面\n\n之前不知道主管面是什么，我以为还是技术面，所以我回答的有点牛头不对马嘴了。\n\n面试官就主要问项目实现方式（不需要硬核的技术层）就没了。\n\n# 内推链接：（实习生招聘）\n\n[https://careers.pinduoduo.com/campus/intern?t=Q1RKK3fACC，内推码：Q1RKK3fACC](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgw-c.nowcoder.com%2Fapi%2Fsparta%2Fjump%2Flink%3Flink%3Dhttps%253A%252F%252Fcareers.pinduoduo.com%252Fcampus%252Fintern%253Ft%253DQ1RKK3fACC%2525EF%2525BC%25258C%2525E5%252586%252585%2525E6%25258E%2525A8%2525E7%2525A0%252581%2525EF%2525BC%25259AQ1RKK3fACC)\n\n欢迎随时咨询联系\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598878146858958848?sourceSSR=users",
        "title": "北京某互联网公司 Java 面经",
        "content": "# 北京某互联网公司 Java 面经\n\n1）\n\n面试官：我看你这块是有一个开源的项目，这个项目主要是做什么的？\n\n我：主要两点是亮点，智能推荐和智能分析，一个就是 AI 模型调用，搞点数据清洗和分析，第二个就是个简单的\nBI，大家主要介绍项目的一个核心业务（亮点），CRUD 的这一块可以一笔带过。\n\n2）\n\n面试官：你 AI 这块用的是什么模型？\n\n我：阿里、讯飞星火，主要是因为免费，我自己开源项目要是用 OpenAI ，被刷流量直接就GG了...\n\n3）\n\n面试官：你的这块主要开发语言是什么？\n\n我：后端 Java、Python（一般），前端：Vue 和 React\n\n4）\n\n面试官：Java 值传递还是引用传递？\n\n我：....经典八股文，不作具体阐述了，别只说值传递，而不说具体的原因和例子就可以了，举例说明，必要时可共享屏幕，敲几个例子。\n\n5）\n\n面试官：介绍一下 Java 的线程安全和锁机制？\n\n我：这个问题其实太宽泛了，可以先将线程安全的一个概念，然后可以讲讲死锁的四个条件、银行家算法、哲学家就餐问题，408的直接拿出来讲，锁机制可以讲讲\nSynchronized 和 Lock，锁升级过程，优缺点、使用场景等等\n\n6）\n\n面试官：HashTable 和 HashMap 的区别？\n\n我：经典问题，HashTable 底层还是调用的 HashMap 的 Put,但 HashTable 的哈希值计算方式不一样，HashTable\n的哈希值是直接拿 Key 的，HashMap 扰动函数，散列分布更加均匀，减少 Hash 冲突的概率，扩容机制也可以对比一样，一般也用不着\nHashTable 和 Vector 基本一样，很少用到。\n\n  7. \n\n面试官：Nginx 代理这块了解多少？\n\n我：正向代理，反向代理，自己找过博客，弄过配置文件去解决跨域问题，也了解过 Nginx 的几种负载均衡算法。\n\n8）\n\n面试官：输入 URL ，到页面渲染的过程？\n\n我：...经典的问题，不作过多的阐述，408越6的讲的越多，随便扯。\n\n9）\n\n面试官：常见的排序算法介绍一下\n\n我：我就介绍了快速、堆、计数、冒泡、选择，希尔、直接插入，桶排序....\n\n10）\n\n面试官：字符串的排序，而且量比较大，用什么排序算法合适？\n\n我：我的想法还是分治，然后堆，不过网上好像有针对字符串的一个键索引计数法...\n\n11）\n\n面试官：Redis 怎么用的？\n\n我：根据项目去介绍即可，分布式锁就讲，有限流就讲，有缓存预热，有缓存穿透，缓存击穿，缓存雪崩的解决方案就讲，要结合业务去讲，不是问常规八股文\n\n12）\n\n面试官：Docker 有学习过吗？\n\n我：有的，自己的项目没有去部署过（项目太简单了，没啥必要，宝塔一键启动（丑陋）），看过一些教程，了解常规的命令。\n\n13）\n\n面试官：图片验证码怎么实现？\n\n我：主要还是要做一个限流，然后调用第三方服务去实现这个功能，存到 Redis 即可，这些数据没啥用，过期时间可以短一些。\n\n14）\n\n反问主要的业务、技术栈、工作时间、薪资待遇。\n\n有挺多很水的面试，基本没问几个问题就过了，于是好久没发面经了，实习说实话还是挺好找的，看个人要求，中大厂实习自然要求不一样勒，别怕面试，先投再说，一开始流程还是挺慢的。\n\n开源 AI 项目 Gitee 地址：[https://gitee.com/falle22222n-leaves/vue_-book-manage-\nsystem](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgitee.com%2Ffalle22222n-leaves%2Fvue_-\nbook-manage-system)\n\n欢迎老铁们 Star 下！累计总后端 800 + Star，1.5W+访问 ⭐⭐⭐\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598864011492454400?sourceSSR=users",
        "title": "腾讯大数据 Java一面面经",
        "content": "已挂\n\n实习时间\n\n自我介绍\n\n了不了解 go（不了解）\n\nredis 为什么快\n\nredis 多线程\n\nredis 实现分布式锁\n\nMySQL 底层索引\n\nB+树\n\n事务四大特性\n\n分库分表\n\n分库分表怎么精准定位\n\nTCP 三次握手、四次挥手\n\nHTTP、HTTPS 的区别\n\nSSL/TLS\n\n消息队列的作用\n\n堆和栈的区别（数据结构）\n\n了不了解 linux（不了解）\n\n线程和进程的区别\n\n死锁的概念\n\n死锁产生的条件\n\n项目\n\n反问\n\n无手撕\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598788915461484544?sourceSSR=users",
        "title": "前端面经上海某游戏厂+碎碎念",
        "content": "🪪背景：双非本硕，25届，0实习经历，小论文已投在审\n\n🧑‍💻岗位：前端开发实习（日常实习）\n\n👨‍💼线下面试，2位面试官\n\n👥面试题目：\n\n1.为什么学习前端（课程写了机器学习和神经网络）\n\n2.讲一下项目\n\n3.讲一下CSS的布局定位\n\n4.浮动，高度塌陷\n\n5.定位，子绝父相\n\n6.flex：1\n\n7.水平垂直居中\n\n8.讲一下响应式布局\n\n9.讲一下闭包\n\n10.vue的组件通信\n\n11.浏览器本地存储\n\n12.输入官网网址，浏览器发生了什么\n\n13.git 合并操作\n\n14.说一下你对自己未来发展的规划\n\n📅 03.12投递，03.14约面，03.15oc\n\n        我面的第一家公司，没想到这么顺利，流程也很快，已接，下周就入职，后面拒掉了另一家国企科技子公司的前端实习 [好无辜]，感觉秋招时国企可能前端招得少（不确定） [疑惑]，还是更想去互联网公司 [打气]。\n\n       由于学校双非+无实习经历+没学react+没刷算法，所以就没敢投暑期实习，从03.07开始海投日常实习，boss沟通66家，共投递27份，5家公司给了面试机会（全是线下面试，上海各地来回跑累死了），最后oc2家，本菜鸡已经十分满意了。\n\n       想问一下各位大佬，是在这家上市游戏公司一直干到秋招前，全力准备秋招面试背八股刷算法？还是在秋招之前再刷一段实习经历（怕秋招时直接被简历筛掉，可能有两段实习简历会更好看？但我又担心是不是到时候，暑期边实习边背八股刷算法，会准备不充分）请各位佬给点建议。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598678848087105536?sourceSSR=users",
        "title": "腾讯 wxg 读书产品团队 一面",
        "content": "## 算法题\n\n  1. 593有效的正方形\n  2. 104二叉树的最大深度 \n     * 递归解决，然后问时间，空间复杂度（![](https://www.nowcoder.com/equation?tex=O\\(n\\)%2CO\\(logn\\)&preview=true)）\n     * 然后问有没有迭代实现，写了层序遍历实现\n     * 继续问有没有其他通过迭代实现的方法，写了后序遍历的迭代实现\n  3. 98验证二叉搜索树 \n     * 先考虑用「判断中序遍历数组是否是严格递增的」来判断，然后问时间空间复杂度（均为 ![](https://www.nowcoder.com/equation?tex=O\\(n\\)&preview=true)）\n     * 然后问觉得有没有空间复杂度是 ![](https://www.nowcoder.com/equation?tex=O\\(1\\)&preview=true) 的算法，回答有，应该可以考虑在遍历的过程中改变节点左指针的指向，但是不会具体实现\n     * 然后问有没有空间复杂度小于 ![](https://www.nowcoder.com/equation?tex=O\\(n\\)&preview=true) 的算法，用中序遍历的迭代实现（记录前一个访问的节点）来解题，然后问空间复杂度（![](https://www.nowcoder.com/equation?tex=O\\(logn\\)&preview=true)）\n  4. 业务题：实现指定字节对齐的内存分配和释放操作，函数头：void *AllignedMalloc(size_t size, int aligned)、void AlignedFree(void *data)\n  5. 业务题：页面上有两个广告位，写一个方法返回ABCD四个广告中的两种（无重复），让他们最终在广告位置上出现的概率分别为：10%，20%，30%，40%\n\n## 八股\n\n  1. 介绍下C++智能指针和使用场景\n  2. C++ map 和 unordered_map的区别，什么场景下选择哪种数据结构\n  3. C++ static 关键字的作用\n  4. 介绍下进程、线程、协程的区别；\n  5. 要执行一批任务时，怎么确定是使用多进程还是多线程还是多协程\n\n## 其他\n\n没有问实习，没有问项目\n\n## 后记\n\n3.12一面，3.15上午仍未出结果，下午打电话过去催，然后在1h内完成 被挂+腾讯新闻组初试的通知\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598665803319234560?sourceSSR=users",
        "title": "美团-前端-笔试",
        "content": "感觉要G了，好难，选择题除了综测类感觉都考的很细，而且不是全部和前端相关的，和考研题目一样。个人记忆能力有限，尽量写一下相关的内容。算法也G了，第二题脑子出问题了，一个快速幂算法没写出来。之后等待下一次笔试，面试看情况吧，选择题做的还可以，万一过了呢！😂😂😂\n\n# 算法部分：\n\n第一题：输入一个字符串，每一次可以将一个字符改为大写或小写字母，最后要变为全大写、全小写、首字母大写三种情况之一，求最小变换次数。如AbC，输出1，可以变为ABC，或Abc。简单题，直接求大写字母个数就能求出解。\n\n第二题：一个数组arr，每一次将其中除了第x个（从1开始）之外的其余元素乘以2，一共操作了q次，求最后操作完的元素和。\n\n这个给个暴力解答案：\n\n    \n    \n    import java.util.Scanner;\n    \n    public class Main {\n      public static void main(String[] args){\n        Scanner scanner =new Scanner(System.in);\n        int n= scanner.nextInt();// 数组的大小\n        int q= scanner.nextInt();// 操作次数\n        long[] arr = new long[n];\n        for(int i= 0;i <n; i++){\n            arr[i]= scanner.nextLong();// 输入数组元素\n        }\n        Long mod = (long) 1000000007;// 10^9 + 7\n        int[] countNotDoubled = new int[n];// 记录每个元素未翻倍的次数\n        for(int i= 0;i< q; i++){\n            int xi = scanner.nextInt()- 1;// 读取操作的元素，索引调整为从0开始countNotDoubled[xi]++;//记录该元素未被翻倍的次数\n            countNotDoubled[xi]+=1;\n        }\n        long sum = 0;\n        for(int i= 0;i< n; i++){\n          long doubleTimes =q- countNotDoubled[i];// 计算实际翻倍的次数\n          long addition =(arr[i]* powMod( 2,doubleTimes,mod))% mod;// 元素经过翻倍后的值\n          sum =(sum + addition)% mod;// 累加到总和中\n        }\n        System.out.println(sum);\n        }\n      // 快速幂模算法，用于计算(base^exponent)% mod 的值1 usage\n      public static long powMod(long base, long exponent, long mod) {\n        long result = 1;\n        base = base % mod;\n        while(exponent>0){\n            if(exponent %2 == 1)result =(result * base)% mod;exponent = exponent >> 1;\n            base =(base * base)% mod;\n        }\n        return result;\n      }\n    }\n    \n\n# 选择部分：\n\n  1. 一个容量为m的循环队列，初始front和rear在同一位置，某一时刻队列长度计算方法\n  2. 1型文法，2型文法，3型文法判断\n  3. 操作系统使用抢占式优点调度算法，一共50个进程等待执行，高优先级事件片为200ms，低优先级为400ms，切换为10ms。若优先级队列中高优先级咱比为0.4.求系统开销占比率\n  4. 已知一个文法求句柄，短语\n  5. TPC三次握手，传说的ACK，seq之类\n  6. DNS报文结构\n  7. 依据类图看设计模式\n  8. 责任链模式\n  9. 16个页面，每个页面1K大小，传入64个物理磁盘，求地址位数\n  10. 经典数字找规律题\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598648392775913472?sourceSSR=users",
        "title": "【京东】JDS 后端面经，面试体验很棒|0316",
        "content": "![alt](https://git.acwing.com/Hasity/interview_hunter/-/raw/master/2024/image/%E9%9D%A2%E7%BB%8F14%E4%BA%AC%E4%B8%9C.png)\n\n## 1\\. 来说说 MySQL的索引?\n\n**解析：**\n\nMySQL 索引属于必考题，难度中等。\n\n**参考回答：**\n\n> **一、MySQL索引原理**\n>\n> MySQL索引采用了B+树的数据结构，能够大大提高查询效率。它类似于书籍的目录，通过索引，数据库系统可以迅速定位到表中的特定数据，无需扫描整个表。\n>\n> **二、MySQL索引的优点**\n>\n>   1. **提高查询速度** ：通过索引，数据库可以迅速找到所需数据，避免了全表扫描的耗时操作。\n>   2. **保证数据的唯一性** ：通过唯一索引，可以确保数据库表中每一行数据的某列或多列组合是唯一的。\n>   3. **加速表与表之间的连接** ：在执行连接操作时，如果连接的字段已经被索引，那么连接的速度会更快。\n>\n\n>\n> **三、MySQL索引的缺点**\n>\n>   1. **占用磁盘空间** ：索引本身需要占用一定的磁盘空间。\n>   2. **降低写操作的性能** ：每次对表中的数据进行增、删、改操作时，索引也需要进行相应的调整，这可能会降低写操作的性能。\n>\n\n>\n> **四、MySQL索引的使用场景**\n>\n>   1. **经常需要搜索的列** ：对于经常出现在WHERE子句中的列，应该考虑建立索引。\n>   2. **作为连接键的列** ：如果某列经常出现在连接（JOIN）操作中，也应该考虑建立索引。\n>   3. **经常需要排序的列** ：如果某列经常需要按照其值进行排序，也可以考虑建立索引。\n>\n\n>\n> **五、注意事项**\n>\n>   1. **避免过度索引** ：不是每个列都需要建立索引，过多的索引会占用更多的磁盘空间，并可能降低写操作的性能。因此，需要根据实际情况进行选择。\n>   2. **定期维护索引** ：随着时间的推移，数据库中的数据会发生变化，索引的性能也可能会受到影响。因此，需要定期检查和优化索引。\n>\n\n>\n> 总的来说，MySQL索引是提高数据库查询性能的重要工具，但也需要根据实际情况进行合理使用和维护。\n\n**学习指引：**[MySQL索引详解（一文搞懂）](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fdeveloper.aliyun.com%2Farticle%2F831250)\n\n>\n> **[面经专栏直通车](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fcreation%2Fmanager%2FcolumnDetail%2F0xKkDM)**\n\n>\n> **[面经专栏下载](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgit.acwing.com%2Flicw%2F24_job_hunter)**\n\n## 2\\. MySQL索引为什么不用红黑树，AVL树，为什么要用 B+树?\n\n**解析：**\n\nMySQL 索引属于必考题，难度中等。\n\n**参考回答：**\n\n> MySQL索引选择使用B+树而不是红黑树或AVL树，主要是基于B+树在数据库环境中的特定优势和特性。\n>\n>   1. **多路搜索特性**\n> ：B+树是一个多路平衡搜索树，这意味着每个节点可以有多于两个的子节点。这种特性使得B+树相对于二叉树（如红黑树和AVL树）在树的高度上具有优势。在数据库中，树的高度直接关系到查询性能，因为每次查询都需要从根节点遍历到叶子节点。多路搜索特性有助于降低树的高度，从而减少I/O操作和查询时间。\n>   2. **范围查询和排序性能**\n> ：B+树特别适用于范围查询和排序操作。由于其叶子节点之间通过指针相连，可以很方便地遍历叶子节点以获取范围内的数据。相比之下，红黑树和AVL树在进行范围查询时可能需要中序遍历，效率较低。此外，B+树在叶子节点中存储了所有的数据，使得排序操作更加高效。\n>   3. **磁盘I/O优化**\n> ：在数据库中，数据通常存储在磁盘上，而磁盘I/O操作是数据库性能的关键瓶颈之一。B+树的非叶子节点只存储键值信息，而实际的数据存储在叶子节点中。这种设计使得非叶子节点可以容纳更多的键值信息，从而减少了树的高度和磁盘I/O次数。此外，由于B+树的叶子节点之间通过指针相连，数据库系统可以更加高效地读取和缓存数据。\n>   4. **平衡性**\n> ：B+树在插入和删除节点时能够保持较好的平衡性，避免了树的高度过度增长。这种平衡性保证了查询性能的稳定性，不会因为数据的插入和删除操作而产生显著的波动。\n>\n\n>\n>\n> 红黑树和AVL树虽然也是平衡二叉树，但在数据库环境中可能并不适用。它们的树高度相对较高，导致查询性能下降；同时，它们在处理范围查询和排序操作时效率较低。此外，红黑树在插入和删除节点时需要调整树的结构以保持平衡，这也会增加额外的开销。\n\n**学习指引：**[为什么mysql索引底层使用的是B+树存储，而不是红黑树吗？](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fjustorderman%2Farticle%2Fdetails%2F110926890)\n\n## 3\\. 说说 MySQL语句的执行过程?\n\n**解析：**\n\nMySQL 的基础题，常考题。\n\n**参考回答：**\n\n> MySQL语句的执行过程涉及多个关键阶段，以下是其大致的执行流程：\n>\n>   1. **客户端发送SQL语句** ：\n> 当用户在客户端（如MySQL命令行工具、图形化界面工具等）输入SQL语句并执行时，这条语句首先被发送到MySQL服务器。\n>   2. **词法解析和语法解析** ：\n> MySQL服务器接收到SQL语句后，首先会进行词法解析，将SQL语句拆分成一个个的词汇单元（如关键字、表名、列名等）。接着进行语法解析，根据MySQL的语法规则判断这条SQL语句是否合法，并生成一个“解析树”。\n>   3. **预处理** ：\n> 在语法解析之后，MySQL会进行预处理阶段。这个阶段会检查SQL语句中涉及的表、列等是否存在，并解析权限。如果涉及存储过程、函数或触发器，也会在这一阶段进行预处理。\n>   4. **优化器优化** ：\n> MySQL查询优化器会对解析树进行优化，选择最高效的执行计划。它会考虑多种因素，如表的大小、索引、统计信息等，以决定如何最快地获取查询结果。\n>   5. **生成执行计划** ： 优化器根据优化结果生成一个详细的执行计划，这个计划描述了如何获取数据、如何连接表、如何排序等。\n>   6. **执行引擎执行** ：\n> 执行引擎按照执行计划开始执行。它可能会与存储引擎交互，从磁盘上读取数据、写入数据或更新数据。如果涉及多个表，执行引擎还会负责表的连接操作。\n>   7. **返回结果** ：\n> 执行引擎将查询结果返回给客户端。这个结果可能是查询到的数据行，也可能是受影响的行数（如INSERT、UPDATE、DELETE操作）。\n>   8. **清理** ： 查询执行完毕后，MySQL会进行清理工作，如释放内存、关闭临时表等。\n>\n\n>\n>\n> 在整个过程中，MySQL还会涉及一些日志的写入，如二进制日志（用于复制和恢复操作）、慢查询日志（记录执行时间较长的查询）等。此外，如果开启了事务，还会涉及事务的管理和锁定机制。\n\n**学习指引：**[【SQL】Mysql中一条sql语句的执行过程](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%2Farticle%2F2392757)\n\n## 4\\. MySQL有缓存吗?\n\n**解析：**\n\n考察 MySQL 的基础，属于中等难度题。\n\n**参考回答：**\n\n> **MySQL有缓存机制**\n> 。MySQL数据库会缓存已经执行过的SQL语句和语句执行结果。如果下次提交同一个SQL语句，MySQL就会直接从缓存中读取执行结果，而不是重新分析、执行SQL，这样可以减少SQL语句的执行时间，提高查询效率。\n>\n>\n> 但是，如果表中的数据发生变化，所有与之相关的缓存都会被释放刷新，以避免出现数据脏读问题。此外，MySQL也提供了手动选择是否使用缓存查询的功能，可以在SQL查询语句的字段前增加SQL_NO_CACHE或SQL_CACHE关键字来控制是否使用缓存。\n>\n>\n> 总的来说，MySQL的缓存机制是其性能优化的一部分，有助于提高查询速度和效率。然而，需要注意的是，缓存并不总是有利的，特别是在数据频繁变化的情况下，因此需要根据实际情况合理使用和管理缓存。\n\n**学习指引：**[[玩转MySQL之四]MySQL缓存机制](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F55947158)\n\n## 5\\. MySQL的事务说一下?\n\n**解析：**\n\n考察数据库基础知识，必考题。\n\n**参考回答：**\n\n>\n> MySQL的事务（Transaction）是数据库管理系统执行过程中的一个逻辑单位，它由一个或多个SQL语句组成，这些语句要么全部执行，要么全部不执行。事务的主要目的是确保数据的完整性和一致性，在并发操作中保持数据的正确状态。\n>\n> 事务具有以下四个关键特性，通常被称为ACID特性：\n>\n>   1. **原子性（Atomicity）** ：事务被视为一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。\n>   2. **一致性（Consistency）**\n> ：事务必须使数据库从一个一致性状态变换到另一个一致性状态。这意味着一个事务在执行前后，数据库都必须处于一致性状态。\n>   3. **隔离性（Isolation）** ：在事务执行过程中，其他事务不能访问该事务的数据，直到该事务完成。这确保了并发执行的事务不会相互干扰。\n>   4. **持久性（Durability）** ：一旦事务提交，则其结果就是永久性的，即使系统崩溃也不会丢失。\n>\n\n>\n>\n> 在MySQL中，特别是InnoDB存储引擎，事务得到了全面的支持。当你在InnoDB中执行一个事务时，可以包含多个SQL语句，这些语句要么全部成功，要么在发生错误时全部回滚（撤销）。这通过维护一个撤销日志（undo\n> log）来实现，当事务需要回滚时，可以利用这个日志将数据恢复到事务开始之前的状态。\n>\n>\n> 此外，MySQL还提供了事务控制语句，如`COMMIT`和`ROLLBACK`，来显式地提交或回滚事务。`COMMIT`用于提交事务，即将事务中的修改永久保存到数据库中；而`ROLLBACK`则用于撤销事务中的修改，将数据库恢复到事务开始之前的状态。\n\n**学习指引：**[MySQL事务【详解-\n最新的总结】](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fwang_luwei%2Farticle%2Fdetails%2F119619105)\n\n## 6\\. Spring 的事务和我们 MySQL的事务是一回事吗?\n\n**解析：**\n\n考察Spring和MySQL的对比，需要了解。\n\n**参考回答：**\n\n> Spring 的声明式事务和数据库的事务并不是一回事，尽管它们在某些方面存在关联。\n>\n> 声明式事务是 Spring\n> 框架提供的一种机制，用于在应用程序中管理事务的执行。它允许你通过配置方式定义事务的行为，而无需显式编写事务管理代码。声明式事务可以应用于多个业务方法，而不仅仅是数据库操作。\n>\n> 数据库的事务是数据库引擎提供的一种机制，用于确保数据库操作的原子性、一致性、隔离性和持久性（ACID\n> 特性）。数据库事务通常用于在数据库操作期间维护数据的完整性和一致性。它可以包含多个数据库操作，并且在事务执行期间，这些操作要么全部提交成功，要么全部回滚到事务开始前的状态。\n>\n> 在 Spring 中，声明式事务可以应用于包含数据库操作的方法，以确保这些操作在事务的上下文中执行，并根据需要进行提交或回滚。\n>\n> 声明式事务通过将事务管理逻辑与业务逻辑分离，提供了更高层次的抽象和灵活性。它可以用于管理其他类型的事务，如消息队列、远程服务调用等。\n>\n> 总结来说，声明式事务是 Spring\n> 框架提供的一种事务管理机制，可以应用于多种业务操作，包括数据库操作。而数据库的事务是数据库引擎提供的一种机制，用于确保数据库操作的一致性和完整性。Spring\n> 的声明式事务可以管理数据库事务，但它不仅限于数据库操作。\n\n**学习指引：**[spring声明式事务和数据库的事务是一回事吗](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhangxueliang.blog.csdn.net%2Farticle%2Fdetails%2F134522691)\n\n## 7\\. Spring的事务什么时候会失效?\n\n**解析：**\n\n考察Spring的熟悉程度，常考题。\n\n**参考回答：**\n\n> Spring的事务在多种情况下可能会失效，以下是一些常见的原因：\n>\n>   1. **自调用**\n> ：当类中的方法调用本类中的另一个方法时，如果调用是通过this进行的（通常省略），那么此时this并不是代理对象，而是实际的类实例。因此，事务不会生效。解决这个问题的方法是，从Spring的IoC容器中获取该类的代理对象，并通过代理对象来调用方法。\n>   2. **方法访问权限问题**\n> ：Spring要求被代理的方法必须是public的。如果方法不是public的，事务将不会生效。此外，如果方法被final修饰，Spring的动态代理无法代理final方法，因此事务也会失效。\n>   3. **数据库不支持事务**\n> ：某些数据库引擎（如MySQL的MyISAM引擎）不支持事务，因此即使Spring配置了事务，这些操作也不会在事务中执行。\n>   4. **方法没有被Spring管理**\n> ：如果类没有被Spring管理（即没有添加@Controller、@Service、@Repository等注解），那么它的方法不会被Spring的事务管理器控制，因此事务不会生效。\n>   5. **异常处理不当**\n> ：如果在事务方法中发生异常，并且该异常没有被Spring的事务管理器捕获，那么事务不会回滚。此外，对于非RuntimeException（即checked异常），Spring默认不会回滚事务，除非在@Transactional注解中明确指定了rollbackFor属性。\n>   6. **多线程调用**\n> ：由于Spring的事务管理是基于ThreadLocal的，不同线程间的事务是隔离的。因此，如果在一个线程中开启事务，然后在另一个线程中执行数据库操作，那么这些操作不会参与之前线程的事务。\n>   7. **错误的传播属性**\n> ：@Transactional注解有一个propagation属性，用于指定事务的传播行为。如果使用了错误的传播属性，可能导致事务的行为不符合预期。\n>   8. **自定义了回滚异常与事务回滚异常不一致**\n> ：如果在@Transactional注解中自定义了回滚的异常类型，但实际抛出的异常与该类型不匹配，那么事务不会回滚。\n>\n\n**学习指引：**[Spring事务失效场景](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fm0_51465608%2Farticle%2Fdetails%2F136724257)\n\n## 8\\. 非聚簇索引的回表机制?\n\n**解析：**\n\n考察MySQL索引，必考题。\n\n**参考回答：**\n\n> 非聚簇索引的回表机制是数据库查询中的一个重要概念，尤其在MySQL的InnoDB存储引擎中。以下是对非聚簇索引回表机制的详细解释：\n>\n>\n> 首先，我们需要理解聚簇索引和非聚簇索引的基本区别。聚簇索引的叶子节点存储的是行记录，也就是说，数据与索引是存储在一起的。而非聚簇索引的叶子节点存储的则是主键值，也就是说，数据和索引是分开的。\n>\n> 当我们使用非聚簇索引进行查询时，查询过程大致如下：\n>\n>   1. 数据库首先在非聚簇索引中找到满足查询条件的数据行的主键值。\n>   2.\n> 然后，根据这些主键值，数据库需要再次回到聚簇索引（通常是主键索引）中查找相应的数据行。这个过程就像是根据一个地址（主键值）去找到实际的房屋（数据行）。\n>\n\n>\n>\n> 这个从非聚簇索引回到聚簇索引查找数据行的过程，就是所谓的“回表”。回表操作会增加额外的IO操作和时间开销，因为需要再次访问数据表。在大量数据或者频繁进行回表查询的场景下，这会对查询性能产生显著影响。\n>\n>\n> 为了避免频繁的回表查询，一种优化策略是使用覆盖索引。覆盖索引是指查询只需要通过索引就可以返回所需要的数据，而无需回表去访问实际的数据行。这可以显著提高查询效率。\n\n**学习指引：**[MySQL -\n聚簇索引和非聚簇索引，回表查询，索引覆盖，索引下推，最左匹配原则](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fm0_65228708%2Farticle%2Fdetails%2F134916018)\n\n## 9\\. 哪些情况下索引会失效?\n\n**解析：**\n\n考察MySQL索引失效，必考题。\n\n**参考回答：**\n\n> 索引失效是指在某些情况下，数据库查询无法有效利用索引来加速查询过程，从而导致查询性能下降。以下是一些常见的导致索引失效的情况：\n>\n>   2. **联合索引列顺序不正确**\n> ：联合索引的列顺序对查询效率有重要影响。如果查询条件中经常使用的列没有放在联合索引的前面，那么索引可能无法被充分利用。\n>   3. **索引列上使用了函数或表达式** ：当在索引列上应用函数或表达式时，数据库通常无法直接利用索引进行查询，从而导致索引失效。\n>   4. **数据库表设计不合理** ：表设计的不合理，如包含大量不必要的字段或冗余数据，或字段类型选择不当，都可能影响索引的有效性。\n>   5. **列类型不匹配** ：当查询条件中的数据类型与索引列的数据类型不匹配时，索引可能无法被使用，从而导致索引失效。\n>   6. **使用了IS NULL或IS NOT NULL** ：如果索引列中包含NULL值，并且在查询条件中使用了IS NULL或IS NOT\n> NULL，那么索引可能无法被有效利用。\n>   7. **隐式类型转换** ：当查询条件中涉及到隐式类型转换时，如将字符串类型与数值类型进行比较，索引可能会失效。\n>\n\n>\n>\n> 为了避免索引失效，需要合理设计数据库表结构、选择适当的索引类型、定期更新数据库统计信息，并在编写查询语句时注意避免上述可能导致索引失效的操作。同时，定期监控和分析查询性能，根据需要进行索引优化和调整，也是保持索引有效性的重要措施。\n\n**学习指引：**[索引失效的情况及解决(超详细)](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fsy_white%2Farticle%2Fdetails%2F122112440)\n\n## 10\\. MQ 如何保证消息一定被消费?\n\n**解析：**\n\nMQ常考题，必会题。\n\n**参考回答：**\n\n> MQ（消息队列）是一种用于在分布式系统中进行异步通信的机制。为了保证消息一定被消费，MQ 通常会采用一系列机制和技术。以下是一些常见的方法：\n>\n>   1. **确认机制**\n> ：当消息被发送到MQ后，MQ会等待消费者的确认。消费者处理完消息后，会向MQ发送一个确认消息，表示该消息已经被成功消费。如果MQ在一定时间内没有收到确认消息，它会认为该消息没有被成功消费，然后会重新发送消息给消费者。这种机制确保了消息至少被消费一次。\n>   2. **持久化存储** ：MQ\n> 通常会将消息持久化存储到磁盘或数据库中，以防止消息丢失。即使MQ服务器宕机或重启，也能从持久化存储中恢复消息，确保消息不会被遗漏。\n>   3. **重试机制**\n> ：如果消费者在处理消息时失败，MQ会尝试重新发送消息给消费者。重试的次数和间隔可以根据需要进行配置。通过重试机制，可以确保在消费者暂时不可用或处理失败的情况下，消息仍然能够被成功消费。\n>   4. **死信队列** ：对于多次尝试消费都失败的消息，MQ\n> 可以将其发送到死信队列中。这样可以避免消息一直阻塞在正常队列中，同时也为开发者提供了处理这些消息的机会。开发者可以定期检查死信队列，对其中的消息进行特殊处理。\n>   5. **消息幂等性**\n> ：对于某些业务场景，要求即使重复消费相同的消息也不会产生副作用。这时，需要保证消息的幂等性。在消费者处理消息时，可以通过一些技术手段（如唯一ID、分布式锁等）来确保消息只被处理一次。\n>   6. **监控和告警** ：MQ\n> 通常提供监控和告警功能，可以实时监控消息的消费情况。当消息消费出现异常时，MQ会及时发出告警通知，以便开发者能够及时处理问题。\n>\n\n**学习指引：**[RabbitMQ\n消息可靠性的保证](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fcloud.baidu.com%2Farticle%2F2919497)\n\n## 11\\. MQ 如何保证消息消费的顺序性?\n\n**解析：**\n\nMQ常考题，必会题。\n\n**参考回答：**\n\n>   1.\n> 使用单个消费者：让单个消费者处理队列中的所有消息，这样可以确保消息按照它们进入队列的顺序被处理。但是，这种方法在处理大量消息时可能会成为性能瓶颈。\n>   2.\n> 使用锁机制：使用锁机制可以防止多个消费者同时访问同一消息。例如，使用数据库锁或分布式锁来确保在任何时候只有一个消费者可以处理特定消息。然而，这种方法可能会增加系统的复杂性和开销。\n>   3.\n> 使用事务：将消息处理与事务结合使用可以确保消息的一致性和顺序性。在事务期间，消费者会锁定消息，进行一些处理，然后提交事务。如果事务失败，消息将被回滚到队列中，以便其他消费者可以重新处理。\n>   4.\n> 使用消息序列号：为每条消息分配一个唯一的序列号，消费者根据这个序列号来处理消息。当消费者处理完一条消息后，它可以将该序列号提交到下一个待处理的消息。这种方法可以避免消息丢失和重复处理的问题。\n>   5. 使用可靠的消息队列：选择一个可靠的消息队列系统，如RabbitMQ或Apache\n> Kafka，这些系统提供了消息持久化和确认机制，以确保消息不会丢失或被重复处理。\n>   6. 限制并发处理：通过限制消费者的并发级别，可以控制同时处理多少消息。这样可以避免因同时处理大量消息而导致的问题，如死锁和竞态条件。\n>   7. 考虑使用单向消息传递：采用单向消息传递模型，其中消息只能从生产者流向消费者，而不能返回生产者。这样可以减少因消息返回而引起的复杂性和性能问题。\n>\n\n**学习指引：**[如何保证MQ中消息的顺序性？](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2FZGL_cyy%2Farticle%2Fdetails%2F112060958)\n\n## 12\\. 什么原因会导致 MQ 消息积压?\n\n**解析：**\n\nMQ常考题，必会题。\n\n**参考回答：**\n\n> MQ消息积压是指生产者发送的消息在Broker端大量堆积，无法被消费者及时消费，导致业务功能无法正常使用。以下是一些导致MQ消息积压的常见原因：\n>\n>   1. **流量变大而服务器配置偏低** ：当消息的产生速度大于消费速度时，如果RabbitMQ服务器配置较低，就可能导致消息积压。\n>   2. **消费者故障** ：如果消费者出现宕机或网络问题，导致无法及时消费消息，消息会持续堆积。\n>   3. **程序逻辑设计问题** ：如果生产者持续生产消息，但消费者由于某种原因（如处理逻辑耗时过长）消费能力不足，也会造成消息积压。\n>   4. **新上线的消费者功能存在BUG** ：新上线的消费者功能如果有缺陷，可能导致消息无法被正常消费，从而引发消息堆积。\n>   5. **配置不合理** ：消息队列的容量设置过小或消费者的线程数设置过少，都可能导致消息积压。\n>   6. **生产者推送大量消息**\n> ：在特定场景下，如大促活动，生产者可能短时间内推送大量消息至Broker，如果消费者的消费能力不足以应对这种突发流量，也会导致消息堆积。\n>\n\n>\n> 为了解决MQ消息积压问题，可以采取以下策略：\n>\n>   1. **扩容** ：纵向扩容，增加服务器资源，如内存和CPU；横向扩容，将单机改为集群模式，增加集群节点，并增加消费者数量。\n>   2. **优化程序逻辑** ：确保生产者和消费者的逻辑设计合理，避免生产者过快生产消息或消费者处理消息过慢。\n>   3. **监控和报警** ：建立有效的监控和报警机制，及时发现并解决消息积压问题。\n>\n\n**学习指引：**[消息积压解决方案](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F168752490)\n\n## 13\\. MQ 的死信队列了解吗，有没有在项目中用过?\n\n**解析：**\n\nMQ常考题，必会题。\n\n**参考回答：**\n\n> MQ的死信队列（Dead-Letter-\n> Exchange，简称DLX）是一个在RabbitMQ中用于处理无法被正常消费的消息的机制。当消息在队列中因为某些原因（如被拒绝、过期或队列达到最大长度）而无法被消费时，它们会被发送到死信交换机，进而路由到死信队列中等待进一步处理。\n>\n> 以下是关于RabbitMQ死信队列的一些关键点：\n>\n>   1. **消息被拒绝并设置requeue为false**\n> ：当消费者使用basic.reject或basic.nack方法拒绝消息，并且设置requeue参数为false时，消息不会重新入队，而是会被发送到死信交换机。\n>   2. **消息过期** ：可以为队列或消息设置TTL（Time-To-Live）值，当消息在队列中的存活时间超过这个值时，消息会变为死信。\n>   3. **队列达到最大长度**\n> ：当队列中的消息数量达到最大限制，并且无法再接受新消息时，如果队列的设置是丢弃最旧的消息或者将消息转为死信，那么被丢弃或转为死信的消息会发送到死信交换机。\n>   4. **配置死信交换机和路由**\n> ：为了确保死信能够被正确处理，需要为每个业务队列配置一个死信交换机，并为死信交换机配置一个或多个路由键和队列。这样，当消息变为死信时，它们会根据配置的路由键被路由到相应的死信队列。\n>   5. **死信队列的处理**\n> ：死信队列中的消息需要被特别关注和处理，因为它们代表了系统中存在的问题或异常情况。开发者可以编写特定的消费者来监听死信队列，以便及时发现并解决这些问题。\n>\n\n>\n> 通过合理配置和使用死信队列，可以帮助我们更好地管理和监控MQ中的消息，确保消息能够被正确处理，避免消息丢失或积压，提高系统的稳定性和可靠性。\n\n**学习指引：**[深入解析RabbitMQ死信队列](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fcloud.baidu.com%2Farticle%2F2822345)\n\n## 14\\. ES的深度分页怎么解决?\n\n**解析：**\n\nES深度分页属于常考内容，难度中等。\n\n**参考回答：**\n\n> ES（Elasticsearch）的深度分页问题通常是由于查询大量数据时，性能会受到影响。\n>\n>   1. **设置max_result_window参数**\n> ：这是分页返回的最大数据量的设置。虽然这可以暂时解决问题，但随着数据量的增大，OOM（内存溢出）问题可能会更加严重。\n>   2. **设置数据限制**\n> ：参考一些大型互联网公司（如淘宝、百度、谷歌等）的做法，对于越往后的数据，其对用户的影响通常越小，因此可以限制返回的数据量。\n>   3. **滚动查询（Scroll Search）**\n> ：滚动查询通过保存快照，并在查询时通过快照获取数据。然而，这种查询方式对Client端并不友好，因为数据的更新、删除和新增都不会影响快照。\n>   4. **search_after方式**\n> ：这种方式是根据上一页的最后一条数据来确定下一页的位置。由于这种特殊的查询方式不支持跳页查询，只能依赖上一页的数据。\n>\n\n**学习指引：**[ElasticSearch深度分页解决方案](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjuejin.cn%2Fpost%2F7092046739414204430)\n\n## 15\\. ES 的写入性能调优了解吗?\n\n**解析：**\n\nES性能调优属于常考内容，难度中等。\n\n**参考回答：**\n\n>   1. 批量写入：使用批量写入API可以显著提高写入性能。将多个文档一次性提交到ES，而不是逐个提交，可以减少网络开销和请求处理时间。\n>   2. 刷新间隔：ES默认每秒自动刷新一次索引，可以通过增加刷新间隔来提高写入性能。刷新间隔越长，写入性能越高，但是数据的可见性会有所延迟。\n>   3. 副本数：副本是ES中用于提高数据冗余和可用性的机制。增加副本数可以提高读取性能，但会降低写入性能。可以根据需求权衡副本数和写入性能。\n>   4.\n> 索引分片：ES将索引分成多个分片，每个分片可以独立地进行读写操作。增加分片数可以提高写入性能，但也会增加集群的负载和资源消耗。需要根据集群规模和硬件配置来确定合适的分片数。\n>   5. 硬件优化：使用高性能的硬件可以提升ES的写入性能。例如，使用SSD硬盘可以加快磁盘写入速度，增加内存可以提高缓存效果。\n>   6. 禁用不必要的功能：ES提供了许多功能和插件，但并不是所有功能都对写入性能有利。禁用不必要的功能和插件可以减少系统开销，提高写入性能。\n>   7.\n> 异步写入：使用异步写入机制可以将写入操作放入后台线程进行处理，提高写入性能。但需要注意异步写入可能会导致数据丢失的风险，需要根据业务需求进行权衡。\n>\n\n**学习指引：**[ES写入性能优化方案](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fwangxuelei036%2Farticle%2Fdetails%2F106684555)\n\n## 16\\. MyBatisPlus 遇到慢 SQL怎么排查?\n\n**解析：**\n\nMyBatisPlus常考题，必会题。\n\n**参考回答：**\n\n>   1. 确认是否是慢SQL：首先，确认是否真的是SQL语句导致了性能问题。可以通过日志或者性能监控工具来查看具体的SQL执行时间和性能指标。\n>   2.\n> 分析SQL语句：仔细分析慢SQL语句，检查是否存在不必要的查询、多表关联、大数据量操作等问题。可以使用数据库的查询分析工具（如EXPLAIN）来查看SQL的执行计划，判断是否存在索引缺失、全表扫描等性能问题。\n>   3.\n> 检查索引：确保数据库表中的相关字段都有适当的索引。索引可以加快查询速度，减少数据库的IO操作。可以通过数据库的索引优化工具或者命令来检查索引的使用情况。\n>   4. 优化SQL语句：根据分析结果，对慢SQL进行优化。可以考虑使用合适的索引、优化查询条件、减少不必要的字段查询等方式来提高SQL的执行效率。\n>   5. 使用缓存：如果某些查询结果是经常被使用的，可以考虑使用缓存来提高查询性能。MyBatis\n> Plus提供了缓存的支持，可以配置二级缓存或者使用其他缓存框架（如Redis）来缓存查询结果。\n>   6.\n> 调整数据库连接池：检查数据库连接池的配置参数，确保连接池大小、最大连接数等参数设置合理。过小的连接池可能导致连接等待，从而影响SQL的执行性能。\n>   7. 监控和日志：使用监控工具和日志记录来跟踪SQL的执行情况和性能指标。可以使用数据库的性能监控工具、MyBatis\n> Plus的日志配置等方式来获取更详细的信息。\n>\n\n**学习指引：**[Mybatis-\nPlus执行超长SQL性能问题排查](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fxuanzai666%2Farticle%2Fdetails%2F134321479)\n\n## 17\\. TomCat 服务器 CPU 负载特别高，但是内存不高可能是什么问题导致的?\n\n**解析：**\n\n考察TomCat问题解决能力，需要一定知识储备。\n\n**参考回答：**\n\n> 当Tomcat服务器的CPU负载特别高，但内存占用并不高时，可能是以下几个问题导致的：\n>\n>   1. 高并发请求：如果Tomcat服务器面临大量的并发请求，CPU负载会增加。即使内存占用不高，但CPU需要处理大量的请求和线程调度，导致负载升高。\n>   2.\n> 长时间运行的线程：如果Tomcat中存在长时间运行的线程，例如长时间的数据库查询或者耗时的业务逻辑处理，这些线程会占用CPU资源，导致CPU负载升高。\n>   3. 错误的配置：Tomcat的配置参数可能不合理，导致CPU负载升高。例如，线程池配置过小，无法处理大量的并发请求，导致CPU负载升高。\n>   4. 死循环或者无限循环：代码中存在死循环或者无限循环的情况，导致CPU一直在执行循环，造成CPU负载升高。\n>   5.\n> 第三方库或应用的问题：某些第三方库或应用可能存在性能问题，导致CPU负载升高。可以检查是否有更新版本的库或应用可用，或者尝试禁用某些库或应用来排除问题。\n>\n\n>\n> 针对以上问题，可以采取以下措施进行排查和解决：\n>\n>   * 检查Tomcat的访问日志和线程堆栈，查看是否有异常请求或者长时间运行的线程。\n>   * 检查Tomcat的配置参数，确保线程池、连接池等参数设置合理。\n>   * 检查应用代码，查找是否存在死循环或者无限循环的情况。\n>   * 使用性能监控工具，分析CPU占用高的线程和方法，定位性能瓶颈。\n>   * 更新或替换可能存在性能问题的第三方库或应用。\n>\n\n**学习指引：**[[排查tomcat服务器CPU使用率过高](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.cnblogs.com%2Fteach%2Fp%2F12660541.html)\n\n## 18\\. 我们的 Redis 缓存怎么保证和数据库中数据的一致性?\n\n**解析：**\n\n**参考回答：**\n\n>   1. **先更新数据库，再更新缓存** ：\n>      * 当需要更新数据时，首先更新数据库。\n>      * 然后，删除或更新对应的Redis缓存项。\n>      * 这种方法的优点在于操作直观且简单。然而，如果第二步更新缓存失败，可能会导致数据不一致。\n>   2. **先删除缓存，再更新数据库** ：\n>      * 当需要更新数据时，首先删除Redis缓存中的对应项。\n>      * 然后，更新数据库。\n>      * 这种方法的缺点是，在删除缓存和更新数据库之间，如果有其他线程读取数据，可能会读取到旧的、已经从缓存中删除的数据，从而导致短暂的数据不一致。\n>   3. **延时双删策略** ：\n>      * 在更新数据库之前，先删除Redis缓存。\n>      * 更新数据库后，等待一段时间（这个时间通常是读操作可能的最长耗时，包括Redis主从同步、网络耗时等），然后再次删除Redis缓存。\n>      * 这种方法可以有效解决在更新过程中其他线程读取旧数据的问题。\n>   4. **设置缓存过期时间** ：\n>      * 为Redis缓存项设置一个合理的过期时间。这样，即使出现不一致的情况，缓存中的数据也会在一段时间后自动失效，从而确保最终一致性。\n>   5. **使用消息队列保证顺序** ：\n>      * 将数据库更新和缓存更新的操作放入消息队列中，确保它们按照正确的顺序执行。\n>      * 这种方法可以确保操作的原子性，但可能会增加系统的复杂性和延迟。\n>   6. **分布式锁** ：\n>      * 在更新数据库和缓存的过程中，使用分布式锁来确保操作的原子性。\n>      * 但需要注意的是，过度使用分布式锁可能会导致性能问题。\n>   7. **读写分离** ：\n>      *\n> 在某些场景中，可以将读操作和写操作分离到不同的服务或数据库中。例如，写操作更新主数据库，而读操作从Redis缓存或只读副本数据库中获取数据。\n>   8. **应用层补偿** ：\n>      * 在应用层实现补偿机制，例如监听数据库的更新事件，并在必要时主动更新或删除Redis缓存。\n>\n\n**学习指引：**[如何保障数据库和redis缓存的一致性](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F119440806)\n\n## 19\\. Redis 什么情况会导致读写性能突然变慢?\n\n**解析：**\n\n考察Redis基础，属于常考题，必会题。\n\n**参考回答：**\n\n> Redis的读写性能突然变慢可能由多种因素导致。以下是一些常见的原因：\n>\n>   1. **内存不足**\n> ：当Redis使用的内存达到其上限时，操作系统可能会开始使用交换分区（swap），这会导致Redis的读写操作变慢。此外，如果Redis实例运行的机器内存不足，也可能导致性能下降。\n>   2. **网络延迟**\n> ：网络问题，如网络IO压力大或客户端使用短连接与Redis相连，都可能导致读写性能下降。短连接需要频繁地建立和关闭连接，增加了额外的开销。\n>   3. **复杂命令或查询** ：使用复杂度高的命令或一次性查询全量数据会增加Redis的处理时间，导致性能下降。\n>   4. **大键（bigkey）操作**\n> ：操作包含大量元素或占用大量内存空间的键（bigkey）会导致性能问题。例如，删除、修改或查询bigkey时，Redis需要消耗更多的CPU和内存资源。\n>   5. **大量键集中过期** ：当大量键在相近的时间点集中过期时，Redis需要处理大量的过期事件，这可能导致性能突然下降。\n>   6. **数据持久化**\n> ：当Redis数据量较大时，无论是生成RDB快照还是进行AOF重写，都会导致fork耗时严重，从而影响读写性能。此外，如果AOF的写回策略设置为always，那么每个操作都需要同步刷回磁盘，这也会增加写操作的延迟。\n>   7. **CPU绑定不合理**\n> ：如果Redis实例的进程绑定到不合适的CPU核上，可能会导致性能下降。同样，如果Redis实例运行机器上开启了透明内存大页机制，也可能影响性能。\n>   8. **硬件问题** ：硬件故障或性能瓶颈，如磁盘I/O速度较慢、CPU性能不足等，也可能导致Redis读写性能变慢。\n>\n\n**学习指引：**[Redis变慢的五大原因以及排查方法](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fskye_fly%2Farticle%2Fdetails%2F119979126)\n\n## 20\\. 单个 Redis 中有热 Key，压力特别大，怎么解决?\n\n**解析：** 考察Redis基础，属于常考题，必会题。 **参考回答：**\n\n>   1. **分离热 Key** ：\n>      * 将热 Key 分离出来，存储在一个独立的 Redis 实例或集群中，以减轻主 Redis 实例的负载。\n>      * 可以使用 Redis 的哈希标签（hash tag）功能，确保与热 Key 相关的数据也存储在同一实例或分片上，以保持数据一致性。\n>   2. **使用更高效的数据结构** ：\n>      * 如果热 Key 对应的是复杂的数据结构（如哈希表、列表等），考虑是否可以使用更高效的数据结构或编码方式。\n>      * 例如，对于频繁更新的列表，可以考虑使用 Redis 的有序集合（sorted set）或跳表（skip list）数据结构。\n>   3. **缓存热点数据** ：\n>      * 在应用层引入缓存机制，将热 Key 的数据缓存到本地缓存（如 Memcached）中，减少对 Redis 的访问。\n>      * 当本地缓存中的数据过期或不存在时，再从 Redis 中获取数据。\n>   4. **分布式缓存** ：\n>      * 如果热 Key 的数据量大到单个 Redis 实例无法承载，可以考虑使用分布式缓存方案。\n>      * 将热 Key 的数据分散到多个 Redis 实例或分片中，通过分片键（sharding key）进行路由，实现负载均衡。\n>   5. **使用读写分离** ：\n>      * 对于读操作特别频繁的热 Key，可以考虑使用读写分离架构，将读请求和写请求分散到不同的 Redis 实例上。\n>      * 写请求仍然发送到主 Redis 实例，而读请求可以发送到从 Redis 实例或从 Redis 集群中的多个节点。\n>   6. **使用 Redis 集群** ：\n>      * 如果单个 Redis 实例已经无法满足需求，可以考虑使用 Redis 集群进行水平扩展。\n>      * Redis 集群可以自动将数据分散到多个节点上，实现负载均衡和高可用性。\n>\n\n**学习指引：**[Redis中什么是热Key问题？如何解决热Key问题？](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2FWeixiaohuai%2Farticle%2Fdetails%2F125310401)\n\n## 21\\. Redis 主节点宕机后，怎么恢复数据，怎么产生新的主?\n\n**解析：**\n\n考察Redis集群的稳定性，属于常考题，必会题。\n\n**参考回答：**\n\n> 在Redis主从架构中，当主节点宕机后，可以通过一系列机制来恢复数据并产生新的主节点，以保证数据的可用性和一致性。具体过程如下：\n>\n>   1. **故障检测**\n> ：从节点会定期向主节点发送心跳检测包（通常是PING命令），以确认主节点的状态。如果在设定的时间内没有收到主节点的响应（PONG回复），从节点会认为主节点已经宕机。\n>   2. **选举新的主节点**\n> ：在从节点中，会按照优先级、复制偏移量等因素选举出一个新的主节点。优先级高的节点更容易被选为新的主节点，如果优先级相同，则比较复制偏移量，偏移量大的节点（即数据更完整的节点）更有可能成为新的主节点。\n>   3. **数据同步**\n> ：新的主节点一旦选举出来，其他的从节点会开始向新的主节点发送SYNC或PSYNC命令，进行数据的同步。如果是第一次同步，会使用SYNC命令进行全量同步；如果是后续同步，由于已经部分同步过数据，会使用PSYNC命令进行增量同步，只同步缺失的部分数据。\n>   4. **客户端重定向**\n> ：在故障转移过程中，客户端可能会收到一些错误响应，因为原来的主节点已经不可用。此时，客户端需要重新连接到新的主节点，或者通过代理层（如Redis\n> Sentinel）来自动处理这种重定向。\n>\n\n>\n> 在Redis\n> Sentinel模式下，这一过程是自动的。Sentinel会监控主从节点的状态，当检测到主节点故障时，会自动执行故障转移，选举新的主节点，并通知客户端更新连接信息。\n\n**学习指引：**[Redis主节点宕机，如何处理？](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjuejin.cn%2Fpost%2F7036615102396629022)\n\n## 22\\. Redis 的内存淘汰策略了解吗?\n\n**解析：**\n\n考察Redis内存淘汰策略，属于常考题，必会题。\n\n**参考回答：**\n\n>   1. **noeviction** ：这是默认的淘汰策略。当 Redis 内存使用达到上限时，它不会淘汰任何数据，而是直接拒绝新的写请求（除了\n> DEL 和一些特定的命令）。读请求仍然会正常处理。\n>   2. **volatile-ttl** ：这个策略会优先淘汰那些设置了过期时间且剩余存活时间（TTL）较短的键。\n>   3. **volatile-random** ：这个策略会随机淘汰那些设置了过期时间的键。\n>   4. **volatile-lru** ：这个策略会淘汰那些设置了过期时间且最久未使用的键（使用 LRU 算法，即最近最少使用）。\n>   5. **volatile-lfu** ：这个策略会淘汰那些设置了过期时间且最少使用的键（使用 LFU 算法，即最近最不常用）。\n>   6. **allkeys-lru** ：这个策略会淘汰整个数据集中最久未使用的键（使用 LRU 算法）。\n>   7. **allkeys-random** ：这个策略会随机淘汰数据集中的任意键。\n>   8. **allkeys-lfu** ：这个策略会淘汰整个数据集中最少使用的键（使用 LFU 算法）。\n>\n\n**学习指引：**[Redis 内存淘汰策略\n（史上最全）](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fcrazymakercircle%2Farticle%2Fdetails%2F115360829)\n\n>\n> [更多面经直通车](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fusers%2F630265916)\n\n>\n> [原贴连接](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Ffeed%2Fmain%2Fdetail%2F5d2b8d8408aa438893a697aa73bff8d6)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598636080333692928?sourceSSR=users",
        "title": "美团3-16笔试题",
        "content": "美团3-16的笔试题，选择题若干+3道编程题，一共花了1个小时20多分钟。\n\n第3道题稍微花了点时间，题目难度算中等吧。\n\n1.小美定义以下三种单词是合法的：\n\n1\\. 所有字母都是小写。例如：good\n\n2\\. 所有字母都是大写。例如：APP\n\n3\\. 第一个字母大写，后面所有字母都是小写。例如：Alice\n\n现在小美拿到了一个单词，她每次操作可以修改任意一个字符的大小写。小美想知道最少操作几次可以使得单词变成合法的？\n\n输入描述\n\n一个仅由大写字母和小写字母组成的字符串，长度不超过10^5。\n\n输出描述\n\n一个整数，代表操作的最小次数。\n\n示例 1\n\n输入\n\nAbC\n\n输出\n\n1\n\n说明\n\n变成 ABC 或者 Abc 均可。只需要一次操作。\n\n    \n    \n    \n    public class Main {\n        public static void main(String[] args) {\n            Scanner in = new Scanner(System.in);\n           \n            while (in.hasNext()) {\n                String str = in.nextLine();\n                int len = str.length();\n                int low = 0, high = 0;\n                boolean firstHigh = false;\n                for(int i = 0; i < len; i++) {\n                    char c = str.charAt(i);\n                    if('a' <= c && c <= 'z') {\n                        low++;\n                    } else if('A' <= c && c <= 'Z') {\n                        high++;\n                    }\n                }\n                if('A' <= str.charAt(0) && str.charAt(0) <= 'Z') {\n                    firstHigh = true;\n                }\n    \n                if(low == len || high == len || (high == 1 && firstHigh)) {\n                    System.out.println(0);\n                } else {\n                    // 走1 need high 次\n                    // 走2 need low 次\n                    // 走3 need high - FirstHigh 次\n                    int other = high - (firstHigh == true ? 1 : 0);\n                    int minn = Math.min(Math.min(high, low), other);\n    \n                    System.out.println(minn);\n                }\n            }\n        }\n    }\n    \n\n2.美团都会为自己的员工生成一个10位的员工号，格式是\n\nYYMMAADDDD\n\nYY:是入职年份的最后2位（入职年份在1970到2023之间）\n\nMM:是入职年份的月份\n\nAA:是是入职月份的日期\n\nDDDD:4位数字，保证唯一，同时满足整个10位的员工号可以被13整除。\n\n现在需要写一份代码，判断输入的工号是否符合对应的格式。\n\n提示：闰年判断的条件是能被 4 整除， 但不能被 100 整除；或能被 400 整除。\n\n输入描述\n\n第一行输入数字n(1<= n <= 10)\n\n接下来n行，每一行输入需要判断的工号。\n\n输出描述\n\n输出n行，如果是合法的，输出 \"Yes\" ，否则输出 \"No\"\n\n示例 1\n\n输入\n\n3\n\n9030121235\n\n9012121235\n\n9012121234\n\n输出\n\nNo\n\nYes\n\nNo\n\n说明\n\n30不是月份\n\n9012121234不能被13整除\n\n    \n    \n    public class Main {\n        public static void main(String[] args) {\n            int days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 31, 30};\n            Set<String> hashSet = new HashSet<>();\n            Scanner in = new Scanner(System.in);\n            int n = in.nextInt();\n            in.nextLine();\n            while(n -- > 0) {\n                String id = in.nextLine();\n                if(id == null || id.length() != 10 || hashSet.contains(id)) {\n                    System.out.println(\"No\");\n                    continue;\n                }\n    \n                hashSet.add(id);\n    \n                int yy = Integer.parseInt(id.substring(0, 2));\n                int mm = Integer.parseInt(id.substring(2, 4));\n                int aa = Integer.parseInt(id.substring(4, 6));\n                int dddd = Integer.parseInt(id.substring(6));\n    \n                if(mm < 0 || mm > 12) {\n                    System.out.println(\"No\");\n                    continue;\n                }\n                if(Long.parseLong(id) % 13 != 0) {\n                    System.out.println(\"No\");\n                    continue;\n                }\n    \n                int year = 0;\n                if(70 <= yy) {\n                    year = 1900 + yy;\n                } else {\n                    year = 2000 + yy;\n                }\n    \n                if(mm != 2) {\n                    if(aa >= 1 && aa <= days[mm]) {\n                        System.out.println(\"Yes\");\n                    } else {\n                        System.out.println(\"No\");\n                    }\n                } else {\n                    boolean is366 = false;\n                    if(year % 4 == 0 && year % 100 != 0) {\n                        is366 = true;\n                    }\n                    if(year % 400 == 0) {\n                        is366 = true;\n                    }\n                    int upper = is366 ? 29 : 28;\n                    if(1 <= aa && aa <= upper) {\n                        System.out.println(\"Yes\");\n                    } else {\n                        System.out.println(\"No\");\n                    }\n                }\n    \n            }\n        }\n    }\n    \n\n3.小美拿到了一个数组，她每次操作会将除了第x个元素的其余元素翻倍，一共操作了q次。请你帮小美计算操作结束后所有元素之和。\n\n由于答案过大，请对10^9+7取模。\n\n输入描述\n\n第一行输入两个正整数n,q，代表数组的大小和操作次数。\n\n第二行输入n个正整数a_i，代表数组的元素。\n\n第三行输入一个正整数q，代表操作的次数。\n\n接下来的q行，每行输入一个正整数x_i，代表第i次操作未被翻倍的元素。\n\n1 <= n,q <= 10^5\n\n1 <= x_i <= n\n\n1 <= a_i <= 10^9\n\n输出描述\n\n一个整数，代表操作结束后所有元素之和模10^9+7的值。\n\n示例 1\n\n输入\n\n4 2\n\n1 2 3 4\n\n1\n\n2\n\n输出\n\n34\n\n说明\n\n第一次操作后，数组变成[1,4,6,8]\n\n第二次操作后，数组变成[2,4,12,16]\n\n所有元素之和为 34。\n\n    \n    \n    public class Main {\n        public static void main(String[] args) {\n            Scanner in = new Scanner(System.in);\n            long mod = 1_000_000_007L;\n            while (in.hasNextInt()) {\n                int n = in.nextInt();\n                int q = in.nextInt();\n                long a[] = new long[n];\n                for(int i = 0; i < n; i++) {\n                    a[i] = in.nextLong();\n                }\n    \n                long normalTime = 1;\n                Map<Integer, Integer> hashMap = new HashMap<>();\n                Map<Integer, Long> mapTimes = new HashMap<>();\n                for(int i = 0; i < q; i++) {\n                    int op = in.nextInt();\n                    hashMap.put(op - 1, hashMap.getOrDefault(op - 1, 0) + 1);\n                    normalTime *= 2;\n                    normalTime %= mod;\n                    mapTimes.put(i + 1, normalTime);\n                }\n    \n                long ans = 0;\n                for(int i = 0; i < n; i++) {\n                    Integer times = hashMap.get(i);\n                    if(times == null) {\n                        ans += (a[i] * normalTime) % mod;\n                        ans %= mod;\n                    } else {\n                        long unNormalTime = mapTimes.get(q - times);\n                        ans += (a[i] * unNormalTime) % mod;\n                        ans %= mod;\n                    }\n                }\n                System.out.println(ans);\n            }\n        }\n    }\n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598635393889726464?sourceSSR=users",
        "title": "2024美团春季笔试第二场 T4 区间众数求和 线段树做法",
        "content": "(以下讲解的下标均从1开始)\n\n## 题目大意\n\n给出一个数组 a[1~n]，a[i] = 1或2， 求每个区间的众数之和。\n\n## 思路\n\n### 写公式\n\n我们假设 two[i] 为 a[1~i] 的“2”的数量，one[i] 为 a[1~i] 的“1”的数量，假设m为众数为2的区间数量，那么有下面的公式：\n\n![](https://uploadfiles.nowcoder.com/images/20240316/188652508_1710595921330/4E237DD125D83835876BB69DF12EBB4A)\n\n其中[...]表示如果括号内的条件满足，则=1，否则=0.\n\n这个式子可以转换为：\n\n![](https://uploadfiles.nowcoder.com/images/20240316/188652508_1710595989605/67F5BF99C0C8D465D38D2CD18C453A91)\n\n设一个数组 diff[i] = two[i] - one[i]。那么式子再写成：\n\n![](https://uploadfiles.nowcoder.com/images/20240316/188652508_1710596073025/EB7F99A081074302DA7E23E59683A7D3)\n\n可以看到这个式子非常的熟悉，可能有人会想到一维偏序什么的。\n\n首先，-n <= diff[i] <= n。我们不喜欢负数的存在，由于比较大小时两边都加同一个数没啥毛病，考虑每个diff[i]都\n+(n+1)，这样就都是正数了。\n\n回到正题，如果暴力求解这个式子的话，显然要用O(n^2)的查询。我们希望遍历r时，可以马上获取数组中在r左边，且 <\ndiff[r]的数的数量，这里，我当时就用的线段树。\n\n### 请出线段树\n\n（不知道线段树的朋友可以先去了解一下）\n\n建立一个线段树tree，tree[i]\n表示树的第i号节点，我们先假设其表示的区间为[left,right]。则tree[i]的值就是diff[1~r-1]的所有值处于[left,right]的元素数量。比如diff[]\n= {3,5,4,7,1, ... }，[left,right] =\n[1,4]，假设r此时为5.则tree[i]就是3,5,4,7（下标<r）中位于[1,4]的数：3,4，它们数量的和：2。则tree[i] = 2.\n\n假设我们处理了diff[1~r-1]，把它们写到了线段树里，现在轮到diff[r]了。\n\n我们要判断diff[1~r-1]中有多少<diff[r]的，怎么办？我们就去线段树中去找在区间[left,right] =\n[0,diff[r]-1]内的tree值。这个[0,diff[r]-1]是可以用线段树的性质拼接出来的，对每个组成其一部分的子区间的tree值求和即可得到答案，对应的增加众数为2的区间数量的贡献。\n\n查找完之后我们还要将diff[r]的值加到线段树里，这样在继续找diff[r+1,n]的答案时可以把diff[r]的贡献算进去。\n\n最后，由于总区间个数为sum = n*(n+1)/2，众数为2的区间个数为m，则众数为1的区间个数为p = sum - m，答案为m*2 + p。\n\n## 复杂度\n\n时间复杂度O(nlogn)，其中线段树查询和单点修改为O(logn)，做n次\n\n空间复杂度O(n)\n\n    \n    \n    #include <iostream>\n    #include <set>\n    #include <algorithm>\n    #include <vector>\n    #include <cstring>\n    using namespace std;\n    using ll = long long;\n    const int N = (int)2e5+5;\n    ll n;\n    ll a[200005];\n    ll tree[N << 3]; // 开大点没关系\n    ll diff[200005];\n    // 将数值x放入线段树，此时所在的区间为[l,r]，线段树下标为id\n    void push(ll x,int l,int r,int id){\n        if(l >= r){\n            tree[id]++;\n            return;\n        }\n        int mid = (l+r)>>1;\n        if(x <= mid){\n            push(x,l,mid,id<<1);\n        }\n        else{\n            push(x,mid+1,r,(id<<1)+1);\n        }\n        tree[id] = tree[id<<1] + tree[(id<<1)+1];\n    }\n    // 求<x的diff数量\n    ll getsum(ll x,int l,int r,int id){\n        if(l >= r){\n            if(x <= l) return 0;\n            return tree[id];\n        }\n        ll res = 0;\n        int mid = (l+r)>>1;\n        if(x > mid){\n            res += tree[id<<1];\n            res += getsum(x,mid+1,r,(id<<1)+1);\n        }\n        else{\n            res += getsum(x,l,mid,(id<<1));\n        }\n        return res;\n    }\n    void solve(){\n        ll m = 0;\n        for(int i = 1;i <= n;++i){\n            cin >> a[i]; // 1 <= a[i] <= 2\n            diff[i] = diff[i-1] + (a[i] == 2 ? 1 : -1);\n        }\n        for(int i = 0;i <= n;++i){\n            diff[i] += n+1; // 保证所有数为正数\n        }\n        push(diff[0],0,2*n+1,1); // 由于l-1可以为0，因此先把diff[0]放进去\n        for(int i = 1;i <= n;++i){\n            m += getsum(diff[i],0,2*n+1,1); // 从最大的区间[0,2n+1]开始递归查询\n            push(diff[i],0,2*n+1,1); // 单点修改，其所在的区间的值都要+1\n        }\n        ll p = n*(n+1)/2 - m;\n        ll ans = m*2 + p;\n        cout << ans << \"\\n\";\n    }\n    int main() {\n        ios::sync_with_stdio(false);\n        cin.tie(nullptr);\n        cout.tie(nullptr);\n        while(cin >> n){\n            solve();\n        }\n        return 0;\n    }\n    \n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598635094902853632?sourceSSR=users",
        "title": "龙湖集团 仕官生 面经",
        "content": "10.11 一面\n\n龙智造千丁数科-技术\n\n30min umeet会议\n\nhr+技术 两个面试官\n\n态度不错 会自我介绍\n\n  * 实习介绍\n  * 同事间的合作\n  * 负责全链路的项目\n  * 为什么不读研\n  * 职业规划\n  * git 常用用法\n  * 访问url的底层原理\n  * offer情况\n  * 城市选择\n\n反问\n\n  * 不定岗 可能要轮岗 可能根据项目调整\n  * 业务大部分tob 也有toc\n  * 问工作强度 说要有追求 推测也要加班\n  * 问待遇 说要有追求 不会太高\n  * 三年后晋升\n\n10.22感谢信\n\n数据平台开发1.18约面拒\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598626461456646144?sourceSSR=users",
        "title": "得物24春招青训营Java面经",
        "content": "  1. 自我介绍\n  2. arraylist和linkedlist的区别？\n  3. 你在之前的项目做了什么内容？\n  4. java set了解吗？\n  5. hashtable了解吗？\n  6. syncronized了解吗？\n  7. 如何使用syncronized?\n  8. syncronized修饰的对象是谁？\n  9. mysql的索引有几种？\n  10. 你如何做sql优化？\n  11. hashMap了解吗？\n  12. excption和erro了解吗？\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598625567927287808?sourceSSR=users",
        "title": "掌上先机（慧策）二面",
        "content": "时间：2024.3.8\n\n时长：1小时\n\n1、自我介绍\n\n2、为什么坚持做软件开发，发展前景在哪些地方\n\n3、对java体系，以及衍生出来的中间件有过了解吗，有扩展的了解现在比较常用的组件\n\n4、要搭一个后台的系统你会怎样选择技术组件\n\n5、在公司实习中你学到了哪些，技术上的、业务上的、对员工的要求等\n\n6、聊了一下社会实践\n\n7、为什么不选前端而做后端\n\n8、手撕算法：找到数组中第limit小的数字，时间复杂度O(n)\n\n9、反问\n\n总结：总的的感觉二面面的比较综合，还是很舒适的，二面是周五，下周一就收到通过的消息了，后面就约了hr面，之后就连续谈薪了好几天，真的非常纠结比秋招的时候还纠结，因为现在好多面试都还在走流程，还不想那么早做决定。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598619881805836288?sourceSSR=users",
        "title": "2024-3-16美团笔试题(A~E)",
        "content": "#\n![](https://uploadfiles.nowcoder.com/images/20240316/663415569_1710594052039/5793152E2108FFB313F1A28ED89FF1A9)\n\n# 提前一小时AK纪念\n\n# A:\n\n## 概述：有n个商品，价值ai﻿元，有一个x元的满减，一个y元的优惠卷，保证一定可以用到满减和优惠卷，问购买这n个商品需要多少元\n\n## 思路：求和，减去x,y即可\n\n    \n    \n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<algorithm>\n    #include<cmath>\n    #include<vector>\n    \n    #define _for(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n    \n    using namespace std;\n    int main(void)\n    {\n        int n;\n        scanf(\"%d\",&n);\n        \n        long long sum=-0;\n        for(int i=1;i<=n;i++)\n        {\n            int x;\n            scanf(\"%d\",&x);\n            sum+=x;\n        }\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        printf(\"%lld\",sum-a-b);\n    }\n    \n    \n\n# B:\n\n## 概述：给定一个只含有大小写字母的字符串，问至少可以变化几个字母的大小写，使得其满足以下条件之一\n\n1.只含有大写字母\n\n2.只含有小写字母\n\n3.除首字母含有大写字母外，其余字母均为小写\n\n## 思路:计算三种方案所需的开销，取min即可\n\n    \n    \n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<algorithm>\n    #include<cmath>\n    #include<vector>\n    \n    #define _for(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n    \n    using namespace std;\n    char s[100500];\n    int main(void)\n    {\n        scanf(\"%s\",s+1);\n        int len=strlen(s+1);\n        int cnt1=0,cnt2=0;\n        _for(i,1,len)\n        {\n            if(s[i]<='z'&&s[i]>='a') cnt1++;\n            else cnt2++;\n        }\n        printf(\"%d\",min(cnt2-(s[1]<='Z'&&s[1]>='A'),cnt1));\n    }\n    \n    \n\n# C:\n\n##\n概述：有一个长度为n的数组，每个数组有一个权值vali，有q次操作，每次操作给定一个数字x，之后除数组中第x个数以外，所有数的权值均翻倍，问q次操作后，所有数字之和mod\n1e9+7是多少\n\n## 思路：与其让所有数字翻倍，不如让该数组除以2，然后在操作结束后，让所有数字翻倍q次即可\n\n当然，对于没有接触过数论和离散数学的同学，并不知道在同余系下的除法如何处理，因此只需要记录每个数字被除二了多少次，然后轮到他的时候给他翻倍q-ti\n次即可(ti 为第i个数被除二的次数)，对于翻倍q次的操作，我们采用快速幂去计算答案即可\n\n    \n    \n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<algorithm>\n    #include<cmath>\n    #include<vector>\n    \n    #define _for(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n    #define MAXN 100050\n    const int mod=1000000007;\n    using namespace std;\n    int arr[MAXN];\n    int cnt[MAXN];\n    inline int quickpow(int x,int k)\n    {\n        int res=1;\n        while(k)\n        {\n            if(k&1) res=1ll*res*x%mod;\n            x=1ll*x*x%mod;\n            k>>=1;\n        }\n        return res;\n    }\n    int main(void)\n    {\n        int n,q;\n        scanf(\"%d%d\",&n,&q);\n        _for(i,1,n)\n        {\n            scanf(\"%d\",&arr[i]);\n        }\n        _for(i,1,q)\n        {\n            int x;\n            scanf(\"%d\",&x);\n            cnt[x]--;\n        }\n        int sum=0;\n        _for(i,1,n)\n        {\n            sum+=1ll*quickpow(2,q+cnt[i])*arr[i]%mod;\n            sum%=mod;\n        }\n        printf(\"%d\",sum);\n    }\n    \n\n# D:\n\n##\n概述：有一个数组，该数组仅仅含有1和2，区间[l,r]的权值为数组中第l个数到第r个数中的众数（如果有多个，则取较小的那个），问该数组中，每个区间的权值和为多少\n\n## 前置知识：树状数组/线段树\n\n## 思路：考虑有哪些区间的众数为2\n\n设f(x)为数组在区间[0,x]中有多少个数字为2，若区间[l,r]的众数为2，那么该区间的2一定比1多\n\n2的数量：f(r)-f(l-1)，1的数量：r-l+1-f(r)+f(l-1)\n\n因此，该区间只需2*f(r)-r>2*f(l)-(l-1)即可\n\n设g(x)=2*f(x)-x，因此，对于每个r结尾的区间，我们只需要知道有多少个l满足g(l)<g(r)即可，因此，我们考虑枚举右端点r，然后通过线段树或者树状数组维护一个可以动态添加以及计算区间和/前缀和的桶即可，然后在计算过所有[l,r]区间的值后，将g(r)添加进桶中即可。\n\n    \n    \n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<algorithm>\n    #include<cmath>\n    #include<vector>\n    #include<queue>\n    \n    #define _for(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n    \n    using namespace std;\n    #define MAXN 200050\n    \n    int n;\n    int tree[MAXN<<4];\n    int arr[MAXN];\n    int sum[MAXN];\n    int val[MAXN];\n    \n    inline int lowbit(int x)\n    {\n        return x&(-x);\n    }\n    inline void update(int x,int k)\n    {\n        for(int i=x;i<=2*n+10;i+=lowbit(i))\n        {\n            tree[i]+=k;\n        }\n    }\n    inline int query(int x)\n    {\n        int sum=0;\n        for(int i=x;i;i-=lowbit(i))\n        {\n            sum+=tree[i];\n        }\n        return sum;\n    }\n    int main(void)\n    {\n        scanf(\"%d\",&n);\n        _for(i,1,n)\n        {\n            scanf(\"%d\",&arr[i]);\n            sum[i]=sum[i-1]+(arr[i]==2);\n        }\n        update(1+n,1);\n        long long cnt=0;\n        _for(i,1,n)\n        {\n            val[i]=2*sum[i]+n-i+1;\n            cnt+=query(val[i]-1);\n            update(val[i],1);\n        }\n        printf(\"%lld\",1ll*n*(n+1)/2+cnt);\n    }\n    \n\n# E:\n\n## 概述：对于一个排列，问，对于该排列中的每一个数字，将其变为其相反数后，该排列的逆序对有多少个\n\n## 前置知识：树状数组维护逆序对\n\n##\n思路：由于取反后为负数，该数字一定小于原本的任何一个数字，我们可以先计算原排列的逆序对数目，然后对于每一个数字，计算他被取反后，能使该排列的逆序对变化多少\n\n对于第i个数字，他在变为最小的数字后，在他之前的所有比他小的数字都会和他组成逆序对，在他之后所有比他小的数字会由原本构成逆序对转变成不构成逆序对，设在他之前比他小的数字的数量为x，因此该次操作的带来的变化为x-(vi-1-x)，考虑原本的逆序对数目k，则第i个数字取反后的逆序对数目为k+x-(vi-1-x)\n\n参考上题用树状数组维护即可\n\n    \n    \n    #include<iostream>\n    #include<cstdio>\n    #include<cstring>\n    #include<algorithm>\n    #include<cmath>\n    #include<vector>\n    \n    #define _for(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n    \n    using namespace std;\n    #define MAXN 200050\n    int n;\n    int arr[MAXN];\n    int tree[MAXN];\n    inline int lowbit(int x)\n    {\n        return x&(-x);\n    }\n    inline void update(int x,int k)\n    {\n        for(int i=x;i<=n;i+=lowbit(i))\n        {\n            tree[i]+=k;\n        }\n    }\n    inline int query(int x)\n    {\n        int sum=0;\n        for(int i=x;i;i-=lowbit(i))\n        {\n            sum+=tree[i];\n        }\n        return sum;\n    }\n    int main(void)\n    {\n        scanf(\"%d\",&n);\n        long long sum=0;\n        _for(i,1,n)\n        {\n            int x;\n            scanf(\"%d\",&x);\n            sum+=query(n)-query(x);\n            int temp=query(x-1);\n            arr[i]=temp-(x-1-temp);\n            update(x,1);\n        }\n        _for(i,1,n)\n        {\n            printf(\"%lld \",sum+arr[i]);\n        }\n    }\n    \n\n;Bval\n\n}\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598608881027227648?sourceSSR=users",
        "title": "测试开发 - 面经 - 得物青训营",
        "content": "面前准备：\n\n**自我介绍**\n\n省略具体技术栈，侧重数据筛选部分以及数据可视化\n\n实习经历简单表述\n\n**反问环节**\n\n对于测试开发的岗位认知还有些模糊，想问下这个岗位工作中的具体内容，以及常用的技术或者工具\n\n想请教下对于测试开发岗未来的职业发展规划，方面的一些建议\n\n入职后的部门以及具体业务\n\n面试过程：\n\n面试官介绍，来自得物效率工程团队\n\n自我介绍\n\n你最擅长的计算机语言是什么\n\n之前实习期间做ci/cd，具体工作是什么\n\n数据可视化和数据报表你具体做了哪些部分呀\n\n实习了多久呀\n\n离职的原因是什么呀\n\n像你们这种突然通知的答辩之类的，常见吗\n\n你这边可实习的时间是多久\n\n之前的那个项目讲一下（日志分析 - 偏数据开发 - 主要工作是数据筛选）\n\n用测试框架做过测试脚本是吧，具体讲讲\n\n这块自动化测试的原理了解吗\n\n之前的一些项目不是在实习的时候做的是吧\n\n讲一下对测开岗位的理解\n\n有做过单元测试\n\n有做过接口测试吗\n\n做项目的时候使用的工具有哪些\n\n你觉得Python相对于其他常见语言的特点有什么\n\nPython中数据结构有哪些\n\n有用过switch么\n\n能接受加班吗\n\n觉得自身有哪些优点能够帮助你胜任测开这个岗位\n\n**反问环节**\n\n**问了准备好的三个问题**\n\n这边测开岗的技术栈主要是Python和Java，工作内容的话，主要是测试执行，基于对业务的理解，写一些测试用例，跟进项目需求；专项方面，自动化脚本的编写，流量回放之类的\n\n尽量实际接触具体的业务，会对岗位以及职业发展有更深的理解\n\n几个业务目前都在招测试方面的实习生，目前无法明确具体的业务和部门\n\n**eg：测试的具体岗位细分以及对应的工作内容需要再多了解下💪**\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598577946596495360?sourceSSR=users",
        "title": "二叉树计算 - 华为OD统一考试（C卷）",
        "content": "> OD统一考试（C卷）\n>\n> 分值： 200分\n>\n> 题解： Java / Python / C++\n\n![alt](https://uploadfiles.nowcoder.com/images/20231201/644248237_1701399029315/A4F5E48572027B66E6ECFA2EF0A7C66A)\n\n## 题目描述\n\n给出一个二叉树如下图所示：\n\n    \n    \n         6\n        / \\\n       7   9\n        \\  /  \n        -2 6  \n    \n\n请由该二叉树生成一个新的二叉树，它满足其树中的每个节点将包含原始树中的左子树和右子树的和。\n\n    \n    \n          20 (7-2+9+6)\n         /   \\\n        -2    6\n         \\   /  \n         0  0 \n    \n\n左子树表示该节点左侧叶子节点为根节点的一颗新树；右子树表示该节点右侧叶子节点为根节点的一颗新树\n\n## 输入描述\n\n2行整数，第1行表示二叉树的中序遍历，第2行表示二叉树的前序遍历，以空格分割\n\n例如：\n\n7 -2 6 6 9 6 7 -2 9 6\n\n## 输出描述\n\n1行整数，表示求和树的中序遍历，以空格分割\n\n例如：\n\n输出1 -2 0 20 0 6\n\n## 示例1\n\n    \n    \n    输入：\n    -3 12 6 8 9 -10 -7\n    8 12 -3 6 -10 9 -7\n    \n    输出：\n    0 3 0 7 0 2 0\n    \n\n## 题解\n\n> **递归的题目**\n>\n> 根据树的中序和先序遍历可以唯一确定一颗树，题解中将中序和先序字符串看成一个整体（树）。\n>\n> 题目求的是**求和树的中序遍历** ， 因此还是使用递归中序遍历的方式去遍历树，遍历的同时去求 左右子树和（即为答案）。\n\n### Java\n\n    \n    \n    import java.util.ArrayList;\n    import java.util.Arrays;\n    import java.util.List;\n    import java.util.Scanner;\n    import java.util.stream.Collectors;\n    \n    /**\n     * @author code5bug\n     */\n    public class Main {\n        static List<Integer> rs = new ArrayList<>();\n    \n        public static void main(String[] args) {\n            Scanner scanner = new Scanner(System.in);\n    \n            // 中序遍历\n            List<Integer> inorder = Arrays.stream(scanner.nextLine().split(\" \"))\n                    .map(p -> Integer.parseInt(p)).collect(Collectors.toList());\n            // 先序遍历\n            List<Integer> preorder = Arrays.stream(scanner.nextLine().split(\" \"))\n                    .map(p -> Integer.parseInt(p)).collect(Collectors.toList());\n    \n            solve(inorder, preorder);\n    \n            for (int num : rs) {\n                System.out.print(num + \" \");\n            }\n        }\n    \n        static void solve(List<Integer> inorder, List<Integer> preorder) {\n            if (inorder.isEmpty() || preorder.isEmpty()) {\n                return;\n            }\n    \n            // 数根节点的值\n            int rootVal = preorder.get(0);\n            int idx = inorder.indexOf(rootVal);\n    \n            // 中序，左右子树\n            List<Integer> leftInorder = inorder.subList(0, idx);\n            List<Integer> rightInorder = inorder.subList(idx + 1, inorder.size());\n    \n            // 先序，左右子树\n            List<\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598567696199864320?sourceSSR=users",
        "title": "腾讯一面，已挂",
        "content": "分享一下面经，我是一个音视频工程师，但腾讯QQ的组不是做这个方向的\n\n首先，面试官让我做一下自己介绍和规划，我简略地说了一下对音视频的兴趣\n\n然后挖项目，问印象深刻的项目，有没有遇到什么难点，如何解决，有没有考虑码率等其他因素\n\n然后开始问八股文\n\nC++中 struct 和 class 的区别\n\n看到你简历的项目用到了epoll，描述一下多线程与IO多路复用的区别\n\nTCP，UDP有什么区别，我回答了面向连接，他问我面向连接是什么意思，我不知道\n\n开始考算法，链表 L0—> L1 —> L2 —> Ln-1 —> Ln 变成 L0—> Ln —> L1 —> Ln-1 —> L2\n\n我用了数组做，AC后让我用空间复杂度O(1)的算法，我就不会了\n\n开始反问，问组内的工作是什么，业务层面在QQ做一个什么东西，非业务做一个开发工具，建议入组后学一下 Kotlin\n\n随后挂，各位牛油，为什么我看别人的面经能答个70%，自己也能答个60%，为什么挂了呢\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598555789468483584?sourceSSR=users",
        "title": "得物青训营Java面试一面",
        "content": "说一下HashMap的结构\n\nhashmap为什么不安全\n\n说一下spring的ioc如何保证创建对象都是单实例的\n\nspring三级缓存\n\n说一下mysql中索引使用的注意事项\n\n说一下线程池的参数 redis的数据结构有哪些\n\n知道dubbo吗？我不太了解，我说会nacos，让我说一下nacos的原理\n\n算法题是很大的数据，不能读入内存，如果要找到第k大的元素如何实现 全程都是八股，完全不问我的实习和项目啥的\n最近一直在美团实习上班，八股看的少了，答的稀碎[牛泪][牛泪]，还得练啊 主要天天上班，没精力看八股和算法了\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598555023244652544?sourceSSR=users",
        "title": "哔哩哔哩后端Java二面",
        "content": "# 前言\n\n> 一面过后面试官叫我别走，然后就直接二面，二面比较简短，记录一下，希望可以帮助到你\n\n# jvm的内存结构\n\n![alt](https://uploadfiles.nowcoder.com/images/20240316/127966388_1710578221596/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n## 1、方法区\n\n方法区主要用于存储虚拟机加载的类信息、常量、静态变量，以及编译器编译后的代码等数据。\n\n在jdk1.7及其之前，方法区是堆的一个“逻辑部分”（一片连续的堆空间），但为了与堆做区分，方法区还有个名字叫“非堆”，也有人用“永久代”（HotSpot对方法区的实现方法）来表示方法区。\n\n在jdk1.8中，方法区已经不存在，原方法区中存储的类信息、编译后的代码数据等已经移动到了元空间（MetaSpace）中，元空间并没有处于堆内存上，而是直接占用的本地内存（NativeMemory）\n\n## 2、程序计数器(PC寄存器)\n\n由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，\n\n因此，为了能够使得每个线程都在线程切换后能够恢复在切换到之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，\n\n## 3、java栈\n\nJava栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand\nStack)、\n\n指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)、\n\n方法返回地址(Return\nAddress)和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。\n\n## 4、堆内存\n\n堆内存主要用于存放对象和数组，它是JVM管理的内存中最大的一块区域，堆内存和方法区都被所有线程共享，在虚拟机启动时创建。在垃圾收集的层面上来看，由于现在收集器基本上都采用分代收集算法，因此堆还可以分为新生代（YoungGeneration）和老年代（OldGeneration），新生代还可以分为\nEden、From Survivor、To Survivor。\n\n## 5、本地方法栈\n\n本地方法栈与虚拟机栈的区别是，虚拟机栈执行的是 Java 方法，本地方法栈执行的是本地方法（Native Method）,其他基本上一致，在 HotSpot\n中直接把本地方法栈和虚拟机栈合二为一，这里暂时不做过多叙述。\n\n# oom如何调试\n\n## 可能原因\n\n1.无法在 Java 堆中分配对象 2.应用程序保存了无法被GC回收的对象。 3.应用程序过度使用 finalizer。\n注：finalizer方法约定对象在被回收前需要调用，会减慢对象回收的速度，可能造成oom。\n\n## 解决方案\n\n1.查找关键报错信息，如：java.lang.OutOfMemoryError: Java heap space 2.使用内存映像分析工具（如Eclipsc\nMemory Analyzer或者Jprofiler）对Dump出来的堆储存快照进行分析，分析清楚是内存泄漏还是内存溢出。\n3.如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，修复应用程序中的内存泄漏。\n4.如果不存在泄漏，先检查代码是否有死循环，递归等，再考虑用 -Xmx 增加堆大小。\n\n# static的作用\n\nstatic表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。\n\n被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。\n\n只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。\n\n简而言之：static表示不要实例化就可以使用\n\n# 算法题sql 表中某一用户最近几天最早登录的日期\n\n假设有一张login表，表中有三个字段，id，date，user_id，则答案如下：\n\n    \n    \n    select\n        min(date) date,\n        user_id\n    from\n        login\n    group by user_id\n    \n\n# 算法题 链表中的一段进行反转\n\n题目链接：[*****](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fleetcode.cn%2Fproblems%2Freverse-\nlinked-list-ii%2F)\n\n    \n    \n    # Definition for singly-linked list.\n    # class ListNode:\n    #     def __init__(self, val=0, next=None):\n    #         self.val = val\n    #         self.next = next\n    class Solution:\n        def reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\n            dummy = ListNode(next = head)\n            left_node,right_node,pre = dummy,dummy,dummy\n    \n            for i in range(left-1):\n                pre = pre.next\n            left_node = pre.next\n            for i in range(right):\n                right_node = right_node.next\n            \n            curr = right_node.next\n    \n            pre.next = None\n            right_node.next = None\n            for i in range(right-left+1):\n                next = left_node.next\n                left_node.next = curr\n                curr = left_node\n                left_node = next\n            pre.next = right_node\n    \n            return dummy.next\n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598544452323483648?sourceSSR=users",
        "title": "腾讯前端一面凉经",
        "content": "手撕快速排序（忘记写递归了）\n\n写一个防抖节流js （也不会😭）\n\n vue兄弟之间组件通信\n\nbus是怎么实现的\n\ncss解析是在什么时候  \n\ncss实现垂直居中三个方法\n\ncss画一条线像素为0.5\n\n用js实现了项目的哪些功能\n\njs模块化操作（完全不懂 问inpot inquiry不知道什么英文不会拼）\n\njs同步异步任务 做一道题\n\nuniapp实现什么功能\n\nuniapp多端复用怎么实现\n\n条件编译会让打包体积变大吗\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598539521533263872?sourceSSR=users",
        "title": "量魁资管 25C++软开实习 一面",
        "content": "## 内容\n\n  1. 自我介绍\n  2. 之前实习经历\n  3. 个人信息\n  4. 本科期间学习的课程, 大作业\n  5. 假设让你做矩阵乘以矩阵的优化,你会怎么做?(除了算法层面的优化,除了调用库,除了多线程还有什么方法, 考虑当前CPU的架构(L1 cache L2 cache)进行优化) **直接被这个问题吓晕**\n  6. 多线程中, 怎么进行数据同步?\n  7. std::mutex从最顶层到操作系统层, 是如何保证互斥的?(**再次被吓晕**)\n  8. Linux 用户态和内核态有概念吗? 应用程序如何从用户态跑到内核态?\n  9. 浮点数在内存中是如何表示的?(**再次被吓晕**)\n  10. 浮点数能比较==吗?\n  11. 自己实现一个性能比较好的浮点数比较方法, 你会怎么做?(**再次被吓晕**)\n  12. 你自己实现的这个方法, 大概需要多少CPU时钟周期才能计算出来?(**再次被吓晕**)\n  13. C++类型转换有几种? 各自应用场景?\n  14. C++ virtual是怎么实现的? 虚函数调用的时候,是一个O几的算法?(**再次被吓晕**)\n  15. 会看汇编指令吗? 能用汇编指令描述一下虚函数跳转吗?(**再次被吓晕**)\n  16. smart pointer, shared_ptr是线程安全的吗? 怎么做到的?(**再次被吓晕**)\n  17. socket了解吗? windows下面的socket编程有一条特殊指令知道吗?(WSSSTART, 把这个进程的TCP协议栈初始化)(**再次被吓晕**)\n  18. 如何使用UDP实现一个可靠的传输协议?(**再次被吓晕**)\n  19. stl知道哪些数据结构?\n  20. unordered_map有几个模板参数?\n  21. 如何实现unordered_map的下标操作符?\n  22. unordered_map内部是怎么实现的?\n  23. std::unordered_map有什么性能问题?你觉得能从哪进行优化?(**再次被吓晕**)\n  24. 拉链法对性能不好的问题是什么?\n\n## 反问\n\n我已经被问蒙了\n\n  1. 工作职责是什么?\n  2. 知道自己凉了, 明白还有很多不足, 感谢面试官.\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598517809185931264?sourceSSR=users",
        "title": "哔哩哔哩秋招Java一面",
        "content": "# 前言\n\n> 作者：晓宜\n>\n> 个人简介：互联网大厂Java准入职，阿里云专家博主，csdn后端优质创作者\n>\n> 最近各大公司的春招和实习招聘都开始了，这里分享下去年面试B站的的一些问题，希望对大家有所帮助！\n\n# 讲一下AOP\n\nAOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程的某个步骤或阶段，以获得逻辑过程的中各部分之间低耦合的隔离效果。\n\n## AOP具体步骤：\n\n  1. 将业务逻辑组件和切面类都加入到容器中, 告诉spring哪个是切面类(@Aspect)\n  2. 编写具体的切面类函数，并且添加注解，如around，before，after等\n  3. 在切面类上的每个通知方法上标注通知注解, 告诉Spring要监控哪些类下的哪些方法\n  4. 开启基于注解的AOP模式 @EableXXXX\n\n# volatile的使用\n\n1.保证可见性，不保证原子性 （1）当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去。\n（2）这个写操作会导致其他线程中的volatile变量缓存无效。\n\n2.禁止指令重排\n重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段，用volatile修饰的共享变量会在读写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，达到阻止成排序的效果。\n\n# 讲一下线程池的参数和流程\n\n## 线程池的核心参数\n\n  * corePoolSize 核心线程数目\n  * maximumPoolSize 最大线程数目 = (核心线程+救急线程的最大数目)\n  * keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放\n  * unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等\n  * workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务\n  * threadFactory 线程工厂 -可以定制线程对象的创建，例如设置线程名字、是否是守护线程等\n  * handler 拒绝策略 - 当所有线程都在繁忙，workQueue也放满时，会触发拒绝策略\n\n## 线程池的执行流程\n\n![alt](https://uploadfiles.nowcoder.com/images/20240316/127966388_1710560562283/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n# threadlocal的用法\n\nThreadlocal是多线程中对于解决线程安全的一个操作类，它会为每个线程分配一个独立的线程副本用来存储数据，从而防止变量并发访问时的冲突问题。threadlocal同时实现了线程内变量的共享\n\n案例：使用JDBC操作数据库时，会将每一个线程的Connection放入各自的ThreadLocal中，从而保证每个线程都在各自的 Connection\n上进行数据库的操作，避免A线程关闭了B线程的连接。\n\n## 基本使用\n\n  * set(v) 设置值\n  * get() 获取值\n  * remove() 删除值\n\n## 内存泄漏\n\n每一个Thread维护一个ThreadLocalMap，在ThreadLocalMap中的Entry对象继承了WeakReference。其中key为使用弱引用的ThreadLocal实例，value为线程变量的副本\n![alt](https://uploadfiles.nowcoder.com/images/20240316/127966388_1710560583503/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n# 讲一讲你熟悉的Java集合\n\n## List：\n\nArrayList：数组实现的，常用于查询，因为他不需要移动指针，玩的是数据 LinedList：\n链表实现的，常用与增删改查，因为他不需要移动数据，玩的是指针 Vectory： 线程安全的，出现问题会抛出异常需要手动捕获（不常用）\nStack：继承自Vector，实现一个后进先出的堆栈（不常用）\n\n## Set：\n\nHashSet：哈希表实现的， 数据无序， 可以放一个Null值，存储单列数据 TreeSet：二叉树实现的，数据自动排序，不允许放null值，存储单列数据\n\n## Map:\n\nTreeMap： 二叉树实现的，数据有序，HashTable 与 HashMap无序 HashMap：线程不安全，效率快，适用于单线程操作\nHashTable：线程安全，因为底层都加了synchronized关键字来确保线程同步，适用于多线程操作\n\n# hashmap的底层结构\n\nHashMap的数据结构： 底层使用hash表数据结构，即数组和链表或红黑树\n\n  1. 当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标\n  2. 存储时，如果出现hash值相同的key，此时有两种情况。 a. 如果key相同，则覆盖原始值； b. 如果key不同（出现冲突），则将当前的key-value放入链表或红黑树中\n  3. 获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。 ![alt](https://uploadfiles.nowcoder.com/images/20240316/127966388_1710560605579/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n# hashmap扩容机制\n\nhashmap的扩容机制是在put()过程中发生的，我们这里介绍下具体的put流程\n\n  1. 判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化）\n  2. 根据键值key计算hash值得到数组索引\n  3. 判断table[i]==null，条件成立，直接新建节点添加\n  4. 如果table[i]==null ,不成立 4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value 4.2 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对 4.3 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 作，遍历过程中若发现key已经存在直接覆盖value\n  5. 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容。\n\n# 为什么string通常作为hashmap的key\n\n设计 hashCode() 时最重要的因素就是对同一个对象调用 hashCode() 都应该产生相同的值。String\n类型的对象对这个条件有着很好的支持，因为 String 对象的 hashCode() 值是根据 String 对象的内容计算的，并不是根据对象的地址计算。\n\nString 对象底层是一个 final 修饰的 char 类型的数组，hashCode() 的计算是根据字符数组的每个元素进行计算的，所以内容相同的\nString 对象会产生相同的散列码。\n\n# 算法题 层序遍历\n\n## 题目\n\n给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。\n\n## 代码\n\n    \n    \n    class Solution:\n        def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n            if not root:return []\n            ans = []\n            cnt = 0\n    \n            queue = []\n            queue.append(root)\n    \n            while queue:\n                n = len(queue)\n                temp = []\n                for i in range(n):\n                    node = queue.pop(0)\n                    if not node: break\n                    # print(node)\n                    temp.append(node.val)\n                    if node.left: queue.append(node.left)\n                    if node.right:queue.append(node.right)\n                ans.append(temp)\n            return ans\n    \n\n# 算法题 全排列\n\n## 题目\n\n给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。\n\n## 代码\n\n    \n    \n    class Solution:\n        def permute(self, nums: List[int]) -> List[List[int]]:\n            n = len(nums)\n            s = set(nums)\n            \n            ans = []\n            path = [0] * n\n    \n            def dfs(index,s):\n                if index==n:\n                    ans.append(path.copy())\n                    return \n                \n                for x in s:\n                    path[index] = x\n                    dfs(index+1,s-{x})\n    \n    \n            dfs(0,s)\n    \n            return ans\n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598488627647213568?sourceSSR=users",
        "title": "【腾讯】WXG视频号面经，撑到了二面|0315",
        "content": "![alt](https://git.acwing.com/Hasity/interview_hunter/-/raw/master/2024/image/%E9%9D%A2%E7%BB%8F13%E8%85%BE%E8%AE%AF%E8%A7%86%E9%A2%91%E5%8F%B7.png)\n\n## 1\\. 操作系统的内存分配设计原理\n\n**解析：**\n\nOS 常见题，难度中等，考察频率适中。\n\n**参考答案：**\n\n> 操作系统的内存分配设计原理主要基于虚拟内存、内存分页、内存分段以及多种内存分配算法。\n>\n>   1.\n> 虚拟内存：操作系统为每个进程分配一个虚拟地址空间，这个空间远大于实际的物理内存。进程在运行时，其所需的代码、数据等被映射到虚拟地址空间中。当进程需要访问某个虚拟地址时，如果该地址对应的物理内存页尚未加载，则发生缺页中断，操作系统负责将该页从磁盘或其他存储介质加载到物理内存中。这种方式有效地扩展了可用内存，使得程序可以像使用大内存一样运行。\n>   2.\n> 内存分页：操作系统将物理内存划分为固定大小的页，每页的大小通常是固定的，如4KB。同样，虚拟地址空间也被划分为页。当进程需要访问某个虚拟页时，操作系统通过页表查找该页对应的物理页。如果物理页不存在，则触发缺页中断。\n>   3.\n> 内存分段：与分页不同，分段是根据程序的逻辑结构来划分内存的。每个段都有自己的名称和长度，并且可以有不同的访问权限。这种方式可以更好地管理程序的内存使用，但实现起来相对复杂。\n>   4.\n> 内存分配算法：操作系统使用多种算法来管理内存分配，包括首次适应算法、最佳适应算法、最坏适应算法等。这些算法在分配内存时考虑不同的因素，如分配速度、内存碎片等。例如，首次适应算法从空闲链表的起始位置开始查找，找到第一个满足需求的空闲分区进行分配；而最佳适应算法则查找最小的满足需求的空闲分区进行分配，以减少内存碎片。\n>\n\n>\n>\n> 操作系统的内存分配设计原理是为了高效、公平、安全地管理计算机系统的内存资源。通过虚拟内存、内存分页、内存分段以及多种内存分配算法，操作系统能够在有限的物理内存条件下满足多个进程的运行需求，提高系统的整体性能。\n\n**学习参考：**[十年大佬讲述，操作系统内存管理(图文详解)](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F495709005)\n\n>\n> **[面经专栏直通车](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fcreation%2Fmanager%2FcolumnDetail%2F0xKkDM)**\n\n>\n> **[面经专栏下载](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgit.acwing.com%2Flicw%2F24_job_hunter)**\n\n## 2\\. . 操作系统的MMU\n\n**解析：**\n\nOS 概念题，难度中等，考察频率中等。\n\n**参考答案：**\n\n> 操作系统的MMU（Memory Management\n> Unit，内存管理单元）是中央处理器（CPU）中用来管理虚拟存储器、物理存储器的控制线路。MMU主要负责虚拟地址到物理地址的映射，以及提供硬件机制的内存访问授权，这在多用户多进程操作系统中尤为重要。\n>\n>\n> MMU的工作原理主要可以概括为地址转换和访问权限控制两个方面。当CPU发出一个访存请求时，MMU会将逻辑地址转换为对应的物理地址，确保能够准确地访问到内存中的数据。同时，MMU还负责控制内存的访问权限，确保程序只能访问到其拥有权限的内存区域，这有助于提高系统的安全性和稳定性。\n>\n>\n> 在实际的计算机系统中，MMU通常通过页表来实现地址转换和访问权限控制。页表是一个存储在内存中的数据结构，记录了逻辑地址和物理地址之间的映射关系，以及每个页面的访问权限信息。当CPU发出访存请求时，MMU会根据页表中的映射关系将逻辑地址转换为物理地址，并检查访问权限是否合法。\n>\n>\n> 除了页表，MMU还可以通过地址变换缓冲器（TLB）来提高地址转换的效率。当CPU发出访存请求时，MMU会首先在TLB中查找对应的页表项，如果找到则直接进行地址转换，否则再去访问页表。\n\n**学习参考：**[MMU原理](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F354142930)\n\n## 3\\. malloc 是怎么实现的\n\n**解析：**\n\nc 语言和 os 综合题，难度中等，考察频率高。\n\n**参考答案：**\n\n> `malloc`是C语言中用于动态分配内存的函数。它的实现方式可以因编译器和操作系统而异，下面是一种常见的实现方式：\n>\n>   1. 首先，`malloc`函数会接收一个参数，即需要分配的内存大小。\n>   2. `malloc`函数会检查当前的空闲内存块链表，查找是否有足够大小的空闲内存块。\n>   3. 如果找到了足够大小的空闲内存块，则将其从空闲内存块链表中移除，并返回该内存块的起始地址给调用者。\n>   4. 如果没有找到足够大小的空闲内存块，则会进行内存分配。这通常涉及到向操作系统请求更多的内存空间。\n>   5. 操作系统会分配一块连续的内存空间，并将其标记为已使用。\n>   6. `malloc`函数将分配到的内存块的起始地址返回给调用者，并将其添加到已分配内存块链表中，以便后续的内存管理。\n>   7. 调用者可以使用返回的内存块地址来存储数据。\n>   8. 当不再需要使用这块内存时，调用者可以使用`free`函数将其释放，将其重新添加到空闲内存块链表中，以便其他程序可以再次使用。\n>\n\n>\n>\n> 需要注意的是，`malloc`函数的实现可能会有一些额外的处理，例如内存对齐、内存池等，以提高内存分配的效率和性能。具体的实现细节可能因编译器和操作系统而异。\n\n**学习参考：**[malloc函数实现原理！](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fyeditaba%2Farticle%2Fdetails%2F53443792)\n\n## 4\\. 缺页机制的实现\n\n**解析：**\n\nos 基础题，必会题，面试频率较高。\n\n**参考答案：**\n\n> 当程序试图访问一个尚未映射到物理内存中的虚拟页面时，就会发生缺页中断，从而触发缺页机制。以下是缺页机制的基本实现步骤：\n>\n>   1. **中断触发** ：当CPU尝试访问一个不在物理内存中的页面时，硬件会生成一个缺页中断。这个中断会暂停当前程序的执行，并将控制权交给操作系统。\n>   2. **中断处理**\n> ：操作系统捕获到缺页中断后，会开始缺页处理流程。首先，它会检查发生缺页中断的虚拟页面的信息。这些信息通常保存在一个特殊的硬件寄存器中，或者通过检查程序计数器和分析当前指令来获取。\n>   3. **页面分配**\n> ：一旦确定了需要加载的页面，操作系统会在物理内存中查找一个空闲的页框（Frame）。如果找不到空闲页框，它可能会选择一个当前正在使用的页框进行置换，这个过程通常涉及到页面置换算法（如LRU、FIFO等）来决定哪个页面应该被替换。\n>   4. **页面调入**\n> ：当找到空闲页框后，操作系统会从磁盘等辅助存储器中加载相应的页面内容到该页框中。这通常涉及到磁盘I/O操作，因此可能是缺页处理中耗时较长的一个步骤。\n>   5. **更新页表**\n> ：页面加载完成后，操作系统会更新页表，将虚拟页面的映射关系更新为新的物理页框。这样，当程序再次访问该页面时，就可以直接从物理内存中获取数据了。\n>   6. **恢复执行** ：最后，操作系统会恢复缺页中断发生前的程序执行状态，将程序指令器重新指向引起缺页中断的指令，并继续执行程序。\n>\n\n>\n>\n> 在整个缺页处理过程中，操作系统需要确保数据的一致性和完整性，同时尽量减少缺页中断对程序性能的影响。这通常涉及到一些复杂的策略和算法，如预取策略、缓存机制等，以优化内存访问的性能。\n\n**学习参考：**[深入理解【缺页中断】](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%2Farticle%2F1683163)\n\n## 5\\. select. poll. epoll讲一下底层原理\n\n**解析：**\n\n操作系统常见题，必会题。\n\n**参考答案：**\n\n> `select`、`poll`和`epoll`都是用于实现I/O多路复用的机制。\n>\n>   1.\n> `select`：`select`是最古老的I/O多路复用机制之一。它通过一个位图来管理文件描述符集合，通过轮询的方式检查每个文件描述符的状态变化。当有文件描述符就绪时，`select`会返回，然后通过遍历文件描述符集合来确定哪些文件描述符可读、可写或出错。\n>   2.\n> `poll`：`poll`是对`select`的改进，它使用一个结构体数组来管理文件描述符集合，每个结构体中保存了文件描述符和关注的事件。与`select`不同的是，`poll`不需要遍历整个文件描述符集合，而是通过系统调用将文件描述符集合传递给内核，内核会将就绪的文件描述符填充到结构体数组中。\n>   3.\n> `epoll`：`epoll`是Linux特有的I/O多路复用机制，相对于`select`和`poll`，它具有更高的性能和扩展性。`epoll`使用了事件驱动的方式，通过将文件描述符添加到内核事件表中，当有事件发生时，内核会通知应用程序。`epoll`提供了三个系统调用：`epoll_create`用于创建一个`epoll`实例，`epoll_ctl`用于控制事件的注册和删除，`epoll_wait`用于等待事件的发生。\n>\n\n>\n>\n> 在底层原理上，`epoll`利用了Linux内核的事件驱动机制，通过使用红黑树和双链表来管理文件描述符集合，以及利用回调机制来处理就绪的事件。相比于`select`和`poll`的轮询方式，`epoll`能够更高效地处理大量的文件描述符，并且支持边缘触发和水平触发两种工作模式。\n>\n>\n> `select`、`poll`和`epoll`都是用于实现I/O多路复用的机制，它们在底层原理上有所不同，而`epoll`相对于`select`和`poll`具有更高的性能和扩展性。\n\n**学习参考：**[Linux下的IO多路复用技术：poll、epoll与select的比较](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fcloud.baidu.com%2Farticle%2F2774815)\n\n## 6\\. 多路复用epoll相比select和poll的主要改进点是什么？\n\n**解析：**\n\n操作系统常见题，必会题。\n\n**参考答案：**\n\n> 多路复用epoll相比select和poll的主要改进点体现在以下几个方面：\n>\n>   1. **效率与性能** ：\n>      * **select**\n> ：select在每次调用时都需要遍历整个文件描述符集合，即使只有少数几个描述符就绪，也会进行无用的遍历，导致效率低下。此外，select能同时处理的文件描述符数量是有上限的，这限制了它在高并发场景下的应用。\n>      * **poll**\n> ：虽然poll解决了select的文件描述符数量限制问题，并且通过将输入输出参数进行分离来减少每次设定的开销，但它仍然需要遍历整个文件描述符数组来查找就绪的描述符，因此在文件描述符数量很大时，性能依然有限。\n>      * **epoll**\n> ：epoll通过红黑树和就绪链表来管理文件描述符，并只关注那些状态已经发生变化的文件描述符。这种机制避免了不必要的遍历，从而大大提高了效率。当有大量文件描述符需要监视时，epoll的性能优势尤为明显。\n>   2. **工作模式** ：\n>      * **select和poll** ：它们只能工作在低效的LT（水平触发）模式下，即当有事件发生时，需要多次循环处理直到没有事件为止。\n>      * **epoll**\n> ：支持高效的ET（边沿触发）模式。在这种模式下，当有事件响应时，应用程序必须立即处理。这种机制减少了不必要的轮询和等待，进一步提高了性能。\n>   3. **事件处理** ：\n>      * **select和poll** ：采用轮询的方式处理事件，即每次调用时都需要检查所有文件描述符的状态。\n>      * **epoll**\n> ：采用回调的方式处理事件。当有就绪的文件描述符时，会触发回调函数，将对应的事件插入到内核就绪事件队列中。内核在适当的时机将该队列中的内容拷贝到用户空间，避免了不必要的遍历和检查。\n>   4. **扩展性：**`epoll`支持边缘触发（Edge Triggered）和水平触发（Level\n> Triggered）两种工作模式。边缘触发模式只在状态变化时通知应用程序，而水平触发模式则在状态保持的情况下持续通知应用程序。这使得应用程序可以更灵活地处理事件。\n>   5.\n> **内存管理：**`epoll`使用红黑树和双链表来管理文件描述符集合，这种数据结构使得添加和删除文件描述符的操作更高效。而`select`和`poll`则使用位图或数组来管理文件描述符集合，效率较低。\n>   6.\n> **大规模并发：**由于`epoll`的高效性和扩展性，它更适合处理大规模并发的场景。它能够处理成千上万个文件描述符，而`select`和`poll`在文件描述符数量较大时性能会下降。\n>\n\n>\n>\n> epoll相比select和poll在效率、性能和工作模式等方面都有显著的改进，使其在高并发、大文件描述符数量的场景下具有更好的表现。因此，在实际应用中，epoll通常被作为首选的多路复用机制。\n\n**学习参考：**[Select、Poll、Epoll详解](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.jianshu.com%2Fp%2F722819425dbd)\n\n## 7\\. docker用过吗？什么场景怎么用的？你认为docker里的空间和虚拟机有什么区别？\n\n**解析：**\n\n容器相关基础知识，常考题。\n\n**参考答案：**\n\n> Docker是一种开源的容器化平台，它可以将应用程序及其依赖项打包成一个独立的容器，提供了一种轻量级、可移植和可扩展的软件交付解决方案。\n>\n> 以下是一些常见的使用场景和区别：\n>\n>   1. 应用程序部署：Docker可以将应用程序及其依赖项打包成一个容器，使得应用程序在不同的环境中能够一致地运行，简化了部署过程。\n>   2. 微服务架构：Docker容器可以独立运行，每个容器承载一个小型的、独立的服务，使得微服务架构更加灵活和可扩展。\n>   3. 持续集成和持续部署：Docker容器可以与持续集成和持续部署工具集成，实现自动化的构建、测试和部署流程。\n>\n\n>\n> Docker空间和虚拟机的区别：\n>\n>   1.\n> 资源占用：虚拟机需要独立的操作系统和硬件资源，因此占用的资源较多。而Docker容器共享主机的操作系统内核，只需要额外的容器运行时和应用程序依赖的资源，因此占用的资源较少。\n>   2. 启动速度：虚拟机需要启动整个操作系统，因此启动速度较慢。而Docker容器只需要启动容器运行时和应用程序，因此启动速度较快。\n>   3.\n> 隔离性：虚拟机提供了较高的隔离性，每个虚拟机都有独立的操作系统和内核。而Docker容器共享主机的操作系统内核，隔离性相对较弱，但通过Linux内核的命名空间和控制组等技术，仍然能够提供一定程度的隔离。\n>   4. 可移植性：虚拟机可以在不同的物理主机或虚拟化平台上运行。而Docker容器可以在任何支持Docker的主机上运行，提供了更高的可移植性。\n>\n\n>\n>\n> Docker相对于虚拟机具有更轻量级、更快速的启动和更高的资源利用率，适用于快速部署和扩展应用程序的场景。虚拟机提供了更高的隔离性和可移植性，适用于需要完全隔离的环境或跨平台部署的场景。\n\n**学习参考：**[Docker入门，这一篇就够了，建议收藏](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F600034612)\n\n## 8\\. TCP和UDP的区别？\n\n**解析：**\n\nTCP 相关内容属于计算机网络必考部分，要熟练掌握。\n\n**参考答案：**\n\n>   * TCP是面向连接的，UDP是无连接的\n>   * TCP是可靠的，UDP是不可靠的\n>   * TCP是面向字节流的，UDP是面向数据报文的\n>   * TCP只支持点对点通信，UDP支持一对一，一对多，多对多\n>   * TCP报文首部20个字节，UDP首部8个字节\n>   * TCP有拥塞控制机制，UDP没有\n>   * TCP协议下双方发送接受缓冲区都有，UDP并无实际意义上的发送缓冲区，但是存在接受缓冲区\n>\n\n**学习参考：**[TCP与UDP的区别（超详细）](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fweixin_43796685%2Farticle%2Fdetails%2F104558965)\n\n## 9\\. TCP三次握手和四次挥手的过程？三次握手为什么不能是两次？四次挥手为什么不能是三次？\n\n**解析：**\n\nTCP 相关内容属于计算机网络必考部分，要熟练掌握。\n\n**参考答案：**\n\n>\n> HTTP本身并不涉及三次握手和四次挥手的过程，这些过程实际上是TCP（传输控制协议）建立连接和断开连接时使用的机制。HTTP是建立在TCP之上的应用层协议，因此了解TCP的这些机制有助于更好地理解HTTP的工作方式。\n>\n> **三次握手的过程** ：\n>\n>   1. **SYN（同步）阶段** ：客户端向服务器发送一个SYN包，并等待服务器的确认。这个SYN包中包含了客户端的初始序列号。\n>   2. **SYN-ACK（同步-应答）阶段** ：服务器收到SYN包后，向客户端发送一个SYN-ACK包作为应答。这个SYN-\n> ACK包中包含了服务器的初始序列号以及对客户端初始序列号的确认。\n>   3. **ACK（应答）阶段** ：客户端收到SYN-\n> ACK包后，向服务器发送一个ACK包作为最终的确认。这个ACK包中包含了对服务器初始序列号的确认。\n>\n\n>\n> **为什么不能是两次** ：\n>\n>   * **防止已失效的连接请求报文段突然又传送到了服务端**\n> ：客户端发出的连接请求报文段可能因为网络拥堵而在某个网络节点长时间滞留，以致延误到连接释放以后的某个时间才到达服务端。这时，服务端会误以为这是一个新的连接请求，于是又向客户端发出确认报文段，同意建立连接。如果不采用“三次握手”，那么只要服务端发出确认，新的连接就建立了。由于现在客户端并没有发出建立连接的请求，因此不会理睬服务端的确认，也不会向服务端发送数据。但服务端却认为新的运输连接已经建立，并一直等待客户端发来数据。这样，服务端就白白浪费了许多资源。采用“三次握手”的办法可以防止上述现象发生。例如上面这种情况发生时，客户端不会向服务端的确认发出确认。服务端由于收不到确认，就知道客户端并没有要求建立连接。\n>   * **防止已失效的连接请求报文段被服务端接收**\n> ：客户端发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留后，最终到达了服务端。这本是一个早已失效的报文段。但服务端收到此失效的连接请求报文段后，就误认为是客户端再次发出的一个新的连接请求。于是就向客户端发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要服务端发出确认，连接就建立了。但由于客户端并没有发出建立连接的请求，因此不会理睬服务端的确认，也不会向服务端发送数据。但服务端却认为新的运输连接已经建立，并一直等待客户端发来数据。这样，服务端就又白白浪费了许多资源。\n>\n\n>\n> **四次挥手的过程** ：\n>\n>   1. **FIN（结束）阶段** ：客户端向服务器发送一个FIN包，表示客户端想要关闭连接。\n>   2. **ACK（应答）阶段**\n> ：服务器收到FIN包后，向客户端发送一个ACK包作为应答，表示已经收到客户端的关闭请求。此时，服务器仍然可以发送数据给客户端。\n>   3. **FIN阶段** ：当服务器完成所有数据发送后，它也向客户端发送一个FIN包，表示服务器也想要关闭连接。\n>   4. **ACK阶段**\n> ：客户端收到服务器的FIN包后，向服务器发送一个ACK包作为最终的确认，表示客户端已经收到服务器的关闭请求。至此，连接完全关闭。\n>\n\n>\n> **为什么不能是三次** ：\n>\n>   * **确保数据完全传输**\n> ：在四次挥手中，第一次和第二次挥手确保了客户端发起关闭连接的请求，并得到服务器的确认。而第三次和第四次挥手则确保了服务器在发送完所有数据后也发起关闭连接的请求，并得到客户端的确认。这样的设计可以确保数据在双方之间完全传输，避免了数据丢失或未完全发送的情况。\n>   * **处理半关闭状态**\n> ：TCP连接允许半关闭状态，即一方可以关闭它的发送通道，但继续接收来自另一方的数据。四次挥手能够处理这种半关闭状态，确保在双方都同意关闭连接之前，连接不会被意外中断。\n>\n\n**学习参考：**[一文彻底搞懂\nTCP三次握手、四次挥手过程及原理](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F108504297)\n\n## 9\\. HTTP3.0了解过吗？QUIC协议的底层原理是什么？\n\n**解析：**\n\nHTTP3.0 相关内容属于计算机网络常考部分，要熟练掌握。\n\n**参考答案：**\n\n>\n> HTTP/3.0是下一代HTTP协议，其最显著的特点是采用了QUIC协议作为传输层协议，取代了之前的TCP+TLS+HTTP/2.0的组合。QUIC协议的设计初衷是为了解决TCP协议在建立连接时的延迟问题，同时提供更高效、更安全的数据传输。\n>\n> QUIC协议的底层原理主要包括以下几个方面：\n>\n>   1. **基于UDP的传输**\n> ：QUIC协议是基于UDP（用户数据报协议）的，这使得QUIC能够避免TCP协议在建立连接时的三次握手过程，从而降低了连接建立的延迟。此外，UDP的无连接特性也使得QUIC在数据传输时更加灵活和高效。\n>   2. **多路复用和流量控制**\n> ：QUIC协议实现了类似TCP的流量控制功能，能够根据网络状况动态调整数据的发送速率，以避免网络拥塞。同时，QUIC也支持多路复用，这意味着在同一个物理连接上，可以有多个独立的逻辑数据流同时进行数据传输，从而提高了数据的传输效率。\n>   3. **加密和安全性**\n> ：QUIC协议集成了TLS（传输层安全性协议）加密功能，使得数据传输过程中可以确保数据的机密性和完整性。这种加密功能不仅提高了数据传输的安全性，也避免了TCP+TLS组合时可能产生的握手延迟。\n>   4. **快速握手**\n> ：由于QUIC协议是基于UDP的，因此它支持0-RTT（零往返时间）和1-RTT（一次往返时间）的快速握手功能。这意味着在客户端和服务器之间已经建立过连接的情况下，客户端可以无需再次进行完整的握手过程就能发送数据，从而进一步降低了连接的延迟。\n>\n\n>\n>\n> HTTP/3.0和QUIC协议的推广和应用也面临一些挑战。例如，目前许多服务器和浏览器端对HTTP/3.0的支持还不够完善，这在一定程度上限制了HTTP/3.0的普及。此外，由于UDP协议在现有网络中的优化程度还低于TCP，因此在部署HTTP/3.0和QUIC协议时可能需要考虑网络环境的优化问题。\n\n**学习参考：**[QUIC/HTTP3\n协议原理](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F641748034)\n\n## 10\\. 一个32位系统，dump结果有1G，但是用户申请512M却触发OOM了，有几种原因？\n\n**解析：**\n\n操作系统中，难度较高，属于提高题。\n\n**参考答案：**\n\n> 在一个32位系统中，尽管系统整体的dump结果（可能是内存转储或系统日志）有1G，但用户申请512M内存时触发OOM（Out of\n> Memory，内存溢出）可能有以下几种原因：\n>\n>   1. **内存碎片**\n> ：系统中的可用内存可能已经被分割成许多小块，无法组合成足够大的连续内存块来满足512M的请求。这种情况通常发生在长时间运行且频繁进行内存分配和释放的系统中。\n>   2. **内核或驱动占用大量内存**\n> ：内核本身或某些驱动程序可能占用了大量内存，导致用户空间可用的内存减少。即使系统整体的内存使用没有达到上限，用户空间也可能因为内核或驱动的占用而无法申请到足够的内存。\n>   3. **缓存和缓冲区占用**\n> ：系统的缓存（如文件缓存、页面缓存等）和缓冲区可能占用了大量内存。这些内存虽然可以被回收，但在某些情况下（如内存压力较大时），回收过程可能不够及时，导致用户空间无法申请到足够的内存。\n>   4. **内存泄漏**\n> ：系统中可能存在内存泄漏的问题，即某些进程或模块在申请内存后没有正确释放，导致内存逐渐耗尽。即使总的dump结果有1G，但可用的连续内存可能已经很少。\n>   5. **内存超配**\n> ：某些虚拟化环境或容器技术可能会采用内存超配的策略，即允许虚拟机或容器使用的内存超过其物理内存的限制。在这种情况下，即使物理内存足够，但由于超配策略的限制，也可能触发OOM。\n>   6. **内存限制**\n> ：系统管理员可能为用户或进程设置了内存使用限制（如通过cgroups或ulimit等工具）。即使系统整体有足够的内存，但如果用户或进程达到了其内存使用限制，也会触发OOM。\n>   7. **内核参数配置不当**\n> ：某些内核参数（如overcommit策略）的配置可能影响到系统对内存申请的处理方式。如果配置不当，可能导致系统即使有足够的内存也拒绝用户的内存申请。\n>\n\n**学习参考：**[什么是OOM，为什么会OOM及一些解决方法](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fqq_42447950%2Farticle%2Fdetails%2F81435080)\n\n>\n> [更多面经直通车](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fusers%2F630265916)\n\n>\n> [原贴连接](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Ffeed%2Fmain%2Fdetail%2F16f8b75847b6487a9a8f58edf547f72f%3FsourceSSR%3Dusers)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598528673708371968?sourceSSR=users",
        "title": "大疆车载 25 C++软开实习 一面面经",
        "content": "## 面试内容\n\n  1. 自我介绍\n  2. 问了一下为什么上一段实习时间只有三个月,面试官比较重视实习时长,最好满足6个月\n  3. 内存调查方法\n  4. 性能优化\n  5. 线程池/内存池的实现(回答的有点卡壳)\n  6. 智能指针\n  7. std::move实现, 作用\n  8. 以往实习经历, 重点拷打了我局域网下面如何通过网络协议来使client自动找到server ip, 这个问题我现在也没有搞懂...\n  9. 对自己上一段实习打分\n\n## 反问\n\n  1. 工作内容\n\n## 后续\n\n拿到offer了, 只有一面\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598473340843479040?sourceSSR=users",
        "title": "字节跳动后端暑期实习最新面经解析：回归基础，方为大道",
        "content": "嗨～我是可拟雀，一个后端开发工程师，毕业于某985大学，目前供职于bat某大厂核心部门后端。每天分享最新面经答案，希望在大环境不好的当下能帮到你，让你多积累面试经验。******************************  \n  \n  \n一面 1h  \n1\\. 布隆过滤器原理  \n答：布隆过滤器（Bloom\nFilter）是一种空间效率极高的概率型数据结构，它利用位数组和一系列哈希函数，以较小的空间代价和较大的概率来检测一个元素是否属于某个集合。  \n  \n其核心原理如下：  \n  \n位数组：布隆过滤器使用一个位数组作为底层存储结构。每个位都可以是0或1，表示该位置是否被“占用”。  \n  \n哈希函数：布隆过滤器使用多个独立的哈希函数。当向过滤器中添加一个元素时，这些哈希函数会计算出多个索引值，并将位数组中对应的位设置为1。  \n  \n添加元素：对于每个待添加的元素，布隆过滤器会利用所有的哈希函数计算出多个索引值，并将这些索引对应的位数组中的位置设为1。  \n  \n查询元素：为了判断一个元素是否存在于集合中，布隆过滤器同样会利用哈希函数计算出多个索引值，并检查这些索引对应的位是否都为1。如果所有位都为1，那么过滤器认为该元素可能存在（但可能存在误报，即实际上元素并不在集合中）。如果有任何一位为0，那么过滤器可以确定该元素一定不存在。  \n  \n需要注意的是，布隆过滤器存在以下特点：  \n  \n误报率：由于哈希冲突的存在，布隆过滤器可能会错误地认为某个不在集合中的元素是存在的，这称为误报或假阳性。但布隆过滤器不会误报不存在的元素为存在，即不存在假阴性。误报率可以通过增加位数组的大小或使用更多的哈希函数来降低。  \n  \n不支持删除：布隆过滤器不支持从集合中删除元素。一旦一个元素被添加到过滤器中，其对应的位就会被设置为1，并且无法再被撤销。尝试删除元素可能会导致其他元素的误报率增加。  \n  \n尽管存在这些限制，但布隆过滤器因其高效的空间利用率和快速的查询速度，在许多场景中都得到了广泛应用，如缓存穿透、垃圾邮件过滤、网页黑名单系统等。  \n  \n2\\. 回表、覆盖索引？  \n答：  \n回表：  \n  \n回表是数据库中一种查询优化方式，通常出现在使用非聚集索引进行查询的场景中。非聚集索引与数据行分开存储，它包含一个指向数据行的指针。当使用非聚集索引进行查询时，数据库引擎首先通过该索引找到匹配的行，然后使用行指针到表中查找相应的行数据。这个额外的查找操作就被称为“回表”。回表操作的代价较高，因为它需要额外的IO操作，增加了查询的开销，特别是在大型数据表中这种开销更为明显。  \n  \n为了优化查询性能，可以考虑将经常需要查询的列包含在非聚集索引中，这样数据库引擎在索引中就能找到所需的所有信息，无需再进行回表操作。但需要注意的是，回表操作并不适用于使用聚集索引的查询，因为聚集索引包含了整个表的数据，查询时无需再回到表中查找数据。  \n  \n覆盖索引：  \n  \n覆盖索引是一个包含了查询语句所需的所有数据的索引。它不仅能够提供索引的搜索能力，还可以完全覆盖查询需求，避免了回表操作。在覆盖索引中，索引本身包含了查询语句中涉及的所有字段，因此数据库引擎可以仅通过索引就获取到所需的所有信息，无需再额外去查找数据行。这减少了I/O消耗，提高了查询效率。  \n  \n覆盖索引是数据库性能优化的一个重要策略，但在使用过程中需要根据具体场景权衡选择，以达到更好的性能优化效果。  \n  \n3\\. 无序数组的中位数？  \n4\\. 差分题目？  \n5\\. UDP 实现和 TCP 实现？  \n答：\n\n  \n\n连接性：UDP是无连接的协议，它不需要在传输数据之前建立连接。发送端只需将数据封装在UDP数据报中，然后发送给接收端。与此不同，TCP是面向连接的协议，在发送数据之前，需要先通过三次握手协议建立连接，确保数据传输的正确性。\n\n可靠性：TCP协议保证数据传输的可靠性，它通过一系列机制（如确认应答、超时重传等）确保数据能够准确、有序地到达接收端。而UDP协议则不保证数据的可靠性，它只负责将数据发送出去，不关注数据是否到达接收端，也不保证数据的顺序性。\n\n传输效率：UDP协议通常具有更高的传输效率，因为它不需要进行连接建立和断开等额外操作，且没有复杂的流量控制和拥塞控制机制。TCP协议虽然保证了数据的可靠性，但也因此引入了更多的开销，导致传输效率相对较低。\n\n  \n\n报文大小：UDP的报文首部只有8个字节大小，而TCP的报文首部有20个字节。这也在一定程度上影响了两种协议的传输效率和应用场景。\n\n  \n\n应用场景：由于UDP协议的高效性和无连接特性，它常被用于实时性要求较高、对数据传输可靠性要求不高的场景，如视频流传输、实时游戏等。而TCP协议则更适用于需要确保数据传输可靠性和顺序性的场景，如文件传输、网页浏览等。\n\n  \n\n  \n\n6\\. LRU 和 LFU 的区别和实现  \n答：  \n\nLRU（Least Recently Used）和LFU（Least Frequently\nUsed）是两种常见的缓存置换算法，它们的主要区别在于评估缓存对象被替换的标准不同。\n\n  \n\nLRU算法主要基于时间局部性原理，即如果一个数据在最近一段时间被访问过，那么将来被访问的可能性也很大。因此，LRU算法会淘汰最长时间未被使用的页面或数据。在LRU中，通常会使用一个双向链表来维护缓存数据的使用顺序，链表的头部表示最新使用的数据，尾部表示最旧的数据。每当有数据被访问时，该数据就会被移到链表的头部。当缓存已满且需要插入新数据时，LRU会从链表尾部选择最久未被使用的数据进行替换。\n\n  \n\n而LFU算法则主要基于频率局部性原理，即如果一个数据在最近一段时间被访问的次数很多，那么将来被访问的可能性也很大。因此，LFU算法会淘汰一定时期内被访问次数最少的页面或数据。LFU的每个数据块都有一个引用计数，当数据被访问时，其引用计数就会增加。所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。当需要淘汰数据时，LFU会将已经排序的列表最后的数据块删除。\n\n  \n\n在实现上，LRU和LFU都需要维护一个数据结构来跟踪缓存中每个数据的使用情况。对于LRU，这通常是一个双向链表，而对于LFU，则需要一个能够记录引用计数的数据结构，如哈希表或优先队列。这两种算法在实现时都需要考虑如何高效地插入、查找和删除数据，以及如何在缓存满时选择合适的数据进行替换。\n\n  \n\n7\\. 虚拟内存？  \n  \n\n虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。\n\n  \n\n虚拟内存的工作原理是将进程使用的内存分为多个页面（通常为4KB或8KB），每个页面都有一个唯一的虚拟地址。当进程需要访问某个页面时，操作系统会检查该页面是否已经在物理内存中，如果已经在内存中，则直接访问该页面；如果不在内存中，则操作系统会将该页面从磁盘上的虚拟内存中读取到内存中，并将其映射到进程的虚拟地址空间中。\n\n  \n\n虚拟内存不仅仅是简单地存放进程的一部分并且与内存可以互相交换，它还涉及到许多复杂的机制和算法，例如页面置换算法、页面预读技术、页面共享技术等，以提高系统的性能和效率。同时，虚拟内存也是操作系统中非常重要的一部分，它为多任务操作系统的正常运行提供了必要的支持。\n\n  \n\n8.os分页算法？\n\n答：\n\nOS分页算法是操作系统中用于管理内存的一种重要机制。分页的基本方法是将地址空间等分成某一个固定大小的页，每一页大小由硬件或操作系统来决定。进程的逻辑地址空间被分成若干个大小相等的页面，而物理内存空间也被分成与页大小相等的物理块或页框。当为进程分配内存时，以块为单位将进程中的页面装入物理内存中的块。\n\n  \n\n在分页机制下，物理内存空间是有限的，当所有物理页面都被占用时，操作系统需要选择某些页面进行置换，以便为新的页面腾出空间。这就涉及到了页面置换算法。\n\n  \n\n常见的页面置换算法包括FIFO（先进先出）算法、最佳置换算法和LRU（最近最少使用）算法等。\n\n  \n\nFIFO算法按照页面调入内存的先后顺序进行置换，最先调入内存的页面先被替换出去。\n\n最佳置换算法选择在未来最长时间内不再被访问的页面进行替换。\n\nLRU算法则选择最近最少使用的页面进行替换。\n\n  \n\n  \n\n9\\. 函数调用与栈  \n答：  \n函数调用与栈的关系主要体现在函数调用的执行过程中。栈（Stack）是一种数据结构，它遵循后进先出（LIFO，Last In First\nOut）的原则，即最后进入栈的元素将最先被移除。在程序执行过程中，函数调用栈（或称为执行栈）用于存储函数调用时的相关信息，以确保函数能够正确地执行和返回。\n\n  \n\n当一个函数被调用时，以下操作通常会在函数调用栈上发生：\n\n  \n\n压栈（Push）：\n\n  \n\n函数调用者的下一条指令地址（即返回地址）被压入栈中。这样，当函数执行完毕后，程序可以返回到正确的位置继续执行。\n\n函数的参数（如果有的话）也会被压入栈中，供函数内部使用。\n\n函数的局部变量和运行时所需的其他信息也可能在栈上分配空间。\n\n  \n\n函数执行：\n\n  \n\n函数在栈顶开始执行。它可以访问其参数（从栈中读取）和局部变量（也在栈上分配）。\n\n函数执行期间，可能会进行更多的函数调用，这些新的调用同样会压入栈中。\n\n  \n\n返回（Return）：\n\n  \n\n当函数执行完毕并准备返回时，它会从栈顶弹出，返回到之前保存的返回地址继续执行。\n\n在返回过程中，函数可能返回一个值，这个值通常会被放置在某个特定的寄存器中，或者在某些情况下也可能被压入栈中，等待调用者读取。\n\n  \n\n清理栈：\n\n  \n\n随着函数的返回，其相关的栈帧（包括局部变量、参数和返回地址）会被从栈中弹出，释放空间。\n\n  \n\n通过栈来管理函数调用，确保了程序能够正确地追踪函数的调用顺序和返回路径。如果栈空间不足（即发生栈溢出），程序通常会崩溃，因为无法为新的函数调用分配空间。栈溢出是一个常见的编程错误，尤其是在递归函数没有正确的终止条件，或者函数内部申请了过多的局部变量时。\n\n  \n\n10\\. lc 394 字符串解码\n\n  \n\n11\\. 岛屿数量  \n  \n总结：可以看出，校招的时候一线大厂都不会过于强调对框架和语言的考察，反而是计算机网络，计算机组成和操作系统，数据库这些计算机专业课基础。  \n  \n[原文出处](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fshare%2Fjump%2F566343146602283988)  \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598330157245505536?sourceSSR=users",
        "title": "华为运营商bg客户经理入池子求捞",
        "content": "![](https://uploadfiles.nowcoder.com/message_images/20240316/111176414_1710523146952/discuss_1710523146760.jpeg)听说写面经会积累好运，所以特来虔心记录两句。  \n背景就是本人江山地区，2.29日面试，一天三面入池子，至今杳杳无信，无对接hr，无保温电话，甚至不知道如何与对接人获得联系。  \n第一面群面，无领导小组讨论，组内10人。个人认为是我三轮中发挥最差的一面。首先一分钟自我介绍，这在我射程之内，不难准备，然后就开始了漫长的近一个小时的煎熬。题目是啥应该不能说，不过跟销售业务有关。  \n讨论20分钟，给出结论并汇报。组内有人虽未明说，但抢先发言跳了leader，一番言语颇有为本次讨论定调子的想法。不过好几个人对此人提出的观点颇有微词，火力还挺猛，一时间竟拿不出一个统一的结论。  \n不得不说这几个人口才都太好了，而且气场极强，表达起来十分自信。我找不到插嘴的机会，直到近10min左右才抢到话筒。殊不知这是我在本次讨论的唯一一次发言。我首先肯定了上一个人的观点，然后对其做了补充，说了有一分钟左右被面试官提醒还有十分钟结束，遂停止发言。  \n当时我心里慌极了，因为我觉得是面试官不满我发言的条理性而故意打断我，之后也丧失了发言的欲望，一直没再说话。leader见时间不多了主动做了总结，他居然自己画了个流程图（他真的好卷啊啊啊）然后做了reporter。  \n面试官对leader展开提问，问他对自己在本次面试中的定位，问他对自己的打分和这次讨论的打分，问他为什么组内有两名同学没发言而没有出言提醒。（我感觉leader犯了大忌，可能没有搞清楚自己这个角色的定位）然后全程没问我问题，我以为是对我不感兴趣。  \n面试完心如死灰，去吃饭，意外发现自己过了。  \n现在来看应该是因为leader表现太差，没有起到组织者的作用，也没有引导我们形成一个统一的结论。整场讨论形成了三个方案，各自为战十分明显。而我现在总结虽然我只发言了一次，但注重输出观点的有效性，而且肯定了队友，这应该是亮点。（这并不是说我表现的多好，我表现的我一点也不好，还有点紧张）我推测leader应该被淘汰了，那两个没说话的人应该也被淘汰了，名额可能快满了，就没轮到我。想来也是万幸。  \n今天写不完了，明天再写。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598298903968071680?sourceSSR=users",
        "title": "腾讯云突击检查",
        "content": "3.15，腾讯中午十二点多发的邮件约下午17:00面试。体验和别的同学不大一样，个人感觉还不错，没有严刑拷打。\n\n  \n\n自我介绍\n\n手撕151反转字符串中的单词（复盘的时候感觉边界有点问题，但是面试官也没多问）\n\nJVM内存结构，生命周期\n\nGolang协程\n\n项目相关，问了外卖里的并发，以及觉得优化的点应该在哪里。\n\n其它问题不太记得了。\n\n几乎没问我网络和操作系统，好像其它腾讯云面试同学会拷打很多这方面内容\n\n  \n\n反问：部门业务 技术栈 后续tl 提升建议。\n\n  \n\n  \n\n我目前入职一个中厂做实习了，硬伤是腾讯那边不能立刻到岗了。之前腾讯也算是意难平吧，可以见上一篇。所以近两周几乎没有复习八股还是硬着头皮接了面试。也算是查漏补缺吧。\n\n  \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598285140879548416?sourceSSR=users",
        "title": "腾讯云客户端二面（本科实习）",
        "content": "自我介绍，然后问项目具体实现，然后问了个场景：下载线程如何通知UI主线程下载进度和下载完成。\n\n然后问了自学cpp看了什么书（学校教java，cpp选修而且教的不深）\n\n## 八股：\n\n  1. 生产者消费者模型（具体没答上来，因为os课正在学，没上到）\n  2. 线程和进程的区别\n  3. 死锁是怎么产生的\n  4. 什么是读写锁\n  5. 深拷贝和浅拷贝区别\n  6. lambda表达式实现原理\n  7. 解释智能指针实现原理\n  8. 解释static,const,堆栈变量的区别\n  9. cpp一个空class（无成员函数，虚函数指针）多大；这个平时没注意，只了解了空基类优化，猜了一个\n  10. 什么是内存对齐，为什么要对齐\n  11. 介绍HTTP协议\n  12. TCP粘包解决\n  13. 解释HTTPS加密\n  14. hashmap产生碰撞怎么解决\n\n## 写题：\n\n手写一个链表，往里面递增插入数据，然后删除重复的数据（问能不能查reference，回答全部手写STL容器都别用）\n\n    \n    \n    1->1->2->3->3->4\n    删除后\n    2->4\n    \n\n太紧张没看到递增，摁写了30min,然后被提醒。面试官有事先去处理，让我继续写，写完可以退会议，最后写完了。\n\n更新一下，隔了一周，收到三面消息，这回技术主管面。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598282520374910976?sourceSSR=users",
        "title": "【怒怼大厂面试官】Kafka消费者手动提交、自动提交的区别？",
        "content": "![alt](https://uploadfiles.nowcoder.com/images/20240312/300233579_1710231520112/F19C9085129709EE14D013BE869DF69B)\n\n> _面试官：听说你精通Kafka，那我就考考你吧_\n>\n>  \n>\n>\n> _面试官：不用慌尽管说，错了也没关系😊。。。_\n>\n>  \n>\n>\n> 以【**面试官面试** 】的形式来分享技术。**整理分类专栏、首发博客**\n> 在[CSDN](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fhdgaadd)（戳这），本期是《Kafka系列》，期待观众老爷的关注❤️\n\n## 面试官：你先说说Kafka由什么模块组成吧\n\n嗯嗯好的。\n\n主要有：生产者、消费者、Brocker、Topic、消息分区**Partition** 。\n\n>  \n>\n>\n> _面试官思考中…_\n>\n>  \n>\n\n## 面试官：那我们先讲讲生产者、消费者？\n\n嗯嗯好的。\n\n>  \n>\n>\n> _面试官思考中…_\n>\n>  \n>\n\n## 面试官：消息生产者的异步回调，知道吧\n\nOk知道的。主要是可以进行**异常日志的记录** 。\n\n是这样的，Kafka的**异步提交消息** 相比同步提交，不需要在brocker响应前阻塞线程。\n\n但是异步提交我们是不知道消费情况的，所以就可以在Kafka消费异常时，通过其**回调** 来告知程序**异常情况** ，从而进行日志记录。\n\n>  \n>\n>\n> _面试官思考中…_\n>\n>  \n>\n\n## 面试官：消费者分区，可以介绍下吗\n\n嗯嗯Ok。分区的作用主要就是为了提高Kafka处理消息**吞吐量** 。\n\n每一个topic会被**分为多个分区** 。\n\n假如同一个topic下有n个分区、n个消费者，**每个** 分区会发送消息给对应的**一个** 消费者，这样**n个消费者就可以负载均衡** 地处理消息。\n\n同时**生产者** 会发送消息给不同分区，每个分区**分给不同的brocker** 处理，让集群平坦压力，这样大大提高了Kafka的吞吐量。\n\n![alt](https://uploadfiles.nowcoder.com/images/20240315/300233579_1710513533969/4F4D2E2C8952FC2218DAFF28177E4635)\n\n>  \n>\n>\n> _面试官思考中…_\n>\n>  \n>\n\n## 面试官：你说说消费者手动提交和自动提交，有什么区别\n\n其实就是两种不同的客户端提交方式。\n\n  1. 自动提交的话，通过设置enable.auto.commit为true，**每过5秒** 消费者客户端就会自动提交最大偏移量\n  2. 手动提交的话，通过设置enable.auto.commit为false，让消费者客户端消费**程序执行后** 提交当前的偏移量\n\n>  \n>\n>\n> _面试官思考中…_\n>\n>  \n>\n\n## 面试官：那它们都有什么优、缺点吗\n\n  1. 自动提交的话，比较方便**只需要配置** 就可以，不过可能会导致消息丢失或重复消费。 \n     * 如果刚好到了5秒时**提交了** 最大偏移量，此时正在消费中的消费者客户端崩溃了，就会导致**消息丢失**\n     * 如果成功消费了，下一秒应该自动提交，但此时消费者客户端奔溃了**提交不了** ，就会导致其他分区的消费者**重复消费**\n  2. 手动提交的话，需要**写程序** 手动提交，要分两种提交方式。 \n     * 手动提交是**同步提交** 的话，在broker对请求做出回应之前，客户端会一直阻塞，这样的话限制应用程序的**吞吐量**\n     * 是**异步提交** 的话，不会有吞吐量的问题。不过发送给broker偏移量之后，**不会管** broker有没有收到消息\n\n![alt](https://uploadfiles.nowcoder.com/images/20240315/300233579_1710513515013/162DF4B4B286FF0846DC558BB76B2337)\n\n> _面试官抓抓脑袋，继续看你的简历......_\n>\n>  \n>\n>\n> _得想想考点你不懂的😰_\n\n## 未完待续。。。。。。\n\n好了，今天的分享就先到这，我们下期【**大厂面试演练** 】继续。\n\n> **整理分类专栏、首发博客在**\n> ：[CSDN](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fhdgaadd)\n>\n>  \n>\n>\n>\n> [GitHub](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgithub.com%2Fhdgaadd)，你的\n> ⭐️ Star ⭐️，是作者的动力！\n>\n>  \n>\n>\n> **创作不易，不妨点赞、收藏、关注支持一下，各位的支持就是我创作的最大动力** ❤️\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598272725957853184?sourceSSR=users",
        "title": "腾讯后端一面凉经50分钟",
        "content": "算法题：开局写个快排（写出来了后面发现时间复杂度说错了当时面试官还思考了一下说对对对，难绷）\n\n问我和别人相比有什么优势，一下次给我卡住了；\n\n然后问我项目和实习时间为什么都这么短。\n\n项目·：\n\n1.什么是HashMap扰动函数\n\n2.布隆过滤器\n\n3.缓存穿透\n\n4.微信支付怎么确保用户支付成功？怎么实现对账功能？\n\n5.redis分布式锁\n\n八股：\n\nredis:redi\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598264725000024064?sourceSSR=users",
        "title": "腾讯处女面",
        "content": "3.12电话约3.14下午一面\n\n被捞面试：微信事业群-小游戏团队后台开发\n\n1.面试官介绍部门\n\n2.自我介绍\n\n3.聊简历上的项目\n\n4.多态靠什么机制实现的？\n\n5.多态内部通过什么实现的？\n\n6.什么是纯虚函数？\n\n7.用过lambda表达式吗？能否写一个？\n\n8.Linux中进程内存布局知道吗？\n\n9.各个分区存放哪些数据？\n\n10.临时变量是存在哪里的？\n\n11.在堆上分配内存，在C++中怎么去申请？\n\n12.假如现在一个数据量比较大，比如达到兆级，一般放在哪里？\n\n13.C++没有内存回收，C++中分配内存要考虑到什么问题？\n\n14.避免内存泄漏的方法有哪些？\n\n15.在使用过程中主动释放，但是很难避免程序在运行过程中中途退出的情况，内存也会泄漏，那有没有其他更好的方式避免内存泄漏？\n\n16.智能指针是用什么方式避免内存泄漏的？\n\n17.进程间的通信方式有哪些？\n\n18.多个线程间的有哪些通信方式？\n\n19.Linux下查看Linux服务器的性能指标通过什么查看？比如内存、CPU使用情况。\n\n20.别人作为客户端给Linux服务器上的程序发消息，但是你这边没收到，Linux下面用什么方式命令可以快速知道这个包有没有到你这边？\n\n21.调试程序有BUG是通过什么方式调试的？\n\n22.5层网络协议是哪5层\n\n23.TCP属于哪一层？\n\n24.数据链路层通过什么来寻址？\n\n25.网络层通过什么来寻址？\n\n26.不在同一局域网的两台机器，分别只有IP，在客户端发出消息到服务端收到地址，经过哪些协议？\n\n27.包到达路由器下的局域网了，拿到的只是一个IP，在局域网下面怎么把IP换成MAC的？\n\n28.ARP协议的流程是什么？\n\n29.socket编程，TCP和UDP在API层面主要有哪些区别？\n\n30.TCP是可靠传输，我们在编程的时候相比UDP是不是要绑定端口这些？\n\n31.网络多路复用里，什么是IO多路复用？\n\n32.经常说大端小端，网络通信是属于大端还是小端？\n\n33.HTTP里面的返回码知道吗？200代表什么？\n\n34.如果要把状态码区分为客户端还是服务端的问题，你觉得客户端问题的返回码主要是什么，以哪些开头的返回码是客户端的问题？\n\n35.数据库中要优化查询性能，最常见的方式是什么？\n\n36.数据库索引是干什么用的？\n\n37.索引是通过什么数据结构实现的知道吗？\n\n38.快排的时间复杂度是多少？\n\n39.常用的负载均衡协议有了解吗？\n\n40.一次性哈希听过没有？\n\n编程题：\n\nATOI函数，将字符串转换成数字\n\n问：什么时候可以开始实习，可以实习多久？\n\n反问：\n\n1.部门具体干什么的？\n\n2.部门员工需要掌握哪些方面的知识？\n\n3.根据我今天的表现，提一些建议。\n\n4.我有可能进到下一轮面试吗？\n\n全程60min\n\n面试官人非常好，一直在引导，问的问题也比较基础，奈何自己太菜[牛泪]\n\n  \n\n————————————————————\n\n3.18晚上流程终止\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598263126567534592?sourceSSR=users",
        "title": "游族 Java后端日常实习面经",
        "content": "自我介绍\n\n自学 Java 的过程\n\n类加载机制\n\n类加载器种类\n\n双亲委派机制\n\n自定义了一个 String 类，能不能正常使用\n\nJava 常见的集合类\n\nArrayList 底层、扩容机制\n\nArrayList、LinkedList 区别\n\n平时开发遇到的异常\n\nThredLocal 原理\n\nsynchronized 和 volatile 的区别\n\nsynchronized 修饰静态方法和实例方法的区别\n\nConcureentHashMap 的实现原理\n\nhashtable 和 ConcureentHashMap 的区别\n\n线程创建方式\n\n死锁的概念、如何避免死锁\n\nMySQL 索引\n\nMySQL 锁\n\nMySQL 表锁和行锁\n\n在哪用到了 Redis\n\n为什么用 Redis\n\nTCP、UDP 的区别\n\n微服务的概念\n\n项目\n\n其他一些问题\n\n反问\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598262142751547392?sourceSSR=users",
        "title": "腾讯 PCG 后台开发 暑期实习 二面 凉经",
        "content": "- 自我介绍\n\n- 项目相关\n\ngin框架怎么处理Cookies和Session\n\nJWT包含哪些部分\n\nSnowFlake算法讲一下？\n\n除了SnowFlake算法之外，还有什么方法可以生成分布式唯一ID\n\n令牌桶你是怎么实现的？\n\n你这个是单机，如果实现分布式的令牌桶怎么搞\n\n了解过RPC框架吗\n\n你的LLM的Agent框架用的是什么\n\n你怎么让它识别用户意图\n\n- 计网\n\nTCP的通信过程是怎么样的，就是你怎么去编写TCP的Socket，讲代码实现\n\n你用CPP写，怎么设置你的Socket是TCP还是UDP啊\n\n- OS\n\n了解过进程间通信吗\n\n管道用过吗，讲一下\n\n调用Pipe创建管道后，管道中返回的是什么\n\n进程跟线程什么区别呢\n\n进程和线程的虚拟内存空间是什么样的，是一样的吗\n\n详细讲一下虚拟内存空间\n\n假如一个进程fork出一个子进程，那么父进程和子进程的虚拟内存空间一样吗\n\n多线程用过吗（答的goroutine）\n\n- Go\n\ngo的map可以并发读取吗\n\n如果发生竞态会发生什么情况\n\n竞态读取map会报错吗\n\nGo的Context你用过吗\n\n协程和线程什么关系\n\nG怎么放在M上？\n\nMP的关系是一对一，还是一对多，还是多对多\n\n怎么个多对多？\n\n30min无手撕，光速寄\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598252302662705152?sourceSSR=users",
        "title": "游族网络 一面 二面 (已OC确认意向)",
        "content": "[#游族网络##u3d开发#k](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fenterprise%2F938%2Fdiscussion)\n\n我的背景：双非本科，打过算法竞赛，做过好几个游戏demo\n\n# 一面 3.12(好像是12号)\n\n面的饭团工作室，面试官是个很和蔼的人。（我答的时候没答好，答的太细节，没讲明白）\n\n1\\. 自我介绍\n\n2\\. 挑我的demo，问demo里感觉最难实现的\n\n回答了一个怎么实现弹幕机制，和编写shader\n\n3\\. 项目中的怪物AI怎么实现的\n\n4\\. 问一个数组，怎么原地每次删除头\n\n5\\. 怎么在100以内筛质数\n\n6\\. 开辟一个一百亿大小的数组会遇到的问题\n\n7\\. 讲一下优先队列\n\n7.1 你说优先队列就是大小根堆，那你是怎么实现堆的\n\n8.图形学了解吗\n\n9\\. 讲一下unity底层中渲染顺序，例如场景和透明物体和不透明物体\n\n10\\. opengl和一个什么什么的库的区别\n\n11.用过什么unity插件\n\n12\\. unity的生命周期\n\n13\\. FixUpdated的实现原理\n\n14\\. awake和start分别在什么时候调用\n\n15\\. 如何知道怪物在玩家的左边还是右边\n\n反问：\n\n1\\. 项目工作室是做什么的\n\n权力的游戏，成熟上线的产品\n\n2\\. 对我这次面试表现得评价\n\n做游戏的能力是有的，我那个游戏项目给面试官留下很深的印象。对unity底层实现不太了解。人很坦诚，不知道就说不知道\n\n总结\n\n面试总体难度不难，unity问题和算法问题都不难，只是图形学我不了解，图形学的东西基本没答出来。\n\n面试官很有耐心，就像朋友在聊天一样轻松，一些我表达不清楚的东西也能很快get到我的意思\n\n后续\n\n面试结束不到一小时，HR通知面试通过，并马上安排三天后的二面。貌似二面是大领导面\n\n评价：\n\n游族hr小姐姐好温柔，有问必答，面试体验很好，效率也是非常的快，3.11号投的简历，笔试完成后当天通知通过，安排15号的一面，一面结束一小时马上安排二面。总的来说是一次很愉快的体验。\n\n# 二面(技术+HR面) 3.15\n\n没有开视频面试，我也就没开，技术主管和HR轮着问问题。顺序已经忘了，面完觉得铁定挂了就没打算写面经，隔了十几天才写面经很多都忘了。\n\n1\\. 自我介绍\n\n2\\. 问项目\n\n3\\. C++和C#的区别\n\n至今我都不明白我当时有那么多可以回答的，我为什么答了一个C#的语法糖？？？\n\n4\\. 为什么加入游戏行业\n\n5\\. 什么时候能来 (这个点很关键，貌似他们很缺人，不能拖太久)\n\n6\\. 忘了。。。。\n\n# 打电话问投递情况(大概在二面后三四天？)\n\n因为当时答最晚4.10号回来，面试完越想越不对劲，加上白等了三四天，所以发生下面这些事\n\n1\\. 打电话给HR\n\n我：我想更新一下我的信息，我当初不是说4.10号来嘛，现在情况有变，我四月出头就能来，能提早一个礼拜\n\nHR：好的好的，这边记下了\n\n我：顺便查一下我有没有通过二面？\n\nHR：好的这边帮你查询一下，这边显示是没有通过的呢、\n\n2.我的心**拔凉拔凉** 的\n\n# 打电话通知面试通过3.28\n\n在今天下午，面试西山居的前5分钟，游族打电话过来说面试通过了（我：一脸懵逼，不是说挂了吗）\n\n晚上就确认意向决定去了，虽然还很多厂没有面完，但不敢保证之后存在更好的\n\n# 结语\n\n哈，终于结束了。。。回忆起3月初什么都没准备，短短一个月内简历改了6版的我，那个一边面试一边被拷打的我，那个一边背八股一边收感谢信的我。。。终于。。暂时告一段落了\n\n待会儿整理一波心路历程，和面试过的面经，攒人品\n\n作者：kekekuli\n\n链接：https://www.nowcoder.com/feed/main/detail/44a75d7d1bd7422fa792276cef60c081?sourceSSR=users\n\n来源：牛客网\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598237454755274752?sourceSSR=users",
        "title": "杭州某小厂前端面经（一面+二面）",
        "content": "本人杭州电子科技大学大三本科生\n\n一面 40分钟左右\n\n1.JS的基本数据类型，复杂数据类型和简单数据类型在内存中的区别\n\n2.JS怎么实现深拷贝（答上来一部分）\n\n3.v-model实现原理结合实际说一说（结合实际的部分没有回答好）\n\n4.组件间通信方式\n\n5.元素实现居中（典）\n\n6.三栏布局实现（典中典）\n\n7.vue组件能直接在浏览器中运行吗\n\n8.能写一个vue3中的hook函数吗（完全不会）\n\n9.Vue3怎么实现响应式\n\n10.事件循环讲输出（专业对口上了）\n\n11.防抖和节流（又专业对口上了）\n\n12.反问\n\n一面过程中虽然有几个问题答得不是很好，但感觉还行，果然面完马上安排了二面（大的要来了）\n\n二面 30分钟左右\n\n听声音，这次直接来了一个成熟稳重的程序员，这时还没意识到马上要遭重了\n\n全程没有八股，按流程先自我介绍了一下，着重拷打了我的两个项目\n\n第一个项目是我全栈开发的，是大创的一个获奖项目。面试官不愧老成，听我吹完项目一眼找到了痛点，盯着这个问，\n\n主要是如何实现一有危险行为就自动播放语音，当时这个部分确实没完善好，需要点击一个按钮才能播放，但是大学里的比赛懂得都懂，想蒙混过关还是被逮到了，这个功能我只是在项目介绍里提了一嘴居然还是被逮住了\n\n第二个项目我直接拉了托大的，因为这个项目是B站上的一个仿百度网盘项目，视频里讲的也不是很细，很多功能怎么实现都没讲清楚，只告诉你要对着敲一遍，所以我在写项目介绍的时候着重提了我比较熟悉的那一部分，但面试官直接问了我秒传文件、文件上传进度、分享的原理实现，虽然一面的时候也问了这个项目，但那时比较浅，但这次面试官逐步深挖，还引申了很多，听得我只能说受教了（当时就觉得应该已经凉了）\n\n总的来说，面试体验还是很好的，虽然二面被拷打得烂了，但是面试官很耐心地给我讲解其中的原理机制，真的很受教\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598225152647700480?sourceSSR=users",
        "title": "软件开发 - 凉经 - 大陆康腾",
        "content": "**2024.3.14 Boss投递**\n\n**2024.3.16 面试（Boss面试间）**\n\n面试官是软件开发部经理\n\n自我介绍\n\n学校的地点\n\n实习和毕设以及学校安排冲突吗\n\n打算参加秋招的具体时间\n\n专业是软件工程是吧\n\n数学学过那几科呢\n\n概率统计中有平均值，标准差，中值，方差，具体讲讲定义以及计算方法\n\n正太分布如何计算，一般如何使用\n\n线性代数学的怎么样\n\n0的整数次方有哪几种结果呢\n\n那0的0次方呢\n\n那0的-1次方的\n\n那在程序中输入会出现什么呢\n\n在写程序中有遇到过0除这样的异常吗\n\nPython基础有多少\n\n如何使用Pandas库进行一些数据加载工作呢\n\n数据清洗的时候的量有多大，是如何加载的\n\n自己有做过编程相关的实践么\n\n如何使用python从Hadoop加载数据，具体描述一下过程\n\n你感觉专业课程中学的最好的有哪些\n\n数据库中的笛卡尔积有了解吗，具体讲讲\n\n如果100*5和10000*3的两张表笛卡尔积是多大\n\n你了解的数据库原理中，二维表有几类计算呢\n\n那你有接触过数据库的哪几类操作呢\n\n表的新建有哪些语句有哪几种方式呢\n\n你数据结构有了解过吗\n\n是基于C还是Java\n\n如何实现双层（双向）链表呢\n\n有做过一些数据结构的联系么\n\n后续二面是进入现场\n\n感觉自己基础特别薄弱，基础问题都不清楚，专业课程没有具体学习，数学基础一般，唉😔！~\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598220470198071296?sourceSSR=users",
        "title": "华为OD-前端面经-D3",
        "content": "  * **背景** ：二年前端开发经验，211本科软件工程，找的前端岗位base杭州，在牛客寻到的栗栗姐。\n  * **一、机试**\n\n机试共三道算法题，分成两部分。其中第一部分是12小题，第二部分是第3题。不能同时做两部分，必须先提交一边，才能开始另一边。所以要安排好时间。\n\n算法题提前准备，刷leetcode常见题型，熟悉你所使用的语言的常用字符串操作。还有推荐看CSDN上的华为题库（有可能会考到原题），感谢hr栗栗提供的笔试资料，非常有用。\n\n1、模拟队列\n\n题目比较长。提供n个执行者和m个任务，一个队列，给出每个任务的入队时刻和所需执行时间。如果队列满了，抛弃掉队列里最老的任务。执行者一旦空闲就会去队列里去最老的任务。当队列满的时候，如果同一时刻既有任务完成又有任务入队。则先从队列取出最老的任务，再将新任务入队。\n\n输出最后结束的时刻和被抛弃的任务数量。对所有输入的时刻t，都有1<=t<=1000\n\n个人思路是 遍历1-1000时刻模拟过程，代码比较复杂。最后通过90%\n\n2、射箭比赛，每个选手有编号，每个选手射箭若干次，将每个选手的成绩取出最好的3个累加即为该选手的最终成绩，如果选手射箭成绩小于3次不统计该选手成绩。将选手最终成绩降序排列，输出选手编号。若成绩相同，编号大的排在前面。\n\n输入三行，第一行一个整数，代表所有射箭次数； 第两行，依次给出每次射箭的选手编号；第三行，依次给出每次射箭的成绩。\n\n简单题，统计并排序就行了。最后通过100%\n\n3、leetcode原题 402. 移掉 K 位数字 题目描述基本相同\n\n华为od题库原题 https://renjie.blog.csdn.net/article/details/130792891\n\n给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。\n\n例如 num=\"2615371\"，k=4， 最后输出 131。\n\n思路: 自己在草稿纸上从简单的情况模拟，来找到规律。\n\n规律如下：每次删除第一个满足str[i] > str[i+1]的下标i，重复N次。\n\n如 2615371 -> 215371 -> 15371 -> 1371 -> 131\n\n如果某次遍历如果没找到 i，那就是删除最后一个。\n\n最后输出的时候注意删除前缀0。\n\n可以用stack堆栈优化，只用一次遍历。\n\n最后通过100%（没用stack堆栈优化也全通过了）\n\n  * **二、技术一面**\n\n先是自我介绍+项目经历，项目这部分提前准备好怎么讲，想好可能会被问的问题。会根据你的项目提问，所以可以一定程度上诱导面试官问向你擅长的方向。\n\n项目问完后是几道常规前端基础知识\n\n了解原型链吗？怎么创建一个没有原型的对象\n\n通过new创建一个对象的过程\n\ncss问题，高度坍塌原因和解决方式\n\nsessionStorage和localStorage的区别，存储大小限制多少？\n\n什么是闭包？闭包的用途？\n\n……\n\n最后是算法题（要在本地ide上写并运行，提前准备好环境）：*************************************************\n每日温度\n\n  * **三、技术二面**\n\n同样自我介绍+项目经历，项目环节特意提了让我讲遇到的难点。然后是八股文问前端面试常规问题，如\n\n前端安全问题XSS和CSRF\n\n防抖节流,定义以及使用场景\n\n列举几个排序算法（追问了从一堆数中多次取出最大值的方法（最大堆），可能是因为我说到了堆排序）\n\n……\n\n最后也有一道算法题，非常简单，青蛙跳台阶***************************************************************\n\n  *  **四、技术三面（前2轮定级不一致，加面一轮技术面试）**\n\n由于一二面面评不一致我还需要加面，还是一样讲项目问项目，然后是八股文问前端面试常规问题\n\n前端性能优化，几个指标，performance\n\n前端跨域请求问题，项目中遇到的如何解决\n\njs事件循环，宏任务微任务\n\n因为我是科班，有问我js中对象/map的存储原理之类的\n\ngit操作，问了开发期间其他人有提交过代码，自己合入要怎么操作，我自己答了git rebase解决冲突后合入。然后还问了git\nrebase的其他用法。（这题按自己正常开发使用git方式答即可）\n\n……\n\n最后算法题是比较简单的动态规划题，******************************************* 不同路径\n\n技术面试总结：大部分时间是在 1、讲项目和根据你所讲的项目提问相关前端问题，也就是抓着项目问问题 2、做算法题。\n而这两块都是能提前多做准备的，尽可能地充分准备好。3、栗栗在综测后会给你发技术面试攻略，可以参考下\n\n  * **hr面：**\n\n自我介绍\n\n上一份工作的经历/做的项目内容、自己的职责\n\n工作地选择的原因\n\n为什么选择来华为\n\n加班情况\n\n离职原因\n\n期望薪资等\n\n  * **主管面：**\n\n电话面，普通聊聊，比较随和\n\n当前情况\n\n换工作原因\n\n上家公司工作内容，团队人数，承担角色\n\n我作为前端的工作研发流程（或者说一次需求流程）、自动化手段、交付节奏、代码重构\n\n为什么从事前端\n\n团队协作代码code review怎么做的\n\n聊了些对angularjs、vue、react等一些想法\n\n平时怎么学习、算法怎么准备的\n\n反问\n\n  * **总结**\n\n最后就是全部面试通过后等审批环节和发offer后准备材料了。要十分感谢hr栗栗的帮助，从头到尾持续帮我去催进度，最后也也如愿以偿的快速收到offer。所以如果对华为\nod\n感兴趣的欢迎来找她！他会根据你的技术栈，个人兴趣等给你推荐，让部门和你电话沟通再决定是否开始面试，不会盲推。很好的HR，也很好说话，很温柔，回复不及时还会和你说抱歉的那种。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598216400339070976?sourceSSR=users",
        "title": "英雄游戏—社区运营1面（校招）",
        "content": "昨天11点钟面试的英雄互娱的社区运营，我真的很喜欢这家公司，腾讯之后就是互娱了，互娱面试也很简单轻松，hr小姐姐真的很漂亮，声音也好听，就是不知道过没过，也感觉不出来！\n\n1、 自我介绍\n\n2、 为什么想做运营\n\n3、 如果某游戏出了一个非常nb的道具，怎么宣传，让用户共鸣\n\n4、 经常使用哪些游戏社区app\n\n5、 我们的产品你最了解哪款？\n\n6、 平时喜欢玩什么类型的游戏，大概总时长，大概消费\n\n7、 那段实习学习到的东西最多\n\n8、 实习到现在的感悟是什么？\n\n9、 从学生到职场人的身份转换我用了多久（第一次听到这个问题）\n\n10、 觉得自己有哪些缺点优点。\n\n反问我就不写了，无非就是入职后我能得到什么，啥时候二面。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598215467999805440?sourceSSR=users",
        "title": "阿里-淘天 校招offer 面经/时间线",
        "content": "8.17开\n\n9.4内推投 java-淘宝买菜（具体组信息已隐去 可私）\n\n9.9北森测评+笔试\n\n##### 9.12 一面\n\n40min\n\n  * 绩点、排名\n  * 实习留用情况怎么样（面试官：我们部门本科生机会很大）\n  * 实习时候prompt engineer做了吗\n  * 实习（细节、难题、技术选型）\n  * http1.1 2.0区别\n  * java的线程池\n  * java的栈在内存的哪个位置，栈和堆的区别\n  * Jit aot区别（aot不会）\n  * 虚拟机的垃圾回收有哪些方法\n  * 进程突然挂掉怎么办（不会）\n  * oom怎么办\n  * spring里一个bean的生命周期\n  * ioc依赖注入有哪些方法\n  * 用过哪些redis数据结构\n  * redis缓存一致性问题\n  * redis击穿和穿透\n  * cap原理和base理论\n\n不会的问题面试官会解答，面试体验很好\n\n##### 9.14 二面\n\n40min\n\n  * 不考研吗\n  * 实习留用情况\n  * 面了哪些公司 offer情况\n  * 实习（项目架构、应用场景、核心问题、业务价值）\n  * 项目（核心问题、技术设计优缺点）\n  * cap理论\n  * mysql索引结构 b+树有什么缺点\n  * 建索引的坏处\n  * 怎么排查索引的问题 索引调优\n  * 单表达到什么规模要分表\n  * mysql日志系统\n  * 队列中间件有看过底层源码吗\n  * 队列的生产消费要注意什么问题\n  * rpc框架比较熟悉哪个 grpc 连接数受什么限制\n  * tcp连接有哪些状态\n  * 用什么命令看网络状态 看磁盘状态\n  * java方面看过哪些书\n  * 自己技术的优点\n  * 关注哪些新技术\n\n##### 9.14 hr面\n\n40min\n\n  * 实习怎么没来阿里 这期间加强了哪些准备\n  * 实习（职责、难点、导师给你指导多少 问的很细、有什么新的认知、业务发展情况、意义、为什么不留用）\n  * 作为技术同学怎么跟业务同学沟通 有分歧的情况吗 怎么解决\n  * 对实习公司的看法 \n  * 导师怎么评价你\n  * 通过什么途径去学习\n  * 在校成绩\n  * 兴趣爱好 哪个最精通\n  * 人生的最大挫折\n\n反问：\n\n  * 考查思考、潜力、技术热情、团队协作\n\n面试体验都很好\n\n##### 9.18 意向\n\n说10月底开奖\n\n11月底催了给p4白菜 意向不大\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598198524030853120?sourceSSR=users",
        "title": "思特奇 产品经理面经",
        "content": "面试官本来两个人，另外一个人有事没来\n\n1、产品经理岗位的职责\n\n2、拿到一个任务怎么做\n\n3、什么是伪需求\n\n4、客户要求你适配所有品牌的手机是否是伪需求\n\n5、你认为产品经理的三大能力\n\n6、最近看的书\n\n7、感悟\n\n8、职业规划\n\n9、给领导或者老师汇报成果时，怎么汇报\n\n10、说一个你自己的项目\n\n11、向别人推销这个项目\n\n.................\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598191425129410560?sourceSSR=users",
        "title": "腾讯 广告工程部 一面",
        "content": "  1. 自我介绍（学历->实习->项目）2min\n  2. 介绍实习内容（粗略了解了一下部门做的事情）8min\n  3. c++\n  4. 介绍一下vector\n  5. 初始化的vector中的元素是存放在堆上还是栈上\n  6. 连续push1000个元素会发生什么\n  7. 网络\n  8. 介绍一下DNS过程，递归/迭代\n  9. 做题\n  10. 压缩字符串：abbccc->a1b2c3\n  11. 反问\n  12. 面试官说部门主要写c++，需要c++基础过硬（应该要求蛮高的）\n\n全程30min，感觉问得过于简单了，是不是kpi了（anyway面试官态度很好）\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598190177395261440?sourceSSR=users",
        "title": "腾讯云一面20min",
        "content": "面试官人很不错，但是很快就结束了，不知道是不是KPI[笑cry]\n\n### 1：自我介绍\n\n### 2：拷打项目\n\n团队合作是怎么进行的？答了后端从微信->svn ，前后端从微信->swagger->部署服务器的流程\n\n### 3：数据库表参与设计了吗？怎么设计的\n\n### 4：谈谈对数据库事务的理解\n\n### 5：Redis在项目中是怎么用的？用来干什么？\n\n### 6: 是怎么进行学习的\n\n### 7：对职业生涯的规划\n\n因为问的比较简单，自认为答的还算完整和具体[笑cry]，面试官也说了解的比较好，但是一会就结束，看了其他uu们的一面感觉比我难多了[牛泪]。我这是KPI吗\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598189090026156032?sourceSSR=users",
        "title": "企业微信团队前端一面",
        "content": "感受：  \n  \n1.八股喜欢往底层问。比如我提到项目中使用的某某插件，紧接着就问我这个插件的底层实现原理，你能不能自己写一个这样的插件；我提到vue-\nrouter，紧接着就问能不能自己用JS实现vue-router的功能  \n  \n2.算法题不难，可能是八股答的太烂了想打发我快点走人😢  \n  \n![](https://uploadfiles.nowcoder.com/message_images/20240315/550678068_1710491266660/discuss_1710491266275.jpeg)  \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598188860039872512?sourceSSR=users",
        "title": "游戏测试 - 二面 - 创梦天地二面",
        "content": "**24.3.6 Boss直聘**\n\n**2024.3.13 面试**\n\n**2024.3.14 电话通知约第二轮面试**\n\n**2024.3.16 二面**\n\n自我介绍\n\n自己有接触过游戏开发么\n\n有玩过什么游戏\n\n有玩过FPS或GPS类，射击类游戏么\n\n讲一下你在校内这个创新平台的具体工作\n\n讲下日常比赛项目组的组内分工，是如何协调\n\nPPT和文档是具体写了哪些\n\nPPT美化具体是指\n\n测试有接触过哪些\n\n**针对QQ登录界面，具体讲一下如何测试**\n\n**针对该界面输入端，有哪些需要测试**\n\n未来的职业规划讲讲\n\n大概什么时候能够到岗\n\n目前是在什么地方\n\n反问环节\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598180198827270144?sourceSSR=users",
        "title": "3/15东方海外 校招宣讲会笔试",
        "content": "一共四道题，语言不限  \n  \n第一道简单算法，翻转句子里面的单词，没有时间复杂度要求  \n  \n第二道给你一个json格式的departs数据，里面存储了部门名和部门人数。departs中还能存departs  \n问题1 能否设计一种数据结构存储departs  \n问题2 根据输入的部门名，输出最后这个部门有多少人  \n  \n第三道3道多表sql查询，最后一道是查询平均分最高的学生学号和名字  \n  \n第四道 给你一个java程序，找错+运用oop思想提高这段代码的可重用性  \n  \n吐槽下约等于没监考，手机随便用的，虽然我没用\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598173603888230400?sourceSSR=users",
        "title": "WXG一面凉经",
        "content": "# 一面\n\n先两道算法题（三十分钟），再问项目，根据项目具体内容提问八股（二十分钟）。被狠狠拷打，水货原型毕露，不过面试官非常的好，对答不出来的也会加以引导。\n\n以下回答如有错误，请各位大佬点点😭\n\n# 算法题\n\n面试官说哪个语言写都可以，但是我C++有点忘了，换的Java写的。\n\n  * 子集 - 力扣78（LeetCode） [******](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fsubsets%2Fdescription%2F)\n\n直接dfs暴搜\n\n  * 找到两个串的最长公共子串，若多个任意一个均可\n\nLCS典题。一开始二分想假了，然后直接dp秒了，这里先写的二维dp，跟面试官说可以滚动掉一维，然后演示了一下。\n\n# 项目和八股\n\n  1. 介绍项目内容，设计是怎么样的？这套系统如何考虑设计的，从技术实现上来描述一下，比如涉及到的服务、模块、功能、层次？\n\n没条例性地胡扯，想到什么说什么\n\n     * 比如如何设计后台接收用户请求？\n\n先通过Nginx转发请求，然后进行身份鉴权，最后才到我们的Controller\n\n     * 这里Nginx转发的作用？\n\n一是反向代理，隐藏真实的服务器地址，将请求转发到上游服务器；二是负载均衡，缓解服务器压力\n\n     * 负载均衡的方式？\n\n轮询、响应时间、权重、随机、区域\n\n  2. 项目是怎么实现的，用了什么框架？\n\n主要是主流框架SpringBoot、MyBatis，没用中间件\n\n     * 你指的中间件是什么？\n\nRabbitMQ、Gateway\n\n     * Gateway是做什么的？\n\n负载均衡、反向代理、请求拦截\n\n  3. 服务直接连的数据库吗？\n\n使用了Redis缓存，先查缓存再查数据库\n\n     * 缓存更新策略\n\n主动更新 + 延时删除，以保证数据一致性\n\n     * 假如数据库更新成功，但是Redis因为延迟等原因更新失败，你想保证两者保证“事务性”，即同时成功同时失败，该如何处理？\n\n不知道\n\n> 延时双删：先删除缓存，然后更新数据库，延时一段时间，然后再次删除缓存。\n> [******](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Ftongkongyu%2Farticle%2Fdetails%2F124861732)\n>\n>\n> 消息队列：数据库更新成功后，将更新操作放入消息队列，由另一个服务消费消息并更新缓存。[******](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F437203229)\n\n     * Redis缓存存在的问题？\n\n缓存穿透、缓存击穿、缓存雪崩，讲了其各自的原因和解决方法\n\n     * 你说解决缓存击穿使用互斥锁，但那些未拿到互斥锁的线程等待时间过长，查询过程就变成串行了，怎么解决？\n\n不知道\n\n> 反问时，面试官回答的答案：\n>\n>\n> 一种解决方案是请求合并。对于请求相同key的线程，只让一个线程去查询数据库，其他线程等待这个线程的查询结果。这样可以避免多个线程同时查询数据库，减少数据库的压力。这种方案在Go语言中的GroupCache库中有实现。\n>\n> 另一种解决方案是使用限流。对于请求频率过高的key，可以限制其请求频率，超过限制的请求直接返回异常，而不是等待。\n\n     * 访问Redis使用TCP还是UDP？\n\n不知道\n\n> 来自ai的回答：\n>\n> Redis使用TCP协议进行通信。TCP（Transmission Control\n> Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议，它能确保数据在网络中的可靠传输。相比之下，UDP（User Datagram\n> Protocol）是一种无连接的协议，它不保证数据的可靠传输。由于Redis需要确保数据的可靠传输，所以选择了TCP协议。\n\n     * TCP与UDP的区别？\n\n忘了，寄，八股没背熟\n\n     * WebSocket使用TCP还是UDP？\n\n不知道，然后瞎吹。因为WebSocket需要保证数据的安全稳定，比如TCP对丢失的数据包会有超时重传的等方式以保证数据稳定。\n\n> 来自ai的回答，同理Redis。\n\n## 反问\n\n  * 问了实际是如何解决缓存击穿、缓存雪崩\n\n  * 我存在的问题和不足\n\n题目做的还不错，认为与你参加比赛的经历有关。\n\n但在项目实施上，没有深入思考和探索其中的问题，只是完成了一些基本功能。深入学习和理解使用的技术和框架，例如Spring Boot，理解其内部运行机制。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598172446541324288?sourceSSR=users",
        "title": "腾讯春招后端一面（算法篇）",
        "content": "# 前言：\n\n哈喽大家好，前段时间发了面试的经验贴，很多同学留言问算法的具体解法，今天就详细写个帖子回复大家。\n\n因为csdn是写的比较详细，所以更新比较慢，大家见谅~~\n\n就题目而言，前两题是平时刷题常见的，第三题没有见过，需要认真思考下\n\n最后，希望找工作的同学都能收获心仪的offer\n\n# 求两个数的最大公约数\n\n这道题没有找到原题链接，找到一个近似的题目\n\n> 给你一个整数数组 nums ，返回数组中最大数和最小数的 最大公约数 。\n>\n> 两个数的 最大公约数 是能够被两个数整除的最大正整数。\n\n思路\n\n> 辗转相除法原理：\n>\n> 两个整数的最大公约数等于其中较小的数和两数相除余数的最大公约数。\n>\n> 例如：欲求252和105的最大公约数；因为\n> 252÷105=2...42，所以这个最大公约数也是42与105的最大公约数(42=21×2)。在这个过程中，较大的数缩小了，所以继续进行同样的计算可以不断缩小这两个数直至余数为零。这时，所剩下的还没有变成零的数就是两数的最大公约数。\n\n我们将上述过程翻译成递归代码，得到如下代码：\n\n    \n    \n        def findGCD(self, nums: List[int]) -> int:\n            def gcd(x,y):\n                if x>y:\n                    x,y = y,x\n                if x==0:return y\n                return gcd(y%x,x)\n            \n            return gcd(max(nums),min(nums))\n    \n\n# lru缓存\n\n> 请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。\n>\n> 实现 LRUCache 类：\n>\n> LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字\n> key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字 key\n> 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该\n> 逐出 最久未使用的关键字。 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。\n\n思路\n\n> 我这里用列表模拟队列，用字典实现缓存，设计了总容量，当前元素数等变量进行模拟\n    \n    \n        def __init__(self, capacity: int):\n            self.capacity = capacity\n            self.cnt = 0\n            self.queue = []\n            self.dic = defaultdict(int)\n     \n        def get(self, key: int) -> int:\n            if key not in self.dic:\n                return -1\n            del self.queue[self.queue.index(key)]\n            self.queue.append(key)\n            # print(self.queue)\n            return self.dic[key] \n     \n        def put(self, key: int, value: int) -> None:\n            if key in self.dic:\n                del self.queue[self.queue.index(key)]\n                self.queue.append(key)\n                self.dic[key] = value\n     \n            elif self.cnt < self.capacity:\n                self.queue.append(key)\n                self.dic[key] = value\n                self.cnt+=1\n            else:\n                del self.dic[self.queue[0]]\n                del self.queue[0]\n                self.queue.append(key)\n                self.dic[key] = value\n    \n\n# 最长字符串链\n\n> 给出一个单词数组 words ，其中每个单词都由小写英文字母组成。\n>\n> 如果我们可以 不改变其他字符的顺序 ，在 wordA 的任何地方添加 恰好一个 字母使其变成 wordB ，那么我们认为 wordA 是 wordB 的\n> 前身 。\n>\n> 例如，\"abc\" 是 \"abac\" 的 前身 ，而 \"cba\" 不是 \"bcad\" 的 前身 词链是单词 [word_1, word_2, ...,\n> word_k] 组成的序列，k >= 1，其中 word1 是 word2 的前身，word2 是 word3 的前身，依此类推。一个单词通常是 k\n> == 1 的 单词链 。\n>\n> 从给定单词列表 words 中选择单词组成词链，返回 词链的 最长可能长度\n\n思路\n\n> 这道题是这三道中我唯一没有见过的题，但面试中遇到没见过的题也蛮正常的，不要慌，放心做即可。\n>\n> 我们对每一个字符串进行查找，比如\n> abfd，我们检查bfd,afd,abd,abf这四个字符串在不在words数组中，如果不在就return，否则继续查找，保存最长的链条。\n>\n>\n> 这道题中，我在dfs函数上加了缓存，存储一些已经计算的点，使用tuple()是因为列表无法被哈希话，所以把它转为元组。题解中有很多更好的写法，读者可以多去学习\n    \n    \n        def longestStrChain(self, words: List[str]) -> int:\n            global cnt\n            cnt = 0\n            words = tuple(words)\n            @cache\n            def dfs(w,words,length):\n                if w not in words:\n                    global cnt\n                    cnt = max(cnt,length)\n                    return\n                n = len(w)\n                for i in range(n):\n                    temp = w\n                    w = w[0:i] + w[i+1:]\n                    dfs(w,words,length+1)\n                    w = temp\n            for w in words:\n                dfs(w,words,0)\n            return cnt\n    \n    \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598164685745102848?sourceSSR=users",
        "title": "大疆机械结构实习生凉经",
        "content": "昨天参加了好几场面试，脑子乱糟糟的，很多都没发挥好，估计很多都凉了！我一一分享！\n\n大疆的结构实习生hr，鸽了我一周，今天理我了，约的昨天下午两点的面试然后约的时间重复了，着急忙慌的改面试时间。\n\n现在来分享了大疆机械结构实习生的凉经了！\n\n1、 自我介绍\n\n2、 我对大疆的刻板印象（问住我了，无人机不是嘛！）\n\n3、 看你实习都是互联网的公司，是不是更倾向去互联网\n\n4、 你觉得你可以大疆收获什么？\n\n5、 非常简单的介绍了我面试的实习岗位要跟进的项目\n\n6、 了解项目\n\n7、 项目跟进难度、项目难点\n\n8、 项目中需要用到哪些材料，哪些技术\n\n9、 我是否具备这么技术\n\n10、 生活中我比较感兴趣的机械结构，\n\n11、 你认为这些结构中有哪些机械之美\n\n12、 你认为自己的技术水平如何？\n\n13、 如果入职会不会从北京来深圳\n\n今天上午收到不合适的邮箱了，意料之中，面试大疆感觉都是干货，尤其是hr介绍自己公司时候总感觉非常自信，大疆给的实习生薪资也是非常高，介绍项目的时候怕我不懂还会问我理解吧！不过我的确听的云里雾里的，我的确是菜鸡，跟大疆这种靠实力说话的公司没有缘分，不过hr人很好，很不错的体验。本人瑕疵过多，机械水军！\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598156053498404864?sourceSSR=users",
        "title": "ARM/Linux嵌入式面经（六）：华为",
        "content": "![](https://img0.baidu.com/it/u=48021080,725072559&fm=253&fmt=auto&app=120&f=JPEG?w=1601&h=500)\n\n> 面试一共四面，面试岗位为嵌入式工程师。华为的面试官本次体验还是蛮好的，技术强，也比较温柔。下面开始进入正题吧~~~\n\n# 【一面】资格面\n\n主要是问了有以下几点：\n\n  * 简历\n\n好奇我的专业，然后问我学过哪些学科。\n\n  * 项目\n\n当时抓我的项目，一个无线传感器网络的项目。没有问技术，主要问了：\n\n    \n    \n    + 做了多久\n    + 在项目中处于什么角色，负责哪部分的工作。\n    + 遇到了什么困难？\n    \n\n  * 规划\n\n问了职业规划\n\n  * 家庭\n\n家庭成员，哪里人，打算在哪里定居。\n\n  * 你在网上看到过华为od的负面消息吗，你什么想法？\n\n不怎么了解，平时不怎么八卦，规避了这个问题。\n\n> 其实这里更好的时候发表一些客观正向的评价，不表现的我谄媚，但是我也不直言。\n\n> 关于面试中很主观的问题，后面我会写两篇专门讲简历项目和HR面加入本专栏。再找几个案列，梳理成模版，让你一次性搞定。这里先行跳过。\n\n# 【二面】技术面\n\n    \n    \n    # 自我介绍\n    # 介绍项目\n    # 全都是自己从零开始构建的吗, 软件硬件\n    # 软件算法, 视觉有用到分割吗, 介绍一下\n    # 项目中遇到什么困难, 队友他们怎么分工\n    # 遇到了新的东西时怎么去学习\n    # 学的什么专业课, 有学过操作系统,数据结构与算法,计组原理这种么\n    # 系统里用到了什么数据结构\n    \n\n> 这些都是有好用的模版的，等我统一给你整一个~~~\n\n# 裸机中断会同时发生怎么办\n\n## 知识\n\n**裸机中断是指在没有操作系统支持的情况下**\n，直接由硬件产生的中断。当两个或更多的中断同时发生时，裸机系统需**要有一种机制来处理这种情况，以确保系统的稳定性和数据的一致性** 。\n\n处理裸机中断同时发生的情况，通常涉及**中断优先级的管理和中断服务程序的编写** 。以下是一些常见的处理方法：\n\n  * 中断优先级管理：裸机系统通常会为每个中断分配一个优先级。当中断同时发生时，系统会首先响应优先级最高的中断。这通常通过硬件中断控制器实现，该控制器能够检测并排序多个同时发生的中断。\n  * 中断嵌套：在某些情况下，一个中断服务程序可能在处理过程中被另一个更高优先级的中断打断。这称为中断嵌套。系统需要能够保存当前中断的上下文，以便在处理完高优先级中断后能够恢复并继续处理低优先级中断。\n  * 中断屏蔽：为了避免中断之间的冲突，系统可以使用中断屏蔽技术来暂时禁用某些中断。这通常是在处理一个关键任务时使用的，以确保该任务不会被其他中断打断。\n  * 中断服务程序的设计：编写中断服务程序时，需要特别注意其执行时间和对系统资源的使用。长时间运行或消耗大量资源的中断服务程序可能会导致系统响应变慢或出现其他问题。\n  * 软件同步机制：在某些情况下，可能需要使用软件同步机制（如信号量、互斥锁等）来确保在中断处理过程中数据的一致性和完整性。\n\n需要注意的是，裸机中断处理通常与具体的硬件平台和处理器架构密切相关。**因此，在设计裸机中断处理机制时，需要深入了解目标硬件的中断特性和处理器架构。**\n\n最后，对于复杂的裸机系统，可能需要考虑使用更高级的中断管理策略，如中断向量表、中断服务例程表等，以更好地管理和处理多个同时发生的中断。\n\n## 回答\n\n当面试官问到裸机中断可能同时发生时，你可以按照以下步骤来回答：\n\n  * 首先，你可以简要解释一下裸机中断的基本概念。裸机中断是指在没有操作系统支持的情况下，硬件直接对CPU发出中断请求，CPU在接收到中断请求后会暂停当前正在执行的程序，转而处理中断服务程序。\n\n  * 接下来，针对中断可能同时发生的情况，你可以强调中断优先级的概念。在系统中，不同的中断源通常会被赋予不同的优先级，以便在多个中断同时发生时，CPU能够按照优先级顺序来处理它们。你可以解释，通过设置中断优先级，可以确保关键的中断请求得到优先处理，避免系统崩溃或数据丢失等问题。\n\n  * 然后，你可以提及中断嵌套的概念。在某些情况下，即使设置了中断优先级，也可能出现高优先级中断在处理过程中被更低优先级中断打断的情况，这就是中断嵌套。你可以解释，中断嵌套机制允许CPU在处理一个中断的同时，响应另一个更高优先级的中断请求，提高了系统的响应速度和灵活性。\n\n  * 此外，你还可以提到中断屏蔽的概念。在某些情况下，为了避免中断的干扰，可以使用中断屏蔽技术来暂时屏蔽某些中断源。这可以在关键代码段执行时确保不受中断的干扰，提高系统的稳定性和可靠性。\n\n  * 最后，你可以强调在实际应用中，需要根据系统的具体需求和硬件特性来合理设计和配置中断处理机制。这包括选择适当的中断优先级、使用中断嵌套和中断屏蔽等技术来确保系统的正常运行和高效响应。\n\n  * 总之，在回答面试官关于裸机中断可能同时发生的问题时，你可以从**中断优先级、中断嵌套、中断屏蔽等方面来阐述你的理解和解决方案** 。同时，结合实际应用中的需求和硬件特性进行具体分析，展示你的专业素养和实践能力。\n\n# 中断处理不完怎么办\n\n> 当面试官询问关于中断处理不完的情况时，他们可能想了解你对系统稳定性、性能优化以及异常处理的理解。以下是一个建议的回答框架：\n\n当面临中断处理不完的情况时，我会首先分析原因，并尝试从以下几个方面进行解决：\n\n  * 优化中断处理流程：我会仔细审查中断处理代码，查找是否存在可以优化的地方，比如减少不必要的操作、使用更高效的数据结构或算法。通过优化代码，可以提高中断处理的效率，减少处理时间。\n\n  * 提高系统性能：如果中断处理不完是因为系统性能不足，我会考虑提升硬件性能，比如使用更高主频的CPU、增加内存等。同时，我也会检查系统配置，确保系统资源得到合理分配，避免资源浪费。\n\n  * 优先级管理：对于不同优先级的中断，我会实施优先级管理策略。高优先级的中断应该得到优先处理，以确保关键任务能够及时响应。对于低优先级的中断，可以考虑采用延迟处理或合并处理的方式，以减轻系统负担。\n\n  * 中断合并与去抖：在某些情况下，可以通过中断合并和去抖技术来减少中断的数量。合并多个相似的中断可以减少处理次数，而去抖技术则可以消除由于噪声或误触导致的频繁中断。\n\n  * 使用中断线程化：如果硬件和操作系统支持，我可以考虑使用中断线程化技术。通过为中断分配专门的线程来处理，可以充分利用多核处理器的优势，提高中断处理的并行度。\n\n  * 监控与日志分析：我会建立有效的监控机制，实时观察中断处理情况。同时，通过日志分析，可以定位到中断处理中的瓶颈和问题，从而进行有针对性的优化。\n\n> 有时候可能答案是错误的，但是面试官在乎的是你结构性的思考力。逻辑、思路与知识作伴。\n\n# 讲讲MMU了解吗？\n\n当面试官问你是否了解MMU（Memory Management Unit，内存管理单元）时，你可以按照以下结构来回答：\n\n## 简要介绍MMU：\n\nMMU是计算机系统中的硬件单元，**负责处理内存访问请求**\n，**包括虚拟地址到物理地址的转换、内存保护（防止一个进程访问另一个进程的内存）、内存分页或分段等功能。**\n\n## MMU的作用：\n\n解释MMU如何帮助操作系统实现虚拟内存管理，**使每个进程拥有独立的地址空间。**\n\n讲述MMU如何通过地址转换机制，**使得有限的物理内存能够被多个进程有效利用。**\n\n提到MMU对于提高系统安全性和稳定性的重要性，**如防止非法内存访问。 MMU与操作系统、CPU的关系：**\n\n解释MMU是如何与操作系统和CPU协同工作的。**操作系统负责内存管理的策略和调度，而MMU则负责执行这些策略，将虚拟地址转换为物理地址** 。\n提到MMU是现代CPU架构中的一部分，对于实现高级内存管理功能至关重要。\n\n## 你对MMU的深入了解：\n\n如果你对MMU有深入的了解，可以谈论一些具体的实现细节，如**页表结构、TLB（Translation Lookaside\nBuffer，转换后备缓冲器）的作用、内存保护机制等。**\n\n如果你在项目或学习中涉及到过MMU的使用或配置，可以分享相关经验和见解。\n\n## 你对MMU的学习态度：\n\n如果面试官的问题超出了你的现有知识范围，你可以表达你对学习新知识的积极态度，并承诺在需要时会深入研究相关内容。\n\n> 记住，如果不知道，可以稍作思考，大胆承认自己暂时不了解，表示自己下去一定好好补习一下。记住不要让空气突然的安静~~~\n\n下面是一个示例回答：\n\n“我对MMU有一定的了解。MMU是计算机系统中的关键硬件组件，它负责处理内存访问请求，特别是虚拟地址到物理地址的转换。通过MMU，操作系统能够实现虚拟内存管理，为每个进程提供独立的地址空间，从而提高内存的利用率和系统的安全性。\n\nMMU与操作系统和CPU紧密协作，操作系统负责内存管理的策略和调度，而MMU则负责执行这些策略。在现代CPU架构中，MMU扮演着至关重要的角色，它使得高级内存管理功能得以实现。\n\n回答至此，如果你很了解MMU，继续讲一个细节点。\n\n如果不熟，那么下面可以作为你的结尾：\n\n我对MMU的具体实现细节还需要进一步学习，但我非常愿意投入时间和精力去深入了解它。我相信通过不断学习和实践，我能够掌握MMU的相关知识，并将其应用到实际工作中。”\n\n这样的回答既展示了**你对MMU的基本了解，又表达了你愿意学习和成长的积极态度。**\n\n# 有没有做过linux驱动开发？\n\n这个问题我觉得只有两种回答：\n\n  * 一：如果你确实有Linux驱动开发的经验\n\n你可以这样说：“是的，我有过Linux驱动开发的经验。在之前的项目中，我负责开发了XXX设备的驱动程序，并成功将其集成到了Linux内核中。我熟悉Linux内核的架构和工作原理，能够熟练使用内核提供的API进行驱动开发。同时，我也具备调试和优化驱动性能的能力，确保驱动的稳定性和高效性。”\n\n  * 二：如果你没有Linux驱动开发的经验，但有相关的技能或兴趣\n\n你可以这样回答：“虽然我没有直接做过Linux驱动开发，但我对Linux系统有一定的了解，熟悉C语言和操作系统原理。我对驱动开发非常感兴趣，并且愿意投入时间和精力去学习相关知识。我相信，凭借我的学习能力和对技术的热情，我能够迅速掌握Linux驱动开发的技能。”\n\n>   * 如果你是第一个，那你就正常表达回忆之前的经历就好。（建议做嵌入式可以找个小项目练练手）\n>   * 如果你是第二个，就表达自己虽然没有做过，但是会什么相关的知识，表达你做驱动开发也有先天的优势。同时也把面试官引向了你擅长的空间，岂不美哉。\n>\n\n# 手撕算法两道\n\n## 两数之和\n\n**解题思路：** 题目：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n**示例:** 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n\n    \n    \n    int* twoSum(int* nums, int numsSize, int target) {\n        int i,j;\n        int *result=NULL;\n        for(i=0;i<numsSize-1;i++)\n        {\n            for(j=i+1;j<numsSize;j++)\n            {\n                if(nums[i]+nums[j]==target)\n                {\n                     result=(int*)malloc(sizeof(int)*2);\n                     result[0]=i;\n                     result[1]=j;\n                     return result;\n                }\n            }\n        }\n        return result;\n    }\n    \n    \n\n## 两数相加\n\n给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n    \n    \n    struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) {\n        struct ListNode *head = NULL, *tail = NULL;\n        int carry = 0;\n        while (l1 || l2) {\n            int n1 = l1 ? l1->val : 0;\n            int n2 = l2 ? l2->val : 0;\n            int sum = n1 + n2 + carry;\n            if (!head) {\n                head = tail = malloc(sizeof(struct ListNode));\n                tail->val = sum % 10;\n                tail->next = NULL;\n            } else {\n                tail->next = malloc(sizeof(struct ListNode));\n                tail->next->val = sum % 10;\n                tail = tail->next;\n                tail->next = NULL;\n            }\n            carry = sum / 10;\n            if (l1) {\n                l1 = l1->next;\n            }\n            if (l2) {\n                l2 = l2->next;\n            }\n        }\n        if (carry > 0) {\n            tail->next = malloc(sizeof(struct ListNode));\n            tail->next->val = carry;\n            tail->next->next = NULL;\n        }\n        return head;\n    }\n    \n\n# 【三面】 交叉面\n\n    \n    \n    # 专业课有哪些\n    # 竞赛\n    # 实习的企业没留下转正吗, 毕业后实习的?\n    # 有没有总结过技术栈, 优势有哪些, 哪块技术更深\n    # mcu用过哪些型号\n    # mcu用过的外设\n    # 项目xx展开介绍一下\n    # xx用到哪些第三方软件\n    # 多大队伍\n    # 有没有用到OpenCV\n    # 为什么要用神经网络, 有什么好处呢\n    # 训练在哪做的\n    # 实习项目做的也都是mcu的开发吗\n    # 感觉对Linux开发感觉怎么样\n    \n\n# 裸跑还是有RTOS, 你觉得有啥区别\n\n当面试官询问裸跑（裸机运行）与RTOS（实时操作系统）之间的区别时，可以从以下几个方面进行回答：\n\n## 资源占用与性能：\n\n  * 裸跑：裸机运行意味着应用程序直接运行在硬件之上，没有操作系统的介入。这种方式资源占用非常低，因为无需为操作系统分配内存或处理时间。因此，它通常能够提供更好的实时性能和更高的效率。\n  * RTOS：实时操作系统为应用程序提供了一套丰富的功能和服务，如任务调度、内存管理、中断处理等。这些功能虽然方便，但也占用了一定的系统资源。RTOS的性能通常低于裸机运行，但其在复杂性和可维护性方面提供了显著的优势。\n\n## 任务管理与调度：\n\n  * 裸跑：在裸机环境中，任务的管理和调度通常需要程序员手动实现。这增加了开发的复杂性和工作量，但对于一些简单的应用来说可能足够。\n  * RTOS：RTOS提供了任务调度和管理的机制，使得开发者可以更容易地创建多任务应用。它支持任务的优先级调度、时间片轮转等策略，有助于确保实时任务的执行。\n\n## 开发与维护：\n\n  * 裸跑：裸机开发通常更底层，需要开发者对硬件有更深入的了解。维护和调试也可能更加困难，因为缺乏高级别的抽象和工具支持。\n  * RTOS：RTOS提供了一套丰富的API和工具，使得开发更加便捷。同时，由于RTOS的标准化和模块化设计，维护和升级也变得更加容易。\n\n## 应用场景：\n\n  * 裸跑：通常适用于资源受限、对性能要求极高的场景，如一些嵌入式系统或微控制器应用。\n  * RTOS：适用于需要多任务处理、复杂功能且对实时性有一定要求的场景，如工业自动化、医疗设备、航空航天等。\n\n在回答时，可以结合**具体的项目经验或案例来进一步说明这些区别** ，以及在**实际应用中如何根据需求选择合适的方案**\n。同时，展现出对两种方案的深入理解和实际应用能力，有助于提升面试官对你的评价。\n\n# 上到Linux后有什么新的感觉呢\n\n# iic和spi的区别是什么\n\n# 手撕两道\n\n## 最接近的三数之和\n\n给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。\n\n返回这三个数的和。\n\n假定每组输入只存在恰好一个解。\n\n    \n    \n    int comp(const void *a, const void *b) { return *(int *)a - *(int *)b; }\n    int threeSumClosest(int *nums, int numsSize, int target) {\n        int n = numsSize;\n        qsort(nums, n, sizeof(int), comp);\n        int best = 1e7;\n    \n        // 根据差值的绝对值来更新答案\n    \n        // 枚举 a\n        for (int i = 0; i < n; ++i) {\n            // 保证和上一次枚举的元素不相等\n            if (i > 0 && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            // 使用双指针枚举 b 和 c\n            int j = i + 1, k = n - 1;\n            while (j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                // 如果和为 target 直接返回答案\n                if (sum == target) {\n                    return target;\n                }\n                if (abs(sum - target) < abs(best - target)) {\n                    best = sum;\n                }\n                if (sum > target) {\n                    // 如果和大于 target，移动 c 对应的指针\n                    int k0 = k - 1;\n                    // 移动到下一个不相等的元素\n                    while (j < k0 && nums[k0] == nums[k]) {\n                        --k0;\n                    }\n                    k = k0;\n                } else {\n                    // 如果和小于 target，移动 b 对应的指针\n                    int j0 = j + 1;\n                    // 移动到下一个不相等的元素\n                    while (j0 < k && nums[j0] == nums[j]) {\n                        ++j0;\n                    }\n                    j = j0;\n                }\n            }\n        }\n        return best;\n    }\n    \n    \n\n## 那四个数呢？\n\n给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a],\nnums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：\n\n0 <= a, b, c, d < n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] ==\ntarget 你可以按 任意顺序 返回答案 。\n\n    \n    \n    int comp(const void* a, const void* b) {\n        return *(int*)a - *(int*)b;\n    }\n    \n    int** fourSum(int* nums, int numsSize, int target, int* returnSize, int** returnColumnSizes) {\n        int** quadruplets = malloc(sizeof(int*) * 1001);\n        *returnSize = 0;\n        *returnColumnSizes = malloc(sizeof(int) * 1001);\n        if (numsSize < 4) {\n            return quadruplets;\n        }\n        qsort(nums, numsSize, sizeof(int), comp);\n        int length = numsSize;\n        for (int i = 0; i < length - 3; i++) {\n            if (i > 0 && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) {\n                break;\n            }\n            if ((long) nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] < target) {\n                continue;\n            }\n            for (int j = i + 1; j < length - 2; j++) {\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\n                    continue;\n                }\n                if ((long) nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) {\n                    break;\n                }\n                if ((long) nums[i] + nums[j] + nums[length - 2] + nums[length - 1] < target) {\n                    continue;\n                }\n                int left = j + 1, right = length - 1;\n                while (left < right) {\n                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];\n                    if (sum == target) {\n                        int* tmp = malloc(sizeof(int) * 4);\n                        tmp[0] = nums[i], tmp[1] = nums[j], tmp[2] = nums[left], tmp[3] = nums[right];\n                        (*returnColumnSizes)[(*returnSize)] = 4;\n                        quadruplets[(*returnSize)++] = tmp;\n                        while (left < right && nums[left] == nums[left + 1]) {\n                            left++;\n                        }\n                        left++;\n                        while (left < right && nums[right] == nums[right - 1]) {\n                            right--;\n                        }\n                        right--;\n                    } else if (sum < target) {\n                        left++;\n                    } else {\n                        right--;\n                    }\n                }\n            }\n        }\n        return quadruplets;\n    }\n    \n    \n\n> 机试是真的挺难的，但是面试的时候手撕，都还是蛮中等的。\n\n# 【四面】主管面\n\n> 主要考察你怎么应对压力和解决问题\n    \n    \n    # 在学校里面有什么嵌入式相关的经验呢\n    # 整个方案设计是从无到有吗\n    # 前面押题吗\n    # 发挥了什么样的作用呢, 作为队长\n    # 有意外吗, 怎么解决的\n    # 比赛紧张期间怎么解决的问题\n    # 花多长时间解决了\n    # 中间有目标调整吗\n    # 换一个方案, 队友认同？\n    # 他们有擅长的方向吗\n    # 你觉得哪些技术因素最重要\n    # 休息了多长时间\n    # 队友都自愿的吗\n    # 竞赛对保研有什么帮助吗\n    # 谈谈期望的薪酬, 怎么考虑的\n    # 什么时候去报道\n    # 平时碰到事情容不容易着急\n    # 碰到上网查一查搞不定, 比较有挑战, 怎么去克服\n    # 自己摸索还是\n    # 没有很焦急的ddl\n    # 团队合作这块有没有相关的经历\n    # 从头到尾都没有问题吗\n    # 修改的方案是怎么定下来的呢\n    # 对未来多人项目怎么样共同工作\n    # 压力大怎么释放压力呢\n    # 在深圳哪\n    # 反问\n    \n    \n\n>\n> 非技术面，后面我会统一放一起，提供一个中肯好使的模版，因为每家公司的风格和文化不一样，对于同一个主观问题，可能想要的结果也不一样，所以等后面咱们好好分析一下。\n\n> 面试题目来源：区欠皇\n\n> 更多有用知识欢迎关注博主GZH：TrustZone\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598151167381708800?sourceSSR=users",
        "title": "微信支付二面（凉经）",
        "content": "1.手撕 179最大数，反转链表，金额元转化成分 3道题\n\n2.mysql引擎 事务隔离级别的几种类型，mysql为什么用可重复读，解决了什么问题\n\n3.mysql怎么解决幻读，for update时候怎么加锁\n\n4.什么是xss，解释一下流程\n\n5.操作系统栈和堆的区别\n\n幻读概念没吃透，一下子问住了，花了好多时间.....后面操作系统栈和堆也没了解，算法题倒是都写出来了，还是太菜了......唉\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598132596102524928?sourceSSR=users",
        "title": "华为od 三面挂 面经",
        "content": "2月9号 技术面一面二面\n\n第一面问了项目，然后手撕了动态规划的\n\n  \n\n第二面我说docker经常用，问我docker镜像制作\n\n我docker build 这个忘记了后面记起来了，然后答了docker pull 还有容器docker commit我忘答了。\n\n  \n\n三面问我单元测试，我说一开始用的robot，问我怎么用，没回答规范，然后就是unittest，问我怎么用，回答的不好，用是用了的。项目结束写了的，后面维护挺久没接触了，答的有些模糊。\n\n  \n\n合议让我挂掉了\n\n  \n\n我平时觉得会问tcp\nredis内存策略，过期策略，redis击穿什么的，或者mysql的索引，数据一致性，python基础啥的。没想到问的很基础。有些方向偏离。\n\n  \n\n有捞我的吗？工作一直是挺认真有责任心的\n\n  \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598150592200044544?sourceSSR=users",
        "title": "微信支付一面（一面过了，二面没过）",
        "content": "1 项目的难度点在哪里\n\n2 项目的网络攻击\n\n3 了解过xss工具\n\n4 mysql隔离级别\n\n5mvcc解释一下\n\n6mysql在高并发的情况下怎么保证数据不会改乱\n\n7 一般有哪些锁\n\n8 实习工作有没有接触过分布式事务的东西\n\n9比较熟悉的java，介绍一下java的多态的实现原理\n\n10 计算机网络，简单介绍一下http和tcp的区别\n\n11 tcp是怎么保证可靠的传输\n\n12 简单介绍一下四次挥手的过程\n\n13 浏览器的访问过程\n\n14 项目后台比较多。但是分布式事物不是很了解\n\n15 leercode 合并两个有序链表\n\n16 进程和线程区别；\n\n17 协程了解过吗？\n\n18为什么有线程还有有协程\n\n19 零拷贝有了解过吗\n\n20cap定理\n\n21 解释一下三个指标的意思\n\n23csrf攻击自己上网查然后自己介绍一下，10分钟后总结\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598122621045161984?sourceSSR=users",
        "title": "腾讯测开一面",
        "content": "# 1.TCP和UDP的区别\n\n# 2.cookie和session的区别——python中request的用法\n\n# 3.cookie和session的生命周期\n\n# 4.python中装饰器的理解 python中最常用的库有哪些？\n\n# 5.linux一些命令 管道、grep\n\n# 6.通过管道 | 如果将当前目录下的文件名复制出来？\n\n# 7.数据库中join的用法？\n\n# 8.docker命令？\n\n# 9.了解数据结构吗？常见的数据结构有哪些？\n\n# 10.常见的二叉树有哪些？\n\n# 11.红黑树的用途？\n\n# 12.常见的设计模式？\n\n# 13.手撕算法 传入数字，输出添加千分位的格式字符串\n\n例如：input 1000 1000000\n\noutput 1，000 1,000,000\n\n根据上述算法设计测试用例：\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598105150045102080?sourceSSR=users",
        "title": "腾讯春招后端一面（八股篇）",
        "content": "# 前言\n\n前几天在网上发了腾讯面试官问的一些问题，好多小伙伴关注，今天对这些问题写个具体答案，博主好久没看八股了，正好复习一下。\n\n面试手撕了三道算法，这部分之后更，喜欢的小伙伴可以留意一下我的账号。\n\n# 1.讲一下数据库的事物特性和底层原理\n\n## 四大特性\n\n⑴ 原子性（Atomicity）\n\n原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。\n\n⑵ 一致性（Consistency）\n\n一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。\n\n转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。\n\n⑶ 隔离性（Isolation）\n\n隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。\n\n即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。\n\n⑷ 持久性（Durability）\n\n持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数\n\n## 原理\n\n数据库系统是通过并发控制技术和日志恢复技术来避免这种情况发生的。\n\n### 并发控制技术：\n\n并发控制技术是实现事务隔离性以及不同隔离级别的关键,实现方式有很多,按照其对可能冲突的操作采取的不同策略可以分为乐观并发控制和悲观并发控制两大类。\n\n> 乐观并发控制:\n>\n> 对于并发执行可能冲突的操作,假定其不会真的冲突,允许并发执行,直到真正发生冲突时才去解决冲突,比如让事务回滚。\n\n> 悲观并发控制:\n>\n> 对于并发执行可能冲突的操作,假定其必定发生冲突,通过让事务等待(锁)或者中止(时间戳排序)的方式使并行的操作串行执行。\n\n  \n\n我们这里介绍基于悲观锁的机制：\n\n核心思想:\n\n对于并发可能冲突的操作,比如读-写,写-读,写-写,通过锁使它们互斥执行。\n\n锁通常分为共享锁和排他锁两种类型\n\n> 共享锁(S):事务T对数据A加共享锁,其他事务只能对A加共享锁但不能加排他锁。\n> 排他锁(X):事务T对数据A加排他锁,其他事务对A既不能加共享锁也不能加排他锁\n\n基于锁的并发控制流程:\n\n> 事务根据自己对数据项进行的操作类型申请相应的锁(读申请共享锁,写申请排他锁)\n>\n> 申请锁的请求被发送给锁管理器。锁管理器根据当前数据项是否已经有锁以及申请的和持有的锁是否冲突决定是否为该请求授予锁。\n>\n> 若锁被授予,则申请锁的事务可以继续执行;若被拒绝,则申请锁的事务将进行等待,直到锁被其他事务释放。\n\n可能出现的问题:\n\n> 死锁:多个事务持有锁并互相循环等待其他事务的锁导致所有事务都无法继续执行。 饥饿:数据项A一直被加共享锁,导致事务一直无法获取A的排他锁。\n\n对于可能发生冲突的并发操作,锁使它们由并行变为串行执行,是一种悲观的并发控制。\n\n### 日志恢复技术\n\n日志恢复技术保证了事务的原子性,使一致性状态不会因事务或系统故障被破坏。同时使已提交的对数据库的修改不会因系统崩溃而丢失,保证了事务的持久性。\n\n撤销事务undo:将事务更新的所有数据项恢复为日志中的旧值\n\n重做事务redo:将事务更新的所有数据项恢复为日志中的新值。\n\n# 2.讲一下数据库的隔离级别\n\n① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。\n\n② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。\n\n③ Read committed (读已提交)：可避免脏读的发生。\n\n④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。\n\n# 3.讲一下数据库的的索引机制\n\n索引（index）是帮助MySQL高效获取数据的数据结构(有序)，提高数据检索的效率，降低数据库的IO成本（不需要全表扫描），通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。\n\nMySQL的InnoDB引擎采用的B+树的数据结构来存储索引，b+树阶数更多，路径更短，磁盘读写代价B+树更低，非叶子节点只存储指针，叶子阶段存储数据，B+树便于扫库和区间查询，叶子节点是一个双向链表\n\n# 4.说一下Redis和MySQL数据同步的方案\n\n## 延时双删策略\n\n在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。\n\n![alt](https://uploadfiles.nowcoder.com/images/20240315/127966388_1710470013746/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n为什么在写入之后还要删除？\n\n因为写入之前可以有读请求读到了未修正的数据，然后写入了缓存，这个时候缓存和真实数据不一致，但是读请求只会读到缓存就返回数据，造成数据更新不及时\n\n## 异步更新缓存(基于订阅binlog的同步机制)\n\nMySQL binlog增量订阅消费+消息队列+增量数据更新到redis\n![alt](https://uploadfiles.nowcoder.com/images/20240315/127966388_1710470042648/D2B5CA33BD970F64A6301FA75AE2EB22)\n\n步骤：\n\n  1. 读Redis：热数据基本都在Redis\n  2. 写MySQL:增删改都是操作MySQL\n  3. 更新Redis数据：MySQ的数据操作binlog，来更新到Redis\n\n# 5.讲一下向某个网站从发送请求到收到数据这个过程中发生了什么。\n\n1.浏览器中输入网址。\n\n2.通过DNS解析域名的实际IP地址\n\nDNS 解析首先会从你的浏览器的缓存中去寻找是否有这个网址对应的 IP 地址，如果没有就向OS系统的 DNS 缓存中寻找，如果没有就是路由器的 DNS\n缓存， 如果没有就是 ISP 的DNS 缓存中寻找。\n\n3.与 WEB 服务器建立 TCP 连接。\n\nTCP 协议通过三次握手建立连接。\n\n客户端通过 SYN 报文段发送连接请求，确定服务端是否开启端口准备连接。状态设置为 SYN_SEND;\n\n服务器如果有开着的端口并且决定接受连接，就会返回一个 SYN+ACK 报文段给客户端，状态设置为 SYN_RECV；\n\n客户端收到服务器的 SYN+ACK 报文段，向服务器发送 ACK 报文段表示确认。此时客户端和服务器都设置为 ESTABLISHED\n状态。连接建立，可以开始数据传输了。\n\n4.若协议是https则会做加密\n\n5.浏览器发送请求获取页面html\n\n6.服务器响应html\n\n7.浏览器解析 HTML\n\n8.浏览器渲染页面\n\n# 6.讲一下进程与线程的区别，以及你对操作系统的理解\n\n进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；\n\n线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。\n\n# 7.线程如何数据交互，进程如何数据交互?\n\n## 线程的数据交互\n\n锁机制：包括互斥锁、条件变量、读写锁\n\n互斥锁提供了以排他方式防止数据结构被并发修改的方法。 读写锁允许多个线程同时读共享数据，而对写操作是互斥的。\n条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。\n信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量\n\n信号机制(Signal)：类似进程间的信号处理\n\n## 进程的数据交互\n\n**管道( pipe )：**\n\n管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。\n\n**有名管道 (namedpipe) ：**\n\n有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。\n\n**信号量(semophore ) ：**\n\n信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。\n\n**消息队列( messagequeue ) ：**\n\n消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。\n\n**信号 (sinal ) ：**\n\n信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。\n\n**共享内存(shared memory ) ：**\n\n共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC\n方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。\n\n**套接字(socket ) ：**\n\n套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。\n\n原文链接：[https://blog.csdn.net/qq_51118755/article/details/136550189](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fblog.csdn.net%2Fqq_51118755%2Farticle%2Fdetails%2F136550189)\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598101381781757952?sourceSSR=users",
        "title": "阿里妈妈 一二三面经",
        "content": "# 一面\n\n  * 自我介绍\n  * 聊实习经历和开源经历\n  * java类加载的步骤\n  * 垃圾回收机制\n  * gc的时候除了清理堆内存，还有清理什么地方的垃圾\n  * java进程突然cpu占用升高，可能是什么问题，如何排查\n  * 反射机制\n  * 乐观锁和悲观锁\n  * 做题：最小栈\n  * 两个线程交替打印ABCD..Z字母，一个大写一个小写\n  * 反问环节\n\n# 二面\n\n  * 自我介绍\n  * 聊实习、聊全职、聊开源经历\n  * 联合唯一索引ab，如果b为空值，下一条数据字段a与上一条相同，b不为空，能插入吗\n  * 然后问的问题有点放飞自我...问我对谷歌AI的发展怎么看\n\n# 三面\n\n  * 自我介绍\n  * 聊实习、全职、开源经历\n  * 聊组里做什么\n\n比牛客很多面经帖简单很多，应该是沾了实习的光，每轮面试聊实习就能聊个十几分钟\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/598058627546607616?sourceSSR=users",
        "title": "腾讯校招实习后端二面：场景题为王",
        "content": "嗨～我是可拟雀，一个后端开发工程师，毕业于某985大学，目前供职于bat某大厂核心部门后端。每天分享最新面经答案，希望在大环境不好的当下能帮到你，让你多积累面试经验。免费分享个人学习2个月速通大厂路线和面经解析合集，需要请私信  \n  \n1.有两张表一张商品表，一张订单表，要查询数据，应该考虑做些什么呢？  \n答：  \n  \n\n索引：  \n\n在经常用于查询条件的字段上创建索引，例如商品ID、客户ID、订单日期等。  \n\n避免在索引字段上使用函数或运算，这可能会导致索引失效。\n\n定期维护和优化索引，以确保其有效性。\n\n  \n\n查询优化：\n\n避免使用SELECT *，而是明确指定需要查询的字段，以减少数据传输量。\n\n使用JOIN代替子查询，当可能时，因为某些情况下JOIN的性能更好。\n\n减少WHERE子句中的条件数量，只包含必要的条件。\n\n使用EXPLAIN命令来查看查询的执行计划，确保它按照预期的方式执行。\n\n  \n\n表结构：\n\n确保表结构合理，避免冗余数据和不必要的复杂关联。\n\n规范化数据，但也要注意不要过度规范化，以免增加查询的复杂性。\n\n  \n\n硬件和配置：\n\n确保数据库服务器具有足够的RAM，以便数据库管理系统可以有效地使用内存缓存。\n\n根据工作负载调整数据库的配置参数，例如缓冲区大小、连接池大小等。\n\n使用SSD替代传统硬盘，以提高I/O性能。\n\n  \n\n分区和分片：\n\n如果表非常大，考虑使用分区或分片技术，将数据分散到多个物理存储位置，以提高查询性能。\n\n  \n\n缓存：\n\n利用查询缓存或其他缓存机制，存储经常查询的结果，以减少对数据库的访问。\n\n  \n\n数据库维护：\n\n定期更新统计信息，以便优化器能够做出更好的决策。\n\n定期清理和优化数据库，例如删除旧数据、重建索引等。\n\n  \n\n并发控制：\n\n使用合适的并发控制策略，如连接池、读写分离等，以减少锁争用和等待时间。\n\n  \n\n应用层优化：\n\n在应用层实现分页功能，避免一次性加载大量数据。\n\n减少不必要的数据库请求，例如通过合并多个请求或使用批量操作。\n\n  \n\n监控和日志：\n\n使用数据库监控工具来跟踪查询性能，及时发现并解决性能瓶颈。\n\n分析慢查询日志，找出并优化那些执行缓慢的查询。\n\n  \n\n2.商品类型适合做索引吗？  \n答：  \n考虑商品类型的多样性。如果商品类型非常多样，且每个类型下的商品数量差异很大，那么对商品类型进行索引可能有助于提高查询效率。因为索引能够加速数据库对特定类型商品的检索速度。\n\n  \n\n如果商品类型数量有限，或者类型之间的商品数量分布较为均匀，那么对商品类型进行索引可能并不会带来明显的性能提升。此外，过多的索引会增加数据库的存储空间和维护成本，因此需要在索引的数量和性能之间做出权衡。\n\n  \n\n除了商品类型的多样性外，还需要考虑查询的频繁程度。如果经常需要根据商品类型进行查询，那么对商品类型进行索引是有意义的。但如果查询不频繁，或者查询方式更加复杂，那么可能需要考虑其他优化策略，如优化查询语句、调整数据库结构等。\n\n  \n\n还需要考虑具体的数据库管理系统和硬件环境。不同的数据库管理系统和硬件环境对索引的支持和性能表现可能有所不同，因此在实际应用中需要根据具体情况进行性能分析和优化。\n\n  \n\n3.商品下单的时候，要做一些什么考虑呢？  \n答：  \n\n1\\. 数据完整性和准确性：  \n\n  \n\n确保接收到的订单数据完整，没有遗漏或错误。\n\n验证商品信息、数量、价格等数据的准确性，防止因数据错误导致的订单问题。\n\n  \n\n2\\. 并发处理能力：\n\n  \n\n考虑到可能的高并发下单场景，需要确保系统能够处理大量并发请求，避免系统崩溃或响应超时。\n\n合理利用缓存、分布式锁等技术手段，提高系统并发处理能力。\n\n  \n\n3\\. 事务一致性：\n\n  \n\n下单过程可能涉及多个数据库操作（如库存扣减、订单生成等），需要确保这些操作在一个事务中完成，以保持数据的一致性。\n\n使用数据库事务管理来确保操作的原子性、一致性和隔离性。\n\n  \n\n4\\. 安全性：\n\n  \n\n对用户输入进行严格的验证和过滤，防止SQL注入、跨站脚本攻击等安全问题。\n\n使用HTTPS协议进行数据传输，确保数据的加密和安全。\n\n  \n\n5\\. 性能优化：\n\n  \n\n对下单流程进行性能分析，找出瓶颈并进行优化，提高系统的响应速度和吞吐量。\n\n利用负载均衡、缓存等技术手段来分摊请求压力，提高系统性能。\n\n  \n\n6\\. 错误处理和日志记录：\n\n  \n\n对下单过程中可能出现的错误进行妥善处理，并向用户返回友好的错误信息。\n\n记录详细的操作日志和错误日志，方便后续的故障排查和问题定位。\n\n  \n\n7\\. 库存管理与同步：\n\n  \n\n在下单时，确保库存扣减操作的原子性，避免超卖现象。\n\n如果系统涉及多个服务或数据源，需要确保库存数据的实时同步和一致性。\n\n  \n\n8\\. 通知与回调：\n\n  \n\n在订单生成后，及时通知用户和其他相关系统（如支付系统、物流系统等）。\n\n提供回调接口，以便其他系统能够实时获取订单状态变化。\n\n  \n\n4.数据库层面怎么保证数据原子性呢？  \n  \n5.如果把订单表放在redis里面怎么保证一致性呢？  \n6.如果数据表非常大，做查询的时候要做些什么考虑呢？  \n答：  \n1\\. 索引优化：  \n  \n为经常用于查询的列创建索引，可以显著提高查询速度。但请注意，索引也会占用存储空间并可能增加插入、更新和删除操作的时间，因此需要根据实际情况权衡。  \n使用复合索引时，要注意列的顺序，将最常用于查询条件的列放在前面。  \n定期审查和优化现有索引，删除不再需要的索引，避免索引冗余。  \n  \n2\\. 查询优化：  \n  \n尽量避免使用SELECT *，只选择需要的列，减少数据传输量。  \n使用WHERE子句限制结果集，避免返回过多数据。  \n避免在列上使用函数或计算，这可能导致索引失效。  \n尝试将复杂的查询分解为多个简单的查询，然后合并结果，有时这样可以提高效率。  \n  \n3\\. 分区与分片：  \n  \n如果表的数据量非常大，可以考虑使用分区技术将数据分散到多个物理存储上，提高查询并行性。  \n对于分布式数据库系统，可以采用分片策略将数据分散到多个节点上，实现负载均衡和扩展性。  \n  \n4\\. 缓存策略：  \n  \n对于经常访问且不经常变动的数据，可以使用缓存技术（如Redis、Memcached等）来存储查询结果，减少对数据库的访问。  \n  \n5\\. 数据库参数调整：  \n  \n根据数据库的类型和版本，调整相关的配置参数，如缓冲区大小、连接数等，以优化数据库性能。  \n  \n6\\. 定期维护：  \n  \n定期对数据库进行维护，如更新统计信息、重建索引、清理无用数据等，保持数据库的健康状态。  \n  \n7\\. 监控与日志分析：  \n  \n使用数据库监控工具实时观察查询性能，及时发现和解决性能瓶颈。  \n分析慢查询日志，找出执行缓慢的查询并进行优化。  \n  \n8\\. 数据库设计：  \n  \n合理的数据库设计是查询优化的基础。避免数据冗余、减少数据关联复杂度、使用合适的数据类型等都可以提高查询效率。  \n  \n9.结合慢查询相关八股进行说明。  \n  \n  \n7.tcp为什么要三次握手呢，两次握手不行吗？  \n  \n8.如果要你做一个qq之类的通讯功能，你会选择什么协议呢？  \n答：如果要设计一个类似于QQ的通讯功能，我会选择基于TCP/IP协议的即时通讯协议作为核心通讯机制。这种协议能够确保消息的可靠传输，并在双方用户之间建立稳定的连接。\n\n  \n\n具体来说，当用户登录时，客户端可以采用TCP协议与服务器进行通信，以确保登录过程的安全和稳定。一旦登录成功，客户端和服务器之间会保持一个TCP连接，用于维持在线状态。\n\n  \n\n在消息传输方面，虽然UDP协议在某些情况下可以提供更高的传输效率，但由于其不保证消息的可靠传输，可能会导致消息丢失或乱序。因此，为了确保消息的准确性和完整性，我会选择使用TCP协议来传输文本消息。同时，我也会利用上层协议来确保消息的可靠传输，并在消息发送失败时提供重新发送的机制。\n\n  \n\n对于文件传输等需要较高效率的场景，我会考虑采用基于UDP的P2P技术。这种技术可以在用户之间直接传输文件，而无需通过服务器中转，从而提高了传输效率。当然，为了确保文件传输的可靠性，我也会设计相应的校验和重传机制。\n\n  \n\n综上所述，我会选择基于TCP/IP协议的即时通讯协议作为核心通讯机制，并根据不同的应用场景和需求，结合使用TCP和UDP协议，以提供稳\n\n定、高效且可靠的通讯功能。\n\n  \n9.用长连接还是短链接呢？  \n答：  \n每个方案都有自己的优点和缺点。  \n\n在设计类似于QQ的通讯功能时，对于连接类型的选择，长连接（Persistent Connection）和短连接（Short\nConnection）都有各自的优缺点，具体选择取决于应用场景和需求。\n\n  \n\n长连接：\n\n  \n\n优点：\n\n  \n\n减少连接建立和断开的开销：由于连接在建立后保持打开状态，因此避免了频繁地建立和断开连接所带来的时间和资源消耗。\n\n实时性更好：长连接使得服务器和客户端能够实时地交换数据，适用于需要即时响应的场景。\n\n减少网络拥塞：由于减少了连接建立和断开的次数，长连接有助于降低网络拥塞的可能性。\n\n  \n\n缺点：\n\n  \n\n资源占用：长时间保持连接状态会占用服务器和客户端的资源，如果连接数过多，可能会导致资源耗尽。\n\n心跳包维护：为了保持连接活跃，通常需要定期发送心跳包，这会增加一定的网络流量和开销。\n\n  \n\n短连接：\n\n  \n\n优点：\n\n  \n\n资源占用少：每次数据传输完成后即断开连接，减少了长时间占用资源的情况。\n\n简单明了：短连接每次数据传输都是独立的，无需考虑连接状态的维护。\n\n  \n\n缺点：\n\n  \n\n连接建立和断开开销大：每次数据传输都需要建立新的连接，并在传输完成后断开连接，这增加了时间和资源的消耗。\n\n实时性较差：由于需要频繁建立和断开连接，短连接在实时性方面不如长连接。\n\n  \n\n由于需要实现实时聊天、文件传输等功能，通常建议选择长连接。长连接能够确保客户端和服务器之间保持稳定的连接状态，实现实时通信，并且减少了连接建立和断开的开销。当然，在实际应用中，还需要根据具体需求和场景来权衡选择长连接还是短连接，以及合理设计心跳包等机制来维护连接的活跃性。\n\n  \n\n10.如果用长连接的话，有大量的用户同时连接，会出现一些什么问题呢？  \n  \n答：如果使用长连接，并且有大量用户同时连接，确实可能会出现一些问题。以下是可能面临的一些挑战：\n\n  \n\n资源消耗：每个长连接都会占用服务器的一定资源，包括内存、CPU和网络带宽。当有大量用户同时连接时，这些资源的消耗会急剧增加，可能导致服务器性能下降，甚至引发服务崩溃。\n\n  \n\n连接管理：服务器需要维护大量的长连接，这增加了连接管理的复杂性。服务器需要有效地管理这些连接，包括监控连接状态、处理连接断开和重新连接等情况。\n\n  \n\n网络稳定性：长连接对网络稳定性要求较高。如果网络出现波动或中断，长连接可能会受到影响，导致数据传输中断或连接断开。\n\n  \n\n安全性问题：大量的长连接可能增加安全风险。恶意用户可能会尝试利用长连接进行攻击，如拒绝服务攻击（DoS）或分布式拒绝服务攻击（DDoS），导致服务器过载或无法正常工作。\n\n  \n\n为了解决这些问题，可以采取一些措施：\n\n  \n\n负载均衡：使用负载均衡技术将用户请求分发到多个服务器上，以减轻单一服务器的压力。\n\n连接池：使用连接池技术来管理和复用连接，减少连接建立和断开的开销。\n\n心跳机制：实现心跳机制来定期检测连接的活性，及时发现并处理失效的连接。\n\n安全策略：加强安全策略，包括使用加密技术保护数据传输、限制并发连接数、设置防火墙等，以提高系统的安全性。\n\n  \n\n11.会给服务器哪些方面带来压力呢，内存、CPU、磁盘还是什么呢？  \n答：  \n\n使用长连接在大量用户同时连接的情况下，会给服务器带来多方面的压力，主要体现在以下几个方面：\n\n  \n\n内存压力：每个长连接都需要在服务器上占用一定的内存资源来维护连接状态和数据缓冲区。当连接数大幅增加时，内存消耗会迅速增长，可能导致内存不足，进而影响服务器性能。\n\n  \n\nCPU压力：处理大量的长连接会增加服务器的CPU负担。服务器需要为每个连接进行数据处理、协议解析和响应生成等操作，这些操作都会消耗CPU资源。如果CPU资源不足，可能会导致响应延迟或处理失败。\n\n  \n\n网络带宽压力：长连接意味着数据在客户端和服务器之间持续传输，这会占用网络带宽。当大量用户同时在线并进行数据传输时，网络带宽可能成为瓶颈，限制数据传输的速度和稳定性。\n\n  \n\n磁盘I/O压力：虽然长连接本身并不直接增加磁盘I/O压力，但如果服务器需要频繁地读写磁盘以支持连接相关的数据存储或日志记录等操作，那么磁盘I/O也可能成为性能瓶颈。\n\n  \n\n12.对于CPU的压力，要怎么解决呢（说的是加服务器）？  \n答：\n\n优化应用程序：首先，对运行在服务器上的应用程序进行优化是关键。这包括优化代码逻辑，减少不必要的计算，使用更高效的数据结构和算法。此外，定期更新软件版本以确保使用的是最新、最优化的代码。  \n\n  \n\n限制进程CPU使用率：使用工具如cpulimit可以限制特定进程的CPU使用率。这对于那些资源消耗过大的进程特别有用，可以确保它们不会过度占用CPU资源。\n\n  \n\n关闭不必要的后台程序：通过任务管理器或系统监控工具，关闭那些不常用或不必要的后台程序，以释放CPU资源。\n\n  \n\n升级硬件：如果服务器的CPU性能确实较低，无法满足业务需求，那么考虑升级硬件可能是一个长期解决方案。更换更强大的CPU或增加CPU核数都可以提升服务器的整体性能。\n\n  \n\n负载均衡：通过实施负载均衡策略，将用户请求分发到多个服务器上，从而分散CPU负载。这有助于确保每个服务器都能处理适量的请求，避免单一服务器过载。\n\n  \n\n使用缓存：对于频繁访问的数据，使用缓存技术（如Redis或Memcached）可以减少对数据库的访问次数，从而降低CPU负载。\n\n  \n\n监控与告警：实施CPU使用率的监控和告警机制，当CPU使用率超过预设阈值时，及时发出告警通知，以便管理员可以及时采取措施进行干预和调整。\n\n  \n\n13.单台服务器怎么做呢？从12问回答中挑选单机相关。  \n14.有用过netty之类的吗，NIO、BIO、AIO之类的  \n15.操作系统内核层面怎么做优化呢  \n16.java的线程模型和操作系统的线程模型  \n17.如果用UDP的话，要考虑一些什么问题呢  \n18.UDP的话，除了丢包问题还有什么问题呢  \n19.如果用HTTP的话，要考虑一些什么问题呢  \n20.常用的web服务器会遇到的问题有那些呢  \n21.共享桌面写一个多线程的题，创建10个线程，主线程要在这10个线程执行完成后执行，很快写了个例子但线程忘记start了（汗流浃背了），然后面试官提醒才加上去  \n22.家是哪里的  \n23.为什么想要去深圳发展  \n  \n[原文链接](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fwww.nowcoder.com%2Fshare%2Fjump%2F566343146505463679)  \n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/597949133776863232?sourceSSR=users",
        "title": "德科信息前端实习一面",
        "content": "全程大概40分钟，氛围还不错\n\n面试内容相对较基础，面试官人很好，也会跟我讲一些很深入的东西[赞]\n\n  * 自我介绍\n  * css animation\n  * css transition\n  * css transform\n  * 盒子水平垂直居中\n  * ES6新特性\n  * 箭头函数和普通函数的区别\n  * promise的使用\n  * async await\n  * 生成器Generators（yield，next）\n  * 防抖和节流\n  * 浅拷贝和深拷贝\n  * 宏任务和微任务\n  * JS执行顺序\n  * UDP和TCP\n  * TCP三次握手\n  * TCP四次挥手\n  * vue响应式\n  * proxy的优点\n  * vue的生命周期\n  * keep-alive（生命周期）\n  * v-show和v-if\n  * 双向数据绑定（v-model）\n  * vuex属性（怎么改变state，在action中干什么，action怎么改变state）\n  * 辅助函数（写在哪）\n  * vue-router使用\n  * pinia\n  * webpack、vite\n  * axios（请求响应拦截器，举了token的例子）\n  * http和https的区别\n  * 加密算法（对称加密和非对称加密，我说了TLS）\n  * 反问\n\n回答的还可以，面试官也说还可以[喝可乐]\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/597915135667204096?sourceSSR=users",
        "title": "招商永隆 （Java开发）一面",
        "content": "时间：2024.2.2\n\n时长：30分钟\n\n1、自我介绍\n\n2、讲一下最近做的项目，在项目中担任的角色\n\n3、未来职业的规划\n\n4、去过深圳吗，有考研打算吗\n\n5、问项目用的什么技术，技术选型为什么用mybatis，用到拦截器了吗，具体做了什么处理\n\n6、java里一般用过哪些方法\n\n7、数组和list之间怎么转换\n\n8、hashmap的底层有了解过吗\n\n9、mybatis的分页怎么使用\n\n10、mysql怎么看查询效率\n\n11、mysql做过什么性能优化吗\n\n12、vue如何使用数据绑定\n\n13、vue使用过滤器\n\n14、vue生命周期\n\n15、如何在spring中使用依赖注入\n\n16、spring的自动配置怎么做的\n\n17、spring有哪些常见的配置文件\n\n18、python的了解情况，如果有网站使用反爬虫技术该如何解决\n\n总结：三个面试官面我一个人，刚开始还是挺紧张的，但是面试官说话很温柔，问的问题也比较轻松，整体交流下来比较愉快。\n\n在2.6的时候约了hr面，但是好像我期望薪资报高了，后面就一直没收到消息了。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/597910465280319488?sourceSSR=users",
        "title": "腾讯云客户端一面（本科实习）",
        "content": "3.12上午投的简历，当天晚上收到电话3.13晚上7:30面\n\n自我介绍，完了开始问项目。问了项目实现的具体细节，技术实现等等\n\n然后开始八股\n\n## 八股（有些记不清了）：\n\n  1. 简述cpp内存结构\n  2. cpp类在内存中的结构，虚函数表如何实现动态绑定\n  3. 线程和进程的区别\n  4. 线程如何相互通讯，进程呢\n  5. 上面提到的进程间通讯（管道，信号量，共享内存，socket）的区别和使用场景\n  6. 列举一下常用数据结构\n  7. b+树和b树的区别\n  8. 如何实现一个堆\n  9. tcp三次握手四次挥手，为什么这么设计\n  10. tcp拥塞避免，滑动窗口\n\n写了一个LRU cache，好久没写cpp,问了下能不能上cppreference,面试官说可以。写完没考虑未满的情况相同key插入的细节，面试官说问题不大\n\n## 提问：\n\n问了下面试官有哪些需要改进的地方，评价是知识较深较广，代码有些生疏，但是问题不大\n\n问了下在面试官目前客户端开发的一些细节\n\n## 结果：\n\n3.14早上收到消息3.15二面\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/597887753870712832?sourceSSR=users",
        "title": "滴滴前端日常实习一面凉经",
        "content": "准备了一堆基础知识，上来让我讲项目难点和vue...我就不该不懂名词瞎蹦\n\n基础：\n\n  1. vue3和vue2的区别 这个挺全：[https://juejin.cn/post/7139921537896808479](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjuejin.cn%2Fpost%2F7139921537896808479)\n  2. vue2->3 ref的用法 用于在 Vue 组件中创建可响应的数据，类似于 Vue 2.x 中的 data。ref 函数返回一个包含初始值的响应式对象。它的主要作用是将普通 JavaScript 对象或值转换为具有响应性的对象，以便在 Vue 组件中使用。具体用法：...\n  3. 具体讲讲webpack的工作原理 [https://juejin.cn/post/7140769906080874504](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjuejin.cn%2Fpost%2F7140769906080874504)\n  4. webpack和vite的区别 [https://juejin.cn/post/7229314985044951095](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fjuejin.cn%2Fpost%2F7229314985044951095)\n\n算法题：用json\n\n1.二分查询 输入数组，返回下标，没查到返回-1\n\n    \n    \n    var search = function binarySearch(list,target){\n        let left = 0, right = list.length -1;\n        while (left <= right){\n            const mid = Math.floor((right-left)/2) +left;\n            const num=list[mid];\n            if (num == target){\n                return mid;\n            }\n            else if(num > target){\n                right=mid-1;\n            }\n            else{\n                left=mid+1;\n            }\n        }\n        return -1;\n    }\n    \n\n2.深拷贝 以及要考虑循环引用陷入死循环的情况\n\n3.回答打印结果\n\n重点是json中key是字符串类型\n\n前面基础知识很多答不上来，所以做了挺多算法题，我感觉考官是为了拖时间，拖到刚满一个小时就结束会议了。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/597880409187282944?sourceSSR=users",
        "title": "游戏测试 - 面经 - 创梦天地科技",
        "content": "**2024.3.6 Boss直聘**\n\n**2024.3.13 面试**\n\n**2024.3.14 电话通知约第二轮面试**\n\n自我介绍\n\n平时有玩过什么游戏\n\n射击类有玩过吗\n\n实习时是测试岗是吗\n\n自动化的测试化脚本有自己编写过吗\n\n有没有做过其他功能测试的部分\n\n有没有测试用例之类的\n\n测试用例表头有哪些内容\n\n你们在写用例之前会写用例分析吗\n\n王者荣耀玩的比较多的英雄是哪个呀\n\n讲一下夏洛特的英雄定位以及技能\n\n罗列一下大招的测试点\n\n还有一些表现类的，可以描述一下有哪些\n\n还有其他的吗\n\n你这边有了解过一些黑盒测试的方法吗\n\n功能测试的一些方法有了解过吗\n\n有了解过我们公司的一些游戏\n\n面的这个项目是《卡拉比丘》有了解过吗\n\n有接触过一些游戏引擎吗（讲了unity）\n\nUE有使用或者了解过吗\n\n你之后的职业规划是怎样的\n\n你这边什么时候能够入职呢\n\n能够实习多久\n\n你这段实习是不考虑转正是吗\n\n**反问环节**\n\n入职之后有导师，会有一些指导\n\n明天二面，千万记得录音，保存好录音\n\n喜欢随手删的习惯害怕ing\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/597879988544729088?sourceSSR=users",
        "title": "理想汽车 一面 面经 24春招",
        "content": "个人背景：本9海硕，一段本硕之间的一年工作经验，一段老外研究所实习\n\n岗位：存储开发\n\nTL：3/12投递，3/14一面\n\n**一面：**\n\n时间：3/14，长度50分钟\n\n内容：\n\n  1. 自我介绍\n  2. 手撕：链表排序，用归并，虽然简单但实际上是多个题的组合，归并+链表中心+有序链表合并，大概主要代码写出来了\n  3. 手撕：如何用SIMD来优化数组求和，问这个是因为简历上提到了SIMD优化，自己挖坑了，我用SIMD没写过这方面的代码，直接不会\n  4. CPU内部SIMD是如何实现的\n  5. 虚析构函数\n  6. sizeof一个std::function是多少，这个没答上来\n  7. 线程数量远大于内核数量时会发生什么问题\n  8. 智能指针使用过程中有什么问题：循环引用和多线程争用\n  9. 记不清了\n  10. 反问岗位工作内容\n\n感受：理想面试难度上来了，SIMD优化这个没深入做过真没人会，八股虽然问的不多，但都是很细节的问题，大多数都能说上一点，有个别个直接不会，总的来说表现出了是一个刚刚合格的C++码农。\n\n结语：春招第一次被拷打，感觉要寄\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/597871000830681088?sourceSSR=users",
        "title": "25找实习记",
        "content": "date 3/14\n\n面试事业单位：烟台中科网络研究所\n\n开场\n\n自我介绍\n\n介绍自己写的两个项目（12306以及黑马点评，只不过包装了一下）。\n\n看你熟悉redis,那讲一讲redis 中的使用场景\n\nredis集群\n\nredis持久化方式\n\n其他的忘了，我看网上基本没有关于这家事业单位的信息，而且给的少。\n\n反问：\n\n面试官：印象不错，等通知。\n\n两个人，一个hr or 人力？还有一个java工程师\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/597866854002061312?sourceSSR=users",
        "title": "腾讯 前端实习面试 游戏数据",
        "content": "会根据简历问问题，开头两道算法题，直接人傻了。\n\n第一道题比较版本号，一上来数组方法split忘了，问的面试官。不过小哥人很好，直接告诉我了，还给我拼了出来s-p-l-i-t\n\n。。。\n\n第二道时字符串相加，一开始是相乘，后来说时间太久了，就变成了相加，不过写了一半，我太磨蹭了（太菜了）。小哥说说一下思路，就开始问八股了。\n\n然后就开始看简历写了啥问我vue-router的两种模式，问我底层原理（不会\n\n问vue的发布者订阅模式（支支吾吾）也不咋会\n\n问我vite和webpack的区别也不会。。。\n\n还问了一些其他的css基础，\n\n浏览器原理啥的\n\ncanves和svg的区别这些说出来了。\n\n还是准备的不够哭哭\n\n反问\n\n给我的建议：多用\n\n用的技术栈：vue不过这个不重要。。\n\n![](https://uploadfiles.nowcoder.com/images/20240314/973406800_1710414489108/EB8EE51FA340793820630ED9999B2EF6)\n\n一定要把简历上写的知识点记牢，我看别人的面经背了好久的计网一个没问。。。\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/597865544930422784?sourceSSR=users",
        "title": "腾讯云后端一面",
        "content": "## CSIG 后端一面 3.14 17:00-18:00\n\n### 面试八股：25min\n\n项目怎么部署的\n\nGo的GMP调度\n\n用过哪些锁(Mutex、RWMutex)\n\n项目中用到过锁吗\n\ngoroutine间如何同步(channel、信号量)\n\nMySQL批量插入(开启事务分批次插入)\n\n如何加行锁(for update)\n\n项目哪里使用到Redis，用了哪些数据类型\n\n如何实现分布式锁(SETNX)\n\nRedis为什么快(单线程、缓存)\n\nSQL慢如何定位(慢查询日志、explain)\n\n索引失效怎么发生(最左、Like、函数操作)\n\n用过Flask，和Gin有什么区别\n\n知道Flask的蓝图吗(不知道) 写过什么东西(RESTful api)\n\nGin如何使用JWT的中间件\n\n面试官介绍业务：监控、网络，可能用到Flask、前端\n\n### 算法：手写LRU 30min\n\n上周刚写过，最后有点小报错还没解决，面试官叫停了\n\n总结：面试官很好，答对了会说“嗯没问题”、“嗯对的”，总体感受不错\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/597853063428304896?sourceSSR=users",
        "title": "（25Java实习）慧策 掌上先机 一面面经",
        "content": "面试官人很好有些难的业务场景会带着一起分析，问了45分钟，主要是八股文和业务场景问题：\n\n0\\. 自我介绍\n\n1\\. 项目拷打（Kafka消息挤压）\n\n1\\. 组内分工情况\n\n2\\. 和kafka组对接的工作量多少\n\n2\\. Kafka和RocketMQ的区别？怎么选型？（kafka快）\n\n3\\.\n假设给你一个ArrayList<Student>怎么根据Student.id来进行去重操作，有哪几个方法？（Set性质去重，stream流的distinct去重方法，filter和map删除出现过的）\n\n4\\. 用for循环去删除ArrayList元素有没有问题？LinkedList呢？\n\n5\\. ArrayList扩容过程，ArrayList在new时期的容量是固定的吗？\n\n6\\.\n给定两个int数组A和B，A比B多一个元素，其他元素都相同，用什么方法可以找出这个多出来的元素的值是多少？复杂度是多少？（从头异或到尾，O(n)复杂度）\n\n7\\. JVM内存模型是什么样的？（吟唱6个部分）\n\n8\\. 简单说一下元空间在jdk1.8前后的变化。\n\n9\\. MySQL的四种事务隔离级别是什么？\n\n10\\. 既然用读已提交幻读无法解决，那么加了x锁还会有幻读吗？（结合业务场景分析，不会）\n\n11\\. SQL题：\n\nStudent(id,course,score,name)\n\nid name course score\n\n1 张青 语文 72\n\n2 张华 英语 81\n\n3 王华 数学 72\n\n4 张青 物理 67\n\n5 李丽 化学 98\n\n1\\. 查询每个学生选的课程数\n\n2\\. 查询出姓张学生平均成绩大于75的学生信息\n\n12\\. 现在有一个百万级数据量的表，查询过程用了索引但是查询速度还是慢，条件字段中也用了索引，该怎么查找问题并做出优化？（EXPLAIN、索引失效场景）\n\n13\\. 分库分表数据是怎么展示的？（我主要是用的ShardingJDBC和Mybatis-Flex框架中现成的分页能力）\n\n14\\. 索引的数据结构是什么？\n\n15\\. 为什么使用B+树？B树和红黑树不行吗？\n\n16\\. 反问（公司主要业务，面试官讲的很详细每个业务模块都给我讲了一遍）\n\n花絮. 1-3个工作日给回复\n\n\\------------\n\n后续\n\n1-3个工作日就来HR面了，这种基本没啥问题直接过，但是hr准备发offer了我给拒了🥺\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/597844444775301120?sourceSSR=users",
        "title": "面试记录贴-诺瓦星云",
        "content": "0.面型对象特性\n\n1.C++虚函数及实现原理\n\n2.智能指针\n\n3.STL中的哈希表，元素过多怎么办\n\n4.依赖倒置原则\n\n5.UDP组播\n\n6.TCP为什么四次挥手\n\n7.QT信号与槽，连接方式，Direct与Queue有什么区别\n\n8.用过什么QT组件\n\n9.右值引用，应用场景\n\n10.进程调度算法\n\n为什么现在还在找工作（因为我菜）\n\n反问环节\n\n面试的老哥感觉有点累，说话很快，有点有气无力的样子\n\n  \n\n更新：已挂\n\n"
    },
    {
        "url": "https://www.nowcoder.com/discuss/597860975013863424?sourceSSR=users",
        "title": "Go后端日常实习面经（成都翼健、亿格云、深圳用图）",
        "content": "## 成都翼健\n\n### 3.1 一面25min\n\nmake和new区别\n\ngolang的异步通信方式\n\nmap底层\n\n内存逃逸\n\ndefer变量快照\n\nGMP\n\n堆和栈\n\nPython的数据类型\n\n手写二分法\n\n### 3.5二面20min\n\n自我介绍\n\n项目讲解\n\n学校学过哪些课程，学得最好的是什么\n\n然后就聊到了数据结构图论、哈希表、密码学\n\n上一段实习经历的项目\n\n自己还用过哪些语言做后端\n\n自己业余时间还学习什么\n\n实习时间和安排\n\n3.10线下参观 已OC\n\n## 亿格云\n\n3.8下午一面忘记录了\n\n3.8晚上二面\n\nweb项目如果用户量上去了如何处理\n\nMySQL哪些字段建索引、联合索引\n\n慢SQL排查优化\n\nSQL死锁\n\n统计网站的访客地理位置\n\nHTTP1.1/2.0/3.0\n\n3.9 OC\n\n## 深圳用图\n\n3.14\n\n项目如何部署上线\n\n平常用github吗\n\n用什么IDE\n\n抓过包吗\n\nTCP和UDP的区别\n\n从输入网址到显示的整个过程\n\n对实习的要求，希望收获什么、做什么\n\n了解Go最新的项目之类的吗\n\n遇到问题怎么解决\n\n"
    }
]